(self["webpackChunkng_ant_admin"] = self["webpackChunkng_ant_admin"] || []).push([["src_app_pages_page-demo_flow_flow-chat_flow-chat_module_ts"],{

/***/ 94795:
/*!****************************************************************************!*\
  !*** ./src/app/pages/page-demo/flow/flow-chat/flow-chat-routing.module.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FlowChatRoutingModule": () => (/* binding */ FlowChatRoutingModule)
/* harmony export */ });
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ 60124);
/* harmony import */ var _flow_chat_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flow-chat.component */ 10966);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 22560);




const routes = [{ path: '', component: _flow_chat_component__WEBPACK_IMPORTED_MODULE_0__.FlowChatComponent, data: { title: 'sơ đồ', key: 'flow-chat' } }];
class FlowChatRoutingModule {
}
FlowChatRoutingModule.ɵfac = function FlowChatRoutingModule_Factory(t) { return new (t || FlowChatRoutingModule)(); };
FlowChatRoutingModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({ type: FlowChatRoutingModule });
FlowChatRoutingModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({ imports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__.RouterModule.forChild(routes), _angular_router__WEBPACK_IMPORTED_MODULE_2__.RouterModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](FlowChatRoutingModule, { imports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__.RouterModule], exports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__.RouterModule] }); })();


/***/ }),

/***/ 10966:
/*!***********************************************************************!*\
  !*** ./src/app/pages/page-demo/flow/flow-chat/flow-chat.component.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FlowChatComponent": () => (/* binding */ FlowChatComponent)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ 4038);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 22560);
/* harmony import */ var _shared_components_page_header_page_header_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../shared/components/page-header/page-header.component */ 32802);
/* harmony import */ var ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ng-zorro-antd/icon */ 5655);
/* harmony import */ var ng_zorro_antd_grid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ng-zorro-antd/grid */ 70031);
/* harmony import */ var ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ng-zorro-antd/button */ 17619);
/* harmony import */ var ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ng-zorro-antd/core/transition-patch */ 16495);
/* harmony import */ var ng_zorro_antd_card__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ng-zorro-antd/card */ 48332);
/* harmony import */ var ng_zorro_antd_tooltip__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ng-zorro-antd/tooltip */ 33923);
/* harmony import */ var ng_zorro_antd_result__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ng-zorro-antd/result */ 64655);











const _c0 = ["container"];
const _c1 = function () { return { padding: 0 }; };
class FlowChatComponent {
    constructor() {
        this.pageHeaderInfo = {
            title: '流程编辑器，有了流程图，我就该知道未来该做什么了',
            breadcrumb: ['首页', '扩展功能', '图形编辑器', '流程图'],
            desc: '千言万语不如一张图，流程图是表示算法思路的好方法(简单流程图示例,具体功能需要自己完善，antV x6)'
        };
        /** x6画布的一些基础属性 */
        this.graphBasicConfig = {
            grid: {
                size: 10,
                visible: true // 渲染网格背景
            },
            panning: true,
            selecting: true,
            height: 400,
            connecting: {
                snap: true,
                allowBlank: false,
                allowLoop: false,
                allowNode: false,
                allowEdge: false,
                connector: 'rounded',
                connectionPoint: 'boundary'
            }
        };
    }
    ngOnInit() { }
    drag(event) {
        const target = event.currentTarget;
        const shap = target.getAttribute('shap');
        const dnd = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Addon.Dnd({
            target: this.graph
        });
        const node = this.graph.createNode({
            width: 100,
            height: 100,
            shape: shap,
            ports: {
                groups: {
                    // 输入链接桩群组定义
                    in: {
                        position: 'top',
                        attrs: {
                            circle: {
                                r: 6,
                                magnet: true,
                                stroke: '#31d0c6',
                                strokeWidth: 2,
                                fill: '#fff'
                            }
                        }
                    },
                    // 输出链接桩群组定义
                    out: {
                        position: 'bottom',
                        attrs: {
                            circle: {
                                r: 6,
                                magnet: true,
                                stroke: '#31d0c6',
                                strokeWidth: 2,
                                fill: '#fff'
                            }
                        }
                    }
                },
                items: [
                    {
                        id: 'port1',
                        group: 'in'
                    },
                    {
                        id: 'port2',
                        group: 'in'
                    },
                    {
                        id: 'port3',
                        group: 'in'
                    },
                    {
                        id: 'port4',
                        group: 'out'
                    },
                    {
                        id: 'port5',
                        group: 'out'
                    }
                ]
            },
            attrs: {
                body: {
                // fill: '#ccc'
                }
            }
        });
        dnd.start(node, event);
    }
    initGraph() {
        const graphConfig = {
            ...this.graphBasicConfig,
            container: this.container.nativeElement
        };
        this.graph = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph(graphConfig);
    }
    ngAfterViewInit() {
        this.initGraph();
    }
}
FlowChatComponent.ɵfac = function FlowChatComponent_Factory(t) { return new (t || FlowChatComponent)(); };
FlowChatComponent.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineComponent"]({ type: FlowChatComponent, selectors: [["app-flow-chat"]], viewQuery: function FlowChatComponent_Query(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵviewQuery"](_c0, 5);
    } if (rf & 2) {
        let _t;
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵloadQuery"]()) && (ctx.container = _t.first);
    } }, decls: 33, vars: 5, consts: [[3, "pageHeaderInfo"], [1, "normal-table-wrap"], [1, "relative", 3, "nzBodyStyle"], ["id", "wrap", "nz-result-content", "", "nz-row", "", "nzJustify", "space-between", 1, "p-0", "m-t-0"], ["nz-tooltip", "", "nzTooltipTitle", "\u7F6E\u524D", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "vertical-align-top", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u7F6E\u540E", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "vertical-align-bottom", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u5F00\u542F\u6846\u9009", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "gateway", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u65B0\u5EFA\u7FA4\u7EC4", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "group", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u89E3\u6563\u7FA4\u7EC4", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "ungroup", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u4FDD\u5B58", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "save", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u653E\u5927", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "plus-circle", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u7F29\u5C0F", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "minus-circle", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u7F29\u653E\u52301\uFF1A1", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "one-to-one", "nzTheme", "outline"], ["nz-tooltip", "", "nzTooltipTitle", "\u7F29\u653E\u5230\u9002\u5E94\u5C4F\u5E55", "nzTooltipPlacement", "bottom", "nz-button", "", "nzType", "text"], ["nz-icon", "", "nzType", "compress", "nzTheme", "outline"], [1, "flex"], ["id", "container", 1, "flex-1"], ["container", ""], [1, "absolute", "node-sel-bar", 3, "nzBodyStyle"], [1, "flex", "flex-coloum"], ["nz-tooltip", "", "nzTooltipTitle", "\u6B63\u65B9\u5F62", "nzTooltipPlacement", "right", "shap", "rect", "nz-icon", "", "nzType", "border", "nzTheme", "outline", 3, "mousedown"], ["nz-tooltip", "", "nzTooltipTitle", "\u5706\u5F62", "nzTooltipPlacement", "right", "shap", "circle", "nz-icon", "", "nzType", "user", "nzTheme", "outline", 3, "mousedown"]], template: function FlowChatComponent_Template(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "app-page-header", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](1, "div", 1)(2, "nz-card", 2)(3, "div", 3)(4, "div")(5, "button", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](6, "i", 5);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](7, "button", 6);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](8, "i", 7);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](9, "button", 8);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](10, "i", 9);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](11, "button", 10);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](12, "i", 11);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](13, "button", 12);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](14, "i", 13);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](15, "button", 14);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](16, "i", 15);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]()();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](17, "div")(18, "button", 16);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](19, "i", 17);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](20, "button", 18);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](21, "i", 19);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](22, "button", 20);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](23, "i", 21);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](24, "button", 22);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](25, "i", 23);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]()()();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](26, "div", 24);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](27, "div", 25, 26);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](29, "nz-card", 27)(30, "div", 28)(31, "i", 29);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("mousedown", function FlowChatComponent_Template_i_mousedown_31_listener($event) { return ctx.drag($event); });
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](32, "i", 30);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("mousedown", function FlowChatComponent_Template_i_mousedown_32_listener($event) { return ctx.drag($event); });
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]()()()()();
    } if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("pageHeaderInfo", ctx.pageHeaderInfo);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](2);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("nzBodyStyle", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction0"](3, _c1));
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](27);
        _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("nzBodyStyle", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction0"](4, _c1));
    } }, dependencies: [_shared_components_page_header_page_header_component__WEBPACK_IMPORTED_MODULE_1__.PageHeaderComponent, ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_3__.NzIconDirective, ng_zorro_antd_grid__WEBPACK_IMPORTED_MODULE_4__.NzRowDirective, ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_5__.NzButtonComponent, ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_6__["ɵNzTransitionPatchDirective"], ng_zorro_antd_card__WEBPACK_IMPORTED_MODULE_7__.NzCardComponent, ng_zorro_antd_tooltip__WEBPACK_IMPORTED_MODULE_8__.NzTooltipDirective, ng_zorro_antd_result__WEBPACK_IMPORTED_MODULE_9__.NzResultContentDirective], styles: [".node-sel-bar[_ngcontent-%COMP%] {\n  top: 50px;\n  left: 20px;\n  border-radius: 5px;\n  padding: 15px 10px;\n  font-size: 20px;\n  box-shadow: 0 1px 4px #0000004d;\n}\n.node-sel-bar[_ngcontent-%COMP%]   i[_ngcontent-%COMP%] {\n  padding: 8px 0;\n  cursor: pointer;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZsb3ctY2hhdC5jb21wb25lbnQubGVzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLFNBQUE7RUFDQSxVQUFBO0VBQ0Esa0JBQUE7RUFDQSxrQkFBQTtFQUNBLGVBQUE7RUFDQSwrQkFBQTtBQUNGO0FBUEE7RUFRSSxjQUFBO0VBQ0EsZUFBQTtBQUVKIiwiZmlsZSI6ImZsb3ctY2hhdC5jb21wb25lbnQubGVzcyIsInNvdXJjZXNDb250ZW50IjpbIi5ub2RlLXNlbC1iYXJ7XG4gIHRvcDogNTBweDtcbiAgbGVmdDogMjBweDtcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xuICBwYWRkaW5nOjE1cHggMTBweDtcbiAgZm9udC1zaXplOiAyMHB4O1xuICBib3gtc2hhZG93OiAwIDFweCA0cHggIzAwMDAwMDRkO1xuICBpe1xuICAgIHBhZGRpbmc6IDhweCAwO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgfVxufVxuIl19 */"], changeDetection: 0 });


/***/ }),

/***/ 83593:
/*!********************************************************************!*\
  !*** ./src/app/pages/page-demo/flow/flow-chat/flow-chat.module.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FlowChatModule": () => (/* binding */ FlowChatModule)
/* harmony export */ });
/* harmony import */ var _shared_shared_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shared/shared.module */ 44466);
/* harmony import */ var _flow_chat_routing_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flow-chat-routing.module */ 94795);
/* harmony import */ var _flow_chat_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flow-chat.component */ 10966);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ 22560);




class FlowChatModule {
}
FlowChatModule.ɵfac = function FlowChatModule_Factory(t) { return new (t || FlowChatModule)(); };
FlowChatModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineNgModule"]({ type: FlowChatModule });
FlowChatModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjector"]({ imports: [_shared_shared_module__WEBPACK_IMPORTED_MODULE_0__.SharedModule, _flow_chat_routing_module__WEBPACK_IMPORTED_MODULE_1__.FlowChatRoutingModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵsetNgModuleScope"](FlowChatModule, { declarations: [_flow_chat_component__WEBPACK_IMPORTED_MODULE_2__.FlowChatComponent], imports: [_shared_shared_module__WEBPACK_IMPORTED_MODULE_0__.SharedModule, _flow_chat_routing_module__WEBPACK_IMPORTED_MODULE_1__.FlowChatRoutingModule] }); })();


/***/ }),

/***/ 69891:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/autosave/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutoSave": () => (/* binding */ AutoSave)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common */ 57566);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class AutoSave extends _common__WEBPACK_IMPORTED_MODULE_0__.Disablable {
  constructor(options) {
    super();
    this.delay = 10;
    this.throttle = 2;
    this.threshold = 5;
    this.changeCount = 0;
    this.timestamp = 0;
    this.options = Object.assign(Object.assign({}, AutoSave.defaultOptions), options);
    this.graph.model.on('cell:change:*', this.onModelChanged, this);
  }

  get graph() {
    return this.options.graph;
  }

  onModelChanged() {
    if (this.disabled) {
      return;
    }

    const now = new Date().getTime();
    const dt = (now - this.timestamp) / 1000;

    if (dt > this.delay || this.changeCount >= this.threshold && dt > this.throttle) {
      this.save();
      this.reset();
    } else {
      this.changeCount += 1;
    }
  }

  save() {
    this.trigger('save');
  }

  reset() {
    this.changeCount = 0;
    this.timestamp = new Date().getTime();
  }

  dispose() {
    this.graph.model.off('cell:change:*', this.onModelChanged, this);
  }

}

__decorate([_common__WEBPACK_IMPORTED_MODULE_0__.Disablable.dispose()], AutoSave.prototype, "dispose", null);

(function (AutoSave) {
  AutoSave.defaultOptions = {
    delay: 10,
    throttle: 2,
    threshold: 5
  };
})(AutoSave || (AutoSave = {}));

/***/ }),

/***/ 23677:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/clipboard/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Clipboard": () => (/* binding */ Clipboard)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _global_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global/config */ 1357);
/* harmony import */ var _graph_graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../graph/graph */ 77947);
/* harmony import */ var _model_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/model */ 69314);




class Clipboard {
  constructor() {
    this.cells = [];
  }

  copy(cells, graph, options = {}) {
    this.options = Object.assign({}, options);
    const model = _model_model__WEBPACK_IMPORTED_MODULE_3__.Model.isModel(graph) ? graph : graph.model;
    const cloned = model.cloneSubGraph(cells, options); // sort asc by cell type

    this.cells = _util__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortBy(Object.keys(cloned).map(key => cloned[key]), cell => cell.isEdge() ? 2 : 1);
    this.serialize(options);
  }

  cut(cells, graph, options = {}) {
    this.copy(cells, graph, options);
    const model = _graph_graph__WEBPACK_IMPORTED_MODULE_2__.Graph.isGraph(graph) ? graph.model : graph;
    model.batchUpdate('cut', () => {
      cells.forEach(cell => cell.remove());
    });
  }

  paste(graph, options = {}) {
    const localOptions = Object.assign(Object.assign({}, this.options), options);
    const {
      offset,
      edgeProps,
      nodeProps
    } = localOptions;
    let dx = 20;
    let dy = 20;

    if (offset) {
      dx = typeof offset === 'number' ? offset : offset.dx;
      dy = typeof offset === 'number' ? offset : offset.dy;
    }

    this.deserialize(localOptions);
    const cells = this.cells;
    cells.forEach(cell => {
      cell.model = null;
      cell.removeProp('zIndex');

      if (dx || dy) {
        cell.translate(dx, dy);
      }

      if (nodeProps && cell.isNode()) {
        cell.prop(nodeProps);
      }

      if (edgeProps && cell.isEdge()) {
        cell.prop(edgeProps);
      }
    });
    const model = _graph_graph__WEBPACK_IMPORTED_MODULE_2__.Graph.isGraph(graph) ? graph.model : graph;
    model.batchUpdate('paste', () => {
      model.addCells(this.cells);
    });
    this.copy(cells, graph, options);
    return cells;
  }

  serialize(options) {
    if (options.useLocalStorage !== false) {
      Storage.save(this.cells);
    }
  }

  deserialize(options) {
    if (options.useLocalStorage) {
      const cells = Storage.fetch();

      if (cells) {
        this.cells = cells;
      }
    }
  }

  isEmpty() {
    return this.cells.length <= 0;
  }

  clean() {
    this.options = {};
    this.cells = [];
    Storage.clean();
  }

}
var Storage;

(function (Storage) {
  const LOCAL_STORAGE_KEY = `${_global_config__WEBPACK_IMPORTED_MODULE_1__.Config.prefixCls}.clipboard.cells`;

  function save(cells) {
    if (window.localStorage) {
      const data = cells.map(cell => cell.toJSON());
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
    }
  }

  Storage.save = save;

  function fetch() {
    if (window.localStorage) {
      const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
      const cells = raw ? JSON.parse(raw) : [];

      if (cells) {
        return _model_model__WEBPACK_IMPORTED_MODULE_3__.Model.fromJSON(cells);
      }
    }
  }

  Storage.fetch = fetch;

  function clean() {
    if (window.localStorage) {
      localStorage.removeItem(LOCAL_STORAGE_KEY);
    }
  }

  Storage.clean = clean;
})(Storage || (Storage = {}));

/***/ }),

/***/ 42775:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/common/handle.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Handle": () => (/* binding */ Handle)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/view */ 58458);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometry */ 17653);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




class Handle {
  get handleClassName() {
    return ClassNames.handle;
  }

  get pie() {
    return Object.assign(Object.assign({}, Handle.defaultPieOptions), this.handleOptions.pie);
  }

  initHandles() {
    this.handles = [];

    if (this.handleOptions.handles) {
      this.handleOptions.handles.forEach(handle => this.addHandle(handle));
    }

    if (this.handleOptions.type === 'pie') {
      if (this.pie.toggles) {
        const className = ClassNames.pieToggle;
        this.$pieToggles = {};
        this.pie.toggles.forEach(item => {
          const $elem = this.$('<div/>');
          this.applyAttrs($elem, item.attrs);
          $elem.addClass(className).addClass(`${className}-pos-${item.position || 'e'}`).attr('data-name', item.name).appendTo(this.container);
          this.$pieToggles[item.name] = $elem;
        });
      }

      this.setPieIcons();
    }

    if (this.$handleContainer) {
      const type = this.handleOptions.type || 'surround';
      this.$handleContainer.addClass(ClassNames.wrap).addClass(ClassNames.animate).addClass(`${ClassNames.handle}-${type}`);
    }

    this.delegateEvents({
      [`mousedown .${ClassNames.handle}`]: 'onHandleMouseDown',
      [`touchstart .${ClassNames.handle}`]: 'onHandleMouseDown',
      [`mousedown .${ClassNames.pieToggle}`]: 'onPieToggleMouseDown',
      [`touchstart .${ClassNames.pieToggle}`]: 'onPieToggleMouseDown'
    });
  }

  onHandleMouseDown(evt) {
    const action = this.$(evt.currentTarget).closest(`.${ClassNames.handle}`).attr('data-action');

    if (action) {
      evt.preventDefault();
      evt.stopPropagation();
      this.setEventData(evt, {
        action,
        clientX: evt.clientX,
        clientY: evt.clientY,
        startX: evt.clientX,
        startY: evt.clientY
      });

      if (evt.type === 'mousedown' && evt.button === 2) {
        this.triggerHandleAction(action, 'contextmenu', evt);
      } else {
        this.triggerHandleAction(action, 'mousedown', evt);
        this.delegateDocumentEvents({
          mousemove: 'onHandleMouseMove',
          touchmove: 'onHandleMouseMove',
          mouseup: 'onHandleMouseUp',
          touchend: 'onHandleMouseUp',
          touchcancel: 'onHandleMouseUp'
        }, evt.data);
      }
    }
  }

  onHandleMouseMove(evt) {
    const data = this.getEventData(evt);
    const action = data.action;

    if (action) {
      this.triggerHandleAction(action, 'mousemove', evt);
    }
  }

  onHandleMouseUp(evt) {
    const data = this.getEventData(evt);
    const action = data.action;

    if (action) {
      this.triggerHandleAction(action, 'mouseup', evt);
      this.undelegateDocumentEvents();
    }
  }

  triggerHandleAction(action, eventName, evt, args) {
    evt.preventDefault();
    evt.stopPropagation();
    const e = this.normalizeEvent(evt);
    const data = this.getEventData(e);
    const local = this.graph.snapToGrid(e.clientX, e.clientY);
    const origin = this.graph.snapToGrid(data.clientX, data.clientY);
    const dx = local.x - origin.x;
    const dy = local.y - origin.y;
    this.trigger(`action:${action}:${eventName}`, Object.assign({
      e,
      dx,
      dy,
      x: local.x,
      y: local.y,
      offsetX: evt.clientX - data.startX,
      offsetY: evt.clientY - data.startY
    }, args));
    data.clientX = evt.clientX;
    data.clientY = evt.clientY;
  }

  onPieToggleMouseDown(evt) {
    evt.stopPropagation();
    const name = this.$(evt.target).closest(`.${ClassNames.pieToggle}`).attr('data-name');

    if (!this.isOpen(name)) {
      if (this.isOpen()) {
        this.toggleState();
      }
    }

    this.toggleState(name);
  }

  setPieIcons() {
    if (this.handleOptions.type === 'pie') {
      this.$handleContainer.find(`.${ClassNames.handle}`).each((_, elem) => {
        const $elem = this.$(elem);
        const action = $elem.attr('data-action');
        const className = ClassNames.pieSlice;
        const handle = this.getHandle(action);

        if (!handle || !handle.icon) {
          const contect = window.getComputedStyle(elem, ':before').getPropertyValue('content');

          if (contect && contect !== 'none') {
            const $icons = $elem.find(`.${className}-txt`);

            if ($icons.length) {
              _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create($icons[0]).text(contect.replace(/['"]/g, ''));
            }
          }

          const bgImg = $elem.css('background-image');

          if (bgImg) {
            const matches = bgImg.match(/url\(['"]?([^'"]+)['"]?\)/);

            if (matches) {
              const href = matches[1];
              const $imgs = $elem.find(`.${className}-img`);

              if ($imgs.length > 0) {
                _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create($imgs[0]).attr('xlink:href', href);
              }
            }
          }
        }
      });
    }
  }

  getHandleIdx(name) {
    return this.handles.findIndex(item => item.name === name);
  }

  hasHandle(name) {
    return this.getHandleIdx(name) >= 0;
  }

  getHandle(name) {
    return this.handles.find(item => item.name === name);
  }

  renderHandle(handle) {
    const $handle = this.$('<div/>').addClass(`${ClassNames.handle} ${ClassNames.handle}-${handle.name}`).attr('data-action', handle.name).prop('draggable', false);

    if (this.handleOptions.type === 'pie') {
      const index = this.getHandleIdx(handle.name);
      const pie = this.pie;
      const outerRadius = pie.outerRadius;
      const innerRadius = pie.innerRadius;
      const offset = (outerRadius + innerRadius) / 2;
      const ratio = new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(outerRadius, outerRadius);
      const delta = _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.toRad(pie.sliceAngle);
      const curRad = index * delta + _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.toRad(pie.startAngle);
      const nextRad = curRad + delta;
      const pathData = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSlicePathData(innerRadius, outerRadius, curRad, nextRad);
      const vSvg = _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create('svg').addClass(`${ClassNames.pieSlice}-svg`);
      const vPath = _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create('path').addClass(ClassNames.pieSlice).attr('d', pathData).translate(outerRadius, outerRadius);
      const pos = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.fromPolar(offset, -curRad - delta / 2, ratio).toJSON();
      const iconSize = pie.iconSize;
      const vImg = _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create('image').attr(pos).addClass(`${ClassNames.pieSlice}-img`);
      pos.y = pos.y + iconSize - 2;
      const vText = _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create('text', {
        'font-size': iconSize
      }).attr(pos).addClass(`${ClassNames.pieSlice}-txt`);
      vImg.attr({
        width: iconSize,
        height: iconSize
      });
      vImg.translate(-iconSize / 2, -iconSize / 2);
      vText.translate(-iconSize / 2, -iconSize / 2);
      vSvg.append([vPath, vImg, vText]);
      $handle.append(vSvg.node);
    } else {
      $handle.addClass(`${ClassNames.handle}-pos-${handle.position}`);

      if (handle.content) {
        if (typeof handle.content === 'string') {
          $handle.html(handle.content);
        } else {
          $handle.append(handle.content);
        }
      }
    }

    this.updateHandleIcon($handle, handle.icon);
    this.applyAttrs($handle, handle.attrs);
    return $handle;
  }

  addHandle(handle) {
    if (!this.hasHandle(handle.name)) {
      this.handles.push(handle);
      const events = handle.events;

      if (events) {
        Object.keys(events).forEach(action => {
          const callback = events[action];
          const name = `action:${handle.name}:${action}`;

          if (typeof callback === 'string') {
            this.on(name, this[callback], this);
          } else {
            this.on(name, callback);
          }
        });
      }

      if (this.$handleContainer) {
        this.$handleContainer.append(this.renderHandle(handle));
      }
    }

    return this;
  }

  addHandles(handles) {
    handles.forEach(handle => this.addHandle(handle));
    return this;
  }

  removeHandles() {
    while (this.handles.length) {
      this.removeHandle(this.handles[0].name);
    }

    return this;
  }

  removeHandle(name) {
    const index = this.getHandleIdx(name);
    const handle = this.handles[index];

    if (handle) {
      if (handle.events) {
        Object.keys(handle.events).forEach(event => {
          this.off(`action:${name}:${event}`);
        });
      }

      this.getHandleElem(name).remove();
      this.handles.splice(index, 1);
    }

    return this;
  }

  changeHandle(name, newHandle) {
    const handle = this.getHandle(name);

    if (handle) {
      this.removeHandle(name);
      this.addHandle(Object.assign(Object.assign({}, handle), newHandle));
    }

    return this;
  }

  toggleHandle(name, selected) {
    const handle = this.getHandle(name);

    if (handle) {
      const $handle = this.getHandleElem(name);
      const className = `${ClassNames.handle}-selected`;

      if (selected === undefined) {
        selected = !$handle.hasClass(className); // eslint-disable-line
      }

      $handle.toggleClass(className, selected);
      const icon = selected ? handle.iconSelected : handle.icon;

      if (icon) {
        this.updateHandleIcon($handle, icon);
      }
    }

    return this;
  }

  selectHandle(name) {
    return this.toggleHandle(name, true);
  }

  deselectHandle(name) {
    return this.toggleHandle(name, false);
  }

  deselectAllHandles() {
    this.handles.forEach(handle => this.deselectHandle(handle.name));
    return this;
  }

  getHandleElem(name) {
    return this.$handleContainer.find(`.${ClassNames.handle}-${name}`);
  }

  updateHandleIcon($handle, icon) {
    if (this.handleOptions.type === 'pie') {
      const $icons = $handle.find(`.${ClassNames.pieSliceImg}`);
      this.$($icons[0]).attr('xlink:href', icon || '');
    } else {
      $handle.css('background-image', icon ? `url(${icon})` : '');
    }
  }

  isRendered() {
    return this.$handleContainer != null;
  }

  isOpen(name) {
    if (this.isRendered()) {
      return name ? this.$pieToggles[name].hasClass(ClassNames.pieToggleOpened) : this.$handleContainer.hasClass(`${ClassNames.pieOpended}`);
    }

    return false;
  }

  toggleState(name) {
    if (this.isRendered()) {
      const $handleContainer = this.$handleContainer;
      Object.keys(this.$pieToggles).forEach(key => {
        const $toggle = this.$pieToggles[key];
        $toggle.removeClass(ClassNames.pieToggleOpened);
      });

      if (this.isOpen()) {
        this.trigger('pie:close', {
          name
        });
        $handleContainer.removeClass(ClassNames.pieOpended);
      } else {
        this.trigger('pie:open', {
          name
        });

        if (name) {
          const toggles = this.pie.toggles;
          const toggle = toggles && toggles.find(i => i.name === name);

          if (toggle) {
            $handleContainer.attr({
              'data-pie-toggle-name': toggle.name,
              'data-pie-toggle-position': toggle.position
            });
          }

          this.$pieToggles[name].addClass(ClassNames.pieToggleOpened);
        }

        $handleContainer.addClass(ClassNames.pieOpended);
      }
    }
  }

  applyAttrs(elem, attrs) {
    if (attrs) {
      const $elem = _view_view__WEBPACK_IMPORTED_MODULE_1__.View.$(elem);
      Object.keys(attrs).forEach(selector => {
        const $element = $elem.find(selector).addBack().filter(selector);

        const _a = attrs[selector],
              {
          class: cls
        } = _a,
              attr = __rest(_a, ["class"]);

        if (cls) {
          $element.addClass(cls);
        }

        $element.attr(attr);
      });
    }
  }

}

(function (Handle) {
  Handle.defaultPieOptions = {
    innerRadius: 20,
    outerRadius: 50,
    sliceAngle: 45,
    startAngle: 0,
    iconSize: 14,
    toggles: [{
      name: 'default',
      position: 'e'
    }]
  };
})(Handle || (Handle = {}));

var ClassNames;

(function (ClassNames) {
  ClassNames.handle = _view_view__WEBPACK_IMPORTED_MODULE_1__.View.prototype.prefixClassName('widget-handle');
  ClassNames.wrap = `${ClassNames.handle}-wrap`;
  ClassNames.animate = `${ClassNames.handle}-animate`;
  ClassNames.pieOpended = `${ClassNames.handle}-pie-opened`;
  ClassNames.pieToggle = `${ClassNames.handle}-pie-toggle`;
  ClassNames.pieToggleOpened = `${ClassNames.handle}-pie-toggle-opened`;
  ClassNames.pieSlice = `${ClassNames.handle}-pie-slice`;
  ClassNames.pieSliceImg = `${ClassNames.handle}-pie-slice-img`;
})(ClassNames || (ClassNames = {}));

/***/ }),

/***/ 92720:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/common/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Handle": () => (/* reexport safe */ _handle__WEBPACK_IMPORTED_MODULE_0__.Handle),
/* harmony export */   "Widget": () => (/* reexport safe */ _widget__WEBPACK_IMPORTED_MODULE_1__.Widget)
/* harmony export */ });
/* harmony import */ var _handle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handle */ 42775);
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./widget */ 72435);



/***/ }),

/***/ 72435:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/common/widget.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Widget": () => (/* binding */ Widget)
/* harmony export */ });
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../view */ 29818);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


class Widget extends _view__WEBPACK_IMPORTED_MODULE_0__.View {
  constructor(options) {
    super();

    const _a = options,
          {
      view,
      cell,
      node,
      edge,
      graph
    } = _a,
          localOptions = __rest(_a, ["view", "cell", "node", "edge", "graph"]);

    if (view) {
      this.view = view;
      this.cell = view.cell;
      this.graph = view.graph;
      this.model = this.graph.model;
    } else if ((cell || edge || node) && graph) {
      this.cell = node || edge || cell;
      this.view = graph.renderer.findViewByCell(this.cell);
      this.graph = graph;
      this.model = this.graph.model;
    }

    const ctor = this.constructor;

    if (options.clearAll !== false) {
      ctor.removeInstances(this.graph);
    }

    ctor.register(this);
    this.init(localOptions);
  }

  static ensureCache() {
    if (!this.instanceCache.has(this)) {
      this.instanceCache.set(this, {});
    }

    return this.instanceCache.get(this);
  }

  static register(instance, graph) {
    if (graph == null) {
      // eslint-disable-next-line
      graph = instance.graph;
    }

    const dic = this.ensureCache();
    let cache = dic[graph.view.cid];

    if (cache == null) {
      cache = dic[graph.view.cid] = {};
    }

    cache[instance.cid] = instance;
  }

  static unregister(instance, graph) {
    if (graph == null) {
      // eslint-disable-next-line
      graph = instance.graph;
    }

    const dic = this.ensureCache();

    if (dic[graph.view.cid]) {
      delete dic[graph.view.cid][instance.cid];
    }
  }

  static removeInstances(graph) {
    const dic = this.ensureCache();
    const cache = dic[graph.view.cid];

    if (cache) {
      Object.keys(cache).forEach(cid => {
        const instance = cache[cid];

        if (instance) {
          instance.remove();
        }
      });
    }
  }

  static getInstances(graph) {
    const dic = this.ensureCache();
    return dic[graph.view.cid] || {};
  }

  init(options) {} // eslint-disable-line


  render() {
    return this;
  }

  startListening() {
    if (this.options.clearOnBlankMouseDown !== false) {
      this.graph.on('blank:mousedown', this.remove, this);
    }
  }

  stopListening() {
    if (this.options.clearOnBlankMouseDown !== false) {
      this.graph.off('blank:mousedown', this.remove, this);
    }
  }

  remove() {
    this.stopListening();
    const ctor = this.constructor;
    ctor.unregister(this);
    return super.remove();
  }

  dispose() {
    this.remove();
  }

} // #region static

Widget.instanceCache = new WeakMap();

__decorate([_view__WEBPACK_IMPORTED_MODULE_0__.View.dispose()], Widget.prototype, "dispose", null);

/***/ }),

/***/ 55924:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/dnd/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dnd": () => (/* binding */ Dnd)
/* harmony export */ });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global */ 9789);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/view */ 58458);
/* harmony import */ var _graph_graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../graph/graph */ 77947);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class Dnd extends _view_view__WEBPACK_IMPORTED_MODULE_3__.View {
  constructor(options) {
    super();
    this.options = Object.assign(Object.assign({}, Dnd.defaults), options);
    this.container = document.createElement('div');
    this.$container = this.$(this.container).addClass(this.prefixClassName('widget-dnd'));
    this.draggingGraph = new _graph_graph__WEBPACK_IMPORTED_MODULE_4__.Graph(Object.assign(Object.assign({}, this.options.delegateGraphOptions), {
      container: document.createElement('div'),
      width: 1,
      height: 1
    }));
    this.$container.append(this.draggingGraph.container);
  }

  get targetScroller() {
    const target = this.options.target;
    return _graph_graph__WEBPACK_IMPORTED_MODULE_4__.Graph.isGraph(target) ? target.scroller.widget : target;
  }

  get targetGraph() {
    const target = this.options.target;
    return _graph_graph__WEBPACK_IMPORTED_MODULE_4__.Graph.isGraph(target) ? target : target.graph;
  }

  get targetModel() {
    return this.targetGraph.model;
  }

  get snapline() {
    return this.targetGraph.snapline.widget;
  }

  start(node, evt) {
    const e = evt;
    e.preventDefault();
    this.targetModel.startBatch('dnd');
    this.$container.addClass('dragging').appendTo(this.options.containerParent || document.body);
    this.sourceNode = node;
    this.prepareDragging(node, e.clientX, e.clientY);
    const local = this.updateNodePosition(e.clientX, e.clientY);

    if (this.isSnaplineEnabled()) {
      this.snapline.captureCursorOffset({
        e,
        node,
        cell: node,
        view: this.draggingView,
        x: local.x,
        y: local.y
      });
      this.draggingNode.on('change:position', this.snap, this);
    }

    this.delegateDocumentEvents(Dnd.documentEvents, e.data);
  }

  isSnaplineEnabled() {
    return this.snapline && !this.snapline.disabled;
  }

  prepareDragging(sourceNode, clientX, clientY) {
    const draggingGraph = this.draggingGraph;
    const draggingModel = draggingGraph.model;
    const draggingNode = this.options.getDragNode(sourceNode, {
      sourceNode,
      draggingGraph,
      targetGraph: this.targetGraph
    });
    draggingNode.position(0, 0);
    let padding = 5;

    if (this.isSnaplineEnabled()) {
      padding += this.snapline.options.tolerance || 0;
    }

    if (this.isSnaplineEnabled() || this.options.scaled) {
      const scale = this.targetGraph.transform.getScale();
      draggingGraph.scale(scale.sx, scale.sy);
      padding *= Math.max(scale.sx, scale.sy);
    } else {
      draggingGraph.scale(1, 1);
    }

    this.clearDragging();

    if (this.options.animation) {
      this.$container.stop(true, true);
    }

    draggingModel.resetCells([draggingNode]);
    const delegateView = draggingGraph.findViewByCell(draggingNode);
    delegateView.undelegateEvents();
    delegateView.cell.off('changed');
    draggingGraph.fitToContent({
      padding,
      allowNewOrigin: 'any'
    });
    const bbox = delegateView.getBBox();
    this.geometryBBox = delegateView.getBBox({
      useCellGeometry: true
    });
    this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft());
    this.draggingNode = draggingNode;
    this.draggingView = delegateView;
    this.draggingBBox = draggingNode.getBBox();
    this.padding = padding;
    this.originOffset = this.updateGraphPosition(clientX, clientY);
  }

  updateGraphPosition(clientX, clientY) {
    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    const delta = this.delta;
    const nodeBBox = this.geometryBBox;
    const padding = this.padding || 5;
    const offset = {
      left: clientX - delta.x - nodeBBox.width / 2 - padding,
      top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop
    };

    if (this.draggingGraph) {
      this.$container.offset(offset);
    }

    return offset;
  }

  updateNodePosition(x, y) {
    const local = this.targetGraph.clientToLocal(x, y);
    const bbox = this.draggingBBox;
    local.x -= bbox.width / 2;
    local.y -= bbox.height / 2;
    this.draggingNode.position(local.x, local.y);
    return local;
  }

  snap({
    cell,
    current,
    options
  }) {
    const node = cell;

    if (options.snapped) {
      const bbox = this.draggingBBox;
      node.position(bbox.x + options.tx, bbox.y + options.ty, {
        silent: true
      });
      this.draggingView.translate();
      node.position(current.x, current.y, {
        silent: true
      });
      this.snapOffset = {
        x: options.tx,
        y: options.ty
      };
    } else {
      this.snapOffset = null;
    }
  }

  onDragging(evt) {
    const draggingView = this.draggingView;

    if (draggingView) {
      evt.preventDefault();
      const e = this.normalizeEvent(evt);
      const clientX = e.clientX;
      const clientY = e.clientY;
      this.updateGraphPosition(clientX, clientY);
      const local = this.updateNodePosition(clientX, clientY);
      const embeddingMode = this.targetGraph.options.embedding.enabled;
      const isValidArea = (embeddingMode || this.isSnaplineEnabled()) && this.isInsideValidArea({
        x: clientX,
        y: clientY
      });

      if (embeddingMode) {
        draggingView.setEventData(e, {
          graph: this.targetGraph,
          candidateEmbedView: this.candidateEmbedView
        });
        const data = draggingView.getEventData(e);

        if (isValidArea) {
          draggingView.processEmbedding(e, data);
        } else {
          draggingView.clearEmbedding(data);
        }

        this.candidateEmbedView = data.candidateEmbedView;
      } // update snapline


      if (this.isSnaplineEnabled()) {
        if (isValidArea) {
          this.snapline.snapOnMoving({
            e,
            view: draggingView,
            x: local.x,
            y: local.y
          });
        } else {
          this.snapline.hide();
        }
      }
    }
  }

  onDragEnd(evt) {
    const draggingNode = this.draggingNode;

    if (draggingNode) {
      const e = this.normalizeEvent(evt);
      const draggingView = this.draggingView;
      const draggingBBox = this.draggingBBox;
      const snapOffset = this.snapOffset;
      let x = draggingBBox.x;
      let y = draggingBBox.y;

      if (snapOffset) {
        x += snapOffset.x;
        y += snapOffset.y;
      }

      draggingNode.position(x, y, {
        silent: true
      });
      const ret = this.drop(draggingNode, {
        x: e.clientX,
        y: e.clientY
      });

      const callback = node => {
        if (node) {
          this.onDropped(draggingNode);

          if (this.targetGraph.options.embedding.enabled && draggingView) {
            draggingView.setEventData(e, {
              cell: node,
              graph: this.targetGraph,
              candidateEmbedView: this.candidateEmbedView
            });
            draggingView.finalizeEmbedding(e, draggingView.getEventData(e));
          }
        } else {
          this.onDropInvalid();
        }

        this.candidateEmbedView = null;
        this.targetModel.stopBatch('dnd');
      };

      if (_util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.isAsync(ret)) {
        // stop dragging
        this.undelegateDocumentEvents();
        ret.then(callback); // eslint-disable-line
      } else {
        callback(ret);
      }
    }
  }

  clearDragging() {
    if (this.draggingNode) {
      this.sourceNode = null;
      this.draggingNode.remove();
      this.draggingNode = null;
      this.draggingView = null;
      this.delta = null;
      this.padding = null;
      this.snapOffset = null;
      this.originOffset = null;
      this.undelegateDocumentEvents();
    }
  }

  onDropped(draggingNode) {
    if (this.draggingNode === draggingNode) {
      this.clearDragging();
      this.$container.removeClass('dragging').remove();
    }
  }

  onDropInvalid() {
    const draggingNode = this.draggingNode;

    if (draggingNode) {
      const anim = this.options.animation;

      if (anim) {
        const duration = typeof anim === 'object' && anim.duration || 150;
        const easing = typeof anim === 'object' && anim.easing || 'swing';
        this.draggingView = null;
        this.$container.animate(this.originOffset, duration, easing, () => this.onDropped(draggingNode));
      } else {
        this.onDropped(draggingNode);
      }
    }
  }

  isInsideValidArea(p) {
    let targetRect;
    const targetGraph = this.targetGraph;
    const targetScroller = this.targetScroller;

    if (targetScroller) {
      if (targetScroller.options.autoResize) {
        targetRect = this.getDropArea(targetScroller.container);
      } else {
        const outter = this.getDropArea(targetScroller.container);
        targetRect = this.getDropArea(targetGraph.container).intersectsWithRect(outter);
      }
    } else {
      targetRect = this.getDropArea(targetGraph.container);
    }

    return targetRect && targetRect.containsPoint(p);
  }

  getDropArea(elem) {
    const $elem = this.$(elem);
    const offset = $elem.offset();
    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
    return _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create({
      x: offset.left + parseInt($elem.css('border-left-width'), 10) - scrollLeft,
      y: offset.top + parseInt($elem.css('border-top-width'), 10) - scrollTop,
      width: $elem.innerWidth(),
      height: $elem.innerHeight()
    });
  }

  drop(draggingNode, pos) {
    if (this.isInsideValidArea(pos)) {
      const targetGraph = this.targetGraph;
      const targetModel = targetGraph.model;
      const local = targetGraph.clientToLocal(pos);
      const sourceNode = this.sourceNode;
      const droppingNode = this.options.getDropNode(draggingNode, {
        sourceNode,
        draggingNode,
        targetGraph: this.targetGraph,
        draggingGraph: this.draggingGraph
      });
      const bbox = droppingNode.getBBox();
      local.x += bbox.x - bbox.width / 2;
      local.y += bbox.y - bbox.height / 2;
      const gridSize = this.snapOffset ? 1 : targetGraph.getGridSize();
      droppingNode.position(_global__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(local.x, gridSize), _global__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(local.y, gridSize));
      droppingNode.removeZIndex();
      const validateNode = this.options.validateNode;
      const ret = validateNode ? validateNode(droppingNode, {
        sourceNode,
        draggingNode,
        droppingNode,
        targetGraph,
        draggingGraph: this.draggingGraph
      }) : true;

      if (typeof ret === 'boolean') {
        if (ret) {
          targetModel.addCell(droppingNode, {
            stencil: this.cid
          });
          return droppingNode;
        }

        return null;
      }

      return _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.toDeferredBoolean(ret).then(valid => {
        if (valid) {
          targetModel.addCell(droppingNode, {
            stencil: this.cid
          });
          return droppingNode;
        }

        return null;
      });
    }

    return null;
  }

  onRemove() {
    if (this.draggingGraph) {
      this.draggingGraph.view.remove();
      this.draggingGraph.dispose();
    }
  }

  dispose() {
    this.remove();
  }

}

__decorate([_view_view__WEBPACK_IMPORTED_MODULE_3__.View.dispose()], Dnd.prototype, "dispose", null);

(function (Dnd) {
  Dnd.defaults = {
    animation: false,
    getDragNode: sourceNode => sourceNode.clone(),
    getDropNode: draggingNode => draggingNode.clone()
  };
  Dnd.documentEvents = {
    mousemove: 'onDragging',
    touchmove: 'onDragging',
    mouseup: 'onDragEnd',
    touchend: 'onDragEnd',
    touchcancel: 'onDragEnd'
  };
})(Dnd || (Dnd = {}));

/***/ }),

/***/ 99410:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/halo/edge-preset.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EdgePreset": () => (/* binding */ EdgePreset)
/* harmony export */ });
class EdgePreset {
  constructor(halo) {
    this.halo = halo;
  }

  get options() {
    return this.halo.options;
  }

  get graph() {
    return this.halo.graph;
  }

  get model() {
    return this.halo.model;
  }

  get view() {
    return this.halo.view;
  }

  get cell() {
    return this.halo.cell;
  }

  get edge() {
    return this.cell;
  }

  getPresets() {
    return {
      className: 'type-edge',
      handles: [{
        name: 'remove',
        position: 'nw',
        icon: null,
        events: {
          mousedown: this.removeEdge.bind(this)
        }
      }, {
        name: 'direction',
        position: 'se',
        icon: null,
        events: {
          mousedown: this.directionSwap.bind(this)
        }
      }],
      content: false,

      bbox(view) {
        return view.graph.localToGraph(view.getPointAtRatio(0.5));
      },

      tinyThreshold: -1,
      smallThreshold: -1
    };
  }

  removeEdge() {
    this.cell.remove();
  }

  directionSwap() {
    const source = this.edge.getSource();
    const target = this.edge.getTarget();
    this.edge.prop({
      source: target,
      target: source
    });
  }

}

/***/ }),

/***/ 22780:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/halo/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Halo": () => (/* binding */ Halo)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ 92720);
/* harmony import */ var _node_preset__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node-preset */ 22995);
/* harmony import */ var _edge_preset__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./edge-preset */ 99410);





class Halo extends _common__WEBPACK_IMPORTED_MODULE_2__.Widget {
  get type() {
    return this.options.type || 'surround';
  }

  get handleOptions() {
    return this.options;
  }

  init(options) {
    this.options = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(Halo.defaultOptions, this.cell.isNode() ? new _node_preset__WEBPACK_IMPORTED_MODULE_3__.NodePreset(this).getPresets() : this.cell.isEdge() ? new _edge_preset__WEBPACK_IMPORTED_MODULE_4__.EdgePreset(this).getPresets() : null, options);
    this.render();
    this.initHandles();
    this.update();
    this.startListening();
  }

  startListening() {
    const model = this.model;
    const graph = this.graph;
    const cell = this.view.cell;
    cell.on('removed', this.remove, this);
    model.on('reseted', this.remove, this);
    graph.on('halo:destroy', this.remove, this);
    model.on('*', this.update, this);
    graph.on('scale', this.update, this);
    graph.on('translate', this.update, this);
    super.startListening();
  }

  stopListening() {
    const model = this.model;
    const graph = this.graph;
    const cell = this.view.cell;
    this.undelegateEvents();
    cell.off('removed', this.remove, this);
    model.off('reseted', this.remove, this);
    graph.off('halo:destroy', this.remove, this);
    model.off('*', this.update, this);
    graph.off('scale', this.update, this);
    graph.off('translate', this.update, this);
    super.stopListening();
  }

  render() {
    const options = this.options;
    const cls = this.prefixClassName('widget-halo');
    this.view.addClass(Private.NODE_CLS);
    this.container = document.createElement('div');
    this.$container = this.$(this.container).addClass(cls).attr('data-shape', this.view.cell.shape);

    if (options.className) {
      this.$container.addClass(options.className);
    }

    this.$handleContainer = this.$('<div/>').addClass(`${cls}-handles`).appendTo(this.container);
    this.$content = this.$('<div/>').addClass(`${cls}-content`).appendTo(this.container);
    this.$container.appendTo(this.graph.container);
    return this;
  }

  remove() {
    this.stopBatch();
    this.view.removeClass(Private.NODE_CLS);
    return super.remove();
  }

  update() {
    if (this.isRendered()) {
      this.updateContent();
      const bbox = this.getBBox();
      const tinyThreshold = this.options.tinyThreshold || 0;
      const smallThreshold = this.options.smallThreshold || 0;
      this.$handleContainer.toggleClass(`${this.handleClassName}-tiny`, bbox.width < tinyThreshold && bbox.height < tinyThreshold);
      const className = `${this.handleClassName}-small`;
      this.$handleContainer.toggleClass(className, !this.$handleContainer.hasClass(className) && bbox.width < smallThreshold && bbox.height < smallThreshold);
      this.$container.css({
        width: bbox.width,
        height: bbox.height,
        left: bbox.x,
        top: bbox.y
      });

      if (this.hasHandle('unlink')) {
        this.toggleUnlink();
      }

      if (this.type === 'surround' || this.type === 'toolbar') {
        if (this.hasHandle('fork')) {
          this.toggleFork();
        }
      }
    }
  }

  updateContent() {
    const content = this.options.content;

    if (typeof content === 'function') {
      const ret = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(content, this, this.view, this.$content[0]);

      if (ret) {
        this.$content.html(ret);
      }
    } else if (content) {
      this.$content.html(content);
    } else {
      this.$content.remove();
    }
  }

  getBBox() {
    const view = this.view;
    const bbox = this.options.bbox;
    const rect = typeof bbox === 'function' ? _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(bbox, this, view) : bbox;
    return _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(Object.assign({
      x: 0,
      y: 0,
      width: 1,
      height: 1
    }, rect));
  }

  removeCell() {
    this.cell.remove();
  }

  toggleFork() {
    const cell = this.view.cell.clone();
    const view = this.graph.hook.createCellView(cell);
    const valid = this.graph.hook.validateConnection(this.view, null, view, null, 'target');
    this.$handleContainer.children('.fork').toggleClass('hidden', !valid);
    view.remove();
  }

  toggleUnlink() {
    const hasEdges = this.model.getConnectedEdges(this.view.cell).length > 0;
    this.$handleContainer.children('.unlink').toggleClass('hidden', !hasEdges);
  } // #region batch


  startBatch() {
    this.model.startBatch('halo', {
      halo: this.cid
    });
  }

  stopBatch() {
    if (this.model.hasActiveBatch('halo')) {
      this.model.stopBatch('halo', {
        halo: this.cid
      });
    }
  }

}

(function (Halo) {
  Halo.defaultOptions = {
    type: 'surround',
    clearAll: true,
    clearOnBlankMouseDown: true,
    useCellGeometry: false,
    clone: cell => cell.clone().removeZIndex()
  };
})(Halo || (Halo = {}));

Object.getOwnPropertyNames(_common__WEBPACK_IMPORTED_MODULE_2__.Handle.prototype).forEach(name => {
  if (name !== 'constructor') {
    Object.defineProperty(Halo.prototype, name, Object.getOwnPropertyDescriptor(_common__WEBPACK_IMPORTED_MODULE_2__.Handle.prototype, name));
  }
});
var Private;

(function (Private) {
  Private.NODE_CLS = 'has-widget-halo';
})(Private || (Private = {}));

/***/ }),

/***/ 22995:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/halo/node-preset.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodePreset": () => (/* binding */ NodePreset)
/* harmony export */ });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global */ 9789);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _model_cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/cell */ 30936);
/* harmony import */ var _transform_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transform/util */ 24309);





class NodePreset {
  constructor(halo) {
    this.halo = halo;
  }

  get options() {
    return this.halo.options;
  }

  get graph() {
    return this.halo.graph;
  }

  get model() {
    return this.halo.model;
  }

  get view() {
    return this.halo.view;
  }

  get cell() {
    return this.halo.cell;
  }

  get node() {
    return this.cell;
  }

  getPresets() {
    return {
      className: 'type-node',
      handles: [{
        name: 'remove',
        position: 'nw',
        events: {
          mousedown: this.removeCell.bind(this)
        },
        icon: null
      }, {
        name: 'resize',
        position: 'se',
        events: {
          mousedown: this.startResize.bind(this),
          mousemove: this.doResize.bind(this),
          mouseup: this.stopResize.bind(this)
        },
        icon: null
      }, {
        name: 'clone',
        position: 'n',
        events: {
          mousedown: this.startClone.bind(this),
          mousemove: this.doClone.bind(this),
          mouseup: this.stopClone.bind(this)
        },
        icon: null
      }, {
        name: 'link',
        position: 'e',
        events: {
          mousedown: this.startLink.bind(this),
          mousemove: this.doLink.bind(this),
          mouseup: this.stopLink.bind(this)
        },
        icon: null
      }, {
        name: 'fork',
        position: 'ne',
        events: {
          mousedown: this.startFork.bind(this),
          mousemove: this.doFork.bind(this),
          mouseup: this.stopFork.bind(this)
        },
        icon: null
      }, {
        name: 'unlink',
        position: 'w',
        events: {
          mousedown: this.unlink.bind(this)
        },
        icon: null
      }, {
        name: 'rotate',
        position: 'sw',
        events: {
          mousedown: this.startRotate.bind(this),
          mousemove: this.doRotate.bind(this),
          mouseup: this.stopRotate.bind(this)
        },
        icon: null
      }],

      bbox(view) {
        if (this.options.useCellGeometry) {
          const node = view.cell;
          return node.getBBox();
        }

        return view.getBBox();
      },

      content(view) {
        const template = _util__WEBPACK_IMPORTED_MODULE_1__.StringExt.template('x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>');
        const cell = view.cell;
        const bbox = cell.getBBox();
        return template({
          x: Math.floor(bbox.x),
          y: Math.floor(bbox.y),
          width: Math.floor(bbox.width),
          height: Math.floor(bbox.height),
          angle: Math.floor(cell.getAngle())
        });
      },

      magnet(view) {
        return view.container;
      },

      tinyThreshold: 40,
      smallThreshold: 80,
      loopEdgePreferredSide: 'top',
      loopEdgeWidth: 40,
      rotateGrid: 15,
      rotateEmbeds: false
    };
  }

  removeCell() {
    this.model.removeConnectedEdges(this.cell);
    this.cell.remove();
  } // #region create edge


  startLink({
    x,
    y
  }) {
    this.halo.startBatch();
    const graph = this.graph;
    const edge = this.createEdgeConnectedToSource();
    edge.setTarget({
      x,
      y
    });
    this.model.addEdge(edge, {
      validation: false,
      halo: this.halo.cid,
      async: false
    });
    graph.view.undelegateEvents();
    this.edgeView = graph.renderer.findViewByCell(edge);
    this.edgeView.prepareArrowheadDragging('target', {
      x,
      y,
      fallbackAction: 'remove'
    });
  }

  createEdgeConnectedToSource() {
    const magnet = this.getMagnet(this.view, 'source');
    const terminal = this.getEdgeTerminal(this.view, magnet);
    const edge = this.graph.hook.getDefaultEdge(this.view, magnet);
    edge.setSource(terminal);
    return edge;
  }

  getMagnet(view, terminal) {
    const magnet = this.options.magnet;

    if (typeof magnet === 'function') {
      const val = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(magnet, this.halo, view, terminal);

      if (val instanceof SVGElement) {
        return val;
      }
    }

    throw new Error('`magnet()` has to return an SVGElement');
  }

  getEdgeTerminal(view, magnet) {
    const terminal = {
      cell: view.cell.id
    };

    if (magnet !== view.container) {
      const port = magnet.getAttribute('port');

      if (port) {
        terminal.port = port;
      } else {
        terminal.selector = view.getSelector(magnet);
      }
    }

    return terminal;
  }

  doLink({
    e,
    x,
    y
  }) {
    if (this.edgeView) {
      this.edgeView.onMouseMove(e, x, y);
    }
  }

  stopLink({
    e,
    x,
    y
  }) {
    const edgeView = this.edgeView;

    if (edgeView) {
      edgeView.onMouseUp(e, x, y);
      const edge = edgeView.cell;

      if (edge.hasLoop()) {
        this.makeLoopEdge(edge);
      }

      this.halo.stopBatch();
      this.halo.trigger('action:edge:addde', {
        edge
      });
      this.edgeView = null;
    }

    this.graph.view.delegateEvents();
  }

  makeLoopEdge(edge) {
    let vertex1 = null;
    let vertex2 = null;
    const loopEdgeWidth = this.options.loopEdgeWidth;
    const graphOptions = this.graph.options;
    const graphRect = new _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle(0, 0, graphOptions.width, graphOptions.height);
    const bbox = this.graph.graphToLocal(this.view.getBBox());
    const found = [this.options.loopEdgePreferredSide, 'top', 'bottom', 'left', 'right'].some(position => {
      let point = null;
      let dx = 0;
      let dy = 0;

      switch (position) {
        case 'top':
          point = new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth);
          dx = loopEdgeWidth / 2;
          break;

        case 'bottom':
          point = new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(bbox.x + bbox.width / 2, bbox.y + bbox.height + loopEdgeWidth);
          dx = loopEdgeWidth / 2;
          break;

        case 'left':
          point = new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2);
          dy = loopEdgeWidth / 2;
          break;

        case 'right':
          point = new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(bbox.x + bbox.width + loopEdgeWidth, bbox.y + bbox.height / 2);
          dy = loopEdgeWidth / 2;
          break;

        default:
          break;
      }

      if (point) {
        vertex1 = point.translate(-dx, -dy);
        vertex2 = point.translate(dx, dy);
        return graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2);
      }

      return false;
    });

    if (found && vertex1 && vertex2) {
      edge.setVertices([vertex1, vertex2]);
    }
  } // #endregion
  // #region resize


  startResize({
    e
  }) {
    this.halo.startBatch();
    this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(_geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.normalize(this.node.getAngle()) / 45)];
    this.view.addClass('node-resizing');
    (0,_transform_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resize', e, this.view);
  }

  doResize({
    e,
    dx,
    dy
  }) {
    const size = this.node.getSize();
    const width = Math.max(size.width + (this.flip ? dx : dy), 1);
    const height = Math.max(size.height + (this.flip ? dy : dx), 1);
    this.node.resize(width, height, {
      absolute: true
    });
    (0,_transform_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resizing', e, this.view);
  }

  stopResize({
    e
  }) {
    this.view.removeClass('node-resizing');
    (0,_transform_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resized', e, this.view);
    this.halo.stopBatch();
  } // #endregion
  // #region clone


  startClone({
    e,
    x,
    y
  }) {
    this.halo.startBatch();
    const options = this.options;
    const cloned = options.clone(this.cell, {
      clone: true
    });

    if (!_model_cell__WEBPACK_IMPORTED_MODULE_3__.Cell.isCell(cloned)) {
      throw new Error("option 'clone()' has to return a cell");
    }

    this.centerNodeAtCursor(cloned, x, y);
    this.model.addCell(cloned, {
      halo: this.halo.cid,
      async: false
    });
    const cloneView = this.graph.renderer.findViewByCell(cloned);
    cloneView.onMouseDown(e, x, y);
    this.halo.setEventData(e, {
      cloneView
    });
  }

  centerNodeAtCursor(cell, x, y) {
    const center = cell.getBBox().getCenter();
    const dx = x - center.x;
    const dy = y - center.y;
    cell.translate(dx, dy);
  }

  doClone({
    e,
    x,
    y
  }) {
    const view = this.halo.getEventData(e).cloneView;

    if (view) {
      view.onMouseMove(e, x, y);
    }
  }

  stopClone({
    e,
    x,
    y
  }) {
    const nodeView = this.halo.getEventData(e).cloneView;

    if (nodeView) {
      nodeView.onMouseUp(e, x, y);
    }

    this.halo.stopBatch();
  } // #endregion
  // #region fork


  startFork({
    e,
    x,
    y
  }) {
    this.halo.startBatch();
    const cloned = this.options.clone(this.cell, {
      fork: true
    });

    if (!_model_cell__WEBPACK_IMPORTED_MODULE_3__.Cell.isCell(cloned)) {
      throw new Error("option 'clone()' has to return a cell");
    }

    this.centerNodeAtCursor(cloned, x, y);
    this.model.addCell(cloned, {
      halo: this.halo.cid,
      async: false
    });
    const edge = this.createEdgeConnectedToSource();
    const cloneView = this.graph.renderer.findViewByCell(cloned);
    const magnet = this.getMagnet(cloneView, 'target');
    const terminal = this.getEdgeTerminal(cloneView, magnet);
    edge.setTarget(terminal);
    this.model.addEdge(edge, {
      halo: this.halo.cid,
      async: false
    });
    cloneView.onMouseDown(e, x, y);
    this.halo.setEventData(e, {
      cloneView
    });
  }

  doFork({
    e,
    x,
    y
  }) {
    const view = this.halo.getEventData(e).cloneView;

    if (view) {
      view.onMouseMove(e, x, y);
    }
  }

  stopFork({
    e,
    x,
    y
  }) {
    const view = this.halo.getEventData(e).cloneView;

    if (view) {
      view.onMouseUp(e, x, y);
    }

    this.halo.stopBatch();
  } // #endregion
  // #region rotate


  startRotate({
    e,
    x,
    y
  }) {
    this.halo.startBatch();
    const center = this.node.getBBox().getCenter();
    const nodes = [this.node];

    if (this.options.rotateEmbeds) {
      this.node.getDescendants({
        deep: true
      }).reduce((memo, cell) => {
        if (cell.isNode()) {
          memo.push(cell);
        }

        return memo;
      }, nodes);
    }

    this.halo.setEventData(e, {
      center,
      nodes,
      rotateStartAngles: nodes.map(node => node.getAngle()),
      clientStartAngle: new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(x, y).theta(center)
    });
    nodes.forEach(node => {
      const view = this.graph.findViewByCell(node);

      if (view) {
        view.addClass('node-rotating');
        (0,_transform_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotate', e, view);
      }
    });
  }

  doRotate({
    e,
    x,
    y
  }) {
    const data = this.halo.getEventData(e);
    const delta = data.clientStartAngle - new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(x, y).theta(data.center);
    data.nodes.forEach((node, index) => {
      const startAngle = data.rotateStartAngles[index];
      const targetAngle = _global__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(startAngle + delta, this.options.rotateGrid);
      node.rotate(targetAngle, {
        absolute: true,
        center: data.center,
        halo: this.halo.cid
      });
      (0,_transform_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotating', e, this.graph.findViewByCell(node));
    });
  }

  stopRotate({
    e
  }) {
    const data = this.halo.getEventData(e);
    data.nodes.forEach(node => {
      const view = this.graph.findViewByCell(node);
      view.removeClass('node-rotating');
      (0,_transform_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotated', e, view);
    });
    this.halo.stopBatch();
  } // #endregion
  // #region unlink


  unlink() {
    this.halo.startBatch();
    this.model.removeConnectedEdges(this.cell);
    this.halo.stopBatch();
  }

}

/***/ }),

/***/ 78955:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AutoSave": () => (/* reexport safe */ _autosave__WEBPACK_IMPORTED_MODULE_0__.AutoSave),
/* harmony export */   "Clipboard": () => (/* reexport safe */ _clipboard__WEBPACK_IMPORTED_MODULE_1__.Clipboard),
/* harmony export */   "Dnd": () => (/* reexport safe */ _dnd__WEBPACK_IMPORTED_MODULE_9__.Dnd),
/* harmony export */   "Halo": () => (/* reexport safe */ _halo__WEBPACK_IMPORTED_MODULE_2__.Halo),
/* harmony export */   "Knob": () => (/* reexport safe */ _knob__WEBPACK_IMPORTED_MODULE_8__.Knob),
/* harmony export */   "MiniMap": () => (/* reexport safe */ _minimap__WEBPACK_IMPORTED_MODULE_3__.MiniMap),
/* harmony export */   "Scroller": () => (/* reexport safe */ _scroller__WEBPACK_IMPORTED_MODULE_4__.Scroller),
/* harmony export */   "Selection": () => (/* reexport safe */ _selection__WEBPACK_IMPORTED_MODULE_5__.Selection),
/* harmony export */   "Snapline": () => (/* reexport safe */ _snapline__WEBPACK_IMPORTED_MODULE_6__.Snapline),
/* harmony export */   "Stencil": () => (/* reexport safe */ _stencil__WEBPACK_IMPORTED_MODULE_10__.Stencil),
/* harmony export */   "Transform": () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_7__.Transform)
/* harmony export */ });
/* harmony import */ var _autosave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autosave */ 69891);
/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clipboard */ 23677);
/* harmony import */ var _halo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./halo */ 22780);
/* harmony import */ var _minimap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./minimap */ 31009);
/* harmony import */ var _scroller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scroller */ 55644);
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection */ 42601);
/* harmony import */ var _snapline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./snapline */ 29733);
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform */ 14748);
/* harmony import */ var _knob__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./knob */ 68792);
/* harmony import */ var _dnd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dnd */ 55924);
/* harmony import */ var _stencil__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./stencil */ 97064);












/***/ }),

/***/ 68792:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/knob/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Knob": () => (/* binding */ Knob)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ 92720);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometry */ 17653);



class Knob extends _common__WEBPACK_IMPORTED_MODULE_0__.Widget {
  get node() {
    return this.cell;
  }

  get metadata() {
    const meta = this.cell.prop('knob');

    if (Array.isArray(meta)) {
      if (this.options.index != null) {
        return meta[this.options.index];
      }

      return null;
    }

    return meta;
  }

  init(options) {
    this.options = Object.assign({}, options);
    this.render();
    this.startListening();
  }

  startListening() {
    this.delegateEvents({
      mousedown: 'onMouseDown',
      touchstart: 'onMouseDown'
    });
    this.model.on('*', this.update, this);
    this.graph.on('scale', this.update, this);
    this.graph.on('translate', this.update, this);
    this.model.on('reseted', this.remove, this);
    this.node.on('removed', this.remove, this);
    this.view.on('node:resize:mousedown', this.onTransform, this);
    this.view.on('node:rotate:mousedown', this.onTransform, this);
    this.view.on('node:resize:mouseup', this.onTransformed, this);
    this.view.on('node:rotate:mouseup', this.onTransformed, this);
    this.view.on('cell:knob:mousedown', this.onKnobMouseDown, this);
    this.view.on('cell:knob:mouseup', this.onKnobMouseUp, this);
    super.startListening();
  }

  stopListening() {
    this.undelegateEvents();
    this.model.off('*', this.update, this);
    this.graph.off('scale', this.update, this);
    this.graph.off('translate', this.update, this);
    this.model.off('reseted', this.remove, this);
    this.node.off('removed', this.remove, this);
    this.view.off('node:resize:mousedown', this.onTransform, this);
    this.view.off('node:rotate:mousedown', this.onTransform, this);
    this.view.off('node:resize:mouseup', this.onTransformed, this);
    this.view.off('node:rotate:mouseup', this.onTransformed, this);
    this.view.off('cell:knob:mousedown', this.onKnobMouseDown, this);
    this.view.off('cell:knob:mouseup', this.onKnobMouseUp, this);
    super.stopListening();
  }

  render() {
    this.container = document.createElement('div');
    _util__WEBPACK_IMPORTED_MODULE_1__.Dom.addClass(this.container, this.prefixClassName('widget-knob'));

    if (this.options.className) {
      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.addClass(this.container, this.options.className);
    }

    this.view.addClass(Private.KNOB);
    this.graph.container.appendChild(this.container);
    this.update();
    return this;
  }

  remove() {
    this.view.removeClass(Private.KNOB);
    return super.remove();
  }

  update() {
    if (this.metadata) {
      const {
        update,
        position
      } = this.metadata;
      const args = {
        knob: this,
        cell: this.cell,
        node: this.node
      };

      if (position) {
        const pos = position.call(this.graph, Object.assign({}, args));

        if (pos) {
          const ctm = this.graph.matrix();
          const bbox = this.node.getBBox();
          const angle = _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.normalize(this.node.getAngle());
          const local = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(pos);

          if (angle !== 0) {
            local.rotate(-angle, {
              x: bbox.width / 2,
              y: bbox.height / 2
            });
          }

          local.translate(bbox).scale(ctm.a, ctm.d).translate(ctm.e, ctm.f);
          this.container.style.left = `${local.x}px`;
          this.container.style.top = `${local.y}px`;
        }
      }

      if (update) {
        update.call(this.graph, Object.assign({}, args));
      }
    }
  }

  hide() {
    this.container.style.display = 'none';
  }

  show() {
    this.container.style.display = '';
  }

  onTransform() {
    this.hide();
  }

  onTransformed() {
    this.show();
  }

  onKnobMouseDown({
    knob
  }) {
    if (this.cid !== knob.cid) {
      this.hide();
    }
  }

  onKnobMouseUp() {
    this.show();
  }

  notify(name, evt) {
    if (this.view) {
      const e = this.view.normalizeEvent(evt);
      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
      this.view.notify(`cell:${name}`, {
        e,
        view: this.view,
        node: this.node,
        cell: this.cell,
        x: localPoint.x,
        y: localPoint.y,
        knob: this
      });

      if (this.cell.isNode()) {
        this.view.notify(`node:${name}`, {
          e,
          view: this.view,
          node: this.node,
          cell: this.cell,
          x: localPoint.x,
          y: localPoint.y,
          knob: this
        });
      } else if (this.cell.isEdge()) {
        this.view.notify(`edge:${name}`, {
          e,
          view: this.view,
          edge: this.cell,
          cell: this.cell,
          x: localPoint.x,
          y: localPoint.y,
          knob: this
        });
      }
    }
  }

  onMouseDown(e) {
    e.stopPropagation();
    this.setEventData(e, {
      knobbing: false,
      originX: e.clientX,
      originY: e.clientY,
      clientX: e.clientX,
      clientY: e.clientY
    });
    this.graph.view.undelegateEvents();
    this.delegateDocumentEvents(Private.documentEvents, e.data);

    if (this.metadata && this.metadata.onMouseDown) {
      this.metadata.onMouseDown.call(this.graph, {
        e,
        data: this.getEventData(e),
        knob: this,
        cell: this.cell,
        node: this.node
      });
    }

    this.notify('knob:mousedown', e);
  }

  onMouseMove(e) {
    const data = this.getEventData(e);
    const view = this.graph.findViewByCell(this.node);

    if (!data.knobbing) {
      data.knobbing = true;

      if (view) {
        view.addClass(Private.KNOBBING);
        this.notify('knob', e);
      }

      this.model.startBatch('knob', {
        cid: this.cid
      });
    }

    data.clientX = e.clientX;
    data.clientY = e.clientY;

    if (this.metadata && this.metadata.onMouseMove) {
      const ctm = this.graph.matrix();
      const dx = (e.clientX - data.originX) / ctm.a;
      const dy = (e.clientY - data.originY) / ctm.d;
      const angle = this.node.getAngle();
      const delta = new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(dx, dy).rotate(angle);
      this.metadata.onMouseMove.call(this.graph, {
        e,
        data,
        deltaX: delta.x,
        deltaY: delta.y,
        knob: this,
        cell: this.cell,
        node: this.node
      });
    }

    this.notify('knobbing', e);
    this.notify('knob:mousemove', e);
  }

  onMouseUp(e) {
    this.undelegateDocumentEvents();
    this.graph.view.delegateEvents();
    const data = this.getEventData(e);
    const view = this.graph.findViewByCell(this.node);

    if (data.knobbing) {
      if (view) {
        view.removeClass(Private.KNOBBING);
      }

      if (this.metadata && this.metadata.onMouseUp) {
        this.metadata.onMouseUp.call(this.graph, {
          e,
          data,
          knob: this,
          cell: this.cell,
          node: this.node
        });
      }

      this.model.stopBatch('knob', {
        cid: this.cid
      });
      this.notify('knobbed', e);
    }

    this.notify('knob:mouseup', e);
  }

}
var Private;

(function (Private) {
  Private.KNOB = 'has-widget-knob';
  Private.KNOBBING = 'node-knobbing';
  Private.documentEvents = {
    mousemove: 'onMouseMove',
    touchmove: 'onMouseMove',
    mouseup: 'onMouseUp',
    touchend: 'onMouseUp'
  };
})(Private || (Private = {}));

/***/ }),

/***/ 31009:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/minimap/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MiniMap": () => (/* binding */ MiniMap)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/view */ 58458);
/* harmony import */ var _graph_graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../graph/graph */ 77947);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




var ClassName;

(function (ClassName) {
  ClassName.root = 'widget-minimap';
  ClassName.viewport = `${ClassName.root}-viewport`;
  ClassName.zoom = `${ClassName.viewport}-zoom`;
})(ClassName || (ClassName = {}));

class MiniMap extends _view_view__WEBPACK_IMPORTED_MODULE_1__.View {
  constructor(options) {
    super();
    this.options = Object.assign(Object.assign({}, Util.defaultOptions), options);
    this.updateViewport = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.debounce(this.updateViewport.bind(this), 0);
    this.container = document.createElement('div');
    this.$container = this.$(this.container).addClass(this.prefixClassName(ClassName.root));
    const graphContainer = document.createElement('div');
    this.container.appendChild(graphContainer);
    this.$viewport = this.$('<div>').addClass(this.prefixClassName(ClassName.viewport));

    if (this.options.scalable) {
      this.zoomHandle = this.$('<div>').addClass(this.prefixClassName(ClassName.zoom)).appendTo(this.$viewport).get(0);
    }

    this.$container.append(this.$viewport).css({
      width: this.options.width,
      height: this.options.height,
      padding: this.options.padding
    });

    if (this.options.container) {
      this.options.container.appendChild(this.container);
    }

    this.sourceGraph = this.graph;
    const targetGraphOptions = Object.assign(Object.assign({}, this.options.graphOptions), {
      container: graphContainer,
      model: this.sourceGraph.model,
      frozen: true,
      async: this.sourceGraph.isAsync(),
      interacting: false,
      grid: false,
      background: false,
      rotating: false,
      resizing: false,
      embedding: false,
      selecting: false,
      snapline: false,
      clipboard: false,
      history: false,
      scroller: false
    });
    this.targetGraph = this.options.createGraph ? this.options.createGraph(targetGraphOptions) : new _graph_graph__WEBPACK_IMPORTED_MODULE_2__.Graph(targetGraphOptions);
    this.targetGraph.renderer.unfreeze();
    this.updatePaper(this.sourceGraph.options.width, this.sourceGraph.options.height);
    this.startListening();
  }

  get graph() {
    return this.options.graph;
  }

  get scroller() {
    return this.graph.scroller.widget;
  }

  get graphContainer() {
    if (this.scroller) {
      return this.scroller.container;
    }

    return this.graph.container;
  }

  get $graphContainer() {
    if (this.scroller) {
      return this.scroller.$container;
    }

    return this.$(this.graph.container);
  }

  startListening() {
    if (this.scroller) {
      this.$graphContainer.on(`scroll${this.getEventNamespace()}`, this.updateViewport);
    } else {
      this.sourceGraph.on('translate', this.onTransform, this);
      this.sourceGraph.on('scale', this.onTransform, this);
      this.sourceGraph.on('model:updated', this.onModelUpdated, this);
    }

    this.sourceGraph.on('resize', this.updatePaper, this);
    this.delegateEvents({
      mousedown: 'startAction',
      touchstart: 'startAction',
      [`mousedown .${this.prefixClassName('graph')}`]: 'scrollTo',
      [`touchstart .${this.prefixClassName('graph')}`]: 'scrollTo'
    });
  }

  stopListening() {
    if (this.scroller) {
      this.$graphContainer.off(this.getEventNamespace());
    } else {
      this.sourceGraph.off('translate', this.onTransform, this);
      this.sourceGraph.off('scale', this.onTransform, this);
      this.sourceGraph.off('model:updated', this.onModelUpdated, this);
    }

    this.sourceGraph.off('resize', this.updatePaper, this);
    this.undelegateEvents();
  }

  onRemove() {
    this.targetGraph.view.remove();
    this.stopListening();
    this.targetGraph.dispose();
  }

  onTransform(options) {
    if (options.ui || this.targetGraphTransforming) {
      this.updateViewport();
    }
  }

  onModelUpdated() {
    this.targetGraph.zoomToFit();
  }

  updatePaper(w, h) {
    let width;
    let height;

    if (typeof w === 'object') {
      width = w.width;
      height = w.height;
    } else {
      width = w;
      height = h;
    }

    const origin = this.sourceGraph.options;
    const scale = this.sourceGraph.transform.getScale();
    const maxWidth = this.options.width - 2 * this.options.padding;
    const maxHeight = this.options.height - 2 * this.options.padding;
    width /= scale.sx; // eslint-disable-line

    height /= scale.sy; // eslint-disable-line

    this.ratio = Math.min(maxWidth / width, maxHeight / height);
    const ratio = this.ratio;
    const x = origin.x * ratio / scale.sx;
    const y = origin.y * ratio / scale.sy;
    width *= ratio; // eslint-disable-line

    height *= ratio; // eslint-disable-line

    this.targetGraph.resizeGraph(width, height);
    this.targetGraph.translate(x, y);

    if (this.scroller) {
      this.targetGraph.scale(ratio, ratio);
    } else {
      this.targetGraph.zoomToFit();
    }

    this.updateViewport();
    return this;
  }

  updateViewport() {
    const sourceGraphScale = this.sourceGraph.transform.getScale();
    const targetGraphScale = this.targetGraph.transform.getScale();
    let origin = null;

    if (this.scroller) {
      origin = this.scroller.clientToLocalPoint(0, 0);
    } else {
      origin = this.graph.graphToLocal(0, 0);
    }

    const position = this.$(this.targetGraph.container).position();
    const translation = this.targetGraph.translate();
    translation.ty = translation.ty || 0;
    this.geometry = {
      top: position.top + origin.y * targetGraphScale.sy + translation.ty,
      left: position.left + origin.x * targetGraphScale.sx + translation.tx,
      width: this.$graphContainer.innerWidth() * targetGraphScale.sx / sourceGraphScale.sx,
      height: this.$graphContainer.innerHeight() * targetGraphScale.sy / sourceGraphScale.sy
    };
    this.$viewport.css(this.geometry);
  }

  startAction(evt) {
    const e = this.normalizeEvent(evt);
    const action = e.target === this.zoomHandle ? 'zooming' : 'panning';
    const {
      tx,
      ty
    } = this.sourceGraph.translate();
    const eventData = {
      action,
      clientX: e.clientX,
      clientY: e.clientY,
      scrollLeft: this.graphContainer.scrollLeft,
      scrollTop: this.graphContainer.scrollTop,
      zoom: this.sourceGraph.zoom(),
      scale: this.sourceGraph.transform.getScale(),
      geometry: this.geometry,
      translateX: tx,
      translateY: ty
    };
    this.targetGraphTransforming = true;
    this.delegateDocumentEvents(Util.documentEvents, eventData);
  }

  doAction(evt) {
    const e = this.normalizeEvent(evt);
    const clientX = e.clientX;
    const clientY = e.clientY;
    const data = e.data;

    switch (data.action) {
      case 'panning':
        {
          const scale = this.sourceGraph.transform.getScale();
          const rx = (clientX - data.clientX) * scale.sx;
          const ry = (clientY - data.clientY) * scale.sy;

          if (this.scroller) {
            this.graphContainer.scrollLeft = data.scrollLeft + rx / this.ratio;
            this.graphContainer.scrollTop = data.scrollTop + ry / this.ratio;
          } else {
            this.sourceGraph.translate(data.translateX - rx / this.ratio, data.translateY - ry / this.ratio);
          }

          break;
        }

      case 'zooming':
        {
          const startScale = data.scale;
          const startGeometry = data.geometry;
          const delta = 1 + (data.clientX - clientX) / startGeometry.width / startScale.sx;

          if (data.frameId) {
            cancelAnimationFrame(data.frameId);
          }

          data.frameId = requestAnimationFrame(() => {
            this.sourceGraph.zoom(delta * data.zoom, {
              absolute: true,
              minScale: this.options.minScale,
              maxScale: this.options.maxScale
            });
          });
          break;
        }

      default:
        break;
    }
  }

  stopAction() {
    this.undelegateDocumentEvents();
    this.targetGraphTransforming = false;
  }

  scrollTo(evt) {
    const e = this.normalizeEvent(evt);
    let x;
    let y;
    const ts = this.targetGraph.translate();
    ts.ty = ts.ty || 0;

    if (e.offsetX == null) {
      const offset = this.$(this.targetGraph.container).offset();
      x = e.pageX - offset.left;
      y = e.pageY - offset.top;
    } else {
      x = e.offsetX;
      y = e.offsetY;
    }

    const cx = (x - ts.tx) / this.ratio;
    const cy = (y - ts.ty) / this.ratio;
    this.sourceGraph.centerPoint(cx, cy);
  }

  dispose() {
    this.remove();
  }

}

__decorate([_view_view__WEBPACK_IMPORTED_MODULE_1__.View.dispose()], MiniMap.prototype, "dispose", null);

var Util;

(function (Util) {
  Util.defaultOptions = {
    width: 300,
    height: 200,
    padding: 10,
    scalable: true,
    minScale: 0.01,
    maxScale: 16,
    graphOptions: {},
    createGraph: options => new _graph_graph__WEBPACK_IMPORTED_MODULE_2__.Graph(options)
  };
  Util.documentEvents = {
    mousemove: 'doAction',
    touchmove: 'doAction',
    mouseup: 'stopAction',
    touchend: 'stopAction'
  };
})(Util || (Util = {}));

/***/ }),

/***/ 55644:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/scroller/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scroller": () => (/* binding */ Scroller)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/view */ 58458);
/* harmony import */ var _graph_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../graph/renderer */ 47801);
/* harmony import */ var _graph_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../graph/view */ 716);
/* harmony import */ var _graph_background__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../graph/background */ 26028);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







class Scroller extends _view_view__WEBPACK_IMPORTED_MODULE_2__.View {
  constructor(options) {
    super();
    this.padding = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    this.options = Util.getOptions(options);
    const scale = this.graph.transform.getScale();
    this.sx = scale.sx;
    this.sy = scale.sy;
    const width = this.options.width || this.graph.options.width;
    const height = this.options.height || this.graph.options.height;
    this.container = document.createElement('div');
    this.$container = this.$(this.container).addClass(this.prefixClassName(Util.containerClass)).css({
      width,
      height
    });

    if (this.options.pageVisible) {
      this.$container.addClass(this.prefixClassName(Util.pagedClass));
    }

    if (this.options.className) {
      this.$container.addClass(this.options.className);
    }

    const graphContainer = this.graph.container;

    if (graphContainer.parentNode) {
      this.$container.insertBefore(graphContainer);
    } // copy style


    const style = graphContainer.getAttribute('style');

    if (style) {
      const obj = {};
      const styles = style.split(';');
      styles.forEach(item => {
        const section = item.trim();

        if (section) {
          const pair = section.split(':');

          if (pair.length) {
            obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';
          }
        }
      });
      Object.keys(obj).forEach(key => {
        if (key === 'width' || key === 'height') {
          return;
        }

        graphContainer.style[key] = '';
        this.container.style[key] = obj[key];
      });
    }

    this.content = document.createElement('div');
    this.$content = this.$(this.content).addClass(this.prefixClassName(Util.contentClass)).css({
      width: this.graph.options.width,
      height: this.graph.options.height
    }); // custom background

    this.background = document.createElement('div');
    this.$background = this.$(this.background).addClass(this.prefixClassName(Util.backgroundClass));
    this.$content.append(this.background);

    if (!this.options.pageVisible) {
      this.$content.append(this.graph.view.grid);
    }

    this.$content.append(graphContainer);
    this.$content.appendTo(this.container);
    this.startListening();

    if (!this.options.pageVisible) {
      this.graph.grid.update();
    }

    this.backgroundManager = new Scroller.Background(this);

    if (!this.options.autoResize) {
      this.update();
    }
  }

  get graph() {
    return this.options.graph;
  }

  get model() {
    return this.graph.model;
  }

  startListening() {
    const graph = this.graph;
    const model = this.model;
    graph.on('scale', this.onScale, this);
    graph.on('resize', this.onResize, this);
    graph.on('before:print', this.storeScrollPosition, this);
    graph.on('before:export', this.storeScrollPosition, this);
    graph.on('after:print', this.restoreScrollPosition, this);
    graph.on('after:export', this.restoreScrollPosition, this);
    graph.on('render:done', this.onRenderDone, this);
    graph.on('unfreeze', this.onUpdate, this);
    model.on('reseted', this.onUpdate, this);
    model.on('cell:added', this.onUpdate, this);
    model.on('cell:removed', this.onUpdate, this);
    model.on('cell:changed', this.onUpdate, this);
    model.on('batch:stop', this.onBatchStop, this);
    this.delegateBackgroundEvents();
  }

  stopListening() {
    const graph = this.graph;
    const model = this.model;
    graph.off('scale', this.onScale, this);
    graph.off('resize', this.onResize, this);
    graph.off('beforeprint', this.storeScrollPosition, this);
    graph.off('beforeexport', this.storeScrollPosition, this);
    graph.off('afterprint', this.restoreScrollPosition, this);
    graph.off('afterexport', this.restoreScrollPosition, this);
    graph.off('render:done', this.onRenderDone, this);
    graph.off('unfreeze', this.onUpdate, this);
    model.off('reseted', this.onUpdate, this);
    model.off('cell:added', this.onUpdate, this);
    model.off('cell:removed', this.onUpdate, this);
    model.off('cell:changed', this.onUpdate, this);
    model.off('batch:stop', this.onBatchStop, this);
    this.undelegateBackgroundEvents();
  }

  enableAutoResize() {
    this.options.autoResize = true;
  }

  disableAutoResize() {
    this.options.autoResize = false;
  }

  onUpdate() {
    if (this.graph.isAsync() || !this.options.autoResize) {
      return;
    }

    this.update();
  }

  onBatchStop(args) {
    if (this.graph.isAsync() || !this.options.autoResize) {
      return;
    }

    if (_graph_renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {
      this.update();
    }
  }

  delegateBackgroundEvents(events) {
    const evts = events || _graph_view__WEBPACK_IMPORTED_MODULE_4__.GraphView.events;
    this.delegatedHandlers = Object.keys(evts).reduce((memo, name) => {
      const handler = evts[name];

      if (name.indexOf(' ') === -1) {
        if (typeof handler === 'function') {
          memo[name] = handler;
        } else {
          let method = this.graph.view[handler];

          if (typeof method === 'function') {
            method = method.bind(this.graph.view);
            memo[name] = method;
          }
        }
      }

      return memo;
    }, {});
    this.onBackgroundEvent = this.onBackgroundEvent.bind(this);
    Object.keys(this.delegatedHandlers).forEach(name => {
      this.delegateEvent(name, {
        guarded: false
      }, this.onBackgroundEvent);
    });
  }

  undelegateBackgroundEvents() {
    Object.keys(this.delegatedHandlers).forEach(name => {
      this.undelegateEvent(name, this.onBackgroundEvent);
    });
  }

  onBackgroundEvent(e) {
    let valid = false;
    const target = e.target;

    if (!this.options.pageVisible) {
      const view = this.graph.view;
      valid = view.background === target || view.grid === target;
    } else if (this.options.background) {
      valid = this.background === target;
    } else {
      valid = this.content === target;
    }

    if (valid) {
      const handler = this.delegatedHandlers[e.type];

      if (typeof handler === 'function') {
        handler.apply(this.graph, arguments); // eslint-disable-line
      }
    }
  }

  onRenderDone({
    stats
  }) {
    if (this.options.autoResize && stats.priority < 2) {
      this.update();
    }
  }

  onResize() {
    if (this.cachedCenterPoint) {
      this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);
      this.updatePageBreak();
    }
  }

  onScale({
    sx,
    sy,
    ox,
    oy
  }) {
    this.updateScale(sx, sy);

    if (ox || oy) {
      this.centerPoint(ox, oy);
      this.updatePageBreak();
    }

    const autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;

    if (typeof autoResizeOptions === 'function') {
      this.update();
    }
  }

  storeScrollPosition() {
    this.cachedScrollLeft = this.container.scrollLeft;
    this.cachedScrollTop = this.container.scrollTop;
  }

  restoreScrollPosition() {
    this.container.scrollLeft = this.cachedScrollLeft;
    this.container.scrollTop = this.cachedScrollTop;
    this.cachedScrollLeft = null;
    this.cachedScrollTop = null;
  }

  storeClientSize() {
    this.cachedClientSize = {
      width: this.container.clientWidth,
      height: this.container.clientHeight
    };
  }

  restoreClientSize() {
    this.cachedClientSize = null;
  }

  beforeManipulation() {
    if (_util__WEBPACK_IMPORTED_MODULE_0__.Platform.IS_IE || _util__WEBPACK_IMPORTED_MODULE_0__.Platform.IS_EDGE) {
      this.$container.css('visibility', 'hidden');
    }
  }

  afterManipulation() {
    if (_util__WEBPACK_IMPORTED_MODULE_0__.Platform.IS_IE || _util__WEBPACK_IMPORTED_MODULE_0__.Platform.IS_EDGE) {
      this.$container.css('visibility', 'visible');
    }
  }

  updatePageSize(width, height) {
    if (width != null) {
      this.options.pageWidth = width;
    }

    if (height != null) {
      this.options.pageHeight = height;
    }

    this.updatePageBreak();
  }

  updatePageBreak() {
    if (this.pageBreak && this.pageBreak.parentNode) {
      this.pageBreak.parentNode.removeChild(this.pageBreak);
    }

    this.pageBreak = null;

    if (this.options.pageVisible && this.options.pageBreak) {
      const graphWidth = this.graph.options.width;
      const graphHeight = this.graph.options.height;
      const pageWidth = this.options.pageWidth * this.sx;
      const pageHeight = this.options.pageHeight * this.sy;

      if (graphWidth > pageWidth || graphHeight > pageHeight) {
        let hasPageBreak = false;
        const container = document.createElement('div');

        for (let i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {
          this.$('<div/>').addClass(this.prefixClassName(`graph-pagebreak-vertical`)).css({
            left: i * pageWidth
          }).appendTo(container);
          hasPageBreak = true;
        }

        for (let i = 1, l = Math.floor(graphHeight / pageHeight); i < l; i += 1) {
          this.$('<div/>').addClass(this.prefixClassName(`graph-pagebreak-horizontal`)).css({
            top: i * pageHeight
          }).appendTo(container);
          hasPageBreak = true;
        }

        if (hasPageBreak) {
          _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(container, this.prefixClassName('graph-pagebreak'));
          this.$(this.graph.view.grid).after(container);
          this.pageBreak = container;
        }
      }
    }
  }

  update() {
    const size = this.getClientSize();
    this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);
    let resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;

    if (typeof resizeOptions === 'function') {
      resizeOptions = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(resizeOptions, this, this);
    }

    const options = Object.assign({
      gridWidth: this.options.pageWidth,
      gridHeight: this.options.pageHeight,
      allowNewOrigin: 'negative'
    }, resizeOptions);
    this.graph.fitToContent(this.getFitToContentOptions(options));
  }

  getFitToContentOptions(options) {
    const sx = this.sx;
    const sy = this.sy;
    options.gridWidth && (options.gridWidth *= sx);
    options.gridHeight && (options.gridHeight *= sy);
    options.minWidth && (options.minWidth *= sx);
    options.minHeight && (options.minHeight *= sy);

    if (typeof options.padding === 'object') {
      options.padding = {
        left: (options.padding.left || 0) * sx,
        right: (options.padding.right || 0) * sx,
        top: (options.padding.top || 0) * sy,
        bottom: (options.padding.bottom || 0) * sy
      };
    } else if (typeof options.padding === 'number') {
      options.padding *= sx;
    }

    if (!this.options.autoResize) {
      options.contentArea = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create();
    }

    return options;
  }

  updateScale(sx, sy) {
    const options = this.graph.options;
    const dx = sx / this.sx;
    const dy = sy / this.sy;
    this.sx = sx;
    this.sy = sy;
    this.graph.translate(options.x * dx, options.y * dy);
    this.graph.resizeGraph(options.width * dx, options.height * dy);
  }

  scrollbarPosition(left, top, options) {
    if (left == null && top == null) {
      return {
        left: this.container.scrollLeft,
        top: this.container.scrollTop
      };
    }

    const prop = {};

    if (typeof left === 'number') {
      prop.scrollLeft = left;
    }

    if (typeof top === 'number') {
      prop.scrollTop = top;
    }

    if (options && options.animation) {
      this.$container.animate(prop, options.animation);
    } else {
      this.$container.prop(prop);
    }

    return this;
  }
  /**
   * Try to scroll to ensure that the position (x,y) on the graph (in local
   * coordinates) is at the center of the viewport. If only one of the
   * coordinates is specified, only scroll in the specified dimension and
   * keep the other coordinate unchanged.
   */


  scrollToPoint(x, y, options) {
    const size = this.getClientSize();
    const ctm = this.graph.matrix();
    const prop = {};

    if (typeof x === 'number') {
      prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);
    }

    if (typeof y === 'number') {
      prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);
    }

    if (options && options.animation) {
      this.$container.animate(prop, options.animation);
    } else {
      this.$container.prop(prop);
    }

    return this;
  }
  /**
   * Try to scroll to ensure that the center of graph content is at the
   * center of the viewport.
   */


  scrollToContent(options) {
    const sx = this.sx;
    const sy = this.sy;
    const center = this.graph.getContentArea().getCenter();
    return this.scrollToPoint(center.x * sx, center.y * sy, options);
  }
  /**
   * Try to scroll to ensure that the center of cell is at the center of
   * the viewport.
   */


  scrollToCell(cell, options) {
    const sx = this.sx;
    const sy = this.sy;
    const center = cell.getBBox().getCenter();
    return this.scrollToPoint(center.x * sx, center.y * sy, options);
  }
  /**
   * The center methods are more aggressive than the scroll methods. These
   * methods position the graph so that a specific point on the graph lies
   * at the center of the viewport, adding paddings around the paper if
   * necessary (e.g. if the requested point lies in a corner of the paper).
   * This means that the requested point will always move into the center
   * of the viewport. (Use the scroll functions to avoid adding paddings
   * and only scroll the viewport as far as the graph boundary.)
   */

  /**
   * Position the center of graph to the center of the viewport.
   */


  center(optons) {
    return this.centerPoint(optons);
  }

  centerPoint(x, y, options) {
    const ctm = this.graph.matrix();
    const sx = ctm.a;
    const sy = ctm.d;
    const tx = -ctm.e;
    const ty = -ctm.f;
    const tWidth = tx + this.graph.options.width;
    const tHeight = ty + this.graph.options.height;
    let localOptions;
    this.storeClientSize(); // avoid multilple reflow

    if (typeof x === 'number' || typeof y === 'number') {
      localOptions = options;
      const visibleCenter = this.getVisibleArea().getCenter();

      if (typeof x === 'number') {
        x *= sx; // eslint-disable-line
      } else {
        x = visibleCenter.x; // eslint-disable-line
      }

      if (typeof y === 'number') {
        y *= sy; // eslint-disable-line
      } else {
        y = visibleCenter.y; // eslint-disable-line
      }
    } else {
      localOptions = x;
      x = (tx + tWidth) / 2; // eslint-disable-line

      y = (ty + tHeight) / 2; // eslint-disable-line
    }

    if (localOptions && localOptions.padding) {
      return this.positionPoint({
        x,
        y
      }, '50%', '50%', localOptions);
    }

    const padding = this.getPadding();
    const clientSize = this.getClientSize();
    const cx = clientSize.width / 2;
    const cy = clientSize.height / 2;
    const left = cx - padding.left - x + tx;
    const right = cx - padding.right + x - tWidth;
    const top = cy - padding.top - y + ty;
    const bottom = cy - padding.bottom + y - tHeight;
    this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));
    const result = this.scrollToPoint(x, y, localOptions || undefined);
    this.restoreClientSize();
    return result;
  }

  centerContent(options) {
    return this.positionContent('center', options);
  }

  centerCell(cell, options) {
    return this.positionCell(cell, 'center', options);
  }
  /**
   * The position methods are a more general version of the center methods.
   * They position the graph so that a specific point on the graph lies at
   * requested coordinates inside the viewport.
   */

  /**
   *
   */


  positionContent(pos, options) {
    const rect = this.graph.getContentArea(options);
    return this.positionRect(rect, pos, options);
  }

  positionCell(cell, pos, options) {
    const bbox = cell.getBBox();
    return this.positionRect(bbox, pos, options);
  }

  positionRect(rect, pos, options) {
    const bbox = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rect);

    switch (pos) {
      case 'center':
        return this.positionPoint(bbox.getCenter(), '50%', '50%', options);

      case 'top':
        return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);

      case 'top-right':
        return this.positionPoint(bbox.getTopRight(), '100%', 0, options);

      case 'right':
        return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);

      case 'bottom-right':
        return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);

      case 'bottom':
        return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);

      case 'bottom-left':
        return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);

      case 'left':
        return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);

      case 'top-left':
        return this.positionPoint(bbox.getTopLeft(), 0, 0, options);

      default:
        return this;
    }
  }

  positionPoint(point, x, y, options = {}) {
    const {
      padding: pad
    } = options,
          localOptions = __rest(options, ["padding"]);

    const padding = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(pad);
    const clientRect = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromSize(this.getClientSize());
    const targetRect = clientRect.clone().moveAndExpand({
      x: padding.left,
      y: padding.top,
      width: -padding.right - padding.left,
      height: -padding.top - padding.bottom
    }); // eslint-disable-next-line

    x = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(x, Math.max(0, targetRect.width));

    if (x < 0) {
      x = targetRect.width + x; // eslint-disable-line
    } // eslint-disable-next-line


    y = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(y, Math.max(0, targetRect.height));

    if (y < 0) {
      y = targetRect.height + y; // eslint-disable-line
    }

    const origin = targetRect.getTopLeft().translate(x, y);
    const diff = clientRect.getCenter().diff(origin);
    const scale = this.zoom();
    const rawDiff = diff.scale(1 / scale, 1 / scale);
    const result = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(point).translate(rawDiff);
    return this.centerPoint(result.x, result.y, localOptions);
  }

  zoom(factor, options) {
    if (factor == null) {
      return this.sx;
    }

    options = options || {}; // eslint-disable-line

    let cx;
    let cy;
    const clientSize = this.getClientSize();
    const center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);
    let sx = factor;
    let sy = factor;

    if (!options.absolute) {
      sx += this.sx;
      sy += this.sy;
    }

    if (options.scaleGrid) {
      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
    }

    if (options.maxScale) {
      sx = Math.min(options.maxScale, sx);
      sy = Math.min(options.maxScale, sy);
    }

    if (options.minScale) {
      sx = Math.max(options.minScale, sx);
      sy = Math.max(options.minScale, sy);
    }

    sx = this.graph.transform.clampScale(sx);
    sy = this.graph.transform.clampScale(sy);

    if (options.center) {
      const fx = sx / this.sx;
      const fy = sy / this.sy;
      cx = options.center.x - (options.center.x - center.x) / fx;
      cy = options.center.y - (options.center.y - center.y) / fy;
    } else {
      cx = center.x;
      cy = center.y;
    }

    this.beforeManipulation();
    this.graph.transform.scale(sx, sy);
    this.centerPoint(cx, cy);
    this.afterManipulation();
    return this;
  }

  zoomToRect(rect, options = {}) {
    const area = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rect);
    const graph = this.graph;
    options.contentArea = area;

    if (options.viewportArea == null) {
      options.viewportArea = {
        x: graph.options.x,
        y: graph.options.y,
        width: this.$container.width(),
        height: this.$container.height()
      };
    }

    this.beforeManipulation();
    graph.transform.scaleContentToFitImpl(options, false);
    const center = area.getCenter();
    this.centerPoint(center.x, center.y);
    this.afterManipulation();
    return this;
  }

  zoomToFit(options = {}) {
    return this.zoomToRect(this.graph.getContentArea(options), options);
  }

  transitionToPoint(x, y, options) {
    if (typeof x === 'object') {
      options = y; // eslint-disable-line

      y = x.y; // eslint-disable-line

      x = x.x; // eslint-disable-line
    } else {
      y = y; // eslint-disable-line
    }

    if (options == null) {
      options = {}; // eslint-disable-line
    }

    let transform;
    let transformOrigin;
    const scale = this.sx;
    const targetScale = Math.max(options.scale || scale, 0.000001);
    const clientSize = this.getClientSize();
    const targetPoint = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y);
    const localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);

    if (scale === targetScale) {
      const translate = localPoint.diff(targetPoint).scale(scale, scale).round();
      transform = `translate(${translate.x}px,${translate.y}px)`;
    } else {
      const delta = targetScale / (scale - targetScale) * targetPoint.distance(localPoint);
      const range = localPoint.clone().move(targetPoint, delta);
      const origin = this.localToBackgroundPoint(range).round();
      transform = `scale(${targetScale / scale})`;
      transformOrigin = `${origin.x}px ${origin.y}px`;
    }

    const onTransitionEnd = options.onTransitionEnd;
    this.$container.addClass(Util.transitionClassName);
    this.$content.off(Util.transitionEventName).on(Util.transitionEventName, e => {
      this.syncTransition(targetScale, {
        x: x,
        y: y
      });

      if (typeof onTransitionEnd === 'function') {
        _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(onTransitionEnd, this, e.originalEvent);
      }
    }).css({
      transform,
      transformOrigin,
      transition: 'transform',
      transitionDuration: options.duration || '1s',
      transitionDelay: options.delay,
      transitionTimingFunction: options.timing
    });
    return this;
  }

  syncTransition(scale, p) {
    this.beforeManipulation();
    this.graph.scale(scale);
    this.removeTransition();
    this.centerPoint(p.x, p.y);
    this.afterManipulation();
    return this;
  }

  removeTransition() {
    this.$container.removeClass(Util.transitionClassName);
    this.$content.off(Util.transitionEventName).css({
      transform: '',
      transformOrigin: '',
      transition: '',
      transitionDuration: '',
      transitionDelay: '',
      transitionTimingFunction: ''
    });
    return this;
  }

  transitionToRect(rectangle, options = {}) {
    const rect = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rectangle);
    const maxScale = options.maxScale || Infinity;
    const minScale = options.minScale || Number.MIN_VALUE;
    const scaleGrid = options.scaleGrid || null;
    const PIXEL_SIZE = options.visibility || 1;
    const center = options.center ? _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(options.center) : rect.getCenter();
    const clientSize = this.getClientSize();
    const w = clientSize.width * PIXEL_SIZE;
    const h = clientSize.height * PIXEL_SIZE;
    let scale = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);
    scale = Math.min(scale, maxScale);

    if (scaleGrid) {
      scale = Math.floor(scale / scaleGrid) * scaleGrid;
    }

    scale = Math.max(minScale, scale);
    return this.transitionToPoint(center, Object.assign({
      scale
    }, options));
  }

  startPanning(evt) {
    const e = this.normalizeEvent(evt);
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.trigger('pan:start', {
      e
    });
    this.$(document.body).on({
      'mousemove.panning touchmove.panning': this.pan.bind(this),
      'mouseup.panning touchend.panning': this.stopPanning.bind(this),
      'mouseleave.panning': this.stopPanning.bind(this)
    });
    this.$(window).on('mouseup.panning', this.stopPanning.bind(this));
  }

  pan(evt) {
    const e = this.normalizeEvent(evt);
    const dx = e.clientX - this.clientX;
    const dy = e.clientY - this.clientY;
    this.container.scrollTop -= dy;
    this.container.scrollLeft -= dx;
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.trigger('panning', {
      e
    });
  }

  stopPanning(e) {
    this.$(document.body).off('.panning');
    this.$(window).off('.panning');
    this.trigger('pan:stop', {
      e
    });
  }

  clientToLocalPoint(a, b) {
    let x = typeof a === 'object' ? a.x : a;
    let y = typeof a === 'object' ? a.y : b;
    const ctm = this.graph.matrix();
    x += this.container.scrollLeft - this.padding.left - ctm.e;
    y += this.container.scrollTop - this.padding.top - ctm.f;
    return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x / ctm.a, y / ctm.d);
  }

  localToBackgroundPoint(x, y) {
    const p = typeof x === 'object' ? _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(x) : new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y);
    const ctm = this.graph.matrix();
    const padding = this.padding;
    return _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformPoint(p, ctm).translate(padding.left, padding.top);
  }

  resize(width, height) {
    let w = width != null ? width : this.container.offsetWidth;
    let h = height != null ? height : this.container.offsetHeight;

    if (typeof w === 'number') {
      w = Math.round(w);
    }

    if (typeof h === 'number') {
      h = Math.round(h);
    }

    this.options.width = w;
    this.options.height = h;
    this.$container.css({
      width: w,
      height: h
    });
    this.update();
  }

  getClientSize() {
    if (this.cachedClientSize) {
      return this.cachedClientSize;
    }

    return {
      width: this.container.clientWidth,
      height: this.container.clientHeight
    };
  }

  autoScroll(clientX, clientY) {
    const buffer = 10;
    const container = this.container;
    const rect = container.getBoundingClientRect();
    let dx = 0;
    let dy = 0;

    if (clientX <= rect.left + buffer) {
      dx = -buffer;
    }

    if (clientY <= rect.top + buffer) {
      dy = -buffer;
    }

    if (clientX >= rect.right - buffer) {
      dx = buffer;
    }

    if (clientY >= rect.bottom - buffer) {
      dy = buffer;
    }

    if (dx !== 0) {
      container.scrollLeft += dx;
    }

    if (dy !== 0) {
      container.scrollTop += dy;
    }

    return {
      scrollerX: dx,
      scrollerY: dy
    };
  }

  addPadding(left, right, top, bottom) {
    let padding = this.getPadding();
    this.padding = {
      left: Math.round(padding.left + (left || 0)),
      top: Math.round(padding.top + (top || 0)),
      bottom: Math.round(padding.bottom + (bottom || 0)),
      right: Math.round(padding.right + (right || 0))
    };
    padding = this.padding;
    this.$content.css({
      width: padding.left + this.graph.options.width + padding.right,
      height: padding.top + this.graph.options.height + padding.bottom
    });
    const container = this.graph.container;
    container.style.left = `${this.padding.left}px`;
    container.style.top = `${this.padding.top}px`;
    return this;
  }

  getPadding() {
    const padding = this.options.padding;

    if (typeof padding === 'function') {
      return _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(_util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(padding, this, this));
    }

    return _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(padding);
  }
  /**
   * Returns the untransformed size and origin of the current viewport.
   */


  getVisibleArea() {
    const ctm = this.graph.matrix();
    const size = this.getClientSize();
    const box = {
      x: this.container.scrollLeft || 0,
      y: this.container.scrollTop || 0,
      width: size.width,
      height: size.height
    };
    const area = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformRectangle(box, ctm.inverse());
    area.x -= (this.padding.left || 0) / this.sx;
    area.y -= (this.padding.top || 0) / this.sy;
    return area;
  }

  isCellVisible(cell, options = {}) {
    const bbox = cell.getBBox();
    const area = this.getVisibleArea();
    return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);
  }

  isPointVisible(point) {
    return this.getVisibleArea().containsPoint(point);
  }
  /**
   * Lock the current viewport by disabling user scrolling.
   */


  lock() {
    this.$container.css('overflow', 'hidden');
    return this;
  }
  /**
   * Enable user scrolling if previously locked.
   */


  unlock() {
    this.$container.css('overflow', 'scroll');
    return this;
  }

  onRemove() {
    this.stopListening();
  }

  dispose() {
    this.$(this.graph.container).insertBefore(this.$container);
    this.remove();
  }

}

__decorate([_view_view__WEBPACK_IMPORTED_MODULE_2__.View.dispose()], Scroller.prototype, "dispose", null);

(function (Scroller) {
  class Background extends _graph_background__WEBPACK_IMPORTED_MODULE_5__.BackgroundManager {
    constructor(scroller) {
      super(scroller.graph);
      this.scroller = scroller;

      if (scroller.options.background) {
        this.draw(scroller.options.background);
      }
    }

    get elem() {
      return this.scroller.background;
    }

    init() {
      this.graph.on('scale', this.update, this);
      this.graph.on('translate', this.update, this);
    }

    updateBackgroundOptions(options) {
      this.scroller.options.background = options;
    }

  }

  Scroller.Background = Background;
})(Scroller || (Scroller = {}));

var Util;

(function (Util) {
  Util.containerClass = 'graph-scroller';
  Util.panningClass = `${Util.containerClass}-panning`;
  Util.pannableClass = `${Util.containerClass}-pannable`;
  Util.pagedClass = `${Util.containerClass}-paged`;
  Util.contentClass = `${Util.containerClass}-content`;
  Util.backgroundClass = `${Util.containerClass}-background`;
  Util.transitionClassName = 'transition-in-progress';
  Util.transitionEventName = 'transitionend.graph-scroller-transition';
  Util.defaultOptions = {
    padding() {
      const size = this.getClientSize();
      const minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;
      const minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;
      const left = Math.max(size.width - minWidth, 0);
      const top = Math.max(size.height - minHeight, 0);
      return {
        left,
        top,
        right: left,
        bottom: top
      };
    },

    minVisibleWidth: 50,
    minVisibleHeight: 50,
    pageVisible: false,
    pageBreak: false,
    autoResize: true
  };

  function getOptions(options) {
    const result = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, Util.defaultOptions, options);

    if (result.pageWidth == null) {
      result.pageWidth = options.graph.options.width;
    }

    if (result.pageHeight == null) {
      result.pageHeight = options.graph.options.height;
    }

    return result;
  }

  Util.getOptions = getOptions;
})(Util || (Util = {}));

/***/ }),

/***/ 42601:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Selection": () => (/* binding */ Selection)
/* harmony export */ });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global */ 9789);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _model_cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/cell */ 30936);
/* harmony import */ var _model_collection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/collection */ 62919);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../view/view */ 58458);
/* harmony import */ var _transform_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transform/util */ 24309);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common */ 92720);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};









class Selection extends _view_view__WEBPACK_IMPORTED_MODULE_5__.View {
  constructor(options) {
    super();
    this.options = _util__WEBPACK_IMPORTED_MODULE_2__.ObjectExt.merge({}, Private.defaultOptions, options);

    if (this.options.model) {
      this.options.collection = this.options.model.collection;
    }

    if (this.options.collection) {
      this.collection = this.options.collection;
    } else {
      this.collection = new _model_collection__WEBPACK_IMPORTED_MODULE_4__.Collection([], {
        comparator: Private.depthComparator
      });
      this.options.collection = this.collection;
    }

    this.boxCount = 0;
    this.createContainer();
    this.initHandles();
    this.startListening();
  }

  get graph() {
    return this.options.graph;
  }

  get boxClassName() {
    return this.prefixClassName(Private.classNames.box);
  }

  get $boxes() {
    return this.$container.children(`.${this.boxClassName}`);
  }

  get handleOptions() {
    return this.options;
  }

  startListening() {
    const graph = this.graph;
    const collection = this.collection;
    this.delegateEvents({
      [`mousedown .${this.boxClassName}`]: 'onSelectionBoxMouseDown',
      [`touchstart .${this.boxClassName}`]: 'onSelectionBoxMouseDown'
    }, true);
    graph.on('scale', this.onGraphTransformed, this);
    graph.on('translate', this.onGraphTransformed, this);
    graph.model.on('updated', this.onModelUpdated, this);
    collection.on('added', this.onCellAdded, this);
    collection.on('removed', this.onCellRemoved, this);
    collection.on('reseted', this.onReseted, this);
    collection.on('updated', this.onCollectionUpdated, this);
    collection.on('node:change:position', this.onNodePositionChanged, this);
    collection.on('cell:changed', this.onCellChanged, this);
  }

  stopListening() {
    const graph = this.graph;
    const collection = this.collection;
    this.undelegateEvents();
    graph.off('scale', this.onGraphTransformed, this);
    graph.off('translate', this.onGraphTransformed, this);
    graph.model.off('updated', this.onModelUpdated, this);
    collection.off('added', this.onCellAdded, this);
    collection.off('removed', this.onCellRemoved, this);
    collection.off('reseted', this.onReseted, this);
    collection.off('updated', this.onCollectionUpdated, this);
    collection.off('node:change:position', this.onNodePositionChanged, this);
    collection.off('cell:changed', this.onCellChanged, this);
  }

  onRemove() {
    this.stopListening();
  }

  onGraphTransformed() {
    this.updateSelectionBoxes({
      async: false
    });
  }

  onCellChanged() {
    this.updateSelectionBoxes();
  }

  onNodePositionChanged({
    node,
    options
  }) {
    const {
      showNodeSelectionBox,
      pointerEvents
    } = this.options;
    const {
      ui,
      selection,
      translateBy
    } = options;
    let allowTranslating = !this.translating;
    /* Scenarios where this method is not called:
     * 1. ShowNodeSelection is true or ponterEvents is none
     * 2. Avoid circular calls with the selection tag
     */

    allowTranslating = allowTranslating && (showNodeSelectionBox !== true || pointerEvents === 'none');
    allowTranslating = allowTranslating && ui && !selection; // Avoid circular calls of child nodes

    allowTranslating = allowTranslating && translateBy && node.id === translateBy;

    if (allowTranslating) {
      this.translating = true;
      const current = node.position();
      const previous = node.previous('position');
      const dx = current.x - previous.x;
      const dy = current.y - previous.y;

      if (dx !== 0 || dy !== 0) {
        this.translateSelectedNodes(dx, dy, node, options);
      }

      this.translating = false;
    }
  }

  onModelUpdated({
    removed
  }) {
    if (removed && removed.length) {
      this.unselect(removed);
    }
  }

  isEmpty() {
    return this.length <= 0;
  }

  isSelected(cell) {
    return this.collection.has(cell);
  }

  get length() {
    return this.collection.length;
  }

  get cells() {
    return this.collection.toArray();
  }

  select(cells, options = {}) {
    options.dryrun = true;
    const items = this.filter(Array.isArray(cells) ? cells : [cells]);
    this.collection.add(items, options);
    return this;
  }

  unselect(cells, options = {}) {
    // dryrun to prevent cell be removed from graph
    options.dryrun = true;
    this.collection.remove(Array.isArray(cells) ? cells : [cells], options);
    return this;
  }

  reset(cells, options = {}) {
    if (cells) {
      if (options.batch) {
        const filterCells = this.filter(Array.isArray(cells) ? cells : [cells]);
        this.collection.reset(filterCells, Object.assign(Object.assign({}, options), {
          ui: true
        }));
        return this;
      }

      const prev = this.cells;
      const next = this.filter(Array.isArray(cells) ? cells : [cells]);
      const prevMap = {};
      const nextMap = {};
      prev.forEach(cell => prevMap[cell.id] = cell);
      next.forEach(cell => nextMap[cell.id] = cell);
      const added = [];
      const removed = [];
      next.forEach(cell => {
        if (!prevMap[cell.id]) {
          added.push(cell);
        }
      });
      prev.forEach(cell => {
        if (!nextMap[cell.id]) {
          removed.push(cell);
        }
      });

      if (removed.length) {
        this.unselect(removed, Object.assign(Object.assign({}, options), {
          ui: true
        }));
      }

      if (added.length) {
        this.select(added, Object.assign(Object.assign({}, options), {
          ui: true
        }));
      }

      if (removed.length === 0 && added.length === 0) {
        this.updateContainer();
      }

      return this;
    }

    return this.clean(options);
  }

  clean(options = {}) {
    if (this.length) {
      if (options.batch === false) {
        this.unselect(this.cells, options);
      } else {
        this.collection.reset([], Object.assign(Object.assign({}, options), {
          ui: true
        }));
      }
    }

    return this;
  }

  setFilter(filter) {
    this.options.filter = filter;
  }

  setContent(content) {
    this.options.content = content;
  }

  startSelecting(evt) {
    // Flow: startSelecting => adjustSelection => stopSelecting
    evt = this.normalizeEvent(evt); // eslint-disable-line

    this.clean();
    let x;
    let y;
    const graphContainer = this.graph.container;

    if (evt.offsetX != null && evt.offsetY != null && graphContainer.contains(evt.target)) {
      x = evt.offsetX;
      y = evt.offsetY;
    } else {
      const offset = this.$(graphContainer).offset();
      const scrollLeft = graphContainer.scrollLeft;
      const scrollTop = graphContainer.scrollTop;
      x = evt.clientX - offset.left + window.pageXOffset + scrollLeft;
      y = evt.clientY - offset.top + window.pageYOffset + scrollTop;
    }

    this.$container.css({
      top: y,
      left: x,
      width: 1,
      height: 1
    });
    this.setEventData(evt, {
      action: 'selecting',
      clientX: evt.clientX,
      clientY: evt.clientY,
      offsetX: x,
      offsetY: y,
      scrollerX: 0,
      scrollerY: 0
    });
    this.delegateDocumentEvents(Private.documentEvents, evt.data);
  }

  filter(cells) {
    const filter = this.options.filter;

    if (Array.isArray(filter)) {
      return cells.filter(cell => !filter.includes(cell) && !filter.includes(cell.shape));
    }

    if (typeof filter === 'function') {
      return cells.filter(cell => _util__WEBPACK_IMPORTED_MODULE_2__.FunctionExt.call(filter, this.graph, cell));
    }

    return cells;
  }

  stopSelecting(evt) {
    const graph = this.graph;
    const eventData = this.getEventData(evt);
    const action = eventData.action;

    switch (action) {
      case 'selecting':
        {
          let width = this.$container.width();
          let height = this.$container.height();
          const offset = this.$container.offset();
          const origin = graph.pageToLocal(offset.left, offset.top);
          const scale = graph.transform.getScale();
          width /= scale.sx;
          height /= scale.sy;
          const rect = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(origin.x, origin.y, width, height);
          const cells = this.getCellViewsInArea(rect).map(view => view.cell);
          this.reset(cells, {
            batch: true
          });
          this.hideRubberband();
          break;
        }

      case 'translating':
        {
          const client = graph.snapToGrid(evt.clientX, evt.clientY);

          if (!this.options.following) {
            const data = eventData;
            this.updateSelectedNodesPosition({
              dx: data.clientX - data.originX,
              dy: data.clientY - data.originY
            });
          }

          this.graph.model.stopBatch('move-selection');
          this.notifyBoxEvent('box:mouseup', evt, client.x, client.y);
          break;
        }

      default:
        {
          this.clean();
          break;
        }
    }
  }

  onMouseUp(evt) {
    const action = this.getEventData(evt).action;

    if (action) {
      this.stopSelecting(evt);
      this.undelegateDocumentEvents();
    }
  }

  onSelectionBoxMouseDown(evt) {
    if (!this.options.following) {
      evt.stopPropagation();
    }

    const e = this.normalizeEvent(evt);

    if (this.options.movable) {
      this.startTranslating(e);
    }

    const activeView = this.getCellViewFromElem(e.target);
    this.setEventData(e, {
      activeView
    });
    const client = this.graph.snapToGrid(e.clientX, e.clientY);
    this.notifyBoxEvent('box:mousedown', e, client.x, client.y);
    this.delegateDocumentEvents(Private.documentEvents, e.data);
  }

  startTranslating(evt) {
    this.graph.model.startBatch('move-selection');
    const client = this.graph.snapToGrid(evt.clientX, evt.clientY);
    this.setEventData(evt, {
      action: 'translating',
      clientX: client.x,
      clientY: client.y,
      originX: client.x,
      originY: client.y
    });
  }

  getSelectionOffset(client, data) {
    let dx = client.x - data.clientX;
    let dy = client.y - data.clientY;
    const restrict = this.graph.hook.getRestrictArea();

    if (restrict) {
      const cells = this.collection.toArray();
      const totalBBox = _model_cell__WEBPACK_IMPORTED_MODULE_3__.Cell.getCellsBBox(cells, {
        deep: true
      }) || _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create();
      const minDx = restrict.x - totalBBox.x;
      const minDy = restrict.y - totalBBox.y;
      const maxDx = restrict.x + restrict.width - (totalBBox.x + totalBBox.width);
      const maxDy = restrict.y + restrict.height - (totalBBox.y + totalBBox.height);

      if (dx < minDx) {
        dx = minDx;
      }

      if (dy < minDy) {
        dy = minDy;
      }

      if (maxDx < dx) {
        dx = maxDx;
      }

      if (maxDy < dy) {
        dy = maxDy;
      }

      if (!this.options.following) {
        const offsetX = client.x - data.originX;
        const offsetY = client.y - data.originY;
        dx = offsetX <= minDx || offsetX >= maxDx ? 0 : dx;
        dy = offsetY <= minDy || offsetY >= maxDy ? 0 : dy;
      }
    }

    return {
      dx,
      dy
    };
  }

  updateSelectedNodesPosition(offset) {
    const {
      dx,
      dy
    } = offset;

    if (dx || dy) {
      if (this.translateSelectedNodes(dx, dy), this.boxesUpdated) {
        if (this.collection.length > 1) {
          this.updateSelectionBoxes();
        }
      } else {
        const scale = this.graph.transform.getScale();
        this.$boxes.add(this.$selectionContainer).css({
          left: `+=${dx * scale.sx}`,
          top: `+=${dy * scale.sy}`
        });
      }
    }
  }

  autoScrollGraph(x, y) {
    const scroller = this.graph.scroller.widget;

    if (scroller) {
      return scroller.autoScroll(x, y);
    }

    return {
      scrollerX: 0,
      scrollerY: 0
    };
  }

  adjustSelection(evt) {
    const e = this.normalizeEvent(evt);
    const eventData = this.getEventData(e);
    const action = eventData.action;

    switch (action) {
      case 'selecting':
        {
          const data = eventData;

          if (data.moving !== true) {
            this.$container.appendTo(this.graph.container);
            this.showRubberband();
            data.moving = true;
          }

          const {
            scrollerX,
            scrollerY
          } = this.autoScrollGraph(e.clientX, e.clientY);
          data.scrollerX += scrollerX;
          data.scrollerY += scrollerY;
          const dx = e.clientX - data.clientX + data.scrollerX;
          const dy = e.clientY - data.clientY + data.scrollerY;
          const left = parseInt(this.$container.css('left'), 10);
          const top = parseInt(this.$container.css('top'), 10);
          this.$container.css({
            left: dx < 0 ? data.offsetX + dx : left,
            top: dy < 0 ? data.offsetY + dy : top,
            width: Math.abs(dx),
            height: Math.abs(dy)
          });
          break;
        }

      case 'translating':
        {
          const client = this.graph.snapToGrid(e.clientX, e.clientY);
          const data = eventData;
          const offset = this.getSelectionOffset(client, data);

          if (this.options.following) {
            this.updateSelectedNodesPosition(offset);
          } else {
            this.updateContainerPosition(offset);
          }

          if (offset.dx) {
            data.clientX = client.x;
          }

          if (offset.dy) {
            data.clientY = client.y;
          }

          this.notifyBoxEvent('box:mousemove', evt, client.x, client.y);
          break;
        }

      default:
        break;
    }

    this.boxesUpdated = false;
  }

  translateSelectedNodes(dx, dy, exclude, otherOptions) {
    const map = {};
    const excluded = [];

    if (exclude) {
      map[exclude.id] = true;
    }

    this.collection.toArray().forEach(cell => {
      cell.getDescendants({
        deep: true
      }).forEach(child => {
        map[child.id] = true;
      });
    });

    if (otherOptions && otherOptions.translateBy) {
      const currentCell = this.graph.getCellById(otherOptions.translateBy);

      if (currentCell) {
        map[currentCell.id] = true;
        currentCell.getDescendants({
          deep: true
        }).forEach(child => {
          map[child.id] = true;
        });
        excluded.push(currentCell);
      }
    }

    this.collection.toArray().forEach(cell => {
      if (!map[cell.id]) {
        const options = Object.assign(Object.assign({}, otherOptions), {
          selection: this.cid,
          exclude: excluded
        });
        cell.translate(dx, dy, options);
        this.graph.model.getConnectedEdges(cell).forEach(edge => {
          if (!map[edge.id]) {
            edge.translate(dx, dy, options);
            map[edge.id] = true;
          }
        });
      }
    });
  }

  getCellViewsInArea(rect) {
    const graph = this.graph;
    const options = {
      strict: this.options.strict
    };
    let views = [];

    if (this.options.rubberNode) {
      if (this.options.useCellGeometry) {
        views = views.concat(graph.model.getNodesInArea(rect, options).map(node => graph.renderer.findViewByCell(node)).filter(view => view != null));
      } else {
        views = views.concat(graph.renderer.findViewsInArea(rect, options));
      }
    }

    if (this.options.rubberEdge) {
      if (this.options.useCellGeometry) {
        views = views.concat(graph.model.getEdgesInArea(rect, options).map(edge => graph.renderer.findViewByCell(edge)).filter(view => view != null));
      } else {
        views = views.concat(graph.renderer.findEdgeViewsInArea(rect, options));
      }
    }

    return views;
  }

  notifyBoxEvent(name, e, x, y) {
    const data = this.getEventData(e);
    const view = data.activeView;
    this.trigger(name, {
      e,
      view,
      x,
      y,
      cell: view.cell
    });
  }

  getSelectedClassName(cell) {
    return this.prefixClassName(`${cell.isNode() ? 'node' : 'edge'}-selected`);
  }

  addCellSelectedClassName(cell) {
    const view = this.graph.renderer.findViewByCell(cell);

    if (view) {
      view.addClass(this.getSelectedClassName(cell));
    }
  }

  removeCellUnSelectedClassName(cell) {
    const view = this.graph.renderer.findViewByCell(cell);

    if (view) {
      view.removeClass(this.getSelectedClassName(cell));
    }
  }

  destroySelectionBox(cell) {
    this.removeCellUnSelectedClassName(cell);

    if (this.canShowSelectionBox(cell)) {
      this.$container.find(`[data-cell-id="${cell.id}"]`).remove();

      if (this.$boxes.length === 0) {
        this.hide();
      }

      this.boxCount = Math.max(0, this.boxCount - 1);
    }
  }

  destroyAllSelectionBoxes(cells) {
    cells.forEach(cell => this.removeCellUnSelectedClassName(cell));
    this.hide();
    this.$boxes.remove();
    this.boxCount = 0;
  }

  hide() {
    this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband)).removeClass(this.prefixClassName(Private.classNames.selected));
  }

  showRubberband() {
    this.$container.addClass(this.prefixClassName(Private.classNames.rubberband));
  }

  hideRubberband() {
    this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband));
  }

  showSelected() {
    this.$container.removeAttr('style').addClass(this.prefixClassName(Private.classNames.selected));
  }

  createContainer() {
    this.container = document.createElement('div');
    this.$container = this.$(this.container);
    this.$container.addClass(this.prefixClassName(Private.classNames.root));

    if (this.options.className) {
      this.$container.addClass(this.options.className);
    }

    this.$selectionContainer = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.inner));
    this.$selectionContent = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.content));
    this.$selectionContainer.append(this.$selectionContent);
    this.$selectionContainer.attr('data-selection-length', this.collection.length);
    this.$container.prepend(this.$selectionContainer);
    this.$handleContainer = this.$selectionContainer;
  }

  updateContainerPosition(offset) {
    if (offset.dx || offset.dy) {
      this.$selectionContainer.css({
        left: `+=${offset.dx}`,
        top: `+=${offset.dy}`
      });
    }
  }

  updateContainer() {
    const origin = {
      x: Infinity,
      y: Infinity
    };
    const corner = {
      x: 0,
      y: 0
    };
    const cells = this.collection.toArray().filter(cell => this.canShowSelectionBox(cell));
    cells.forEach(cell => {
      const view = this.graph.renderer.findViewByCell(cell);

      if (view) {
        const bbox = view.getBBox({
          useCellGeometry: this.options.useCellGeometry
        });
        origin.x = Math.min(origin.x, bbox.x);
        origin.y = Math.min(origin.y, bbox.y);
        corner.x = Math.max(corner.x, bbox.x + bbox.width);
        corner.y = Math.max(corner.y, bbox.y + bbox.height);
      }
    });
    this.$selectionContainer.css({
      position: 'absolute',
      pointerEvents: 'none',
      left: origin.x,
      top: origin.y,
      width: corner.x - origin.x,
      height: corner.y - origin.y
    }).attr('data-selection-length', this.collection.length);
    const boxContent = this.options.content;

    if (boxContent) {
      if (typeof boxContent === 'function') {
        const content = _util__WEBPACK_IMPORTED_MODULE_2__.FunctionExt.call(boxContent, this.graph, this, this.$selectionContent[0]);

        if (content) {
          this.$selectionContent.html(content);
        }
      } else {
        this.$selectionContent.html(boxContent);
      }
    }

    if (this.collection.length > 0 && !this.container.parentNode) {
      this.$container.appendTo(this.graph.container);
    } else if (this.collection.length <= 0 && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
  }

  canShowSelectionBox(cell) {
    return cell.isNode() && this.options.showNodeSelectionBox === true || cell.isEdge() && this.options.showEdgeSelectionBox === true;
  }

  createSelectionBox(cell) {
    this.addCellSelectedClassName(cell);

    if (this.canShowSelectionBox(cell)) {
      const view = this.graph.renderer.findViewByCell(cell);

      if (view) {
        const bbox = view.getBBox({
          useCellGeometry: this.options.useCellGeometry
        });
        const className = this.boxClassName;
        this.$('<div/>').addClass(className).addClass(`${className}-${cell.isNode() ? 'node' : 'edge'}`).attr('data-cell-id', cell.id).css({
          position: 'absolute',
          left: bbox.x,
          top: bbox.y,
          width: bbox.width,
          height: bbox.height,
          pointerEvents: this.options.pointerEvents || 'auto'
        }).appendTo(this.container);
        this.showSelected();
        this.boxCount += 1;
      }
    }
  }

  updateSelectionBoxes(options = {}) {
    if (this.collection.length > 0) {
      this.boxesUpdated = true;
      this.graph.renderer.requestViewUpdate(this, 1, 2, options);
    }
  }

  confirmUpdate() {
    if (this.boxCount) {
      this.hide();
      this.$boxes.each((_, elem) => {
        const cellId = this.$(elem).remove().attr('data-cell-id');
        const cell = this.collection.get(cellId);

        if (cell) {
          this.createSelectionBox(cell);
        }
      });
      this.updateContainer();
    }

    return 0;
  }

  getCellViewFromElem(elem) {
    const id = elem.getAttribute('data-cell-id');

    if (id) {
      const cell = this.collection.get(id);

      if (cell) {
        return this.graph.renderer.findViewByCell(cell);
      }
    }

    return null;
  }

  onCellRemoved({
    cell
  }) {
    this.destroySelectionBox(cell);
    this.updateContainer();
  }

  onReseted({
    previous,
    current
  }) {
    this.destroyAllSelectionBoxes(previous);
    current.forEach(cell => {
      this.listenCellRemoveEvent(cell);
      this.createSelectionBox(cell);
    });
    this.updateContainer();
  }

  onCellAdded({
    cell
  }) {
    // The collection do not known the cell was removed when cell was
    // removed by interaction(such as, by "delete" shortcut), so we should
    // manually listen to cell's remove evnet.
    this.listenCellRemoveEvent(cell);
    this.createSelectionBox(cell);
    this.updateContainer();
  }

  listenCellRemoveEvent(cell) {
    cell.off('removed', this.onCellRemoved, this);
    cell.on('removed', this.onCellRemoved, this);
  }

  onCollectionUpdated({
    added,
    removed,
    options
  }) {
    added.forEach(cell => {
      this.trigger('cell:selected', {
        cell,
        options
      });
      this.graph.trigger('cell:selected', {
        cell,
        options
      });

      if (cell.isNode()) {
        this.trigger('node:selected', {
          cell,
          options,
          node: cell
        });
        this.graph.trigger('node:selected', {
          cell,
          options,
          node: cell
        });
      } else if (cell.isEdge()) {
        this.trigger('edge:selected', {
          cell,
          options,
          edge: cell
        });
        this.graph.trigger('edge:selected', {
          cell,
          options,
          edge: cell
        });
      }
    });
    removed.forEach(cell => {
      this.trigger('cell:unselected', {
        cell,
        options
      });
      this.graph.trigger('cell:unselected', {
        cell,
        options
      });

      if (cell.isNode()) {
        this.trigger('node:unselected', {
          cell,
          options,
          node: cell
        });
        this.graph.trigger('node:unselected', {
          cell,
          options,
          node: cell
        });
      } else if (cell.isEdge()) {
        this.trigger('edge:unselected', {
          cell,
          options,
          edge: cell
        });
        this.graph.trigger('edge:unselected', {
          cell,
          options,
          edge: cell
        });
      }
    });
    const args = {
      added,
      removed,
      options,
      selected: this.cells.filter(cell => !!this.graph.getCellById(cell.id))
    };
    this.trigger('selection:changed', args);
    this.graph.trigger('selection:changed', args);
  } // #region handle


  deleteSelectedCells() {
    const cells = this.collection.toArray();
    this.clean();
    this.graph.model.removeCells(cells, {
      selection: this.cid
    });
  }

  startRotate({
    e
  }) {
    const cells = this.collection.toArray();
    const center = _model_cell__WEBPACK_IMPORTED_MODULE_3__.Cell.getCellsBBox(cells).getCenter();
    const client = this.graph.snapToGrid(e.clientX, e.clientY);
    const angles = cells.reduce((memo, cell) => {
      memo[cell.id] = _geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(cell.getAngle());
      return memo;
    }, {});
    this.setEventData(e, {
      center,
      angles,
      start: client.theta(center)
    });
  }

  doRotate({
    e
  }) {
    const data = this.getEventData(e);
    const grid = this.graph.options.rotating.grid;
    const gridSize = typeof grid === 'function' ? _util__WEBPACK_IMPORTED_MODULE_2__.FunctionExt.call(grid, this.graph, null) : grid;
    const client = this.graph.snapToGrid(e.clientX, e.clientY);
    const delta = data.start - client.theta(data.center);

    if (!data.rotated) {
      data.rotated = true;
    }

    if (Math.abs(delta) > 0.001) {
      this.collection.toArray().forEach(node => {
        const angle = _global__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(data.angles[node.id] + delta, gridSize || 15);
        node.rotate(angle, {
          absolute: true,
          center: data.center,
          selection: this.cid
        });
      });
      this.updateSelectionBoxes();
    }
  }

  stopRotate({
    e
  }) {
    const data = this.getEventData(e);

    if (data.rotated) {
      data.rotated = false;
      this.collection.toArray().forEach(node => {
        (0,_transform_util__WEBPACK_IMPORTED_MODULE_6__.notify)('node:rotated', e, this.graph.findViewByCell(node));
      });
    }
  }

  startResize({
    e
  }) {
    const gridSize = this.graph.getGridSize();
    const cells = this.collection.toArray();
    const bbox = _model_cell__WEBPACK_IMPORTED_MODULE_3__.Cell.getCellsBBox(cells);
    const bboxes = cells.map(cell => cell.getBBox());
    const maxWidth = bboxes.reduce((maxWidth, bbox) => {
      return bbox.width < maxWidth ? bbox.width : maxWidth;
    }, Infinity);
    const maxHeight = bboxes.reduce((maxHeight, bbox) => {
      return bbox.height < maxHeight ? bbox.height : maxHeight;
    }, Infinity);
    this.setEventData(e, {
      bbox,
      cells: this.graph.model.getSubGraph(cells),
      minWidth: gridSize * bbox.width / maxWidth,
      minHeight: gridSize * bbox.height / maxHeight
    });
  }

  doResize({
    e,
    dx,
    dy
  }) {
    const data = this.eventData(e);
    const bbox = data.bbox;
    const width = bbox.width;
    const height = bbox.height;
    const newWidth = Math.max(width + dx, data.minWidth);
    const newHeight = Math.max(height + dy, data.minHeight);

    if (!data.resized) {
      data.resized = true;
    }

    if (Math.abs(width - newWidth) > 0.001 || Math.abs(height - newHeight) > 0.001) {
      this.graph.model.resizeCells(newWidth, newHeight, data.cells, {
        selection: this.cid
      });
      bbox.width = newWidth;
      bbox.height = newHeight;
      this.updateSelectionBoxes();
    }
  }

  stopResize({
    e
  }) {
    const data = this.eventData(e);

    if (data.resized) {
      data.resized = false;
      this.collection.toArray().forEach(node => {
        (0,_transform_util__WEBPACK_IMPORTED_MODULE_6__.notify)('node:resized', e, this.graph.findViewByCell(node));
      });
    }
  } // #endregion


  dispose() {
    this.clean();
    this.remove();
  }

}

__decorate([_view_view__WEBPACK_IMPORTED_MODULE_5__.View.dispose()], Selection.prototype, "dispose", null);

_util__WEBPACK_IMPORTED_MODULE_2__.ObjectExt.applyMixins(Selection, _common__WEBPACK_IMPORTED_MODULE_7__.Handle); // private
// -------

var Private;

(function (Private) {
  const base = 'widget-selection';
  Private.classNames = {
    root: base,
    inner: `${base}-inner`,
    box: `${base}-box`,
    content: `${base}-content`,
    rubberband: `${base}-rubberband`,
    selected: `${base}-selected`
  };
  Private.documentEvents = {
    mousemove: 'adjustSelection',
    touchmove: 'adjustSelection',
    mouseup: 'onMouseUp',
    touchend: 'onMouseUp',
    touchcancel: 'onMouseUp'
  };
  Private.defaultOptions = {
    movable: true,
    following: true,
    strict: false,
    useCellGeometry: false,

    content(selection) {
      return _util__WEBPACK_IMPORTED_MODULE_2__.StringExt.template('<%= length %> node<%= length > 1 ? "s":"" %> selected.')({
        length: selection.length
      });
    },

    handles: [{
      name: 'remove',
      position: 'nw',
      events: {
        mousedown: 'deleteSelectedCells'
      }
    }, {
      name: 'rotate',
      position: 'sw',
      events: {
        mousedown: 'startRotate',
        mousemove: 'doRotate',
        mouseup: 'stopRotate'
      }
    }, {
      name: 'resize',
      position: 'se',
      events: {
        mousedown: 'startResize',
        mousemove: 'doResize',
        mouseup: 'stopResize'
      }
    }]
  };

  function depthComparator(cell) {
    return cell.getAncestors().length;
  }

  Private.depthComparator = depthComparator;
})(Private || (Private = {}));

/***/ }),

/***/ 29733:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/snapline/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Snapline": () => (/* binding */ Snapline)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _util_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/vector */ 9502);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/view */ 58458);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





class Snapline extends _view_view__WEBPACK_IMPORTED_MODULE_3__.View {
  constructor(options) {
    super();

    const {
      graph
    } = options,
          others = __rest(options, ["graph"]);

    this.graph = graph;
    this.options = Object.assign({
      tolerance: 10
    }, others);
    this.offset = {
      x: 0,
      y: 0
    };
    this.render();
    this.parseFilter();

    if (!this.disabled) {
      this.startListening();
    }
  }

  get model() {
    return this.graph.model;
  }

  get containerClassName() {
    return this.prefixClassName('widget-snapline');
  }

  get verticalClassName() {
    return `${this.containerClassName}-vertical`;
  }

  get horizontalClassName() {
    return `${this.containerClassName}-horizontal`;
  }

  get disabled() {
    return this.options.enabled !== true || this.graph.options.snapline.enabled !== true;
  }

  enable() {
    if (this.disabled) {
      this.options.enabled = true;
      this.graph.options.snapline.enabled = true;
      this.startListening();
    }
  }

  disable() {
    if (!this.disabled) {
      this.options.enabled = false;
      this.graph.options.snapline.enabled = false;
      this.stopListening();
    }
  }

  setFilter(filter) {
    this.options.filter = filter;
    this.parseFilter();
  }

  render() {
    const container = this.containerWrapper = new _util_vector__WEBPACK_IMPORTED_MODULE_2__.Vector('svg');
    const horizontal = this.horizontal = new _util_vector__WEBPACK_IMPORTED_MODULE_2__.Vector('path');
    const vertical = this.vertical = new _util_vector__WEBPACK_IMPORTED_MODULE_2__.Vector('path');
    container.addClass(this.containerClassName);
    horizontal.addClass(this.horizontalClassName);
    vertical.addClass(this.verticalClassName);
    container.setAttribute('width', '100%');
    container.setAttribute('height', '100%');
    horizontal.setAttribute('display', 'none');
    vertical.setAttribute('display', 'none');
    container.append([horizontal, vertical]);

    if (this.options.className) {
      container.addClass(this.options.className);
    }

    this.container = this.containerWrapper.node;
  }

  startListening() {
    this.stopListening();
    this.graph.on('node:mousedown', this.captureCursorOffset, this);
    this.graph.on('node:mousemove', this.snapOnMoving, this);
    this.model.on('batch:stop', this.onBatchStop, this);
    this.delegateDocumentEvents({
      mouseup: 'hide',
      touchend: 'hide'
    });
  }

  stopListening() {
    this.graph.off('node:mousedown', this.captureCursorOffset, this);
    this.graph.off('node:mousemove', this.snapOnMoving, this);
    this.model.off('batch:stop', this.onBatchStop, this);
    this.undelegateDocumentEvents();
  }

  parseFilter() {
    this.filterShapes = {};
    this.filterCells = {};
    this.filterFunction = null;
    const filter = this.options.filter;

    if (Array.isArray(filter)) {
      filter.forEach(item => {
        if (typeof item === 'string') {
          this.filterShapes[item] = true;
        } else {
          this.filterCells[item.id] = true;
        }
      });
    } else if (typeof filter === 'function') {
      this.filterFunction = filter;
    }
  }

  onBatchStop({
    name,
    data
  }) {
    if (name === 'resize') {
      this.snapOnResizing(data.cell, data);
    }
  }

  captureCursorOffset({
    view,
    x,
    y
  }) {
    const targetView = view.getDelegatedView();

    if (targetView && this.isNodeMovable(targetView)) {
      const pos = view.cell.getPosition();
      this.offset = {
        x: x - pos.x,
        y: y - pos.y
      };
    }
  }

  isNodeMovable(view) {
    return view && view.cell.isNode() && view.can('nodeMovable');
  }

  snapOnResizing(node, options) {
    if (this.options.resizing && !options.snapped && options.ui && options.direction && options.trueDirection) {
      const view = this.graph.renderer.findViewByCell(node);

      if (view && view.cell.isNode()) {
        const nodeBbox = node.getBBox();
        const nodeBBoxRotated = nodeBbox.bbox(node.getAngle());
        const nodeTopLeft = nodeBBoxRotated.getTopLeft();
        const nodeBottomRight = nodeBBoxRotated.getBottomRight();
        const angle = _geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(node.getAngle());
        const tolerance = this.options.tolerance || 0;
        let verticalLeft;
        let verticalTop;
        let verticalHeight;
        let horizontalTop;
        let horizontalLeft;
        let horizontalWidth;
        const snapOrigin = {
          vertical: 0,
          horizontal: 0
        };
        const direction = options.direction;
        const trueDirection = options.trueDirection;
        const relativeDirection = options.relativeDirection;

        if (trueDirection.indexOf('right') !== -1) {
          snapOrigin.vertical = nodeBottomRight.x;
        } else {
          snapOrigin.vertical = nodeTopLeft.x;
        }

        if (trueDirection.indexOf('bottom') !== -1) {
          snapOrigin.horizontal = nodeBottomRight.y;
        } else {
          snapOrigin.horizontal = nodeTopLeft.y;
        }

        this.model.getNodes().some(cell => {
          if (this.isIgnored(node, cell)) {
            return false;
          }

          const snapBBox = cell.getBBox().bbox(cell.getAngle());
          const snapTopLeft = snapBBox.getTopLeft();
          const snapBottomRight = snapBBox.getBottomRight();
          const groups = {
            vertical: [snapTopLeft.x, snapBottomRight.x],
            horizontal: [snapTopLeft.y, snapBottomRight.y]
          };
          const distances = {};
          Object.keys(groups).forEach(k => {
            const key = k;
            const list = groups[key].map(value => ({
              position: value,
              distance: Math.abs(value - snapOrigin[key])
            })).filter(item => item.distance <= tolerance);
            distances[key] = _util__WEBPACK_IMPORTED_MODULE_1__.ArrayExt.sortBy(list, item => item.distance);
          });

          if (verticalLeft == null && distances.vertical.length > 0) {
            verticalLeft = distances.vertical[0].position;
            verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);
            verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;
          }

          if (horizontalTop == null && distances.horizontal.length > 0) {
            horizontalTop = distances.horizontal[0].position;
            horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);
            horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;
          }

          return verticalLeft != null && horizontalTop != null;
        });
        this.hide();
        let dx = 0;
        let dy = 0;

        if (horizontalTop != null || verticalLeft != null) {
          if (verticalLeft != null) {
            dx = trueDirection.indexOf('right') !== -1 ? verticalLeft - nodeBottomRight.x : nodeTopLeft.x - verticalLeft;
          }

          if (horizontalTop != null) {
            dy = trueDirection.indexOf('bottom') !== -1 ? horizontalTop - nodeBottomRight.y : nodeTopLeft.y - horizontalTop;
          }
        }

        let dWidth = 0;
        let dHeight = 0;

        if (angle % 90 === 0) {
          if (angle === 90 || angle === 270) {
            dWidth = dy;
            dHeight = dx;
          } else {
            dWidth = dx;
            dHeight = dy;
          }
        } else {
          const quadrant = angle >= 0 && angle < 90 ? 1 : angle >= 90 && angle < 180 ? 4 : angle >= 180 && angle < 270 ? 3 : 2;

          if (horizontalTop != null && verticalLeft != null) {
            if (dx < dy) {
              dy = 0;
              horizontalTop = undefined;
            } else {
              dx = 0;
              verticalLeft = undefined;
            }
          }

          const rad = _geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle % 90);

          if (dx) {
            dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);
          }

          if (dy) {
            dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);
          }

          const quadrant13 = quadrant === 1 || quadrant === 3;

          switch (relativeDirection) {
            case 'top':
            case 'bottom':
              dHeight = dy ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));
              break;

            case 'left':
            case 'right':
              dWidth = dx ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));
              break;

            default:
              break;
          }
        }

        switch (relativeDirection) {
          case 'top':
          case 'bottom':
            dWidth = 0;
            break;

          case 'left':
          case 'right':
            dHeight = 0;
            break;

          default:
            break;
        }

        const gridSize = this.graph.getGridSize();
        let newWidth = Math.max(nodeBbox.width + dWidth, gridSize);
        let newHeight = Math.max(nodeBbox.height + dHeight, gridSize);

        if (options.minWidth && options.minWidth > gridSize) {
          newWidth = Math.max(newWidth, options.minWidth);
        }

        if (options.minHeight && options.minHeight > gridSize) {
          newHeight = Math.max(newHeight, options.minHeight);
        }

        if (options.maxWidth) {
          newWidth = Math.min(newWidth, options.maxWidth);
        }

        if (options.maxHeight) {
          newHeight = Math.min(newHeight, options.maxHeight);
        }

        if (options.preserveAspectRatio) {
          if (dHeight < dWidth) {
            newHeight = newWidth * (nodeBbox.height / nodeBbox.width);
          } else {
            newWidth = newHeight * (nodeBbox.width / nodeBbox.height);
          }
        }

        if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {
          node.resize(newWidth, newHeight, {
            direction,
            relativeDirection,
            trueDirection,
            snapped: true,
            snaplines: this.cid,
            restrict: this.graph.hook.getRestrictArea(view)
          });

          if (verticalHeight) {
            verticalHeight += newHeight - nodeBbox.height;
          }

          if (horizontalWidth) {
            horizontalWidth += newWidth - nodeBbox.width;
          }
        }

        const newRotatedBBox = node.getBBox().bbox(angle);

        if (verticalLeft && Math.abs(newRotatedBBox.x - verticalLeft) > 1 && Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {
          verticalLeft = undefined;
        }

        if (horizontalTop && Math.abs(newRotatedBBox.y - horizontalTop) > 1 && Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {
          horizontalTop = undefined;
        }

        this.update({
          verticalLeft,
          verticalTop,
          verticalHeight,
          horizontalTop,
          horizontalLeft,
          horizontalWidth
        });
      }
    }
  }

  snapOnMoving({
    view,
    e,
    x,
    y
  }) {
    const targetView = view.getEventData(e).delegatedView || view;

    if (!this.isNodeMovable(targetView)) {
      return;
    }

    const node = targetView.cell;
    const size = node.getSize();
    const position = node.getPosition();
    const cellBBox = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);
    const angle = node.getAngle();
    const nodeCenter = cellBBox.getCenter();
    const nodeBBoxRotated = cellBBox.bbox(angle);
    const nodeTopLeft = nodeBBoxRotated.getTopLeft();
    const nodeBottomRight = nodeBBoxRotated.getBottomRight();
    const distance = this.options.tolerance || 0;
    let verticalLeft;
    let verticalTop;
    let verticalHeight;
    let horizontalTop;
    let horizontalLeft;
    let horizontalWidth;
    let verticalFix = 0;
    let horizontalFix = 0;
    this.model.getNodes().some(targetNode => {
      if (this.isIgnored(node, targetNode)) {
        return false;
      }

      const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());
      const snapCenter = snapBBox.getCenter();
      const snapTopLeft = snapBBox.getTopLeft();
      const snapBottomRight = snapBBox.getBottomRight();

      if (verticalLeft == null) {
        if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {
          verticalLeft = snapCenter.x;
          verticalFix = 0.5;
        } else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {
          verticalLeft = snapTopLeft.x;
          verticalFix = 0;
        } else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {
          verticalLeft = snapTopLeft.x;
          verticalFix = 1;
        } else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {
          verticalLeft = snapBottomRight.x;
          verticalFix = 1;
        } else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {
          verticalLeft = snapBottomRight.x;
        }

        if (verticalLeft != null) {
          verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);
          verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;
        }
      }

      if (horizontalTop == null) {
        if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {
          horizontalTop = snapCenter.y;
          horizontalFix = 0.5;
        } else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {
          horizontalTop = snapTopLeft.y;
        } else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {
          horizontalTop = snapTopLeft.y;
          horizontalFix = 1;
        } else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {
          horizontalTop = snapBottomRight.y;
          horizontalFix = 1;
        } else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {
          horizontalTop = snapBottomRight.y;
        }

        if (horizontalTop != null) {
          horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);
          horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;
        }
      }

      return verticalLeft != null && horizontalTop != null;
    });
    this.hide();

    if (horizontalTop != null || verticalLeft != null) {
      if (horizontalTop != null) {
        nodeBBoxRotated.y = horizontalTop - horizontalFix * nodeBBoxRotated.height;
      }

      if (verticalLeft != null) {
        nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;
      }

      const newCenter = nodeBBoxRotated.getCenter();
      const newX = newCenter.x - cellBBox.width / 2;
      const newY = newCenter.y - cellBBox.height / 2;
      const dx = newX - position.x;
      const dy = newY - position.y;

      if (dx !== 0 || dy !== 0) {
        node.translate(dx, dy, {
          snapped: true,
          restrict: this.graph.hook.getRestrictArea(targetView)
        });

        if (horizontalWidth) {
          horizontalWidth += dx;
        }

        if (verticalHeight) {
          verticalHeight += dy;
        }
      }

      this.update({
        verticalLeft,
        verticalTop,
        verticalHeight,
        horizontalTop,
        horizontalLeft,
        horizontalWidth
      });
    }
  }

  isIgnored(snapNode, targetNode) {
    return targetNode.id === snapNode.id || targetNode.isDescendantOf(snapNode) || this.filterShapes[targetNode.shape] || this.filterCells[targetNode.id] || this.filterFunction && _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(this.filterFunction, this.graph, targetNode);
  }

  update(metadata) {
    // https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations
    if (metadata.horizontalTop) {
      const start = this.graph.localToGraph(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(metadata.horizontalLeft, metadata.horizontalTop));
      const end = this.graph.localToGraph(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(metadata.horizontalLeft + metadata.horizontalWidth, metadata.horizontalTop));
      this.horizontal.setAttributes({
        d: `M ${start.x},${start.y} L ${end.x},${end.y}`,
        display: 'inherit'
      });
    } else {
      this.horizontal.setAttribute('display', 'none');
    }

    if (metadata.verticalLeft) {
      const start = this.graph.localToGraph(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(metadata.verticalLeft, metadata.verticalTop));
      const end = this.graph.localToGraph(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(metadata.verticalLeft, metadata.verticalTop + metadata.verticalHeight));
      this.vertical.setAttributes({
        d: `M ${start.x},${start.y} L ${end.x},${end.y}`,
        display: 'inherit'
      });
    } else {
      this.vertical.setAttribute('display', 'none');
    }

    this.show();
  }

  resetTimer() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }

  show() {
    this.resetTimer();

    if (this.container.parentNode == null) {
      this.graph.container.appendChild(this.container);
    }

    return this;
  }

  hide() {
    this.resetTimer();
    this.vertical.setAttribute('display', 'none');
    this.horizontal.setAttribute('display', 'none');
    const clean = this.options.clean;
    const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;

    if (delay > 0) {
      this.timer = window.setTimeout(() => {
        if (this.container.parentNode !== null) {
          this.unmount();
        }
      }, delay);
    }

    return this;
  }

  onRemove() {
    this.stopListening();
    this.hide();
  }

  dispose() {
    this.remove();
  }

}

__decorate([_view_view__WEBPACK_IMPORTED_MODULE_3__.View.dispose()], Snapline.prototype, "dispose", null);

/***/ }),

/***/ 97064:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/stencil/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stencil": () => (/* binding */ Stencil)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _layout_grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../layout/grid */ 75444);
/* harmony import */ var _model_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/node */ 21738);
/* harmony import */ var _model_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/model */ 69314);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../view/view */ 58458);
/* harmony import */ var _graph_graph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../graph/graph */ 77947);
/* harmony import */ var _dnd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dnd */ 55924);







class Stencil extends _view_view__WEBPACK_IMPORTED_MODULE_4__.View {
  constructor(options) {
    super();
    this.graphs = {};
    this.$groups = {};
    this.options = Object.assign(Object.assign({}, Stencil.defaultOptions), options);
    this.dnd = new _dnd__WEBPACK_IMPORTED_MODULE_6__.Dnd(this.options);
    this.onSearch = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.debounce(this.onSearch, 200);
    this.container = document.createElement('div');
    this.$container = this.$(this.container).addClass(this.prefixClassName(ClassNames.base)).attr('data-not-found-text', this.options.notFoundText || 'No matches found');
    this.options.collapsable = options.collapsable && options.groups && options.groups.some(group => group.collapsable !== false);

    if (this.options.collapsable) {
      this.$container.addClass('collapsable');
      const collapsed = options.groups && options.groups.every(group => group.collapsed || group.collapsable === false);

      if (collapsed) {
        this.$container.addClass('collapsed');
      }
    }

    this.$('<div/>').addClass(this.prefixClassName(ClassNames.title)).html(this.options.title).appendTo(this.$container);

    if (options.search) {
      this.$container.addClass('searchable').append(this.renderSearch());
    }

    this.$content = this.$('<div/>').addClass(this.prefixClassName(ClassNames.content)).appendTo(this.$container);
    const globalGraphOptions = options.stencilGraphOptions || {};

    if (options.groups && options.groups.length) {
      options.groups.forEach(group => {
        const $group = this.$('<div/>').addClass(this.prefixClassName(ClassNames.group)).attr('data-name', group.name);

        if (group.collapsable == null && options.collapsable || group.collapsable !== false) {
          $group.addClass('collapsable');
        }

        $group.toggleClass('collapsed', group.collapsed === true);
        const $title = this.$('<h3/>').addClass(this.prefixClassName(ClassNames.groupTitle)).html(group.title || group.name);
        const $content = this.$('<div/>').addClass(this.prefixClassName(ClassNames.groupContent));
        const graphOptionsInGroup = group.graphOptions;
        const graph = new _graph_graph__WEBPACK_IMPORTED_MODULE_5__.Graph(Object.assign(Object.assign(Object.assign({}, globalGraphOptions), graphOptionsInGroup), {
          container: document.createElement('div'),
          model: globalGraphOptions.model || new _model_model__WEBPACK_IMPORTED_MODULE_3__.Model(),
          width: group.graphWidth || options.stencilGraphWidth,
          height: group.graphHeight || options.stencilGraphHeight,
          interacting: false,
          preventDefaultBlankAction: false
        }));
        $content.append(graph.container);
        $group.append($title, $content).appendTo(this.$content);
        this.$groups[group.name] = $group;
        this.graphs[group.name] = graph;
      });
    } else {
      const graph = new _graph_graph__WEBPACK_IMPORTED_MODULE_5__.Graph(Object.assign(Object.assign({}, globalGraphOptions), {
        container: document.createElement('div'),
        model: globalGraphOptions.model || new _model_model__WEBPACK_IMPORTED_MODULE_3__.Model(),
        width: options.stencilGraphWidth,
        height: options.stencilGraphHeight,
        interacting: false,
        preventDefaultBlankAction: false
      }));
      this.$content.append(graph.container);
      this.graphs[Private.defaultGroupName] = graph;
    }

    this.startListening();
    return this;
  }

  get targetScroller() {
    const target = this.options.target;
    return _graph_graph__WEBPACK_IMPORTED_MODULE_5__.Graph.isGraph(target) ? target.scroller.widget : target;
  }

  get targetGraph() {
    const target = this.options.target;
    return _graph_graph__WEBPACK_IMPORTED_MODULE_5__.Graph.isGraph(target) ? target : target.graph;
  }

  get targetModel() {
    return this.targetGraph.model;
  }

  renderSearch() {
    return this.$('<div/>').addClass(this.prefixClassName(ClassNames.search)).append(this.$('<input/>').attr({
      type: 'search',
      placeholder: this.options.placeholder || 'Search'
    }).addClass(this.prefixClassName(ClassNames.searchText)));
  }

  startListening() {
    const title = this.prefixClassName(ClassNames.title);
    const searchText = this.prefixClassName(ClassNames.searchText);
    const groupTitle = this.prefixClassName(ClassNames.groupTitle);
    this.delegateEvents({
      [`click .${title}`]: 'onTitleClick',
      [`touchstart .${title}`]: 'onTitleClick',
      [`click .${groupTitle}`]: 'onGroupTitleClick',
      [`touchstart .${groupTitle}`]: 'onGroupTitleClick',
      [`input .${searchText}`]: 'onSearch',
      [`focusin .${searchText}`]: 'onSearchFocusIn',
      [`focusout .${searchText}`]: 'onSearchFocusOut'
    });
    Object.keys(this.graphs).forEach(groupName => {
      const graph = this.graphs[groupName];
      graph.on('cell:mousedown', this.onDragStart, this);
    });
  }

  stopListening() {
    this.undelegateEvents();
    Object.keys(this.graphs).forEach(groupName => {
      const graph = this.graphs[groupName];
      graph.off('cell:mousedown', this.onDragStart, this);
    });
  }

  load(data, groupName) {
    if (Array.isArray(data)) {
      this.loadGroup(data, groupName);
    } else if (this.options.groups) {
      Object.keys(this.options.groups).forEach(groupName => {
        if (data[groupName]) {
          this.loadGroup(data[groupName], groupName);
        }
      });
    }

    return this;
  }

  loadGroup(cells, groupName) {
    const model = this.getModel(groupName);

    if (model) {
      const nodes = cells.map(cell => _model_node__WEBPACK_IMPORTED_MODULE_2__.Node.isNode(cell) ? cell : _model_node__WEBPACK_IMPORTED_MODULE_2__.Node.create(cell));
      model.resetCells(nodes);
    }

    const group = this.getGroup(groupName);
    let height = this.options.stencilGraphHeight;

    if (group && group.graphHeight != null) {
      height = group.graphHeight;
    }

    const layout = group && group.layout || this.options.layout;

    if (layout && model) {
      _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(layout, this, model, group);
    }

    if (!height) {
      const graph = this.getGraph(groupName);
      graph.fitToContent({
        minWidth: graph.options.width,
        gridHeight: 1,
        padding: group && group.graphPadding || this.options.stencilGraphPadding || 10
      });
    }

    return this;
  }

  onDragStart(args) {
    const {
      e,
      node
    } = args;
    this.dnd.start(node, e);
  }

  filter(keyword, filter) {
    const found = Object.keys(this.graphs).reduce((memo, groupName) => {
      const graph = this.graphs[groupName];
      const name = groupName === Private.defaultGroupName ? null : groupName;
      const items = graph.model.getNodes().filter(cell => {
        let matched = false;

        if (typeof filter === 'function') {
          matched = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(filter, this, cell, keyword, name, this);
        } else if (typeof filter === 'boolean') {
          matched = filter;
        } else {
          matched = this.isCellMatched(cell, keyword, filter, keyword.toLowerCase() !== keyword);
        }

        const view = graph.renderer.findViewByCell(cell);

        if (view) {
          view.$(view.container).toggleClass('unmatched', !matched);
        }

        return matched;
      });
      const found = items.length > 0;
      const options = this.options;
      const model = new _model_model__WEBPACK_IMPORTED_MODULE_3__.Model();
      model.resetCells(items);

      if (options.layout) {
        _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(options.layout, this, model, this.getGroup(groupName));
      }

      if (this.$groups[groupName]) {
        this.$groups[groupName].toggleClass('unmatched', !found);
      }

      graph.fitToContent({
        gridWidth: 1,
        gridHeight: 1,
        padding: options.stencilGraphPadding || 10
      });
      return memo || found;
    }, false);
    this.$container.toggleClass('not-found', !found);
  }

  isCellMatched(cell, keyword, filters, ignoreCase) {
    if (keyword && filters) {
      return Object.keys(filters).some(shape => {
        if (shape === '*' || cell.shape === shape) {
          const filter = filters[shape];

          if (typeof filter === 'boolean') {
            return filter;
          }

          const paths = Array.isArray(filter) ? filter : [filter];
          return paths.some(path => {
            let val = cell.getPropByPath(path);

            if (val != null) {
              val = `${val}`;

              if (!ignoreCase) {
                val = val.toLowerCase();
              }

              return val.indexOf(keyword) >= 0;
            }

            return false;
          });
        }

        return false;
      });
    }

    return true;
  }

  onSearch(evt) {
    this.filter(evt.target.value, this.options.search);
  }

  onSearchFocusIn() {
    this.$container.addClass('is-focused');
  }

  onSearchFocusOut() {
    this.$container.removeClass('is-focused');
  }

  onTitleClick() {
    if (this.options.collapsable) {
      this.$container.toggleClass('collapsed');

      if (this.$container.hasClass('collapsed')) {
        this.collapseGroups();
      } else {
        this.expandGroups();
      }
    }
  }

  onGroupTitleClick(evt) {
    const $group = this.$(evt.target).closest(`.${this.prefixClassName(ClassNames.group)}`);
    this.toggleGroup($group.attr('data-name') || '');
    const allCollapsed = Object.keys(this.$groups).every(name => {
      const group = this.getGroup(name);
      const $group = this.$groups[name];
      return group && group.collapsable === false || $group.hasClass('collapsed');
    });
    this.$container.toggleClass('collapsed', allCollapsed);
  }

  getModel(groupName) {
    const graph = this.getGraph(groupName);
    return graph ? graph.model : null;
  }

  getGraph(groupName) {
    return this.graphs[groupName || Private.defaultGroupName];
  }

  getGroup(groupName) {
    const groups = this.options.groups;

    if (groupName != null && groups && groups.length) {
      return groups.find(group => group.name === groupName);
    }

    return null;
  }

  toggleGroup(groupName) {
    if (this.isGroupCollapsed(groupName)) {
      this.expandGroup(groupName);
    } else {
      this.collapseGroup(groupName);
    }

    return this;
  }

  collapseGroup(groupName) {
    if (this.isGroupCollapsable(groupName)) {
      const $group = this.$groups[groupName];

      if ($group && !this.isGroupCollapsed(groupName)) {
        this.trigger('group:collapse', {
          name: groupName
        });
        $group.addClass('collapsed');
      }
    }

    return this;
  }

  expandGroup(groupName) {
    if (this.isGroupCollapsable(groupName)) {
      const $group = this.$groups[groupName];

      if ($group && this.isGroupCollapsed(groupName)) {
        this.trigger('group:expand', {
          name: groupName
        });
        $group.removeClass('collapsed');
      }
    }

    return this;
  }

  isGroupCollapsable(groupName) {
    const $group = this.$groups[groupName];
    return $group.hasClass('collapsable');
  }

  isGroupCollapsed(groupName) {
    const $group = this.$groups[groupName];
    return $group && $group.hasClass('collapsed');
  }

  collapseGroups() {
    Object.keys(this.$groups).forEach(groupName => this.collapseGroup(groupName));
    return this;
  }

  expandGroups() {
    Object.keys(this.$groups).forEach(groupName => this.expandGroup(groupName));
    return this;
  }

  resizeGroup(groupName, size) {
    const graph = this.graphs[groupName];

    if (graph) {
      graph.resize(size.width, size.height);
    }

    return this;
  }

  onRemove() {
    Object.keys(this.graphs).forEach(groupName => {
      const graph = this.graphs[groupName];
      graph.view.remove();
      delete this.graphs[groupName];
    });
    this.dnd.remove();
    this.stopListening();
    this.undelegateDocumentEvents();
  }

}

(function (Stencil) {
  Stencil.defaultOptions = Object.assign({
    stencilGraphWidth: 200,
    stencilGraphHeight: 800,
    title: 'Stencil',
    collapsable: false,
    placeholder: 'Search',
    notFoundText: 'No matches found',

    layout(model, group) {
      const options = {
        columnWidth: this.options.stencilGraphWidth / 2 - 10,
        columns: 2,
        rowHeight: 80,
        resizeToFit: false,
        dx: 10,
        dy: 10
      };
      (0,_layout_grid__WEBPACK_IMPORTED_MODULE_1__.grid)(model, Object.assign(Object.assign(Object.assign({}, options), this.options.layoutOptions), group ? group.layoutOptions : {}));
    }

  }, _dnd__WEBPACK_IMPORTED_MODULE_6__.Dnd.defaults);
})(Stencil || (Stencil = {}));

var ClassNames;

(function (ClassNames) {
  ClassNames.base = 'widget-stencil';
  ClassNames.title = `${ClassNames.base}-title`;
  ClassNames.search = `${ClassNames.base}-search`;
  ClassNames.searchText = `${ClassNames.search}-text`;
  ClassNames.content = `${ClassNames.base}-content`;
  ClassNames.group = `${ClassNames.base}-group`;
  ClassNames.groupTitle = `${ClassNames.group}-title`;
  ClassNames.groupContent = `${ClassNames.group}-content`;
})(ClassNames || (ClassNames = {}));

var Private;

(function (Private) {
  Private.defaultGroupName = '__default__';
})(Private || (Private = {}));

/***/ }),

/***/ 14748:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/transform/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Transform": () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global */ 9789);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common */ 92720);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ 24309);





class Transform extends _common__WEBPACK_IMPORTED_MODULE_3__.Widget {
  get node() {
    return this.cell;
  }

  get containerClassName() {
    return this.prefixClassName('widget-transform');
  }

  get resizeClassName() {
    return `${this.containerClassName}-resize`;
  }

  get rotateClassName() {
    return `${this.containerClassName}-rotate`;
  }

  init(options) {
    this.options = Object.assign(Object.assign({}, Private.defaultOptions), options);
    this.render();
    this.startListening();
  }

  startListening() {
    this.delegateEvents({
      [`mousedown .${this.resizeClassName}`]: 'startResizing',
      [`touchstart .${this.resizeClassName}`]: 'startResizing',
      [`mousedown .${this.rotateClassName}`]: 'startRotating',
      [`touchstart .${this.rotateClassName}`]: 'startRotating'
    });
    this.model.on('*', this.update, this);
    this.graph.on('scale', this.update, this);
    this.graph.on('translate', this.update, this);
    this.node.on('removed', this.remove, this);
    this.model.on('reseted', this.remove, this);
    this.view.on('cell:knob:mousedown', this.onKnobMouseDown, this);
    this.view.on('cell:knob:mouseup', this.onKnobMouseUp, this);
    super.startListening();
  }

  stopListening() {
    this.undelegateEvents();
    this.model.off('*', this.update, this);
    this.graph.off('scale', this.update, this);
    this.graph.off('translate', this.update, this);
    this.node.off('removed', this.remove, this);
    this.model.off('reseted', this.remove, this);
    this.view.off('cell:knob:mousedown', this.onKnobMouseDown, this);
    this.view.off('cell:knob:mouseup', this.onKnobMouseUp, this);
    super.stopListening();
  }

  renderHandles() {
    this.container = document.createElement('div');
    this.$container = this.$(this.container);
    const $knob = this.$('<div/>').prop('draggable', false);
    const $rotate = $knob.clone().addClass(this.rotateClassName);
    const $resizes = Private.POSITIONS.map(pos => {
      return $knob.clone().addClass(this.resizeClassName).attr('data-position', pos);
    });
    this.empty();
    this.$container.append($resizes, $rotate);
  }

  render() {
    this.renderHandles();
    this.view.addClass(Private.NODE_CLS);
    this.$container.addClass(this.containerClassName).toggleClass('no-orth-resize', this.options.preserveAspectRatio || !this.options.orthogonalResizing).toggleClass('no-resize', !this.options.resizable).toggleClass('no-rotate', !this.options.rotatable);

    if (this.options.className) {
      this.$container.addClass(this.options.className);
    }

    this.graph.container.appendChild(this.container);
    return this.update();
  }

  update() {
    const ctm = this.graph.matrix();
    const bbox = this.node.getBBox();
    bbox.x *= ctm.a;
    bbox.x += ctm.e;
    bbox.y *= ctm.d;
    bbox.y += ctm.f;
    bbox.width *= ctm.a;
    bbox.height *= ctm.d;
    const angle = _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.normalize(this.node.getAngle());
    const transform = angle !== 0 ? `rotate(${angle}deg)` : '';
    this.$container.css({
      transform,
      width: bbox.width,
      height: bbox.height,
      left: bbox.x,
      top: bbox.y
    });
    this.updateResizerDirections();
    return this;
  }

  remove() {
    this.view.removeClass(Private.NODE_CLS);
    return super.remove();
  }

  onKnobMouseDown() {
    this.startHandle();
  }

  onKnobMouseUp() {
    this.stopHandle();
  }

  updateResizerDirections() {
    // Update the directions on the resizer divs while the node being rotated.
    // The directions are represented by cardinal points (N,S,E,W). For example
    // the div originally pointed to north needs to be changed to point to south
    // if the node was rotated by 180 degrees.
    const angle = _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.normalize(this.node.getAngle());
    const shift = Math.floor(angle * (Private.DIRECTIONS.length / 360));

    if (shift !== this.prevShift) {
      // Create the current directions array based on the calculated shift.
      const directions = Private.DIRECTIONS.slice(shift).concat(Private.DIRECTIONS.slice(0, shift));

      const className = dir => `${this.containerClassName}-cursor-${dir}`;

      this.$container.find(`.${this.resizeClassName}`).removeClass(Private.DIRECTIONS.map(dir => className(dir)).join(' ')).each((index, elem) => {
        this.$(elem).addClass(className(directions[index]));
      });
      this.prevShift = shift;
    }
  }

  getTrueDirection(dir) {
    const angle = _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.normalize(this.node.getAngle());
    let index = Private.POSITIONS.indexOf(dir);
    index += Math.floor(angle * (Private.POSITIONS.length / 360));
    index %= Private.POSITIONS.length;
    return Private.POSITIONS[index];
  }

  toValidResizeDirection(dir) {
    return {
      top: 'top-left',
      bottom: 'bottom-right',
      left: 'bottom-left',
      right: 'top-right'
    }[dir] || dir;
  }

  startResizing(evt) {
    evt.stopPropagation();
    this.model.startBatch('resize', {
      cid: this.cid
    });
    const dir = this.$(evt.target).attr('data-position');
    const view = this.graph.findViewByCell(this.node);
    this.prepareResizing(evt, dir);
    this.startAction(evt);
    (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resize:mousedown', evt, view);
  }

  prepareResizing(evt, relativeDirection) {
    const trueDirection = this.getTrueDirection(relativeDirection);
    let rx = 0;
    let ry = 0;
    relativeDirection.split('-').forEach(direction => {
      rx = {
        left: -1,
        right: 1
      }[direction] || rx;
      ry = {
        top: -1,
        bottom: 1
      }[direction] || ry;
    });
    const direction = this.toValidResizeDirection(relativeDirection);
    const selector = {
      'top-right': 'bottomLeft',
      'top-left': 'bottomRight',
      'bottom-left': 'topRight',
      'bottom-right': 'topLeft'
    }[direction];
    const angle = _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.normalize(this.node.getAngle());
    this.setEventData(evt, {
      selector,
      direction,
      trueDirection,
      relativeDirection,
      angle,
      resizeX: rx,
      resizeY: ry,
      action: 'resizing'
    });
  }

  startRotating(evt) {
    evt.stopPropagation();
    this.model.startBatch('rotate', {
      cid: this.cid
    });
    const view = this.graph.findViewByCell(this.node);
    const center = this.node.getBBox().getCenter();
    const e = this.normalizeEvent(evt);
    const client = this.graph.snapToGrid(e.clientX, e.clientY);
    this.setEventData(evt, {
      center,
      action: 'rotating',
      angle: _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.normalize(this.node.getAngle()),
      start: _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(client).theta(center)
    });
    this.startAction(evt);
    (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotate:mousedown', evt, view);
  }

  onMouseMove(evt) {
    const view = this.graph.findViewByCell(this.node);
    let data = this.getEventData(evt);

    if (data.action) {
      const e = this.normalizeEvent(evt);
      let clientX = e.clientX;
      let clientY = e.clientY;
      const scroller = this.graph.scroller.widget;
      const restrict = this.options.restrictedResizing;

      if (restrict === true || typeof restrict === 'number') {
        const factor = restrict === true ? 0 : restrict;
        const fix = scroller ? Math.max(factor, 8) : factor;
        const rect = this.graph.container.getBoundingClientRect();
        clientX = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.clamp(clientX, rect.left + fix, rect.right - fix);
        clientY = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.clamp(clientY, rect.top + fix, rect.bottom - fix);
      } else if (this.options.autoScrollOnResizing && scroller) {
        scroller.autoScroll(clientX, clientY);
      }

      const pos = this.graph.snapToGrid(clientX, clientY);
      const gridSize = this.graph.getGridSize();
      const node = this.node;
      const options = this.options;

      if (data.action === 'resizing') {
        data = data;

        if (!data.resized) {
          if (view) {
            view.addClass('node-resizing');
            (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resize', evt, view);
          }

          data.resized = true;
        }

        const currentBBox = node.getBBox();
        const requestedSize = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(pos).rotate(data.angle, currentBBox.getCenter()).diff(currentBBox[data.selector]);
        let width = data.resizeX ? requestedSize.x * data.resizeX : currentBBox.width;
        let height = data.resizeY ? requestedSize.y * data.resizeY : currentBBox.height;
        const rawWidth = width;
        const rawHeight = height;
        width = _global__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(width, gridSize);
        height = _global__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(height, gridSize);
        width = Math.max(width, options.minWidth || gridSize);
        height = Math.max(height, options.minHeight || gridSize);
        width = Math.min(width, options.maxWidth || Infinity);
        height = Math.min(height, options.maxHeight || Infinity);

        if (options.preserveAspectRatio) {
          const candidateWidth = currentBBox.width * height / currentBBox.height;
          const candidateHeight = currentBBox.height * width / currentBBox.width;

          if (width < candidateWidth) {
            height = candidateHeight;
          } else {
            width = candidateWidth;
          }
        }

        const relativeDirection = data.relativeDirection;

        if (options.allowReverse && (rawWidth <= -width || rawHeight <= -height)) {
          let reverted;

          if (relativeDirection === 'left') {
            if (rawWidth <= -width) {
              reverted = 'right';
            }
          } else if (relativeDirection === 'right') {
            if (rawWidth <= -width) {
              reverted = 'left';
            }
          } else if (relativeDirection === 'top') {
            if (rawHeight <= -height) {
              reverted = 'bottom';
            }
          } else if (relativeDirection === 'bottom') {
            if (rawHeight <= -height) {
              reverted = 'top';
            }
          } else if (relativeDirection === 'top-left') {
            if (rawWidth <= -width && rawHeight <= -height) {
              reverted = 'bottom-right';
            } else if (rawWidth <= -width) {
              reverted = 'top-right';
            } else if (rawHeight <= -height) {
              reverted = 'bottom-left';
            }
          } else if (relativeDirection === 'top-right') {
            if (rawWidth <= -width && rawHeight <= -height) {
              reverted = 'bottom-left';
            } else if (rawWidth <= -width) {
              reverted = 'top-left';
            } else if (rawHeight <= -height) {
              reverted = 'bottom-right';
            }
          } else if (relativeDirection === 'bottom-left') {
            if (rawWidth <= -width && rawHeight <= -height) {
              reverted = 'top-right';
            } else if (rawWidth <= -width) {
              reverted = 'bottom-right';
            } else if (rawHeight <= -height) {
              reverted = 'top-left';
            }
          } else if (relativeDirection === 'bottom-right') {
            if (rawWidth <= -width && rawHeight <= -height) {
              reverted = 'top-left';
            } else if (rawWidth <= -width) {
              reverted = 'bottom-left';
            } else if (rawHeight <= -height) {
              reverted = 'top-right';
            }
          }

          const revertedDir = reverted;
          this.stopHandle();
          const $handle = this.$container.find(`.${this.resizeClassName}[data-position="${revertedDir}"]`);
          this.startHandle($handle[0]);
          this.prepareResizing(evt, revertedDir);
          this.onMouseMove(evt);
        }

        if (currentBBox.width !== width || currentBBox.height !== height) {
          const resizeOptions = {
            ui: true,
            direction: data.direction,
            relativeDirection: data.relativeDirection,
            trueDirection: data.trueDirection,
            minWidth: options.minWidth,
            minHeight: options.minHeight,
            maxWidth: options.maxWidth,
            maxHeight: options.maxHeight,
            preserveAspectRatio: options.preserveAspectRatio === true
          };
          node.resize(width, height, resizeOptions);
          (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resizing', evt, view);
        }

        (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resize:mousemove', evt, view);
      } else if (data.action === 'rotating') {
        data = data;

        if (!data.rotated) {
          if (view) {
            view.addClass('node-rotating');
            (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotate', evt, view);
          }

          data.rotated = true;
        }

        const currentAngle = node.getAngle();
        const theta = data.start - _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(pos).theta(data.center);
        let target = data.angle + theta;

        if (options.rotateGrid) {
          target = _global__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(target, options.rotateGrid);
        }

        target = _geometry__WEBPACK_IMPORTED_MODULE_2__.Angle.normalize(target);

        if (currentAngle !== target) {
          node.rotate(target, {
            absolute: true
          });
          (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotating', evt, view);
        }

        (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotate:mousemove', evt, view);
      }
    }
  }

  onMouseUp(evt) {
    const view = this.graph.findViewByCell(this.node);
    const data = this.getEventData(evt);

    if (data.action) {
      this.stopAction(evt);
      this.model.stopBatch(data.action === 'resizing' ? 'resize' : 'rotate', {
        cid: this.cid
      });

      if (data.action === 'resizing') {
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resize:mouseup', evt, view);
      } else if (data.action === 'rotating') {
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotate:mouseup', evt, view);
      }
    }
  }

  startHandle(handle) {
    this.handle = handle || null;
    this.$container.addClass(`${this.containerClassName}-active`);

    if (handle) {
      this.$(handle).addClass(`${this.containerClassName}-active-handle`);
      const pos = handle.getAttribute('data-position');

      if (pos) {
        const dir = Private.DIRECTIONS[Private.POSITIONS.indexOf(pos)];
        this.$container.addClass(`${this.containerClassName}-cursor-${dir}`);
      }
    }
  }

  stopHandle() {
    this.$container.removeClass(`${this.containerClassName}-active`);

    if (this.handle) {
      this.$(this.handle).removeClass(`${this.containerClassName}-active-handle`);
      const pos = this.handle.getAttribute('data-position');

      if (pos) {
        const dir = Private.DIRECTIONS[Private.POSITIONS.indexOf(pos)];
        this.$container.removeClass(`${this.containerClassName}-cursor-${dir}`);
      }

      this.handle = null;
    }
  }

  startAction(evt) {
    this.startHandle(evt.target);
    this.graph.view.undelegateEvents();
    this.delegateDocumentEvents(Private.documentEvents, evt.data);
  }

  stopAction(evt) {
    this.stopHandle();
    this.undelegateDocumentEvents();
    this.graph.view.delegateEvents();
    const view = this.graph.findViewByCell(this.node);
    const data = this.getEventData(evt);

    if (view) {
      view.removeClass(`node-${data.action}`);

      if (data.action === 'resizing' && data.resized) {
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:resized', evt, view);
      } else if (data.action === 'rotating' && data.rotated) {
        (0,_util__WEBPACK_IMPORTED_MODULE_4__.notify)('node:rotated', evt, view);
      }
    }
  }

}
var Private;

(function (Private) {
  Private.NODE_CLS = 'has-widget-transform';
  Private.DIRECTIONS = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
  Private.POSITIONS = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
  Private.documentEvents = {
    mousemove: 'onMouseMove',
    touchmove: 'onMouseMove',
    mouseup: 'onMouseUp',
    touchend: 'onMouseUp'
  };
  Private.defaultOptions = {
    minWidth: 0,
    minHeight: 0,
    maxWidth: Infinity,
    maxHeight: Infinity,
    rotateGrid: 15,
    rotatable: true,
    preserveAspectRatio: false,
    orthogonalResizing: true,
    restrictedResizing: false,
    autoScrollOnResizing: true,
    allowReverse: true
  };
})(Private || (Private = {}));

/***/ }),

/***/ 24309:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/addon/transform/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "notify": () => (/* binding */ notify)
/* harmony export */ });
function notify(name, evt, view, args = {}) {
  if (view) {
    const graph = view.graph;
    const e = graph.view.normalizeEvent(evt);
    const localPoint = graph.snapToGrid(e.clientX, e.clientY);
    view.notify(name, Object.assign({
      e,
      view,
      node: view.cell,
      cell: view.cell,
      x: localPoint.x,
      y: localPoint.y
    }, args));
  }
}

/***/ }),

/***/ 79304:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/algorithm/dijkstra.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dijkstra": () => (/* binding */ Dijkstra)
/* harmony export */ });
/* harmony import */ var _priorityqueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./priorityqueue */ 29586);

var Dijkstra;

(function (Dijkstra) {
  function run(adjacencyList, source, weight = (u, v) => 1) {
    const dist = {};
    const previous = {};
    const scanned = {};
    const queue = new _priorityqueue__WEBPACK_IMPORTED_MODULE_0__.PriorityQueue();
    dist[source] = 0;
    Object.keys(adjacencyList).forEach(v => {
      if (v !== source) {
        dist[v] = Infinity;
      }

      queue.insert(dist[v], v, v);
    });

    while (!queue.isEmpty()) {
      const u = queue.remove();
      scanned[u] = true;
      const neighbours = adjacencyList[u] || [];

      for (let i = 0; i < neighbours.length; i += 1) {
        const v = neighbours[i];

        if (!scanned[v]) {
          const alt = dist[u] + weight(u, v);

          if (alt < dist[v]) {
            dist[v] = alt;
            previous[v] = u;
            queue.updatePriority(v, alt);
          }
        }
      }
    }

    return previous;
  }

  Dijkstra.run = run;
})(Dijkstra || (Dijkstra = {}));

/***/ }),

/***/ 4366:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/algorithm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dijkstra": () => (/* reexport safe */ _dijkstra__WEBPACK_IMPORTED_MODULE_1__.Dijkstra),
/* harmony export */   "PriorityQueue": () => (/* reexport safe */ _priorityqueue__WEBPACK_IMPORTED_MODULE_0__.PriorityQueue)
/* harmony export */ });
/* harmony import */ var _priorityqueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./priorityqueue */ 29586);
/* harmony import */ var _dijkstra__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dijkstra */ 79304);



/***/ }),

/***/ 29586:
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/algorithm/priorityqueue.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PriorityQueue": () => (/* binding */ PriorityQueue)
/* harmony export */ });
/**
 * An implementation of the Priority Queue abstract data type.
 *
 * @see: http://en.wikipedia.org/wiki/Priority_queue
 *
 * It is like a normal stack or queue, but where each item has assigned a
 * priority (a number). Items with higher priority are served before items
 * with lower priority. This implementation uses binary heap as an internal
 * representation of the queue. The time complexity of all the methods is as
 * follows:
 *
 * - create: `O(n)`
 * - insert: `O(log n)`
 * - remove: `O(log n)`
 * - peek: `O(1)`
 * - isEmpty: `O(1)`
 * - peekPriority: `O(1)`
 */
class PriorityQueue {
  constructor(options = {}) {
    this.comparator = options.comparator || PriorityQueue.defaultComparator;
    this.index = {};
    this.data = options.data || [];
    this.heapify();
  }
  /**
   * Returns `true` if the priority queue is empty, `false` otherwise.
   */


  isEmpty() {
    return this.data.length === 0;
  }
  /**
   * Inserts a value with priority to the queue. Optionally pass a unique
   * id of this item. Passing unique IDs for each item you insert allows
   * you to use the `updatePriority()` operation.
   * @param priority
   * @param value
   * @param id
   */


  insert(priority, value, id) {
    const item = {
      priority,
      value
    };
    const index = this.data.length - 1;

    if (id) {
      item.id = id;
      this.index[id] = index;
    }

    this.data.push(item);
    this.bubbleUp(index);
    return this;
  }
  /**
   * Returns the value of an item with the highest priority.
   */


  peek() {
    return this.data[0] ? this.data[0].value : null;
  }
  /**
   * Returns the highest priority in the queue.
   */


  peekPriority() {
    return this.data[0] ? this.data[0].priority : null;
  }

  updatePriority(id, priority) {
    const index = this.index[id];

    if (typeof index === 'undefined') {
      throw new Error(`Node with id '${id}' was not found in the heap.`);
    }

    const data = this.data;
    const oldPriority = data[index].priority;
    const comp = this.comparator(priority, oldPriority);

    if (comp < 0) {
      data[index].priority = priority;
      this.bubbleUp(index);
    } else if (comp > 0) {
      data[index].priority = priority;
      this.bubbleDown(index);
    }
  }
  /**
   * Removes the item with the highest priority from the queue
   *
   * @returns The value of the removed item.
   */


  remove() {
    const data = this.data;
    const peek = data[0];
    const last = data.pop();
    delete this.index[data.length];

    if (data.length > 0) {
      data[0] = last;

      if (last.id) {
        this.index[last.id] = 0;
      }

      this.bubbleDown(0);
    }

    return peek ? peek.value : null;
  }

  heapify() {
    for (let i = 0; i < this.data.length; i += 1) {
      this.bubbleUp(i);
    }
  }

  bubbleUp(index) {
    const data = this.data;
    let tmp;
    let parent;
    let current = index;

    while (current > 0) {
      parent = current - 1 >>> 1;

      if (this.comparator(data[current].priority, data[parent].priority) < 0) {
        tmp = data[parent];
        data[parent] = data[current];
        let id = data[current].id;

        if (id != null) {
          this.index[id] = parent;
        }

        data[current] = tmp;
        id = data[current].id;

        if (id != null) {
          this.index[id] = current;
        }

        current = parent;
      } else {
        break;
      }
    }
  }

  bubbleDown(index) {
    const data = this.data;
    const last = data.length - 1;
    let current = index; // eslint-disable-next-line

    while (true) {
      const left = (current << 1) + 1;
      const right = left + 1;
      let minIndex = current;

      if (left <= last && this.comparator(data[left].priority, data[minIndex].priority) < 0) {
        minIndex = left;
      }

      if (right <= last && this.comparator(data[right].priority, data[minIndex].priority) < 0) {
        minIndex = right;
      }

      if (minIndex !== current) {
        const tmp = data[minIndex];
        data[minIndex] = data[current];
        let id = data[current].id;

        if (id != null) {
          this.index[id] = minIndex;
        }

        data[current] = tmp;
        id = data[current].id;

        if (id != null) {
          this.index[id] = current;
        }

        current = minIndex;
      } else {
        break;
      }
    }
  }

}

(function (PriorityQueue) {
  PriorityQueue.defaultComparator = (a, b) => a - b;
})(PriorityQueue || (PriorityQueue = {}));

/***/ }),

/***/ 25536:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/animation/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interp": () => (/* reexport safe */ _interp__WEBPACK_IMPORTED_MODULE_1__.Interp),
/* harmony export */   "Timing": () => (/* reexport safe */ _timing__WEBPACK_IMPORTED_MODULE_0__.Timing)
/* harmony export */ });
/* harmony import */ var _timing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timing */ 67451);
/* harmony import */ var _interp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interp */ 56327);



/***/ }),

/***/ 56327:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/animation/interp.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interp": () => (/* binding */ Interp)
/* harmony export */ });
var Interp;

(function (Interp) {
  Interp.number = (a, b) => {
    const d = b - a;
    return t => {
      return a + d * t;
    };
  };

  Interp.object = (a, b) => {
    const keys = Object.keys(a);
    return t => {
      const ret = {};

      for (let i = keys.length - 1; i !== -1; i -= 1) {
        const key = keys[i];
        ret[key] = a[key] + (b[key] - a[key]) * t;
      }

      return ret;
    };
  };

  Interp.unit = (a, b) => {
    const reg = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
    const ma = reg.exec(a);
    const mb = reg.exec(b);
    const pb = mb ? mb[1] : '';
    const aa = ma ? +ma[1] : 0;
    const bb = mb ? +mb[1] : 0;
    const index = pb.indexOf('.');
    const precision = index > 0 ? pb[1].length - index - 1 : 0;
    const d = bb - aa;
    const u = ma ? ma[2] : '';
    return t => {
      return (aa + d * t).toFixed(precision) + u;
    };
  };

  Interp.color = (a, b) => {
    const ca = parseInt(a.slice(1), 16);
    const cb = parseInt(b.slice(1), 16);
    const ra = ca & 0x0000ff;
    const rd = (cb & 0x0000ff) - ra;
    const ga = ca & 0x00ff00;
    const gd = (cb & 0x00ff00) - ga;
    const ba = ca & 0xff0000;
    const bd = (cb & 0xff0000) - ba;
    return t => {
      const r = ra + rd * t & 0x000000ff;
      const g = ga + gd * t & 0x0000ff00;
      const b = ba + bd * t & 0x00ff0000;
      return `#${(1 << 24 | r | g | b).toString(16).slice(1)}`;
    };
  };
})(Interp || (Interp = {}));

/***/ }),

/***/ 67451:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/animation/timing.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Timing": () => (/* binding */ Timing)
/* harmony export */ });
var Timing;

(function (Timing) {
  Timing.linear = t => t;

  Timing.quad = t => t * t;

  Timing.cubic = t => t * t * t;

  Timing.inout = t => {
    if (t <= 0) {
      return 0;
    }

    if (t >= 1) {
      return 1;
    }

    const t2 = t * t;
    const t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
  };

  Timing.exponential = t => {
    return Math.pow(2, 10 * (t - 1)); // eslint-disable-line
  };

  Timing.bounce = t => {
    // eslint-disable-next-line
    for (let a = 0, b = 1; 1; a += b, b /= 2) {
      if (t >= (7 - 4 * a) / 11) {
        const q = (11 - 6 * a - 11 * t) / 4;
        return -q * q + b * b;
      }
    }
  };
})(Timing || (Timing = {}));

(function (Timing) {
  Timing.decorators = {
    reverse(f) {
      return t => 1 - f(1 - t);
    },

    reflect(f) {
      return t => 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
    },

    clamp(f, n = 0, x = 1) {
      return t => {
        const r = f(t);
        return r < n ? n : r > x ? x : r;
      };
    },

    back(s = 1.70158) {
      return t => t * t * ((s + 1) * t - s);
    },

    elastic(x = 1.5) {
      return t => Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t); // eslint-disable-line
    }

  };
})(Timing || (Timing = {}));

(function (Timing) {
  // Slight acceleration from zero to full speed
  function easeInSine(t) {
    return -1 * Math.cos(t * (Math.PI / 2)) + 1;
  }

  Timing.easeInSine = easeInSine; // Slight deceleration at the end

  function easeOutSine(t) {
    return Math.sin(t * (Math.PI / 2));
  }

  Timing.easeOutSine = easeOutSine; // Slight acceleration at beginning and slight deceleration at end

  function easeInOutSine(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
  }

  Timing.easeInOutSine = easeInOutSine; // Accelerating from zero velocity

  function easeInQuad(t) {
    return t * t;
  }

  Timing.easeInQuad = easeInQuad; // Decelerating to zero velocity

  function easeOutQuad(t) {
    return t * (2 - t);
  }

  Timing.easeOutQuad = easeOutQuad; // Acceleration until halfway, then deceleration

  function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  Timing.easeInOutQuad = easeInOutQuad; // Accelerating from zero velocity

  function easeInCubic(t) {
    return t * t * t;
  }

  Timing.easeInCubic = easeInCubic; // Decelerating to zero velocity

  function easeOutCubic(t) {
    const t1 = t - 1;
    return t1 * t1 * t1 + 1;
  }

  Timing.easeOutCubic = easeOutCubic; // Acceleration until halfway, then deceleration

  function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  }

  Timing.easeInOutCubic = easeInOutCubic; // Accelerating from zero velocity

  function easeInQuart(t) {
    return t * t * t * t;
  }

  Timing.easeInQuart = easeInQuart; // Decelerating to zero velocity

  function easeOutQuart(t) {
    const t1 = t - 1;
    return 1 - t1 * t1 * t1 * t1;
  }

  Timing.easeOutQuart = easeOutQuart; // Acceleration until halfway, then deceleration

  function easeInOutQuart(t) {
    const t1 = t - 1;
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;
  }

  Timing.easeInOutQuart = easeInOutQuart; // Accelerating from zero velocity

  function easeInQuint(t) {
    return t * t * t * t * t;
  }

  Timing.easeInQuint = easeInQuint; // Decelerating to zero velocity

  function easeOutQuint(t) {
    const t1 = t - 1;
    return 1 + t1 * t1 * t1 * t1 * t1;
  }

  Timing.easeOutQuint = easeOutQuint; // Acceleration until halfway, then deceleration

  function easeInOutQuint(t) {
    const t1 = t - 1;
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;
  }

  Timing.easeInOutQuint = easeInOutQuint; // Accelerate exponentially until finish

  function easeInExpo(t) {
    if (t === 0) {
      return 0;
    }

    return Math.pow(2, 10 * (t - 1)); // eslint-disable-line
  }

  Timing.easeInExpo = easeInExpo; // Initial exponential acceleration slowing to stop

  function easeOutExpo(t) {
    if (t === 1) {
      return 1;
    }

    return -Math.pow(2, -10 * t) + 1; // eslint-disable-line
  }

  Timing.easeOutExpo = easeOutExpo; // Exponential acceleration and deceleration

  function easeInOutExpo(t) {
    if (t === 0 || t === 1) {
      return t;
    }

    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 1;

    if (scaledTime < 1) {
      return 0.5 * Math.pow(2, 10 * scaledTime1); // eslint-disable-line
    }

    return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2); // eslint-disable-line
  }

  Timing.easeInOutExpo = easeInOutExpo; // Increasing velocity until stop

  function easeInCirc(t) {
    const scaledTime = t / 1;
    return -1 * (Math.sqrt(1 - scaledTime * t) - 1);
  }

  Timing.easeInCirc = easeInCirc; // Start fast, decreasing velocity until stop

  function easeOutCirc(t) {
    const t1 = t - 1;
    return Math.sqrt(1 - t1 * t1);
  }

  Timing.easeOutCirc = easeOutCirc; // Fast increase in velocity, fast decrease in velocity

  function easeInOutCirc(t) {
    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 2;

    if (scaledTime < 1) {
      return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);
    }

    return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);
  }

  Timing.easeInOutCirc = easeInOutCirc; // Slow movement backwards then fast snap to finish

  function easeInBack(t, magnitude = 1.70158) {
    return t * t * ((magnitude + 1) * t - magnitude);
  }

  Timing.easeInBack = easeInBack; // Fast snap to backwards point then slow resolve to finish

  function easeOutBack(t, magnitude = 1.70158) {
    const scaledTime = t / 1 - 1;
    return scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1;
  }

  Timing.easeOutBack = easeOutBack; // Slow movement backwards, fast snap to past finish, slow resolve to finish

  function easeInOutBack(t, magnitude = 1.70158) {
    const scaledTime = t * 2;
    const scaledTime2 = scaledTime - 2;
    const s = magnitude * 1.525;

    if (scaledTime < 1) {
      return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);
    }

    return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);
  }

  Timing.easeInOutBack = easeInOutBack; // Bounces slowly then quickly to finish

  function easeInElastic(t, magnitude = 0.7) {
    if (t === 0 || t === 1) {
      return t;
    }

    const scaledTime = t / 1;
    const scaledTime1 = scaledTime - 1;
    const p = 1 - magnitude;
    const s = p / (2 * Math.PI) * Math.asin(1);
    return -(Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
    Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));
  }

  Timing.easeInElastic = easeInElastic; // Fast acceleration, bounces to zero

  function easeOutElastic(t, magnitude = 0.7) {
    const p = 1 - magnitude;
    const scaledTime = t * 2;

    if (t === 0 || t === 1) {
      return t;
    }

    const s = p / (2 * Math.PI) * Math.asin(1);
    return Math.pow(2, -10 * scaledTime) * // eslint-disable-line
    Math.sin((scaledTime - s) * (2 * Math.PI) / p) + 1;
  }

  Timing.easeOutElastic = easeOutElastic; // Slow start and end, two bounces sandwich a fast motion

  function easeInOutElastic(t, magnitude = 0.65) {
    const p = 1 - magnitude;

    if (t === 0 || t === 1) {
      return t;
    }

    const scaledTime = t * 2;
    const scaledTime1 = scaledTime - 1;
    const s = p / (2 * Math.PI) * Math.asin(1);

    if (scaledTime < 1) {
      return -0.5 * (Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
      Math.sin((scaledTime1 - s) * (2 * Math.PI) / p));
    }

    return Math.pow(2, -10 * scaledTime1) * // eslint-disable-line
    Math.sin((scaledTime1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
  }

  Timing.easeInOutElastic = easeInOutElastic; // Bounce to completion

  function easeOutBounce(t) {
    const scaledTime = t / 1;

    if (scaledTime < 1 / 2.75) {
      return 7.5625 * scaledTime * scaledTime;
    }

    if (scaledTime < 2 / 2.75) {
      const scaledTime2 = scaledTime - 1.5 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.75;
    }

    if (scaledTime < 2.5 / 2.75) {
      const scaledTime2 = scaledTime - 2.25 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.9375;
    }

    {
      const scaledTime2 = scaledTime - 2.625 / 2.75;
      return 7.5625 * scaledTime2 * scaledTime2 + 0.984375;
    }
  }

  Timing.easeOutBounce = easeOutBounce; // Bounce increasing in velocity until completion

  function easeInBounce(t) {
    return 1 - easeOutBounce(1 - t);
  }

  Timing.easeInBounce = easeInBounce; // Bounce in and bounce out

  function easeInOutBounce(t) {
    if (t < 0.5) {
      return easeInBounce(t * 2) * 0.5;
    }

    return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
  }

  Timing.easeInOutBounce = easeInOutBounce;
})(Timing || (Timing = {}));

/***/ }),

/***/ 22192:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/basecoat.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Basecoat": () => (/* binding */ Basecoat)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ 59560);
/* harmony import */ var _disposable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./disposable */ 45321);



class Basecoat extends _events__WEBPACK_IMPORTED_MODULE_1__.Events {}

(function (Basecoat) {
  Basecoat.dispose = _disposable__WEBPACK_IMPORTED_MODULE_2__.Disposable.dispose;
})(Basecoat || (Basecoat = {}));

_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.applyMixins(Basecoat, _disposable__WEBPACK_IMPORTED_MODULE_2__.Disposable);

/***/ }),

/***/ 54425:
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": () => (/* binding */ Color)
/* harmony export */ });
/* harmony import */ var _util_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/number */ 65090);

class Color {
  constructor(color, g, b, a) {
    if (color == null) {
      return this.set(255, 255, 255, 1);
    }

    if (typeof color === 'number') {
      return this.set(color, g, b, a);
    }

    if (typeof color === 'string') {
      return Color.fromString(color) || this;
    }

    if (Array.isArray(color)) {
      return this.set(color);
    }

    this.set(color.r, color.g, color.b, color.a == null ? 1 : color.a);
  }

  blend(start, end, weight) {
    this.set(start.r + (end.r - start.r) * weight, start.g + (end.g - start.g) * weight, start.b + (end.b - start.b) * weight, start.a + (end.a - start.a) * weight);
  }

  lighten(amount) {
    const rgba = Color.lighten(this.toArray(), amount);
    this.r = rgba[0];
    this.g = rgba[1];
    this.b = rgba[2];
    this.a = rgba[3];
  }

  darken(amount) {
    this.lighten(-amount);
  }

  set(arg0, arg1, arg2, arg3) {
    const r = Array.isArray(arg0) ? arg0[0] : arg0;
    const g = Array.isArray(arg0) ? arg0[1] : arg1;
    const b = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    this.r = Math.round(_util_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(r, 0, 255));
    this.g = Math.round(_util_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(g, 0, 255));
    this.b = Math.round(_util_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(b, 0, 255));
    this.a = a == null ? 1 : _util_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(a, 0, 1);
    return this;
  }

  toHex() {
    const hex = ['r', 'g', 'b'].map(key => {
      const str = this[key].toString(16);
      return str.length < 2 ? `0${str}` : str;
    });
    return `#${hex.join('')}`;
  }

  toRGBA() {
    return this.toArray();
  }

  toHSLA() {
    return Color.rgba2hsla(this.r, this.g, this.b, this.a);
  }

  toCSS(ignoreAlpha) {
    const rgb = `${this.r},${this.g},${this.b},`;
    return ignoreAlpha ? `rgb(${rgb})` : `rgba(${rgb},${this.a})`;
  }

  toGrey() {
    return Color.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
  }

  toArray() {
    return [this.r, this.g, this.b, this.a];
  }

  toString() {
    return this.toCSS();
  }

}

(function (Color) {
  function fromArray(arr) {
    return new Color(arr);
  }

  Color.fromArray = fromArray;

  function fromHex(color) {
    return new Color([...hex2rgb(color), 1]);
  }

  Color.fromHex = fromHex;

  function fromRGBA(color) {
    const matches = color.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);

    if (matches) {
      const arr = matches[1].split(/\s*,\s*/).map(v => parseInt(v, 10));
      return new Color(arr);
    }

    return null;
  }

  Color.fromRGBA = fromRGBA;

  function hue2rgb(m1, m2, h) {
    if (h < 0) {
      ++h; // eslint-disable-line
    }

    if (h > 1) {
      --h; // eslint-disable-line
    }

    const h6 = 6 * h;

    if (h6 < 1) {
      return m1 + (m2 - m1) * h6;
    }

    if (2 * h < 1) {
      return m2;
    }

    if (3 * h < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }

    return m1;
  }

  function fromHSLA(color) {
    const matches = color.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);

    if (matches) {
      const arr = matches[2].split(/\s*,\s*/);
      const h = (parseFloat(arr[0]) % 360 + 360) % 360 / 360;
      const s = parseFloat(arr[1]) / 100;
      const l = parseFloat(arr[2]) / 100;
      const a = arr[3] == null ? 1 : parseInt(arr[3], 10);
      return new Color(hsla2rgba(h, s, l, a));
    }

    return null;
  }

  Color.fromHSLA = fromHSLA;

  function fromString(color) {
    if (color.startsWith('#')) {
      return fromHex(color);
    }

    if (color.startsWith('rgb')) {
      return fromRGBA(color);
    }

    const preset = Color.named[color];

    if (preset) {
      return fromHex(preset);
    }

    return fromHSLA(color);
  }

  Color.fromString = fromString;

  function makeGrey(g, a) {
    return Color.fromArray([g, g, g, a]);
  }

  Color.makeGrey = makeGrey;

  function rgba2hsla(arg0, arg1, arg2, arg3) {
    const r = Array.isArray(arg0) ? arg0[0] : arg0;
    const g = Array.isArray(arg0) ? arg0[1] : arg1;
    const b = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h = 0;
    let s = 0;

    if (min !== max) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;

        default:
          break;
      }

      h /= 6;
    }

    return [h, s, l, a == null ? 1 : a];
  }

  Color.rgba2hsla = rgba2hsla;

  function hsla2rgba(arg0, arg1, arg2, arg3) {
    const h = Array.isArray(arg0) ? arg0[0] : arg0;
    const s = Array.isArray(arg0) ? arg0[1] : arg1;
    const l = Array.isArray(arg0) ? arg0[2] : arg2;
    const a = Array.isArray(arg0) ? arg0[3] : arg3;
    const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    const m1 = 2 * l - m2;
    return [hue2rgb(m1, m2, h + 1 / 3) * 256, hue2rgb(m1, m2, h) * 256, hue2rgb(m1, m2, h - 1 / 3) * 256, a == null ? 1 : a];
  }

  Color.hsla2rgba = hsla2rgba;

  function random(ignoreAlpha) {
    return new Color(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), ignoreAlpha ? undefined : parseFloat(Math.random().toFixed(2)));
  }

  Color.random = random;

  function randomHex() {
    const letters = '0123456789ABCDEF';
    let color = '#';

    for (let i = 0; i < 6; i += 1) {
      color += letters[Math.floor(Math.random() * 16)];
    }

    return color;
  }

  Color.randomHex = randomHex;

  function randomRGBA(ignoreAlpha) {
    return random(ignoreAlpha).toString();
  }

  Color.randomRGBA = randomRGBA;

  function invert(color, bw) {
    if (typeof color === 'string') {
      const pound = color[0] === '#';
      const [r, g, b] = hex2rgb(color);

      if (bw) {
        // http://stackoverflow.com/a/3943023/112731
        return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#ffffff';
      }

      return `${pound ? '#' : ''}${rgb2hex(255 - r, 255 - g, 255 - b)}`;
    }

    const r = color[0];
    const g = color[1];
    const b = color[2];
    const a = color[3];

    if (bw) {
      return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? [0, 0, 0, a] : [255, 255, 255, a];
    }

    return [255 - r, 255 - g, 255 - b, a];
  }

  Color.invert = invert;

  function hex2rgb(hex) {
    const color = hex.indexOf('#') === 0 ? hex : `#${hex}`;
    let val = Number(`0x${color.substr(1)}`);

    if (!(color.length === 4 || color.length === 7) || Number.isNaN(val)) {
      throw new Error('Invalid hex color.');
    }

    const bits = color.length === 4 ? 4 : 8;
    const mask = (1 << bits) - 1;
    const bgr = ['b', 'g', 'r'].map(() => {
      const c = val & mask;
      val >>= bits;
      return bits === 4 ? 17 * c : c;
    });
    return [bgr[2], bgr[1], bgr[0]];
  }

  function rgb2hex(r, g, b) {
    const pad = hex => hex.length < 2 ? `0${hex}` : hex;

    return `${pad(r.toString(16))}${pad(g.toString(16))}${pad(b.toString(16))}`;
  }

  function lighten(color, amt) {
    return lum(color, amt);
  }

  Color.lighten = lighten;

  function darken(color, amt) {
    return lum(color, -amt);
  }

  Color.darken = darken;

  function lum(color, amt) {
    if (typeof color === 'string') {
      const pound = color[0] === '#';
      const num = parseInt(pound ? color.substr(1) : color, 16);
      const r = _util_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp((num >> 16) + amt, 0, 255);
      const g = _util_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp((num >> 8 & 0x00ff) + amt, 0, 255);
      const b = _util_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp((num & 0x0000ff) + amt, 0, 255);
      return `${pound ? '#' : ''}${(b | g << 8 | r << 16).toString(16)}`;
    }

    const hex = rgb2hex(color[0], color[1], color[2]);
    const arr = hex2rgb(lum(hex, amt));
    return [arr[0], arr[1], arr[2], color[3]];
  }
})(Color || (Color = {}));

(function (Color) {
  Color.named = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    burntsienna: '#ea7e5d',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkgrey: '#a9a9a9',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    grey: '#808080',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightgrey: '#d3d3d3',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32'
  };
})(Color || (Color = {}));

/***/ }),

/***/ 7422:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/dictionary.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dictionary": () => (/* binding */ Dictionary)
/* harmony export */ });
/* harmony import */ var _disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./disposable */ 45321);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class Dictionary extends _disposable__WEBPACK_IMPORTED_MODULE_0__.Disposable {
  constructor() {
    super();
    this.clear();
  }

  clear() {
    this.map = new WeakMap();
    this.arr = [];
  }

  has(key) {
    return this.map.has(key);
  }

  get(key) {
    return this.map.get(key);
  }

  set(key, value) {
    this.map.set(key, value);
    this.arr.push(key);
  }

  delete(key) {
    const index = this.arr.indexOf(key);

    if (index >= 0) {
      this.arr.splice(index, 1);
    }

    const ret = this.map.get(key);
    this.map.delete(key);
    return ret;
  }

  each(iterator) {
    this.arr.forEach(key => {
      const value = this.map.get(key);
      iterator(value, key);
    });
  }

  dispose() {
    this.clear();
  }

}

__decorate([_disposable__WEBPACK_IMPORTED_MODULE_0__.Disposable.dispose()], Dictionary.prototype, "dispose", null);

/***/ }),

/***/ 32801:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/disablable.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Disablable": () => (/* binding */ Disablable)
/* harmony export */ });
/* harmony import */ var _basecoat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basecoat */ 22192);
/* eslint-disable no-underscore-dangle */

class Disablable extends _basecoat__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
  get disabled() {
    return this._disabled === true;
  }

  enable() {
    delete this._disabled;
  }

  disable() {
    this._disabled = true;
  }

}

/***/ }),

/***/ 45321:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/disposable.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Disposable": () => (/* binding */ Disposable),
/* harmony export */   "DisposableDelegate": () => (/* binding */ DisposableDelegate),
/* harmony export */   "DisposableSet": () => (/* binding */ DisposableSet)
/* harmony export */ });
/* eslint-disable no-underscore-dangle */
class Disposable {
  get disposed() {
    return this._disposed === true;
  }

  dispose() {
    this._disposed = true;
  }

}

(function (Disposable) {
  function dispose() {
    return (target, methodName, descriptor) => {
      const raw = descriptor.value;
      const proto = target.__proto__; // eslint-disable-line

      descriptor.value = function () {
        if (this.disposed) {
          return;
        }

        raw.call(this);
        proto.dispose.call(this);
      };
    };
  }

  Disposable.dispose = dispose;
})(Disposable || (Disposable = {}));
/**
 * A disposable object which delegates to a callback function.
 */


class DisposableDelegate {
  /**
   * Construct a new disposable delegate.
   *
   * @param callback - The callback function to invoke on dispose.
   */
  constructor(callback) {
    this.callback = callback;
  }
  /**
   * Test whether the delegate has been disposed.
   */


  get disposed() {
    return !this.callback;
  }
  /**
   * Dispose of the delegate and invoke the callback function.
   */


  dispose() {
    if (!this.callback) {
      return;
    }

    const callback = this.callback;
    this.callback = null;
    callback();
  }

}
/**
 * An object which manages a collection of disposable items.
 */

class DisposableSet {
  constructor() {
    this.isDisposed = false; // eslint-disable-line:variable-name

    this.items = new Set();
  }
  /**
   * Test whether the set has been disposed.
   */


  get disposed() {
    return this.isDisposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */


  dispose() {
    if (this.isDisposed) {
      return;
    }

    this.isDisposed = true;
    this.items.forEach(item => {
      item.dispose();
    });
    this.items.clear();
  }
  /**
   * Test whether the set contains a specific item.
   *
   * @param item - The item of interest.
   *
   * @returns `true` if the set contains the item, `false` otherwise.
   */


  contains(item) {
    return this.items.has(item);
  }
  /**
   * Add a disposable item to the set.
   *
   * @param item - The item to add to the set.
   *
   * #### Notes
   * If the item is already contained in the set, this is a no-op.
   */


  add(item) {
    this.items.add(item);
  }
  /**
   * Remove a disposable item from the set.
   *
   * @param item - The item to remove from the set.
   *
   * #### Notes
   * If the item is not contained in the set, this is a no-op.
   */


  remove(item) {
    this.items.delete(item);
  }
  /**
   * Remove all items from the set.
   */


  clear() {
    this.items.clear();
  }

}

(function (DisposableSet) {
  /**
   * Create a disposable set from an iterable of items.
   *
   * @param items - The iterable or array-like object of interest.
   *
   * @returns A new disposable initialized with the given items.
   */
  function from(items) {
    const set = new DisposableSet();
    items.forEach(item => {
      set.add(item);
    });
    return set;
  }

  DisposableSet.from = from;
})(DisposableSet || (DisposableSet = {}));

/***/ }),

/***/ 59560:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/events.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Events": () => (/* binding */ Events)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);

class Events {
  constructor() {
    this.listeners = {};
  }

  on(name, handler, context) {
    if (handler == null) {
      return this;
    }

    if (!this.listeners[name]) {
      this.listeners[name] = [];
    }

    const cache = this.listeners[name];
    cache.push(handler, context);
    return this;
  }

  once(name, handler, context) {
    const cb = (...args) => {
      this.off(name, cb);
      return Private.call([handler, context], args);
    };

    return this.on(name, cb, this);
  }

  off(name, handler, context) {
    // remove all events.
    if (!(name || handler || context)) {
      this.listeners = {};
      return this;
    }

    const listeners = this.listeners;
    const names = name ? [name] : Object.keys(listeners);
    names.forEach(n => {
      const cache = listeners[n];

      if (!cache) {
        return;
      } // remove all events with specified name.


      if (!(handler || context)) {
        delete listeners[n];
        return;
      }

      for (let i = cache.length - 2; i >= 0; i -= 2) {
        if (!(handler && cache[i] !== handler || context && cache[i + 1] !== context)) {
          cache.splice(i, 2);
        }
      }
    });
    return this;
  }

  trigger(name, ...args) {
    let returned = true;

    if (name !== '*') {
      const list = this.listeners[name];

      if (list != null) {
        returned = Private.call([...list], args);
      }
    }

    const list = this.listeners['*'];

    if (list != null) {
      return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.toAsyncBoolean([returned, Private.call([...list], [name, ...args])]);
    }

    return returned;
  }

  emit(name, ...args) {
    return this.trigger(name, ...args);
  }

}
var Private;

(function (Private) {
  function call(list, args) {
    const results = [];

    for (let i = 0; i < list.length; i += 2) {
      const handler = list[i];
      const context = list[i + 1];
      const params = Array.isArray(args) ? args : [args];
      const ret = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.apply(handler, context, params);
      results.push(ret);
    }

    return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.toAsyncBoolean(results);
  }

  Private.call = call;
})(Private || (Private = {}));

/***/ }),

/***/ 57566:
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Basecoat": () => (/* reexport safe */ _basecoat__WEBPACK_IMPORTED_MODULE_2__.Basecoat),
/* harmony export */   "Color": () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_0__.Color),
/* harmony export */   "Dictionary": () => (/* reexport safe */ _dictionary__WEBPACK_IMPORTED_MODULE_5__.Dictionary),
/* harmony export */   "Dijkstra": () => (/* reexport safe */ _algorithm__WEBPACK_IMPORTED_MODULE_6__.Dijkstra),
/* harmony export */   "Disablable": () => (/* reexport safe */ _disablable__WEBPACK_IMPORTED_MODULE_4__.Disablable),
/* harmony export */   "Disposable": () => (/* reexport safe */ _disposable__WEBPACK_IMPORTED_MODULE_3__.Disposable),
/* harmony export */   "DisposableDelegate": () => (/* reexport safe */ _disposable__WEBPACK_IMPORTED_MODULE_3__.DisposableDelegate),
/* harmony export */   "DisposableSet": () => (/* reexport safe */ _disposable__WEBPACK_IMPORTED_MODULE_3__.DisposableSet),
/* harmony export */   "Events": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.Events),
/* harmony export */   "Interp": () => (/* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_7__.Interp),
/* harmony export */   "LocalStorage": () => (/* reexport safe */ _localstorage__WEBPACK_IMPORTED_MODULE_8__.LocalStorage),
/* harmony export */   "PriorityQueue": () => (/* reexport safe */ _algorithm__WEBPACK_IMPORTED_MODULE_6__.PriorityQueue),
/* harmony export */   "Timing": () => (/* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_7__.Timing)
/* harmony export */ });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ 54425);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ 59560);
/* harmony import */ var _basecoat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basecoat */ 22192);
/* harmony import */ var _disposable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./disposable */ 45321);
/* harmony import */ var _disablable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./disablable */ 32801);
/* harmony import */ var _dictionary__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dictionary */ 7422);
/* harmony import */ var _algorithm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./algorithm */ 4366);
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./animation */ 25536);
/* harmony import */ var _localstorage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./localstorage */ 8253);










/***/ }),

/***/ 8253:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/common/localstorage.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalStorage": () => (/* binding */ LocalStorage)
/* harmony export */ });
/* harmony import */ var _global_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global/config */ 1357);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);


var LocalStorage;

(function (LocalStorage) {
  const prefix = `${_global_config__WEBPACK_IMPORTED_MODULE_0__.Config.prefixCls}.storage`;

  function insert(collection, doc, cb) {
    const id = doc.id || _util__WEBPACK_IMPORTED_MODULE_1__.StringExt.uniqueId('doc-');
    const index = loadIndex(collection);
    index.keys.push(id);
    setItem(docKey(collection, id), doc);
    setItem(indexKey(collection), index);
    callback(cb, null, Object.assign(Object.assign({}, doc), {
      id
    }));
  }

  LocalStorage.insert = insert;

  function find(collection, query, cb) {
    const index = loadIndex(collection);
    const docs = [];

    if (query == null) {
      index.keys.forEach(id => {
        const doc = getItem(docKey(collection, id));

        if (!doc) {
          callback(cb, new Error(`No document found for an ID '${id}' from index.`));
        } else {
          docs.push(doc);
        }
      });
      callback(cb, null, docs);
    } else if (query.id) {
      const doc = getItem(docKey(collection, query.id));
      callback(cb, null, doc ? [doc] : []);
    } else {
      callback(cb, null, []);
    }
  }

  LocalStorage.find = find;

  function remove(collection, query, cb) {
    const index = loadIndex(collection);

    if (query == null) {
      index.keys.forEach(id => {
        localStorage.removeItem(docKey(collection, id));
      });
      localStorage.removeItem(indexKey(collection));
      callback(cb, null);
    } else if (query.id) {
      const idx = index.keys.indexOf(query.id);

      if (idx >= 0) {
        index.keys.splice(idx, 1);
      }

      localStorage.removeItem(docKey(collection, query.id));
      setItem(indexKey(collection), index);
      callback(cb, null);
    }
  }

  LocalStorage.remove = remove; // util
  // ----

  function callback(cb, err, ret) {
    if (cb) {
      _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.defer(() => {
        cb(err, ret);
      });
    }
  }

  function setItem(key, item) {
    localStorage.setItem(key, JSON.stringify(item));
  }

  function getItem(key) {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  }

  function loadIndex(collection) {
    const index = getItem(indexKey(collection));

    if (index) {
      if (index.keys == null) {
        index.keys = [];
      }

      return index;
    }

    return {
      keys: []
    };
  }

  function docKey(collection, id) {
    return `${prefix}.${collection}.docs.${id}`;
  }

  function indexKey(collection) {
    return `${prefix}.${collection}.index`;
  }
})(LocalStorage || (LocalStorage = {}));

/***/ }),

/***/ 39092:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/angle.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Angle": () => (/* binding */ Angle)
/* harmony export */ });
var Angle;

(function (Angle) {
  /**
   * Converts radian angle to degree angle.
   * @param rad The radians to convert.
   */
  function toDeg(rad) {
    return 180 * rad / Math.PI % 360;
  }

  Angle.toDeg = toDeg;
  /**
   * Converts degree angle to radian angle.
   * @param deg The degree angle to convert.
   * @param over360
   */

  Angle.toRad = function (deg, over360 = false) {
    const d = over360 ? deg : deg % 360;
    return d * Math.PI / 180;
  };
  /**
   * Returns the angle in degrees and clamps its value between `0` and `360`.
   */


  function normalize(angle) {
    return angle % 360 + (angle < 0 ? 360 : 0);
  }

  Angle.normalize = normalize;
})(Angle || (Angle = {}));

/***/ }),

/***/ 67238:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/curve.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Curve": () => (/* binding */ Curve)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ 99761);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line */ 75408);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rectangle */ 87005);
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polyline */ 52267);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometry */ 67634);





class Curve extends _geometry__WEBPACK_IMPORTED_MODULE_4__.Geometry {
  constructor(start, controlPoint1, controlPoint2, end) {
    super();
    this.PRECISION = 3;
    this.start = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(start);
    this.controlPoint1 = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(controlPoint1);
    this.controlPoint2 = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(controlPoint2);
    this.end = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(end);
  }

  get [Symbol.toStringTag]() {
    return Curve.toStringTag;
  }

  bbox() {
    const start = this.start;
    const controlPoint1 = this.controlPoint1;
    const controlPoint2 = this.controlPoint2;
    const end = this.end;
    const x0 = start.x;
    const y0 = start.y;
    const x1 = controlPoint1.x;
    const y1 = controlPoint1.y;
    const x2 = controlPoint2.x;
    const y2 = controlPoint2.y;
    const x3 = end.x;
    const y3 = end.y;
    const points = []; // local extremes

    const tvalues = []; // t values of local extremes

    const bounds = [[], []];
    let a;
    let b;
    let c;
    let t;
    let t1;
    let t2;
    let b2ac;
    let sqrtb2ac;

    for (let i = 0; i < 2; i += 1) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }

        t = -c / b;
        if (t > 0 && t < 1) tvalues.push(t);
        continue;
      }

      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);
      if (b2ac < 0) continue;
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (t1 > 0 && t1 < 1) tvalues.push(t1);
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (t2 > 0 && t2 < 1) tvalues.push(t2);
    }

    let x;
    let y;
    let mt;
    let j = tvalues.length;
    const jlen = j;

    while (j) {
      j -= 1;
      t = tvalues[j];
      mt = 1 - t;
      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[0][j] = x;
      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
      bounds[1][j] = y;
      points[j] = {
        X: x,
        Y: y
      };
    }

    tvalues[jlen] = 0;
    tvalues[jlen + 1] = 1;
    points[jlen] = {
      X: x0,
      Y: y0
    };
    points[jlen + 1] = {
      X: x3,
      Y: y3
    };
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    tvalues.length = jlen + 2;
    bounds[0].length = jlen + 2;
    bounds[1].length = jlen + 2;
    points.length = jlen + 2;
    const left = Math.min.apply(null, bounds[0]);
    const top = Math.min.apply(null, bounds[1]);
    const right = Math.max.apply(null, bounds[0]);
    const bottom = Math.max.apply(null, bounds[1]);
    return new _rectangle__WEBPACK_IMPORTED_MODULE_2__.Rectangle(left, top, right - left, bottom - top);
  }

  closestPoint(p, options = {}) {
    return this.pointAtT(this.closestPointT(p, options));
  }

  closestPointLength(p, options = {}) {
    const opts = this.getOptions(options);
    return this.lengthAtT(this.closestPointT(p, opts), opts);
  }

  closestPointNormalizedLength(p, options = {}) {
    const opts = this.getOptions(options);
    const cpLength = this.closestPointLength(p, opts);

    if (!cpLength) {
      return 0;
    }

    const length = this.length(opts);

    if (length === 0) {
      return 0;
    }

    return cpLength / length;
  }

  closestPointT(p, options = {}) {
    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line

    let investigatedSubdivision = null;
    let investigatedSubdivisionStartT = 0;
    let investigatedSubdivisionEndT = 0;
    let distFromStart = 0;
    let distFromEnd = 0;
    let chordLength = 0;
    let minSumDist = null;
    const count = subdivisions.length;
    let piece = count > 0 ? 1 / count : 0;
    subdivisions.forEach((division, i) => {
      const startDist = division.start.distance(p);
      const endDist = division.end.distance(p);
      const sumDist = startDist + endDist;

      if (minSumDist == null || sumDist < minSumDist) {
        investigatedSubdivision = division;
        investigatedSubdivisionStartT = i * piece;
        investigatedSubdivisionEndT = (i + 1) * piece;
        distFromStart = startDist;
        distFromEnd = endDist;
        minSumDist = sumDist;
        chordLength = division.endpointDistance();
      }
    }); // Recursively divide investigated subdivision, until distance between
    // baselinePoint and closest path endpoint is within `10^(-precision)`,
    // then return the closest endpoint of that final subdivision.
    // eslint-disable-next-line

    while (true) {
      // check if we have reached at least one required observed precision
      // - calculated as: the difference in distances from point to start and end divided by the distance
      // - note that this function is not monotonic = it doesn't converge stably but has "teeth"
      // - the function decreases while one of the endpoints is fixed but "jumps" whenever we switch
      // - this criterion works well for points lying far away from the curve
      const startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;
      const endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;
      const hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio; // check if we have reached at least one required minimal distance
      // - calculated as: the subdivision chord length multiplied by precisionRatio
      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions
      // - this is a backup criterion that works well for points lying "almost at" the curve

      const hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;
      const hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;
      const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;

      if (hasRequiredPrecision || hasMiniDistance) {
        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;
      } // otherwise, set up for next iteration


      const divided = investigatedSubdivision.divide(0.5);
      piece /= 2;
      const startDist1 = divided[0].start.distance(p);
      const endDist1 = divided[0].end.distance(p);
      const sumDist1 = startDist1 + endDist1;
      const startDist2 = divided[1].start.distance(p);
      const endDist2 = divided[1].end.distance(p);
      const sumDist2 = startDist2 + endDist2;

      if (sumDist1 <= sumDist2) {
        investigatedSubdivision = divided[0];
        investigatedSubdivisionEndT -= piece;
        distFromStart = startDist1;
        distFromEnd = endDist1;
      } else {
        investigatedSubdivision = divided[1];
        investigatedSubdivisionStartT += piece;
        distFromStart = startDist2;
        distFromEnd = endDist2;
      }
    }
  }

  closestPointTangent(p, options = {}) {
    return this.tangentAtT(this.closestPointT(p, options));
  }

  containsPoint(p, options = {}) {
    const polyline = this.toPolyline(options);
    return polyline.containsPoint(p);
  }

  divideAt(ratio, options = {}) {
    if (ratio <= 0) {
      return this.divideAtT(0);
    }

    if (ratio >= 1) {
      return this.divideAtT(1);
    }

    const t = this.tAt(ratio, options);
    return this.divideAtT(t);
  }

  divideAtLength(length, options = {}) {
    const t = this.tAtLength(length, options);
    return this.divideAtT(t);
  }

  divide(t) {
    return this.divideAtT(t);
  }

  divideAtT(t) {
    const start = this.start;
    const controlPoint1 = this.controlPoint1;
    const controlPoint2 = this.controlPoint2;
    const end = this.end;

    if (t <= 0) {
      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];
    }

    if (t >= 1) {
      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];
    }

    const dividerPoints = this.getSkeletonPoints(t);
    const startControl1 = dividerPoints.startControlPoint1;
    const startControl2 = dividerPoints.startControlPoint2;
    const divider = dividerPoints.divider;
    const dividerControl1 = dividerPoints.dividerControlPoint1;
    const dividerControl2 = dividerPoints.dividerControlPoint2;
    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];
  }

  endpointDistance() {
    return this.start.distance(this.end);
  }

  getSkeletonPoints(t) {
    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end; // shortcuts for `t` values that are out of range

    if (t <= 0) {
      return {
        startControlPoint1: start.clone(),
        startControlPoint2: start.clone(),
        divider: start.clone(),
        dividerControlPoint1: control1.clone(),
        dividerControlPoint2: control2.clone()
      };
    }

    if (t >= 1) {
      return {
        startControlPoint1: control1.clone(),
        startControlPoint2: control2.clone(),
        divider: end.clone(),
        dividerControlPoint1: end.clone(),
        dividerControlPoint2: end.clone()
      };
    }

    const midpoint1 = new _line__WEBPACK_IMPORTED_MODULE_1__.Line(start, control1).pointAt(t);
    const midpoint2 = new _line__WEBPACK_IMPORTED_MODULE_1__.Line(control1, control2).pointAt(t);
    const midpoint3 = new _line__WEBPACK_IMPORTED_MODULE_1__.Line(control2, end).pointAt(t);
    const subControl1 = new _line__WEBPACK_IMPORTED_MODULE_1__.Line(midpoint1, midpoint2).pointAt(t);
    const subControl2 = new _line__WEBPACK_IMPORTED_MODULE_1__.Line(midpoint2, midpoint3).pointAt(t);
    const divideLine = new _line__WEBPACK_IMPORTED_MODULE_1__.Line(subControl1, subControl2).pointAt(t);
    return {
      startControlPoint1: midpoint1,
      startControlPoint2: subControl1,
      divider: divideLine,
      dividerControlPoint1: subControl2,
      dividerControlPoint2: midpoint3
    };
  }

  getSubdivisions(options = {}) {
    const precision = this.getPrecision(options);
    let subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];

    if (precision === 0) {
      return subdivisions;
    }

    let previousLength = this.endpointDistance();
    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
    // Recursively divide curve at `t = 0.5`, until the difference between
    // observed length at subsequent iterations is lower than precision.

    let iteration = 0; // eslint-disable-next-line

    while (true) {
      iteration += 1;
      const divisions = [];
      subdivisions.forEach(c => {
        // dividing at t = 0.5 (not at middle length!)
        const divided = c.divide(0.5);
        divisions.push(divided[0], divided[1]);
      }); // measure new length

      const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0); // check if we have reached required observed precision
      // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1
      // not a problem for further iterations because cubic curves cannot have more than two local extrema
      // (i.e. cubic curves cannot intersect the baseline more than once)
      // therefore two subsequent iterations cannot produce sampling with equal length

      const ratio = length !== 0 ? (length - previousLength) / length : 0;

      if (iteration > 1 && ratio < precisionRatio) {
        return divisions;
      }

      subdivisions = divisions;
      previousLength = length;
    }
  }

  length(options = {}) {
    const divisions = this.getDivisions(options);
    return divisions.reduce((memo, c) => {
      return memo + c.endpointDistance();
    }, 0);
  }

  lengthAtT(t, options = {}) {
    if (t <= 0) {
      return 0;
    }

    const precision = options.precision === undefined ? this.PRECISION : options.precision;
    const subCurve = this.divide(t)[0];
    return subCurve.length({
      precision
    });
  }

  pointAt(ratio, options = {}) {
    if (ratio <= 0) {
      return this.start.clone();
    }

    if (ratio >= 1) {
      return this.end.clone();
    }

    const t = this.tAt(ratio, options);
    return this.pointAtT(t);
  }

  pointAtLength(length, options = {}) {
    const t = this.tAtLength(length, options);
    return this.pointAtT(t);
  }

  pointAtT(t) {
    if (t <= 0) {
      return this.start.clone();
    }

    if (t >= 1) {
      return this.end.clone();
    }

    return this.getSkeletonPoints(t).divider;
  }

  isDifferentiable() {
    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end;
    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
  }

  tangentAt(ratio, options = {}) {
    if (!this.isDifferentiable()) return null;

    if (ratio < 0) {
      ratio = 0; // eslint-disable-line
    } else if (ratio > 1) {
      ratio = 1; // eslint-disable-line
    }

    const t = this.tAt(ratio, options);
    return this.tangentAtT(t);
  }

  tangentAtLength(length, options = {}) {
    if (!this.isDifferentiable()) {
      return null;
    }

    const t = this.tAtLength(length, options);
    return this.tangentAtT(t);
  }

  tangentAtT(t) {
    if (!this.isDifferentiable()) {
      return null;
    }

    if (t < 0) {
      t = 0; // eslint-disable-line
    }

    if (t > 1) {
      t = 1; // eslint-disable-line
    }

    const skeletonPoints = this.getSkeletonPoints(t);
    const p1 = skeletonPoints.startControlPoint2;
    const p2 = skeletonPoints.dividerControlPoint1;
    const tangentStart = skeletonPoints.divider;
    const tangentLine = new _line__WEBPACK_IMPORTED_MODULE_1__.Line(p1, p2); // move so that tangent line starts at the point requested

    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
    return tangentLine;
  }

  getPrecision(options = {}) {
    return options.precision == null ? this.PRECISION : options.precision;
  }

  getDivisions(options = {}) {
    if (options.subdivisions != null) {
      return options.subdivisions;
    }

    const precision = this.getPrecision(options);
    return this.getSubdivisions({
      precision
    });
  }

  getOptions(options = {}) {
    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    return {
      precision,
      subdivisions
    };
  }

  tAt(ratio, options = {}) {
    if (ratio <= 0) {
      return 0;
    }

    if (ratio >= 1) {
      return 1;
    }

    const opts = this.getOptions(options);
    const total = this.length(opts);
    const length = total * ratio;
    return this.tAtLength(length, opts);
  }

  tAtLength(length, options = {}) {
    let fromStart = true;

    if (length < 0) {
      fromStart = false;
      length = -length; // eslint-disable-line
    }

    const precision = this.getPrecision(options);
    const subdivisions = this.getDivisions(options);
    const opts = {
      precision,
      subdivisions
    };
    let investigatedSubdivision = null;
    let investigatedSubdivisionStartT;
    let investigatedSubdivisionEndT;
    let baselinePointDistFromStart = 0;
    let baselinePointDistFromEnd = 0;
    let memo = 0;
    const count = subdivisions.length;
    let piece = count > 0 ? 1 / count : 0;

    for (let i = 0; i < count; i += 1) {
      const index = fromStart ? i : count - 1 - i;
      const division = subdivisions[i];
      const dist = division.endpointDistance();

      if (length <= memo + dist) {
        investigatedSubdivision = division;
        investigatedSubdivisionStartT = index * piece;
        investigatedSubdivisionEndT = (index + 1) * piece;
        baselinePointDistFromStart = fromStart ? length - memo : dist + memo - length;
        baselinePointDistFromEnd = fromStart ? dist + memo - length : length - memo;
        break;
      }

      memo += dist;
    }

    if (investigatedSubdivision == null) {
      return fromStart ? 1 : 0;
    } // note that precision affects what length is recorded
    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)
    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1


    const total = this.length(opts);
    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
    // recursively divide investigated subdivision:
    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
    // then return the closest endpoint of that final subdivision
    // eslint-disable-next-line

    while (true) {
      let ratio;
      ratio = total !== 0 ? baselinePointDistFromStart / total : 0;

      if (ratio < precisionRatio) {
        return investigatedSubdivisionStartT;
      }

      ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;

      if (ratio < precisionRatio) {
        return investigatedSubdivisionEndT;
      } // otherwise, set up for next iteration


      let newBaselinePointDistFromStart;
      let newBaselinePointDistFromEnd;
      const divided = investigatedSubdivision.divide(0.5);
      piece /= 2;
      const baseline1Length = divided[0].endpointDistance();
      const baseline2Length = divided[1].endpointDistance();

      if (baselinePointDistFromStart <= baseline1Length) {
        investigatedSubdivision = divided[0];
        investigatedSubdivisionEndT -= piece;
        newBaselinePointDistFromStart = baselinePointDistFromStart;
        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;
      } else {
        investigatedSubdivision = divided[1];
        investigatedSubdivisionStartT += piece;
        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;
        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;
      }

      baselinePointDistFromStart = newBaselinePointDistFromStart;
      baselinePointDistFromEnd = newBaselinePointDistFromEnd;
    }
  }

  toPoints(options = {}) {
    const subdivisions = this.getDivisions(options);
    const points = [subdivisions[0].start.clone()];
    subdivisions.forEach(c => points.push(c.end.clone()));
    return points;
  }

  toPolyline(options = {}) {
    return new _polyline__WEBPACK_IMPORTED_MODULE_3__.Polyline(this.toPoints(options));
  }

  scale(sx, sy, origin) {
    this.start.scale(sx, sy, origin);
    this.controlPoint1.scale(sx, sy, origin);
    this.controlPoint2.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }

  rotate(angle, origin) {
    this.start.rotate(angle, origin);
    this.controlPoint1.rotate(angle, origin);
    this.controlPoint2.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }

  translate(tx, ty) {
    if (typeof tx === 'number') {
      this.start.translate(tx, ty);
      this.controlPoint1.translate(tx, ty);
      this.controlPoint2.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.start.translate(tx);
      this.controlPoint1.translate(tx);
      this.controlPoint2.translate(tx);
      this.end.translate(tx);
    }

    return this;
  }

  equals(c) {
    return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);
  }

  clone() {
    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }

  toJSON() {
    return {
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }

  serialize() {
    return [this.start.serialize(), this.controlPoint1.serialize(), this.controlPoint2.serialize(), this.end.serialize()].join(' ');
  }

}

(function (Curve) {
  Curve.toStringTag = `X6.Geometry.${Curve.name}`;

  function isCurve(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Curve) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const curve = instance;

    try {
      if ((tag == null || tag === Curve.toStringTag) && _point__WEBPACK_IMPORTED_MODULE_0__.Point.isPoint(curve.start) && _point__WEBPACK_IMPORTED_MODULE_0__.Point.isPoint(curve.controlPoint1) && _point__WEBPACK_IMPORTED_MODULE_0__.Point.isPoint(curve.controlPoint2) && _point__WEBPACK_IMPORTED_MODULE_0__.Point.isPoint(curve.end) && typeof curve.toPoints === 'function' && typeof curve.toPolyline === 'function') {
        return true;
      }
    } catch (e) {
      return false;
    }

    return false;
  }

  Curve.isCurve = isCurve;
})(Curve || (Curve = {}));

(function (Curve) {
  function getFirstControlPoints(rhs) {
    const n = rhs.length;
    const x = []; // `x` is a solution vector.

    const tmp = [];
    let b = 2.0;
    x[0] = rhs[0] / b; // Decomposition and forward substitution.

    for (let i = 1; i < n; i += 1) {
      tmp[i] = 1 / b;
      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
      x[i] = (rhs[i] - x[i - 1]) / b;
    }

    for (let i = 1; i < n; i += 1) {
      // Backsubstitution.
      x[n - i - 1] -= tmp[n - i] * x[n - i];
    }

    return x;
  }

  function getCurveControlPoints(points) {
    const knots = points.map(p => _point__WEBPACK_IMPORTED_MODULE_0__.Point.clone(p));
    const firstControlPoints = [];
    const secondControlPoints = [];
    const n = knots.length - 1; // Special case: Bezier curve should be a straight line.

    if (n === 1) {
      // 3P1 = 2P0 + P3
      firstControlPoints[0] = new _point__WEBPACK_IMPORTED_MODULE_0__.Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 – P0

      secondControlPoints[0] = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
      return [firstControlPoints, secondControlPoints];
    } // Calculate first Bezier control points.
    // Right hand side vector.


    const rhs = []; // Set right hand side X values.

    for (let i = 1; i < n - 1; i += 1) {
      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
    }

    rhs[0] = knots[0].x + 2 * knots[1].x;
    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.

    const x = getFirstControlPoints(rhs); // Set right hand side Y values.

    for (let i = 1; i < n - 1; i += 1) {
      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
    }

    rhs[0] = knots[0].y + 2 * knots[1].y;
    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.

    const y = getFirstControlPoints(rhs); // Fill output arrays.

    for (let i = 0; i < n; i += 1) {
      // First control point.
      firstControlPoints.push(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x[i], y[i])); // Second control point.

      if (i < n - 1) {
        secondControlPoints.push(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
      } else {
        secondControlPoints.push(new _point__WEBPACK_IMPORTED_MODULE_0__.Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
      }
    }

    return [firstControlPoints, secondControlPoints];
  }

  function throughPoints(points) {
    if (points == null || Array.isArray(points) && points.length < 2) {
      throw new Error('At least 2 points are required');
    }

    const controlPoints = getCurveControlPoints(points);
    const curves = [];

    for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {
      const controlPoint1 = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(controlPoints[0][i].x, controlPoints[0][i].y);
      const controlPoint2 = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(controlPoints[1][i].x, controlPoints[1][i].y);
      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
    }

    return curves;
  }

  Curve.throughPoints = throughPoints;
})(Curve || (Curve = {}));

/***/ }),

/***/ 27394:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/ellipse.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ellipse": () => (/* binding */ Ellipse)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ 99761);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rectangle */ 87005);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry */ 67634);



class Ellipse extends _geometry__WEBPACK_IMPORTED_MODULE_2__.Geometry {
  constructor(x, y, a, b) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.a = a == null ? 0 : a;
    this.b = b == null ? 0 : b;
  }

  get [Symbol.toStringTag]() {
    return Ellipse.toStringTag;
  }

  get center() {
    return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y);
  }
  /**
   * Returns a rectangle that is the bounding box of the ellipse.
   */


  bbox() {
    return _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromEllipse(this);
  }
  /**
   * Returns a point that is the center of the ellipse.
   */


  getCenter() {
    return this.center;
  }

  inflate(dx, dy) {
    const w = dx;
    const h = dy != null ? dy : dx;
    this.a += 2 * w;
    this.b += 2 * h;
    return this;
  }

  normalizedDistance(x, y) {
    const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x, y);
    const dx = ref.x - this.x;
    const dy = ref.y - this.y;
    const a = this.a;
    const b = this.b;
    return dx * dx / (a * a) + dy * dy / (b * b);
  }

  containsPoint(x, y) {
    return this.normalizedDistance(x, y) <= 1;
  }
  /**
   * Returns an array of the intersection points of the ellipse and the line.
   * Returns `null` if no intersection exists.
   */


  intersectsWithLine(line) {
    const intersections = [];
    const rx = this.a;
    const ry = this.b;
    const a1 = line.start;
    const a2 = line.end;
    const dir = line.vector();
    const diff = a1.diff(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y));
    const mDir = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(dir.x / (rx * rx), dir.y / (ry * ry));
    const mDiff = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(diff.x / (rx * rx), diff.y / (ry * ry));
    const a = dir.dot(mDir);
    const b = dir.dot(mDiff);
    const c = diff.dot(mDiff) - 1.0;
    const d = b * b - a * c;

    if (d < 0) {
      return null;
    }

    if (d > 0) {
      const root = Math.sqrt(d);
      const ta = (-b - root) / a;
      const tb = (-b + root) / a;

      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {
        // outside
        return null;
      }

      if (ta >= 0 && ta <= 1) {
        intersections.push(a1.lerp(a2, ta));
      }

      if (tb >= 0 && tb <= 1) {
        intersections.push(a1.lerp(a2, tb));
      }
    } else {
      const t = -b / a;

      if (t >= 0 && t <= 1) {
        intersections.push(a1.lerp(a2, t));
      } else {
        // outside
        return null;
      }
    }

    return intersections;
  }
  /**
   * Returns the point on the boundary of the ellipse that is the
   * intersection of the ellipse with a line starting in the center
   * of the ellipse ending in the point `p`.
   *
   * If angle is specified, the intersection will take into account
   * the rotation of the ellipse by angle degrees around its center.
   */


  intersectsWithLineFromCenterToPoint(p, angle = 0) {
    const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.clone(p);

    if (angle) {
      ref.rotate(angle, this.getCenter());
    }

    const dx = ref.x - this.x;
    const dy = ref.y - this.y;
    let result;

    if (dx === 0) {
      result = this.bbox().getNearestPointToPoint(ref);

      if (angle) {
        return result.rotate(-angle, this.getCenter());
      }

      return result;
    }

    const m = dy / dx;
    const mSquared = m * m;
    const aSquared = this.a * this.a;
    const bSquared = this.b * this.b;
    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));
    x = dx < 0 ? -x : x;
    const y = m * x;
    result = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.x + x, this.y + y);

    if (angle) {
      return result.rotate(-angle, this.getCenter());
    }

    return result;
  }
  /**
   * Returns the angle between the x-axis and the tangent from a point. It is
   * valid for points lying on the ellipse boundary only.
   */


  tangentTheta(p) {
    const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.clone(p);
    const x0 = ref.x;
    const y0 = ref.y;
    const a = this.a;
    const b = this.b;
    const center = this.bbox().center;
    const cx = center.x;
    const cy = center.y;
    const refPointDelta = 30;
    const q1 = x0 > center.x + a / 2;
    const q3 = x0 < center.x - a / 2;
    let x;
    let y;

    if (q1 || q3) {
      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;
      x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;
    } else {
      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;
      y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;
    }

    return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x, y).theta(ref);
  }

  scale(sx, sy) {
    this.a *= sx;
    this.b *= sy;
    return this;
  }

  rotate(angle, origin) {
    const rect = _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromEllipse(this);
    rect.rotate(angle, origin);
    const ellipse = Ellipse.fromRect(rect);
    this.a = ellipse.a;
    this.b = ellipse.b;
    this.x = ellipse.x;
    this.y = ellipse.y;
    return this;
  }

  translate(dx, dy) {
    const p = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(dx, dy);
    this.x += p.x;
    this.y += p.y;
    return this;
  }

  equals(ellipse) {
    return ellipse != null && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;
  }

  clone() {
    return new Ellipse(this.x, this.y, this.a, this.b);
  }

  toJSON() {
    return {
      x: this.x,
      y: this.y,
      a: this.a,
      b: this.b
    };
  }

  serialize() {
    return `${this.x} ${this.y} ${this.a} ${this.b}`;
  }

}

(function (Ellipse) {
  Ellipse.toStringTag = `X6.Geometry.${Ellipse.name}`;

  function isEllipse(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Ellipse) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const ellipse = instance;

    if ((tag == null || tag === Ellipse.toStringTag) && typeof ellipse.x === 'number' && typeof ellipse.y === 'number' && typeof ellipse.a === 'number' && typeof ellipse.b === 'number' && typeof ellipse.inflate === 'function' && typeof ellipse.normalizedDistance === 'function') {
      return true;
    }

    return false;
  }

  Ellipse.isEllipse = isEllipse;
})(Ellipse || (Ellipse = {}));

(function (Ellipse) {
  function create(x, y, a, b) {
    if (x == null || typeof x === 'number') {
      return new Ellipse(x, y, a, b);
    }

    return parse(x);
  }

  Ellipse.create = create;

  function parse(e) {
    if (Ellipse.isEllipse(e)) {
      return e.clone();
    }

    if (Array.isArray(e)) {
      return new Ellipse(e[0], e[1], e[2], e[3]);
    }

    return new Ellipse(e.x, e.y, e.a, e.b);
  }

  Ellipse.parse = parse;

  function fromRect(rect) {
    const center = rect.center;
    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);
  }

  Ellipse.fromRect = fromRect;
})(Ellipse || (Ellipse = {}));

/***/ }),

/***/ 67634:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/geometry.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Geometry": () => (/* binding */ Geometry)
/* harmony export */ });
class Geometry {
  valueOf() {
    return this.toJSON();
  }

  toString() {
    return JSON.stringify(this.toJSON());
  }

}

/***/ }),

/***/ 17653:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Angle": () => (/* reexport safe */ _angle__WEBPACK_IMPORTED_MODULE_0__.Angle),
/* harmony export */   "Curve": () => (/* reexport safe */ _curve__WEBPACK_IMPORTED_MODULE_6__.Curve),
/* harmony export */   "Ellipse": () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_3__.Ellipse),
/* harmony export */   "Line": () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.Line),
/* harmony export */   "Path": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_5__.Path),
/* harmony export */   "Point": () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_1__.Point),
/* harmony export */   "Polyline": () => (/* reexport safe */ _polyline__WEBPACK_IMPORTED_MODULE_7__.Polyline),
/* harmony export */   "Rectangle": () => (/* reexport safe */ _rectangle__WEBPACK_IMPORTED_MODULE_4__.Rectangle),
/* harmony export */   "Segment": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_5__.Segment)
/* harmony export */ });
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./angle */ 39092);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ 99761);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ 75408);
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ellipse */ 27394);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rectangle */ 87005);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path */ 85085);
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./curve */ 67238);
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polyline */ 52267);









/***/ }),

/***/ 75408:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/line.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Line": () => (/* binding */ Line)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ 99761);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry */ 67634);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rectangle */ 87005);



class Line extends _geometry__WEBPACK_IMPORTED_MODULE_1__.Geometry {
  constructor(x1, y1, x2, y2) {
    super();

    if (typeof x1 === 'number' && typeof y1 === 'number') {
      this.start = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x1, y1);
      this.end = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x2, y2);
    } else {
      this.start = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x1);
      this.end = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(y1);
    }
  }

  get [Symbol.toStringTag]() {
    return Line.toStringTag;
  }

  get center() {
    return new _point__WEBPACK_IMPORTED_MODULE_0__.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }

  getCenter() {
    return this.center;
  }
  /**
   * Rounds the line to the given `precision`.
   */


  round(precision = 0) {
    this.start.round(precision);
    this.end.round(precision);
    return this;
  }

  translate(tx, ty) {
    if (typeof tx === 'number') {
      this.start.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.start.translate(tx);
      this.end.translate(tx);
    }

    return this;
  }
  /**
   * Rotate the line by `angle` around `origin`.
   */


  rotate(angle, origin) {
    this.start.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }
  /**
   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
   * specified, the line is scaled around `0,0`.
   */


  scale(sx, sy, origin) {
    this.start.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }
  /**
   * Returns the length of the line.
   */


  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Useful for distance comparisons in which real length is not necessary
   * (saves one `Math.sqrt()` operation).
   */


  squaredLength() {
    const dx = this.start.x - this.end.x;
    const dy = this.start.y - this.end.y;
    return dx * dx + dy * dy;
  }
  /**
   * Scale the line so that it has the requested length. The start point of
   * the line is preserved.
   */


  setLength(length) {
    const total = this.length();

    if (!total) {
      return this;
    }

    const scale = length / total;
    return this.scale(scale, scale, this.start);
  }

  parallel(distance) {
    const line = this.clone();

    if (!line.isDifferentiable()) {
      return line;
    }

    const {
      start,
      end
    } = line;
    const eRef = start.clone().rotate(270, end);
    const sRef = end.clone().rotate(90, start);
    start.move(sRef, distance);
    end.move(eRef, distance);
    return line;
  }
  /**
   * Returns the vector of the line with length equal to length of the line.
   */


  vector() {
    return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);
  }
  /**
   * Returns the angle of incline of the line.
   *
   * The function returns `NaN` if the start and end endpoints of the line
   * both lie at the same coordinates(it is impossible to determine the angle
   * of incline of a line that appears to be a point). The
   * `line.isDifferentiable()` function may be used in advance to determine
   * whether the angle of incline can be computed for a given line.
   */


  angle() {
    const horizontal = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.start.x + 1, this.start.y);
    return this.start.angleBetween(this.end, horizontal);
  }
  /**
   * Returns a rectangle that is the bounding box of the line.
   */


  bbox() {
    const left = Math.min(this.start.x, this.end.x);
    const top = Math.min(this.start.y, this.end.y);
    const right = Math.max(this.start.x, this.end.x);
    const bottom = Math.max(this.start.y, this.end.y);
    return new _rectangle__WEBPACK_IMPORTED_MODULE_2__.Rectangle(left, top, right - left, bottom - top);
  }
  /**
   * Returns the bearing (cardinal direction) of the line.
   *
   * The return value is one of the following strings:
   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
   *
   * The function returns 'N' if the two endpoints of the line are coincident.
   */


  bearing() {
    return this.start.bearing(this.end);
  }
  /**
   * Returns the point on the line that lies closest to point `p`.
   */


  closestPoint(p) {
    return this.pointAt(this.closestPointNormalizedLength(p));
  }
  /**
   * Returns the length of the line up to the point that lies closest to point `p`.
   */


  closestPointLength(p) {
    return this.closestPointNormalizedLength(p) * this.length();
  }
  /**
   * Returns a line that is tangent to the line at the point that lies closest
   * to point `p`.
   */


  closestPointTangent(p) {
    return this.tangentAt(this.closestPointNormalizedLength(p));
  }
  /**
   * Returns the normalized length (distance from the start of the line / total
   * line length) of the line up to the point that lies closest to point.
   */


  closestPointNormalizedLength(p) {
    const product = this.vector().dot(new Line(this.start, p).vector());
    const normalized = Math.min(1, Math.max(0, product / this.squaredLength())); // normalized returns `NaN` if this line has zero length

    if (Number.isNaN(normalized)) {
      return 0;
    }

    return normalized;
  }
  /**
   * Returns a point on the line that lies `rate` (normalized length) away from
   * the beginning of the line.
   */


  pointAt(ratio) {
    const start = this.start;
    const end = this.end;

    if (ratio <= 0) {
      return start.clone();
    }

    if (ratio >= 1) {
      return end.clone();
    }

    return start.lerp(end, ratio);
  }
  /**
   * Returns a point on the line that lies length away from the beginning of
   * the line.
   */


  pointAtLength(length) {
    const start = this.start;
    const end = this.end;
    let fromStart = true;

    if (length < 0) {
      fromStart = false; // start calculation from end point

      length = -length; // eslint-disable-line
    }

    const total = this.length();

    if (length >= total) {
      return fromStart ? end.clone() : start.clone();
    }

    const rate = (fromStart ? length : total - length) / total;
    return this.pointAt(rate);
  }
  /**
   * Divides the line into two lines at the point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */


  divideAt(ratio) {
    const dividerPoint = this.pointAt(ratio);
    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];
  }
  /**
   * Divides the line into two lines at the point that lies length away from
   * the beginning of the line.
   */


  divideAtLength(length) {
    const dividerPoint = this.pointAtLength(length);
    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];
  }
  /**
   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
   */


  containsPoint(p) {
    const start = this.start;
    const end = this.end; // cross product of 0 indicates that this line and
    // the vector to `p` are collinear.

    if (start.cross(p, end) !== 0) {
      return false;
    }

    const length = this.length();

    if (new Line(start, p).length() > length) {
      return false;
    }

    if (new Line(p, end).length() > length) {
      return false;
    }

    return true;
  }

  intersect(shape, options) {
    const ret = shape.intersectsWithLine(this, options);

    if (ret) {
      return Array.isArray(ret) ? ret : [ret];
    }

    return null;
  }
  /**
   * Returns the intersection point of the line with another line. Returns
   * `null` if no intersection exists.
   */


  intersectsWithLine(line) {
    const pt1Dir = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);
    const pt2Dir = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - line.start.x, line.end.y - line.start.y);
    const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
    const deltaPt = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x - this.start.x, line.start.y - this.start.y);
    const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
    const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;

    if (det === 0 || alpha * det < 0 || beta * det < 0) {
      return null;
    }

    if (det > 0) {
      if (alpha > det || beta > det) {
        return null;
      }
    } else if (alpha < det || beta < det) {
      return null;
    }

    return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det);
  }
  /**
   * Returns `true` if a tangent line can be found for the line.
   *
   * Tangents cannot be found if both of the line endpoints are coincident
   * (the line appears to be a point).
   */


  isDifferentiable() {
    return !this.start.equals(this.end);
  }
  /**
   * Returns the perpendicular distance between the line and point. The
   * distance is positive if the point lies to the right of the line, negative
   * if the point lies to the left of the line, and `0` if the point lies on
   * the line.
   */


  pointOffset(p) {
    const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.clone(p);
    const start = this.start;
    const end = this.end;
    const determinant = (end.x - start.x) * (ref.y - start.y) - (end.y - start.y) * (ref.x - start.x);
    return determinant / this.length();
  }

  pointSquaredDistance(x, y) {
    const p = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x, y);
    return this.closestPoint(p).squaredDistance(p);
  }

  pointDistance(x, y) {
    const p = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x, y);
    return this.closestPoint(p).distance(p);
  }
  /**
   * Returns a line tangent to the line at point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */


  tangentAt(ratio) {
    if (!this.isDifferentiable()) {
      return null;
    }

    const start = this.start;
    const end = this.end;
    const tangentStart = this.pointAt(ratio);
    const tangentLine = new Line(start, end);
    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
    return tangentLine;
  }
  /**
   * Returns a line tangent to the line at point that lies `length` away from
   * the beginning of the line.
   */


  tangentAtLength(length) {
    if (!this.isDifferentiable()) {
      return null;
    }

    const start = this.start;
    const end = this.end;
    const tangentStart = this.pointAtLength(length);
    const tangentLine = new Line(start, end);
    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
    return tangentLine;
  }

  relativeCcw(x, y) {
    const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x, y);
    let dx1 = ref.x - this.start.x;
    let dy1 = ref.y - this.start.y;
    const dx2 = this.end.x - this.start.x;
    const dy2 = this.end.y - this.start.y;
    let ccw = dx1 * dy2 - dy1 * dx2;

    if (ccw === 0) {
      ccw = dx1 * dx2 + dy1 * dy2;

      if (ccw > 0.0) {
        dx1 -= dx2;
        dy1 -= dy2;
        ccw = dx1 * dx2 + dy1 * dy2;

        if (ccw < 0.0) {
          ccw = 0.0;
        }
      }
    }

    return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;
  }
  /**
   * Return `true` if the line equals the other line.
   */


  equals(l) {
    return l != null && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;
  }
  /**
   * Returns another line which is a clone of the line.
   */


  clone() {
    return new Line(this.start, this.end);
  }

  toJSON() {
    return {
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }

  serialize() {
    return [this.start.serialize(), this.end.serialize()].join(' ');
  }

}

(function (Line) {
  Line.toStringTag = `X6.Geometry.${Line.name}`;

  function isLine(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Line) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const line = instance;

    try {
      if ((tag == null || tag === Line.toStringTag) && _point__WEBPACK_IMPORTED_MODULE_0__.Point.isPoint(line.start) && _point__WEBPACK_IMPORTED_MODULE_0__.Point.isPoint(line.end) && typeof line.vector === 'function' && typeof line.bearing === 'function' && typeof line.parallel === 'function' && typeof line.intersect === 'function') {
        return true;
      }
    } catch (e) {
      return false;
    }

    return false;
  }

  Line.isLine = isLine;
})(Line || (Line = {}));

/***/ }),

/***/ 3057:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/close.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Close": () => (/* binding */ Close)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ 75408);
/* harmony import */ var _lineto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lineto */ 96781);
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segment */ 56150);



class Close extends _segment__WEBPACK_IMPORTED_MODULE_2__.Segment {
  get end() {
    if (!this.subpathStartSegment) {
      throw new Error('Missing subpath start segment. (This segment needs a subpath ' + 'start segment (e.g. MoveTo), or segment has not yet been added' + ' to a path.)');
    }

    return this.subpathStartSegment.end;
  }

  get type() {
    return 'Z';
  }

  get line() {
    return new _line__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);
  }

  bbox() {
    return this.line.bbox();
  }

  closestPoint(p) {
    return this.line.closestPoint(p);
  }

  closestPointLength(p) {
    return this.line.closestPointLength(p);
  }

  closestPointNormalizedLength(p) {
    return this.line.closestPointNormalizedLength(p);
  }

  closestPointTangent(p) {
    return this.line.closestPointTangent(p);
  }

  length() {
    return this.line.length();
  }

  divideAt(ratio) {
    const divided = this.line.divideAt(ratio);
    return [// do not actually cut into the segment, first divided part can stay as Z
    divided[1].isDifferentiable() ? new _lineto__WEBPACK_IMPORTED_MODULE_1__.LineTo(divided[0]) : this.clone(), new _lineto__WEBPACK_IMPORTED_MODULE_1__.LineTo(divided[1])];
  }

  divideAtLength(length) {
    const divided = this.line.divideAtLength(length);
    return [divided[1].isDifferentiable() ? new _lineto__WEBPACK_IMPORTED_MODULE_1__.LineTo(divided[0]) : this.clone(), new _lineto__WEBPACK_IMPORTED_MODULE_1__.LineTo(divided[1])];
  }

  getSubdivisions() {
    return [];
  }

  pointAt(ratio) {
    return this.line.pointAt(ratio);
  }

  pointAtLength(length) {
    return this.line.pointAtLength(length);
  }

  tangentAt(ratio) {
    return this.line.tangentAt(ratio);
  }

  tangentAtLength(length) {
    return this.line.tangentAtLength(length);
  }

  isDifferentiable() {
    if (!this.previousSegment || !this.subpathStartSegment) {
      return false;
    }

    return !this.start.equals(this.end);
  }

  scale() {
    return this;
  }

  rotate() {
    return this;
  }

  translate() {
    return this;
  }

  equals(s) {
    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);
  }

  clone() {
    return new Close();
  }

  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }

  serialize() {
    return this.type;
  }

}

(function (Close) {
  function create() {
    return new Close();
  }

  Close.create = create;
})(Close || (Close = {}));

/***/ }),

/***/ 98489:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/curveto.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CurveTo": () => (/* binding */ CurveTo)
/* harmony export */ });
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curve */ 67238);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ 99761);
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segment */ 56150);



class CurveTo extends _segment__WEBPACK_IMPORTED_MODULE_2__.Segment {
  constructor(arg0, arg1, arg2, arg3, arg4, arg5) {
    super();

    if (_curve__WEBPACK_IMPORTED_MODULE_0__.Curve.isCurve(arg0)) {
      this.controlPoint1 = arg0.controlPoint1.clone().round(2);
      this.controlPoint2 = arg0.controlPoint2.clone().round(2);
      this.endPoint = arg0.end.clone().round(2);
    } else if (typeof arg0 === 'number') {
      this.controlPoint1 = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(arg0, arg1).round(2);
      this.controlPoint2 = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(arg2, arg3).round(2);
      this.endPoint = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(arg4, arg5).round(2);
    } else {
      this.controlPoint1 = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(arg0).round(2);
      this.controlPoint2 = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(arg1).round(2);
      this.endPoint = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(arg2).round(2);
    }
  }

  get type() {
    return 'C';
  }

  get curve() {
    return new _curve__WEBPACK_IMPORTED_MODULE_0__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }

  bbox() {
    return this.curve.bbox();
  }

  closestPoint(p) {
    return this.curve.closestPoint(p);
  }

  closestPointLength(p) {
    return this.curve.closestPointLength(p);
  }

  closestPointNormalizedLength(p) {
    return this.curve.closestPointNormalizedLength(p);
  }

  closestPointTangent(p) {
    return this.curve.closestPointTangent(p);
  }

  length() {
    return this.curve.length();
  }

  divideAt(ratio, options = {}) {
    // TODO: fix options
    const divided = this.curve.divideAt(ratio, options);
    return [new CurveTo(divided[0]), new CurveTo(divided[1])];
  }

  divideAtLength(length, options = {}) {
    // TODO: fix options
    const divided = this.curve.divideAtLength(length, options);
    return [new CurveTo(divided[0]), new CurveTo(divided[1])];
  }

  divideAtT(t) {
    const divided = this.curve.divideAtT(t);
    return [new CurveTo(divided[0]), new CurveTo(divided[1])];
  }

  getSubdivisions() {
    return [];
  }

  pointAt(ratio) {
    return this.curve.pointAt(ratio);
  }

  pointAtLength(length) {
    return this.curve.pointAtLength(length);
  }

  tangentAt(ratio) {
    return this.curve.tangentAt(ratio);
  }

  tangentAtLength(length) {
    return this.curve.tangentAtLength(length);
  }

  isDifferentiable() {
    if (!this.previousSegment) {
      return false;
    }

    const start = this.start;
    const control1 = this.controlPoint1;
    const control2 = this.controlPoint2;
    const end = this.end;
    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
  }

  scale(sx, sy, origin) {
    this.controlPoint1.scale(sx, sy, origin);
    this.controlPoint2.scale(sx, sy, origin);
    this.end.scale(sx, sy, origin);
    return this;
  }

  rotate(angle, origin) {
    this.controlPoint1.rotate(angle, origin);
    this.controlPoint2.rotate(angle, origin);
    this.end.rotate(angle, origin);
    return this;
  }

  translate(tx, ty) {
    if (typeof tx === 'number') {
      this.controlPoint1.translate(tx, ty);
      this.controlPoint2.translate(tx, ty);
      this.end.translate(tx, ty);
    } else {
      this.controlPoint1.translate(tx);
      this.controlPoint2.translate(tx);
      this.end.translate(tx);
    }

    return this;
  }

  equals(s) {
    return this.start.equals(s.start) && this.end.equals(s.end) && this.controlPoint1.equals(s.controlPoint1) && this.controlPoint2.equals(s.controlPoint2);
  }

  clone() {
    return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);
  }

  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }

  serialize() {
    const c1 = this.controlPoint1;
    const c2 = this.controlPoint2;
    const end = this.end;
    return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');
  }

}

(function (CurveTo) {
  function create(...args) {
    const len = args.length;
    const arg0 = args[0]; // curve provided

    if (_curve__WEBPACK_IMPORTED_MODULE_0__.Curve.isCurve(arg0)) {
      return new CurveTo(arg0);
    } // points provided


    if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(arg0)) {
      if (len === 3) {
        return new CurveTo(args[0], args[1], args[2]);
      } // this is a poly-bezier segment


      const segments = [];

      for (let i = 0; i < len; i += 3) {
        segments.push(new CurveTo(args[i], args[i + 1], args[i + 2]));
      }

      return segments;
    } // coordinates provided


    if (len === 6) {
      return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5]);
    } // this is a poly-bezier segment


    const segments = [];

    for (let i = 0; i < len; i += 6) {
      segments.push(new CurveTo(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));
    }

    return segments;
  }

  CurveTo.create = create;
})(CurveTo || (CurveTo = {}));

/***/ }),

/***/ 85085:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Path": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_0__.Path),
/* harmony export */   "Segment": () => (/* reexport safe */ _segment__WEBPACK_IMPORTED_MODULE_1__.Segment)
/* harmony export */ });
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path */ 5198);
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segment */ 56150);



/***/ }),

/***/ 96781:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/lineto.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineTo": () => (/* binding */ LineTo)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ 75408);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ 99761);
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segment */ 56150);



class LineTo extends _segment__WEBPACK_IMPORTED_MODULE_2__.Segment {
  constructor(x, y) {
    super();

    if (_line__WEBPACK_IMPORTED_MODULE_0__.Line.isLine(x)) {
      this.endPoint = x.end.clone().round(2);
    } else {
      this.endPoint = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(x, y).round(2);
    }
  }

  get type() {
    return 'L';
  }

  get line() {
    return new _line__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);
  }

  bbox() {
    return this.line.bbox();
  }

  closestPoint(p) {
    return this.line.closestPoint(p);
  }

  closestPointLength(p) {
    return this.line.closestPointLength(p);
  }

  closestPointNormalizedLength(p) {
    return this.line.closestPointNormalizedLength(p);
  }

  closestPointTangent(p) {
    return this.line.closestPointTangent(p);
  }

  length() {
    return this.line.length();
  }

  divideAt(ratio) {
    const divided = this.line.divideAt(ratio);
    return [new LineTo(divided[0]), new LineTo(divided[1])];
  }

  divideAtLength(length) {
    const divided = this.line.divideAtLength(length);
    return [new LineTo(divided[0]), new LineTo(divided[1])];
  }

  getSubdivisions() {
    return [];
  }

  pointAt(ratio) {
    return this.line.pointAt(ratio);
  }

  pointAtLength(length) {
    return this.line.pointAtLength(length);
  }

  tangentAt(ratio) {
    return this.line.tangentAt(ratio);
  }

  tangentAtLength(length) {
    return this.line.tangentAtLength(length);
  }

  isDifferentiable() {
    if (this.previousSegment == null) {
      return false;
    }

    return !this.start.equals(this.end);
  }

  clone() {
    return new LineTo(this.end);
  }

  scale(sx, sy, origin) {
    this.end.scale(sx, sy, origin);
    return this;
  }

  rotate(angle, origin) {
    this.end.rotate(angle, origin);
    return this;
  }

  translate(tx, ty) {
    if (typeof tx === 'number') {
      this.end.translate(tx, ty);
    } else {
      this.end.translate(tx);
    }

    return this;
  }

  equals(s) {
    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);
  }

  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }

  serialize() {
    const end = this.end;
    return `${this.type} ${end.x} ${end.y}`;
  }

}

(function (LineTo) {
  function create(...args) {
    const len = args.length;
    const arg0 = args[0]; // line provided

    if (_line__WEBPACK_IMPORTED_MODULE_0__.Line.isLine(arg0)) {
      return new LineTo(arg0);
    } // points provided


    if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(arg0)) {
      if (len === 1) {
        return new LineTo(arg0);
      } // poly-line segment


      return args.map(arg => new LineTo(arg));
    } // coordinates provided


    if (len === 2) {
      return new LineTo(+args[0], +args[1]);
    } // poly-line segment


    const segments = [];

    for (let i = 0; i < len; i += 2) {
      const x = +args[i];
      const y = +args[i + 1];
      segments.push(new LineTo(x, y));
    }

    return segments;
  }

  LineTo.create = create;
})(LineTo || (LineTo = {}));

/***/ }),

/***/ 5455:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/moveto.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MoveTo": () => (/* binding */ MoveTo)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ 75408);
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../curve */ 67238);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point */ 99761);
/* harmony import */ var _lineto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lineto */ 96781);
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./segment */ 56150);





class MoveTo extends _segment__WEBPACK_IMPORTED_MODULE_4__.Segment {
  constructor(x, y) {
    super();
    this.isVisible = false;
    this.isSubpathStart = true;

    if (_line__WEBPACK_IMPORTED_MODULE_0__.Line.isLine(x) || _curve__WEBPACK_IMPORTED_MODULE_1__.Curve.isCurve(x)) {
      this.endPoint = x.end.clone().round(2);
    } else {
      this.endPoint = _point__WEBPACK_IMPORTED_MODULE_2__.Point.create(x, y).round(2);
    }
  }

  get start() {
    throw new Error('Illegal access. Moveto segments should not need a start property.');
  }

  get type() {
    return 'M';
  }

  bbox() {
    return null;
  }

  closestPoint() {
    return this.end.clone();
  }

  closestPointLength() {
    return 0;
  }

  closestPointNormalizedLength() {
    return 0;
  }

  closestPointT() {
    return 1;
  }

  closestPointTangent() {
    return null;
  }

  length() {
    return 0;
  }

  lengthAtT() {
    return 0;
  }

  divideAt() {
    return [this.clone(), this.clone()];
  }

  divideAtLength() {
    return [this.clone(), this.clone()];
  }

  getSubdivisions() {
    return [];
  }

  pointAt() {
    return this.end.clone();
  }

  pointAtLength() {
    return this.end.clone();
  }

  pointAtT() {
    return this.end.clone();
  }

  tangentAt() {
    return null;
  }

  tangentAtLength() {
    return null;
  }

  tangentAtT() {
    return null;
  }

  isDifferentiable() {
    return false;
  }

  scale(sx, sy, origin) {
    this.end.scale(sx, sy, origin);
    return this;
  }

  rotate(angle, origin) {
    this.end.rotate(angle, origin);
    return this;
  }

  translate(tx, ty) {
    if (typeof tx === 'number') {
      this.end.translate(tx, ty);
    } else {
      this.end.translate(tx);
    }

    return this;
  }

  clone() {
    return new MoveTo(this.end);
  }

  equals(s) {
    return this.type === s.type && this.end.equals(s.end);
  }

  toJSON() {
    return {
      type: this.type,
      end: this.end.toJSON()
    };
  }

  serialize() {
    const end = this.end;
    return `${this.type} ${end.x} ${end.y}`;
  }

}

(function (MoveTo) {
  function create(...args) {
    const len = args.length;
    const arg0 = args[0]; // line provided

    if (_line__WEBPACK_IMPORTED_MODULE_0__.Line.isLine(arg0)) {
      return new MoveTo(arg0);
    } // curve provided


    if (_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.isCurve(arg0)) {
      return new MoveTo(arg0);
    } // points provided


    if (_point__WEBPACK_IMPORTED_MODULE_2__.Point.isPointLike(arg0)) {
      if (len === 1) {
        return new MoveTo(arg0);
      } // this is a moveto-with-subsequent-poly-line segment


      const segments = []; // points come one by one

      for (let i = 0; i < len; i += 1) {
        if (i === 0) {
          segments.push(new MoveTo(args[i]));
        } else {
          segments.push(new _lineto__WEBPACK_IMPORTED_MODULE_3__.LineTo(args[i]));
        }
      }

      return segments;
    } // coordinates provided


    if (len === 2) {
      return new MoveTo(+args[0], +args[1]);
    } // this is a moveto-with-subsequent-poly-line segment


    const segments = [];

    for (let i = 0; i < len; i += 2) {
      const x = +args[i];
      const y = +args[i + 1];

      if (i === 0) {
        segments.push(new MoveTo(x, y));
      } else {
        segments.push(new _lineto__WEBPACK_IMPORTED_MODULE_3__.LineTo(x, y));
      }
    }

    return segments;
  }

  MoveTo.create = create;
})(MoveTo || (MoveTo = {}));

/***/ }),

/***/ 8077:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/normalize.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizePathData": () => (/* binding */ normalizePathData)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 86735);


function rotate(x, y, rad) {
  return {
    x: x * Math.cos(rad) - y * Math.sin(rad),
    y: x * Math.sin(rad) + y * Math.cos(rad)
  };
}

function q2c(x1, y1, ax, ay, x2, y2) {
  const v13 = 1 / 3;
  const v23 = 2 / 3;
  return [v13 * x1 + v23 * ax, v13 * y1 + v23 * ay, v13 * x2 + v23 * ax, v13 * y2 + v23 * ay, x2, y2];
}

function a2c(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2, recursive) {
  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  const v120 = Math.PI * 120 / 180;
  const rad = Math.PI / 180 * (+angle || 0);
  let res = [];
  let xy;
  let f1;
  let f2;
  let cx;
  let cy;

  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x; // eslint-disable-line

    y1 = xy.y; // eslint-disable-line

    xy = rotate(x2, y2, -rad);
    x2 = xy.x; // eslint-disable-line

    y2 = xy.y; // eslint-disable-line

    const x = (x1 - x2) / 2;
    const y = (y1 - y2) / 2;
    let h = x * x / (rx * rx) + y * y / (ry * ry);

    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx; // eslint-disable-line

      ry = h * ry; // eslint-disable-line
    }

    const rx2 = rx * rx;
    const ry2 = ry * ry;
    const k = (largeArcFlag === sweepFlag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin((y1 - cy) / ry);
    f2 = Math.asin((y2 - cy) / ry);
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;

    if (f1 < 0) {
      f1 = Math.PI * 2 + f1;
    }

    if (f2 < 0) {
      f2 = Math.PI * 2 + f2;
    }

    if (sweepFlag && f1 > f2) {
      f1 -= Math.PI * 2;
    }

    if (!sweepFlag && f2 > f1) {
      f2 -= Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }

  let df = f2 - f1;

  if (Math.abs(df) > v120) {
    const f2old = f2;
    const x2old = x2;
    const y2old = y2;
    f2 = f1 + v120 * (sweepFlag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2); // eslint-disable-line

    y2 = cy + ry * Math.sin(f2); // eslint-disable-line

    res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [f2, f2old, cx, cy]);
  }

  df = f2 - f1;
  const c1 = Math.cos(f1);
  const s1 = Math.sin(f1);
  const c2 = Math.cos(f2);
  const s2 = Math.sin(f2);
  const t = Math.tan(df / 4);
  const hx = 4 / 3 * (rx * t);
  const hy = 4 / 3 * (ry * t);
  const m1 = [x1, y1];
  const m2 = [x1 + hx * s1, y1 - hy * c1];
  const m3 = [x2 + hx * s2, y2 - hy * c2];
  const m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];

  if (recursive) {
    return [m2, m3, m4].concat(res);
  }

  {
    res = [m2, m3, m4].concat(res).join().split(',');
    const newres = [];
    const ii = res.length;

    for (let i = 0; i < ii; i += 1) {
      newres[i] = i % 2 ? rotate(+res[i - 1], +res[i], rad).y : rotate(+res[i], +res[i + 1], rad).x;
    }

    return newres;
  }
}

function parse(pathData) {
  if (!pathData) {
    return null;
  }

  const spaces = '\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029'; // https://regexper.com/#%28%5Ba-z%5D%29%5B%5Cs%2C%5D*%28%28-%3F%5Cd*%5C.%3F%5C%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*%29%2B%29

  const segmentReg = new RegExp(`([a-z])[${spaces},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${spaces}]*,?[${spaces}]*)+)`, // eslint-disable-line
  'ig'); // https://regexper.com/#%28-%3F%5Cd*%5C.%3F%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%29%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*

  const commandParamReg = new RegExp( // eslint-disable-next-line
  `(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${spaces}]*,?[${spaces}]*`, 'ig');
  const paramsCount = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  };
  const segmetns = [];
  pathData.replace(segmentReg, (input, cmd, args) => {
    const params = [];
    let command = cmd.toLowerCase();
    args.replace(commandParamReg, (a, b) => {
      if (b) {
        params.push(+b);
      }

      return a;
    });

    if (command === 'm' && params.length > 2) {
      segmetns.push([cmd, ...params.splice(0, 2)]);
      command = 'l';
      cmd = cmd === 'm' ? 'l' : 'L'; // eslint-disable-line
    }

    const count = paramsCount[command];

    while (params.length >= count) {
      segmetns.push([cmd, ...params.splice(0, count)]);

      if (!count) {
        break;
      }
    }

    return input;
  });
  return segmetns;
}

function abs(pathString) {
  const pathArray = parse(pathString); // if invalid string, return 'M 0 0'

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }

  let x = 0;
  let y = 0;
  let mx = 0;
  let my = 0;
  const segments = [];

  for (let i = 0, ii = pathArray.length; i < ii; i += 1) {
    const r = [];
    segments.push(r);
    const segment = pathArray[i];
    const command = segment[0];

    if (command !== command.toUpperCase()) {
      r[0] = command.toUpperCase();

      switch (r[0]) {
        case 'A':
          r[1] = segment[1];
          r[2] = segment[2];
          r[3] = segment[3];
          r[4] = segment[4];
          r[5] = segment[5];
          r[6] = +segment[6] + x;
          r[7] = +segment[7] + y;
          break;

        case 'V':
          r[1] = +segment[1] + y;
          break;

        case 'H':
          r[1] = +segment[1] + x;
          break;

        case 'M':
          mx = +segment[1] + x;
          my = +segment[2] + y;

          for (let j = 1, jj = segment.length; j < jj; j += 1) {
            r[j] = +segment[j] + (j % 2 ? x : y);
          }

          break;

        default:
          for (let j = 1, jj = segment.length; j < jj; j += 1) {
            r[j] = +segment[j] + (j % 2 ? x : y);
          }

          break;
      }
    } else {
      for (let j = 0, jj = segment.length; j < jj; j += 1) {
        r[j] = segment[j];
      }
    }

    switch (r[0]) {
      case 'Z':
        x = +mx;
        y = +my;
        break;

      case 'H':
        x = r[1];
        break;

      case 'V':
        y = r[1];
        break;

      case 'M':
        mx = r[r.length - 2];
        my = r[r.length - 1];
        x = r[r.length - 2];
        y = r[r.length - 1];
        break;

      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
        break;
    }
  }

  return segments;
}

function normalize(path) {
  const pathArray = abs(path);
  const attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };

  function processPath(path, d, pcom) {
    let nx;
    let ny;

    if (!path) {
      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
    }

    if (!(path[0] in {
      T: 1,
      Q: 1
    })) {
      d.qx = null;
      d.qy = null;
    }

    switch (path[0]) {
      case 'M':
        d.X = path[1];
        d.Y = path[2];
        break;

      case 'A':
        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {
          // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
          // "If either rx or ry is 0, then this arc is treated as a
          // straight line segment (a "lineto") joining the endpoints."
          return ['L', path[6], path[7]];
        }

        return ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));

      case 'S':
        if (pcom === 'C' || pcom === 'S') {
          // In 'S' case we have to take into account, if the previous command is C/S.
          nx = d.x * 2 - d.bx; // And reflect the previous

          ny = d.y * 2 - d.by; // command's control point relative to the current point.
        } else {
          // or some else or nothing
          nx = d.x;
          ny = d.y;
        }

        return ['C', nx, ny].concat(path.slice(1));

      case 'T':
        if (pcom === 'Q' || pcom === 'T') {
          // In 'T' case we have to take into account, if the previous command is Q/T.
          d.qx = d.x * 2 - d.qx; // And make a reflection similar

          d.qy = d.y * 2 - d.qy; // to case 'S'.
        } else {
          // or something else or nothing
          d.qx = d.x;
          d.qy = d.y;
        }

        return ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));

      case 'Q':
        d.qx = path[1];
        d.qy = path[2];
        return ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));

      case 'H':
        return ['L'].concat(path[1], d.y);

      case 'V':
        return ['L'].concat(d.x, path[1]);

      case 'L':
        break;

      case 'Z':
        break;

      default:
        break;
    }

    return path;
  }

  function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      const pi = pp[i];

      while (pi.length) {
        // if created multiple 'C's, their original seg is saved
        commands[i] = 'A';
        i += 1; // eslint-disable-line

        pp.splice(i, 0, ['C'].concat(pi.splice(0, 6)));
      }

      pp.splice(i, 1);
      ii = pathArray.length;
    }
  }

  const commands = []; // path commands of original path p

  let prevCommand = ''; // holder for previous path command of original path

  let ii = pathArray.length;

  for (let i = 0; i < ii; i += 1) {
    let command = ''; // temporary holder for original path command

    if (pathArray[i]) {
      command = pathArray[i][0]; // save current path command
    }

    if (command !== 'C') {
      // C is not saved yet, because it may be result of conversion
      commands[i] = command; // Save current path command

      if (i > 0) {
        prevCommand = commands[i - 1]; // Get previous path command pcom
      }
    } // Previous path command is inputted to processPath


    pathArray[i] = processPath(pathArray[i], attrs, prevCommand);

    if (commands[i] !== 'A' && command === 'C') {
      commands[i] = 'C'; // 'A' is the only command
    } // which may produce multiple 'C's
    // so we have to make sure that 'C' is also 'C' in original path


    fixArc(pathArray, i); // fixArc adds also the right amount of 'A's to pcoms

    const seg = pathArray[i];
    const seglen = seg.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
  } // make sure normalized path data string starts with an M segment


  if (!pathArray[0][0] || pathArray[0][0] !== 'M') {
    pathArray.unshift(['M', 0, 0]);
  }

  return pathArray;
}
/**
 * Converts provided SVG path data string into a normalized path data string.
 *
 * The normalization uses a restricted subset of path commands; all segments
 * are translated into lineto, curveto, moveto, and closepath segments.
 *
 * Relative path commands are changed into their absolute counterparts,
 * and chaining of coordinates is disallowed.
 *
 * The function will always return a valid path data string; if an input
 * string cannot be normalized, 'M 0 0' is returned.
 */


function normalizePathData(pathData) {
  return normalize(pathData).map(segment => segment.map(item => typeof item === 'string' ? item : (0,_util__WEBPACK_IMPORTED_MODULE_0__.round)(item, 2))).join(',').split(',').join(' ');
}

/***/ }),

/***/ 5198:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/path.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Path": () => (/* binding */ Path)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 86735);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../line */ 75408);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point */ 99761);
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../curve */ 67238);
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../polyline */ 52267);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../rectangle */ 87005);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geometry */ 67634);
/* harmony import */ var _close__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./close */ 3057);
/* harmony import */ var _lineto__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lineto */ 96781);
/* harmony import */ var _moveto__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./moveto */ 5455);
/* harmony import */ var _curveto__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./curveto */ 98489);
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./normalize */ 8077);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./util */ 57967);













class Path extends _geometry__WEBPACK_IMPORTED_MODULE_6__.Geometry {
  constructor(args) {
    super();
    this.PRECISION = 3;
    this.segments = [];

    if (Array.isArray(args)) {
      if (_line__WEBPACK_IMPORTED_MODULE_1__.Line.isLine(args[0]) || _curve__WEBPACK_IMPORTED_MODULE_3__.Curve.isCurve(args[0])) {
        let previousObj = null;
        const arr = args;
        arr.forEach((o, i) => {
          if (i === 0) {
            this.appendSegment(Path.createSegment('M', o.start));
          }

          if (previousObj != null && !previousObj.end.equals(o.start)) {
            this.appendSegment(Path.createSegment('M', o.start));
          }

          if (_line__WEBPACK_IMPORTED_MODULE_1__.Line.isLine(o)) {
            this.appendSegment(Path.createSegment('L', o.end));
          } else if (_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.isCurve(o)) {
            this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));
          }

          previousObj = o;
        });
      } else {
        const arr = args;
        arr.forEach(s => {
          if (s.isSegment) {
            this.appendSegment(s);
          }
        });
      }
    } else if (args != null) {
      if (_line__WEBPACK_IMPORTED_MODULE_1__.Line.isLine(args)) {
        this.appendSegment(Path.createSegment('M', args.start));
        this.appendSegment(Path.createSegment('L', args.end));
      } else if (_curve__WEBPACK_IMPORTED_MODULE_3__.Curve.isCurve(args)) {
        this.appendSegment(Path.createSegment('M', args.start));
        this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));
      } else if (_polyline__WEBPACK_IMPORTED_MODULE_4__.Polyline.isPolyline(args)) {
        if (args.points && args.points.length) {
          args.points.forEach((point, index) => {
            const segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);
            this.appendSegment(segment);
          });
        }
      } else if (args.isSegment) {
        this.appendSegment(args);
      }
    }
  }

  get [Symbol.toStringTag]() {
    return Path.toStringTag;
  }

  get start() {
    const segments = this.segments;
    const count = segments.length;

    if (count === 0) {
      return null;
    }

    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];

      if (segment.isVisible) {
        return segment.start;
      }
    } // if no visible segment, return last segment end point


    return segments[count - 1].end;
  }

  get end() {
    const segments = this.segments;
    const count = segments.length;

    if (count === 0) {
      return null;
    }

    for (let i = count - 1; i >= 0; i -= 1) {
      const segment = segments[i];

      if (segment.isVisible) {
        return segment.end;
      }
    } // if no visible segment, return last segment end point


    return segments[count - 1].end;
  }

  moveTo(...args) {
    return this.appendSegment(_moveto__WEBPACK_IMPORTED_MODULE_9__.MoveTo.create.call(null, ...args));
  }

  lineTo(...args) {
    return this.appendSegment(_lineto__WEBPACK_IMPORTED_MODULE_8__.LineTo.create.call(null, ...args));
  }

  curveTo(...args) {
    return this.appendSegment(_curveto__WEBPACK_IMPORTED_MODULE_10__.CurveTo.create.call(null, ...args));
  }

  arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {
    const start = this.end || new _point__WEBPACK_IMPORTED_MODULE_2__.Point();
    const points = typeof endX === 'number' ? _util__WEBPACK_IMPORTED_MODULE_12__.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : _util__WEBPACK_IMPORTED_MODULE_12__.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);

    if (points != null) {
      for (let i = 0, ii = points.length; i < ii; i += 6) {
        this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
      }
    }

    return this;
  }

  quadTo(x1, y1, x, y) {
    const start = this.end || new _point__WEBPACK_IMPORTED_MODULE_2__.Point();
    const data = ['M', start.x, start.y];

    if (typeof x1 === 'number') {
      data.push('Q', x1, y1, x, y);
    } else {
      const p = y1;
      data.push(`Q`, x1.x, x1.y, p.x, p.y);
    }

    const path = Path.parse(data.join(' '));
    this.appendSegment(path.segments.slice(1));
    return this;
  }

  close() {
    return this.appendSegment(_close__WEBPACK_IMPORTED_MODULE_7__.Close.create());
  }

  drawPoints(points, options = {}) {
    const raw = _util__WEBPACK_IMPORTED_MODULE_12__.drawPoints(points, options);
    const sub = Path.parse(raw);

    if (sub && sub.segments) {
      this.appendSegment(sub.segments);
    }
  }

  bbox() {
    const segments = this.segments;
    const count = segments.length;

    if (count === 0) {
      return null;
    }

    let bbox;

    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];

      if (segment.isVisible) {
        const segmentBBox = segment.bbox();

        if (segmentBBox != null) {
          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;
        }
      }
    }

    if (bbox != null) {
      return bbox;
    } // if the path has only invisible elements, return end point of last segment


    const lastSegment = segments[count - 1];
    return new _rectangle__WEBPACK_IMPORTED_MODULE_5__.Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);
  }

  appendSegment(seg) {
    const count = this.segments.length;
    let previousSegment = count !== 0 ? this.segments[count - 1] : null;
    let currentSegment;
    const nextSegment = null;

    if (Array.isArray(seg)) {
      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.push(currentSegment);
        previousSegment = currentSegment;
      }
    } else if (seg != null && seg.isSegment) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.push(currentSegment);
    }

    return this;
  }

  insertSegment(index, seg) {
    const count = this.segments.length;

    if (index < 0) {
      index = count + index + 1; // eslint-disable-line
    }

    if (index > count || index < 0) {
      throw new Error('Index out of range.');
    }

    let currentSegment;
    let previousSegment = null;
    let nextSegment = null;

    if (count !== 0) {
      if (index >= 1) {
        previousSegment = this.segments[index - 1];
        nextSegment = previousSegment.nextSegment;
      } else {
        previousSegment = null;
        nextSegment = this.segments[0];
      }
    }

    if (!Array.isArray(seg)) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.splice(index, 0, currentSegment);
    } else {
      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.splice(index + i, 0, currentSegment);
        previousSegment = currentSegment;
      }
    }

    return this;
  }

  removeSegment(index) {
    const idx = this.fixIndex(index);
    const removedSegment = this.segments.splice(idx, 1)[0];
    const previousSegment = removedSegment.previousSegment;
    const nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)

    if (previousSegment) {
      previousSegment.nextSegment = nextSegment;
    }

    if (nextSegment) {
      nextSegment.previousSegment = previousSegment;
    }

    if (removedSegment.isSubpathStart && nextSegment) {
      this.updateSubpathStartSegment(nextSegment);
    }

    return removedSegment;
  }

  replaceSegment(index, seg) {
    const idx = this.fixIndex(index);
    let currentSegment;
    const replacedSegment = this.segments[idx];
    let previousSegment = replacedSegment.previousSegment;
    const nextSegment = replacedSegment.nextSegment;
    let updateSubpathStart = replacedSegment.isSubpathStart;

    if (!Array.isArray(seg)) {
      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
      this.segments.splice(idx, 1, currentSegment);

      if (updateSubpathStart && currentSegment.isSubpathStart) {
        // already updated by `prepareSegment`
        updateSubpathStart = false;
      }
    } else {
      this.segments.splice(index, 1);

      for (let i = 0, ii = seg.length; i < ii; i += 1) {
        const segment = seg[i];
        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
        this.segments.splice(index + i, 0, currentSegment);
        previousSegment = currentSegment;

        if (updateSubpathStart && currentSegment.isSubpathStart) {
          updateSubpathStart = false;
        }
      }
    }

    if (updateSubpathStart && nextSegment) {
      this.updateSubpathStartSegment(nextSegment);
    }
  }

  getSegment(index) {
    const idx = this.fixIndex(index);
    return this.segments[idx];
  }

  fixIndex(index) {
    const length = this.segments.length;

    if (length === 0) {
      throw new Error('Path has no segments.');
    }

    let i = index;

    while (i < 0) {
      i = length + i;
    }

    if (i >= length || i < 0) {
      throw new Error('Index out of range.');
    }

    return i;
  }

  segmentAt(ratio, options = {}) {
    const index = this.segmentIndexAt(ratio, options);

    if (!index) {
      return null;
    }

    return this.getSegment(index);
  }

  segmentAtLength(length, options = {}) {
    const index = this.segmentIndexAtLength(length, options);
    if (!index) return null;
    return this.getSegment(index);
  }

  segmentIndexAt(ratio, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    const rate = (0,_util__WEBPACK_IMPORTED_MODULE_0__.clamp)(ratio, 0, 1);
    const opt = this.getOptions(options);
    const len = this.length(opt);
    const length = len * rate;
    return this.segmentIndexAtLength(length, opt);
  }

  segmentIndexAtLength(length, options = {}) {
    const count = this.segments.length;

    if (count === 0) {
      return null;
    }

    let fromStart = true;

    if (length < 0) {
      fromStart = false;
      length = -length; // eslint-disable-line
    }

    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let memo = 0;
    let lastVisibleIndex = null;

    for (let i = 0; i < count; i += 1) {
      const index = fromStart ? i : count - 1 - i;
      const segment = this.segments[index];
      const subdivisions = segmentSubdivisions[index];
      const len = segment.length({
        precision,
        subdivisions
      });

      if (segment.isVisible) {
        if (length <= memo + len) {
          return index;
        }

        lastVisibleIndex = index;
      }

      memo += len;
    } // If length requested is higher than the length of the path, return
    // last visible segment index. If no visible segment, return null.


    return lastVisibleIndex;
  }

  getSegmentSubdivisions(options = {}) {
    const precision = this.getPrecision(options);
    const segmentSubdivisions = [];

    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segment.getSubdivisions({
        precision
      });
      segmentSubdivisions.push(subdivisions);
    }

    return segmentSubdivisions;
  }

  updateSubpathStartSegment(segment) {
    let previous = segment.previousSegment;
    let current = segment;

    while (current && !current.isSubpathStart) {
      // assign previous segment's subpath start segment to this segment
      if (previous != null) {
        current.subpathStartSegment = previous.subpathStartSegment;
      } else {
        current.subpathStartSegment = null;
      }

      previous = current;
      current = current.nextSegment;
    }
  }

  prepareSegment(segment, previousSegment, nextSegment) {
    segment.previousSegment = previousSegment;
    segment.nextSegment = nextSegment;

    if (previousSegment != null) {
      previousSegment.nextSegment = segment;
    }

    if (nextSegment != null) {
      nextSegment.previousSegment = segment;
    }

    let updateSubpathStart = segment;

    if (segment.isSubpathStart) {
      // move to
      segment.subpathStartSegment = segment;
      updateSubpathStart = nextSegment;
    } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments


    if (updateSubpathStart != null) {
      this.updateSubpathStartSegment(updateSubpathStart);
    }

    return segment;
  }

  closestPoint(p, options = {}) {
    const t = this.closestPointT(p, options);

    if (!t) {
      return null;
    }

    return this.pointAtT(t);
  }

  closestPointLength(p, options = {}) {
    const opts = this.getOptions(options);
    const t = this.closestPointT(p, opts);

    if (!t) {
      return 0;
    }

    return this.lengthAtT(t, opts);
  }

  closestPointNormalizedLength(p, options = {}) {
    const opts = this.getOptions(options);
    const cpLength = this.closestPointLength(p, opts);

    if (cpLength === 0) {
      return 0;
    }

    const length = this.length(opts);

    if (length === 0) {
      return 0;
    }

    return cpLength / length;
  }

  closestPointT(p, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let closestPointT;
    let minSquaredDistance = Infinity;

    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];

      if (segment.isVisible) {
        const segmentClosestPointT = segment.closestPointT(p, {
          precision,
          subdivisions
        });
        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
        const squaredDistance = (0,_util__WEBPACK_IMPORTED_MODULE_0__.squaredLength)(segmentClosestPoint, p);

        if (squaredDistance < minSquaredDistance) {
          closestPointT = {
            segmentIndex: i,
            value: segmentClosestPointT
          };
          minSquaredDistance = squaredDistance;
        }
      }
    }

    if (closestPointT) {
      return closestPointT;
    }

    return {
      segmentIndex: this.segments.length - 1,
      value: 1
    };
  }

  closestPointTangent(p, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let closestPointTangent;
    let minSquaredDistance = Infinity;

    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];

      if (segment.isDifferentiable()) {
        const segmentClosestPointT = segment.closestPointT(p, {
          precision,
          subdivisions
        });
        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
        const squaredDistance = (0,_util__WEBPACK_IMPORTED_MODULE_0__.squaredLength)(segmentClosestPoint, p);

        if (squaredDistance < minSquaredDistance) {
          closestPointTangent = segment.tangentAtT(segmentClosestPointT);
          minSquaredDistance = squaredDistance;
        }
      }
    }

    if (closestPointTangent) {
      return closestPointTangent;
    }

    return null;
  }

  containsPoint(p, options = {}) {
    const polylines = this.toPolylines(options);

    if (!polylines) {
      return false;
    }

    let numIntersections = 0;

    for (let i = 0, ii = polylines.length; i < ii; i += 1) {
      const polyline = polylines[i];

      if (polyline.containsPoint(p)) {
        numIntersections += 1;
      }
    } // returns `true` for odd numbers of intersections (even-odd algorithm)


    return numIntersections % 2 === 1;
  }

  pointAt(ratio, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    if (ratio <= 0) {
      return this.start.clone();
    }

    if (ratio >= 1) {
      return this.end.clone();
    }

    const opts = this.getOptions(options);
    const pathLength = this.length(opts);
    const length = pathLength * ratio;
    return this.pointAtLength(length, opts);
  }

  pointAtLength(length, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    if (length === 0) {
      return this.start.clone();
    }

    let fromStart = true;

    if (length < 0) {
      fromStart = false;
      length = -length; // eslint-disable-line
    }

    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let lastVisibleSegment;
    let memo = 0;

    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index = fromStart ? i : ii - 1 - i;
      const segment = this.segments[index];
      const subdivisions = segmentSubdivisions[index];
      const d = segment.length({
        precision,
        subdivisions
      });

      if (segment.isVisible) {
        if (length <= memo + d) {
          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {
            precision,
            subdivisions
          });
        }

        lastVisibleSegment = segment;
      }

      memo += d;
    } // if length requested is higher than the length of the path,
    // return last visible segment endpoint


    if (lastVisibleSegment) {
      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
    } // if no visible segment, return last segment end point


    const lastSegment = this.segments[this.segments.length - 1];
    return lastSegment.end.clone();
  }

  pointAtT(t) {
    const segments = this.segments;
    const numSegments = segments.length;
    if (numSegments === 0) return null; // if segments is an empty array

    const segmentIndex = t.segmentIndex;
    if (segmentIndex < 0) return segments[0].pointAtT(0);

    if (segmentIndex >= numSegments) {
      return segments[numSegments - 1].pointAtT(1);
    }

    const tValue = (0,_util__WEBPACK_IMPORTED_MODULE_0__.clamp)(t.value, 0, 1);
    return segments[segmentIndex].pointAtT(tValue);
  }

  divideAt(ratio, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    const rate = (0,_util__WEBPACK_IMPORTED_MODULE_0__.clamp)(ratio, 0, 1);
    const opts = this.getOptions(options);
    const len = this.length(opts);
    const length = len * rate;
    return this.divideAtLength(length, opts);
  }

  divideAtLength(length, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    let fromStart = true;

    if (length < 0) {
      fromStart = false;
      length = -length; // eslint-disable-line
    }

    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let memo = 0;
    let divided;
    let dividedSegmentIndex;
    let lastValidSegment;
    let lastValidSegmentIndex;
    let t;

    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index = fromStart ? i : ii - 1 - i;
      const segment = this.getSegment(index);
      const subdivisions = segmentSubdivisions[index];
      const opts = {
        precision,
        subdivisions
      };
      const len = segment.length(opts);

      if (segment.isDifferentiable()) {
        lastValidSegment = segment;
        lastValidSegmentIndex = index;

        if (length <= memo + len) {
          dividedSegmentIndex = index;
          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);
          break;
        }
      }

      memo += len;
    }

    if (!lastValidSegment) {
      return null;
    }

    if (!divided) {
      dividedSegmentIndex = lastValidSegmentIndex;
      t = fromStart ? 1 : 0;
      divided = lastValidSegment.divideAtT(t);
    } // create a copy of this path and replace the identified segment with its two divided parts:


    const pathCopy = this.clone();
    const index = dividedSegmentIndex;
    pathCopy.replaceSegment(index, divided);
    const divisionStartIndex = index;
    let divisionMidIndex = index + 1;
    let divisionEndIndex = index + 2; // do not insert the part if it looks like a point

    if (!divided[0].isDifferentiable()) {
      pathCopy.removeSegment(divisionStartIndex);
      divisionMidIndex -= 1;
      divisionEndIndex -= 1;
    } // insert a Moveto segment to ensure secondPath will be valid:


    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));
    divisionEndIndex += 1; // do not insert the part if it looks like a point

    if (!divided[1].isDifferentiable()) {
      pathCopy.removeSegment(divisionEndIndex - 1);
      divisionEndIndex -= 1;
    } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:


    const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;

    for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {
      const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
      const segment = pathCopy.getSegment(i);

      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
        // pathCopy segment's subpathStartSegment is different from original segment's one
        // convert this Closepath segment to a Lineto and replace it in pathCopy
        const convertedSegment = Path.createSegment('L', originalSegment.end);
        pathCopy.replaceSegment(i, convertedSegment);
      }
    } // distribute pathCopy segments into two paths and return those:


    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));
    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));
    return [firstPath, secondPath];
  }

  intersectsWithLine(line, options = {}) {
    const polylines = this.toPolylines(options);

    if (polylines == null) {
      return null;
    }

    let intersections = null;

    for (let i = 0, ii = polylines.length; i < ii; i += 1) {
      const polyline = polylines[i];
      const intersection = line.intersect(polyline);

      if (intersection) {
        if (intersections == null) {
          intersections = [];
        }

        if (Array.isArray(intersection)) {
          intersections.push(...intersection);
        } else {
          intersections.push(intersection);
        }
      }
    }

    return intersections;
  }

  isDifferentiable() {
    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];

      if (segment.isDifferentiable()) {
        return true;
      }
    }

    return false;
  }

  isValid() {
    const segments = this.segments;
    const isValid = segments.length === 0 || segments[0].type === 'M';
    return isValid;
  }

  length(options = {}) {
    if (this.segments.length === 0) {
      return 0;
    }

    const segmentSubdivisions = this.getSubdivisions(options);
    let length = 0;

    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];
      length += segment.length({
        subdivisions
      });
    }

    return length;
  }

  lengthAtT(t, options = {}) {
    const count = this.segments.length;

    if (count === 0) {
      return 0;
    }

    let segmentIndex = t.segmentIndex;

    if (segmentIndex < 0) {
      return 0;
    }

    let tValue = (0,_util__WEBPACK_IMPORTED_MODULE_0__.clamp)(t.value, 0, 1);

    if (segmentIndex >= count) {
      segmentIndex = count - 1;
      tValue = 1;
    }

    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let length = 0;

    for (let i = 0; i < segmentIndex; i += 1) {
      const segment = this.segments[i];
      const subdivisions = segmentSubdivisions[i];
      length += segment.length({
        precision,
        subdivisions
      });
    }

    const segment = this.segments[segmentIndex];
    const subdivisions = segmentSubdivisions[segmentIndex];
    length += segment.lengthAtT(tValue, {
      precision,
      subdivisions
    });
    return length;
  }

  tangentAt(ratio, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    const rate = (0,_util__WEBPACK_IMPORTED_MODULE_0__.clamp)(ratio, 0, 1);
    const opts = this.getOptions(options);
    const len = this.length(opts);
    const length = len * rate;
    return this.tangentAtLength(length, opts);
  }

  tangentAtLength(length, options = {}) {
    if (this.segments.length === 0) {
      return null;
    }

    let fromStart = true;

    if (length < 0) {
      fromStart = false;
      length = -length; // eslint-disable-line
    }

    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    let lastValidSegment;
    let memo = 0;

    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
      const index = fromStart ? i : ii - 1 - i;
      const segment = this.segments[index];
      const subdivisions = segmentSubdivisions[index];
      const len = segment.length({
        precision,
        subdivisions
      });

      if (segment.isDifferentiable()) {
        if (length <= memo + len) {
          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {
            precision,
            subdivisions
          });
        }

        lastValidSegment = segment;
      }

      memo += len;
    } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment


    if (lastValidSegment) {
      const t = fromStart ? 1 : 0;
      return lastValidSegment.tangentAtT(t);
    } // if no valid segment, return null


    return null;
  }

  tangentAtT(t) {
    const count = this.segments.length;

    if (count === 0) {
      return null;
    }

    const segmentIndex = t.segmentIndex;

    if (segmentIndex < 0) {
      return this.segments[0].tangentAtT(0);
    }

    if (segmentIndex >= count) {
      return this.segments[count - 1].tangentAtT(1);
    }

    const tValue = (0,_util__WEBPACK_IMPORTED_MODULE_0__.clamp)(t.value, 0, 1);
    return this.segments[segmentIndex].tangentAtT(tValue);
  }

  getPrecision(options = {}) {
    return options.precision == null ? this.PRECISION : options.precision;
  }

  getSubdivisions(options = {}) {
    if (options.segmentSubdivisions == null) {
      const precision = this.getPrecision(options);
      return this.getSegmentSubdivisions({
        precision
      });
    }

    return options.segmentSubdivisions;
  }

  getOptions(options = {}) {
    const precision = this.getPrecision(options);
    const segmentSubdivisions = this.getSubdivisions(options);
    return {
      precision,
      segmentSubdivisions
    };
  }

  toPoints(options = {}) {
    const segments = this.segments;
    const count = segments.length;

    if (count === 0) {
      return null;
    }

    const segmentSubdivisions = this.getSubdivisions(options);
    const points = [];
    let partialPoints = [];

    for (let i = 0; i < count; i += 1) {
      const segment = segments[i];

      if (segment.isVisible) {
        const divisions = segmentSubdivisions[i];

        if (divisions.length > 0) {
          // eslint-disable-next-line no-loop-func
          divisions.forEach(c => partialPoints.push(c.start));
        } else {
          partialPoints.push(segment.start);
        }
      } else if (partialPoints.length > 0) {
        partialPoints.push(segments[i - 1].end);
        points.push(partialPoints);
        partialPoints = [];
      }
    }

    if (partialPoints.length > 0) {
      partialPoints.push(this.end);
      points.push(partialPoints);
    }

    return points;
  }

  toPolylines(options = {}) {
    const points = this.toPoints(options);

    if (!points) {
      return null;
    }

    return points.map(arr => new _polyline__WEBPACK_IMPORTED_MODULE_4__.Polyline(arr));
  }

  scale(sx, sy, origin) {
    this.segments.forEach(s => s.scale(sx, sy, origin));
    return this;
  }

  rotate(angle, origin) {
    this.segments.forEach(segment => segment.rotate(angle, origin));
    return this;
  }

  translate(tx, ty) {
    if (typeof tx === 'number') {
      this.segments.forEach(s => s.translate(tx, ty));
    } else {
      this.segments.forEach(s => s.translate(tx));
    }

    return this;
  }

  clone() {
    const path = new Path();
    this.segments.forEach(s => path.appendSegment(s.clone()));
    return path;
  }

  equals(p) {
    if (p == null) {
      return false;
    }

    const segments = this.segments;
    const otherSegments = p.segments;
    const count = segments.length;

    if (otherSegments.length !== count) {
      return false;
    }

    for (let i = 0; i < count; i += 1) {
      const a = segments[i];
      const b = otherSegments[i];

      if (a.type !== b.type || !a.equals(b)) {
        return false;
      }
    }

    return true;
  }

  toJSON() {
    return this.segments.map(s => s.toJSON());
  }

  serialize() {
    if (!this.isValid()) {
      throw new Error('Invalid path segments.');
    }

    return this.segments.map(s => s.serialize()).join(' ');
  }

  toString() {
    return this.serialize();
  }

}

(function (Path) {
  Path.toStringTag = `X6.Geometry.${Path.name}`;

  function isPath(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Path) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const path = instance;

    if ((tag == null || tag === Path.toStringTag) && Array.isArray(path.segments) && typeof path.moveTo === 'function' && typeof path.lineTo === 'function' && typeof path.curveTo === 'function') {
      return true;
    }

    return false;
  }

  Path.isPath = isPath;
})(Path || (Path = {}));

(function (Path) {
  function parse(pathData) {
    if (!pathData) {
      return new Path();
    }

    const path = new Path();
    const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
    const commands = Path.normalize(pathData).match(commandRe);

    if (commands != null) {
      for (let i = 0, ii = commands.length; i < ii; i += 1) {
        const command = commands[i];
        const argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g; // args = [type, coordinate1, coordinate2...]

        const args = command.match(argRe);

        if (args != null) {
          const type = args[0];
          const coords = args.slice(1).map(a => +a);
          const segment = createSegment.call(null, type, ...coords);
          path.appendSegment(segment);
        }
      }
    }

    return path;
  }

  Path.parse = parse;

  function createSegment(type, ...args) {
    if (type === 'M') {
      return _moveto__WEBPACK_IMPORTED_MODULE_9__.MoveTo.create.call(null, ...args);
    }

    if (type === 'L') {
      return _lineto__WEBPACK_IMPORTED_MODULE_8__.LineTo.create.call(null, ...args);
    }

    if (type === 'C') {
      return _curveto__WEBPACK_IMPORTED_MODULE_10__.CurveTo.create.call(null, ...args);
    }

    if (type === 'z' || type === 'Z') {
      return _close__WEBPACK_IMPORTED_MODULE_7__.Close.create();
    }

    throw new Error(`Invalid path segment type "${type}"`);
  }

  Path.createSegment = createSegment;
})(Path || (Path = {}));

(function (Path) {
  Path.normalize = _normalize__WEBPACK_IMPORTED_MODULE_11__.normalizePathData;
  Path.isValid = _util__WEBPACK_IMPORTED_MODULE_12__.isValid;
  Path.drawArc = _util__WEBPACK_IMPORTED_MODULE_12__.drawArc;
  Path.drawPoints = _util__WEBPACK_IMPORTED_MODULE_12__.drawPoints;
  Path.arcToCurves = _util__WEBPACK_IMPORTED_MODULE_12__.arcToCurves;
})(Path || (Path = {}));

/***/ }),

/***/ 56150:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/segment.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Segment": () => (/* binding */ Segment)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ 67634);

class Segment extends _geometry__WEBPACK_IMPORTED_MODULE_0__.Geometry {
  constructor() {
    super(...arguments);
    this.isVisible = true;
    this.isSegment = true;
    this.isSubpathStart = false;
  }

  get end() {
    return this.endPoint;
  }

  get start() {
    if (this.previousSegment == null) {
      throw new Error('Missing previous segment. (This segment cannot be the ' + 'first segment of a path, or segment has not yet been ' + 'added to a path.)');
    }

    return this.previousSegment.end;
  }

  closestPointT(p, options) {
    if (this.closestPointNormalizedLength) {
      return this.closestPointNormalizedLength(p);
    }

    throw new Error('Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.');
  } // eslint-disable-next-line


  lengthAtT(t, options) {
    if (t <= 0) {
      return 0;
    }

    const length = this.length();

    if (t >= 1) {
      return length;
    }

    return length * t;
  }

  divideAtT(t) {
    if (this.divideAt) {
      return this.divideAt(t);
    }

    throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.');
  }

  pointAtT(t) {
    if (this.pointAt) {
      return this.pointAt(t);
    }

    throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.');
  }

  tangentAtT(t) {
    if (this.tangentAt) {
      return this.tangentAt(t);
    }

    throw new Error('Neither `tangentAtT` nor `tangentAt` method is implemented.');
  }

}

/***/ }),

/***/ 57967:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/path/util.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arcToCurves": () => (/* binding */ arcToCurves),
/* harmony export */   "drawArc": () => (/* binding */ drawArc),
/* harmony export */   "drawPoints": () => (/* binding */ drawPoints),
/* harmony export */   "isValid": () => (/* binding */ isValid)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point */ 99761);

const regexSupportedData = new RegExp(`^[\\s\\dLMCZz,.]*$`);
function isValid(data) {
  if (typeof data !== 'string') {
    return false;
  }

  return regexSupportedData.test(data);
}
/**
 * Returns the remainder of division of `n` by `m`. You should use this
 * instead of the built-in operation as the built-in operation does not
 * properly handle negative numbers.
 */

function mod(n, m) {
  return (n % m + m) % m;
}

function draw(points, round, initialMove, close, exclude) {
  const data = [];
  const end = points[points.length - 1];
  const rounded = round != null && round > 0;
  const arcSize = round || 0; // Adds virtual waypoint in the center between start and end point

  if (close && rounded) {
    points = points.slice(); // eslint-disable-line

    const p0 = points[0];
    const wp = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);
    points.splice(0, 0, wp);
  }

  let pt = points[0];
  let i = 1; // Draws the line segments

  if (initialMove) {
    data.push('M', pt.x, pt.y);
  } else {
    data.push('L', pt.x, pt.y);
  }

  while (i < (close ? points.length : points.length - 1)) {
    let tmp = points[mod(i, points.length)];
    let dx = pt.x - tmp.x;
    let dy = pt.y - tmp.y;

    if (rounded && (dx !== 0 || dy !== 0) && (exclude == null || exclude.indexOf(i - 1) < 0)) {
      // Draws a line from the last point to the current
      // point with a spacing of size off the current point
      // into direction of the last point
      let dist = Math.sqrt(dx * dx + dy * dy);
      const nx1 = dx * Math.min(arcSize, dist / 2) / dist;
      const ny1 = dy * Math.min(arcSize, dist / 2) / dist;
      const x1 = tmp.x + nx1;
      const y1 = tmp.y + ny1;
      data.push('L', x1, y1); // Draws a curve from the last point to the current
      // point with a spacing of size off the current point
      // into direction of the next point

      let next = points[mod(i + 1, points.length)]; // Uses next non-overlapping point

      while (i < points.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0) {
        next = points[mod(i + 2, points.length)];
        i += 1;
      }

      dx = next.x - tmp.x;
      dy = next.y - tmp.y;
      dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
      const nx2 = dx * Math.min(arcSize, dist / 2) / dist;
      const ny2 = dy * Math.min(arcSize, dist / 2) / dist;
      const x2 = tmp.x + nx2;
      const y2 = tmp.y + ny2;
      data.push('Q', tmp.x, tmp.y, x2, y2);
      tmp = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x2, y2);
    } else {
      data.push('L', tmp.x, tmp.y);
    }

    pt = tmp;
    i += 1;
  }

  if (close) {
    data.push('Z');
  } else {
    data.push('L', end.x, end.y);
  }

  return data.map(v => typeof v === 'string' ? v : +v.toFixed(3)).join(' ');
}

function drawPoints(points, options = {}) {
  const pts = [];

  if (points && points.length) {
    points.forEach(p => {
      if (Array.isArray(p)) {
        pts.push({
          x: p[0],
          y: p[1]
        });
      } else {
        pts.push({
          x: p.x,
          y: p.y
        });
      }
    });
  }

  return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);
}
/**
 * Converts the given arc to a series of curves.
 */

function arcToCurves(x0, y0, r1, r2, angle = 0, largeArcFlag = 0, sweepFlag = 0, x, y) {
  if (r1 === 0 || r2 === 0) {
    return [];
  }

  x -= x0; // eslint-disable-line

  y -= y0; // eslint-disable-line

  r1 = Math.abs(r1); // eslint-disable-line

  r2 = Math.abs(r2); // eslint-disable-line

  const ctx = -x / 2;
  const cty = -y / 2;
  const cpsi = Math.cos(angle * Math.PI / 180);
  const spsi = Math.sin(angle * Math.PI / 180);
  const rxd = cpsi * ctx + spsi * cty;
  const ryd = -1 * spsi * ctx + cpsi * cty;
  const rxdd = rxd * rxd;
  const rydd = ryd * ryd;
  const r1x = r1 * r1;
  const r2y = r2 * r2;
  const lamda = rxdd / r1x + rydd / r2y;
  let sds;

  if (lamda > 1) {
    r1 = Math.sqrt(lamda) * r1; // eslint-disable-line

    r2 = Math.sqrt(lamda) * r2; // eslint-disable-line

    sds = 0;
  } else {
    let seif = 1;

    if (largeArcFlag === sweepFlag) {
      seif = -1;
    }

    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
  }

  const txd = sds * r1 * ryd / r2;
  const tyd = -1 * sds * r2 * rxd / r1;
  const tx = cpsi * txd - spsi * tyd + x / 2;
  const ty = spsi * txd + cpsi * tyd + y / 2;
  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;

  if (sweepFlag === 0 && dr > 0) {
    dr -= 2 * Math.PI;
  } else if (sweepFlag !== 0 && dr < 0) {
    dr += 2 * Math.PI;
  }

  const sse = dr * 2 / Math.PI;
  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
  const segr = dr / seg;
  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);
  const cpsir1 = cpsi * r1;
  const cpsir2 = cpsi * r2;
  const spsir1 = spsi * r1;
  const spsir2 = spsi * r2;
  let mc = Math.cos(s1);
  let ms = Math.sin(s1);
  let x2 = -t * (cpsir1 * ms + spsir2 * mc);
  let y2 = -t * (spsir1 * ms - cpsir2 * mc);
  let x3 = 0;
  let y3 = 0;
  const result = [];

  for (let n = 0; n < seg; n += 1) {
    s1 += segr;
    mc = Math.cos(s1);
    ms = Math.sin(s1);
    x3 = cpsir1 * mc - spsir2 * ms + tx;
    y3 = spsir1 * mc + cpsir2 * ms + ty;
    const dx = -t * (cpsir1 * ms + spsir2 * mc);
    const dy = -t * (spsir1 * ms - cpsir2 * mc); // CurveTo updates x0, y0 so need to restore it

    const index = n * 6;
    result[index] = Number(x2 + x0);
    result[index + 1] = Number(y2 + y0);
    result[index + 2] = Number(x3 - dx + x0);
    result[index + 3] = Number(y3 - dy + y0);
    result[index + 4] = Number(x3 + x0);
    result[index + 5] = Number(y3 + y0);
    x2 = x3 + dx;
    y2 = y3 + dy;
  }

  return result.map(num => +num.toFixed(2));
}
function drawArc(startX, startY, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0, stopX, stopY) {
  const data = [];
  const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);

  if (points != null) {
    for (let i = 0, ii = points.length; i < ii; i += 6) {
      data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
    }
  }

  return data.join(' ');
}

/***/ }),

/***/ 99761:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/point.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Point": () => (/* binding */ Point)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 86735);
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./angle */ 39092);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry */ 67634);



class Point extends _geometry__WEBPACK_IMPORTED_MODULE_2__.Geometry {
  constructor(x, y) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
  }

  get [Symbol.toStringTag]() {
    return Point.toStringTag;
  }
  /**
   * Rounds the point to the given precision.
   */


  round(precision = 0) {
    this.x = _util__WEBPACK_IMPORTED_MODULE_0__.round(this.x, precision);
    this.y = _util__WEBPACK_IMPORTED_MODULE_0__.round(this.y, precision);
    return this;
  }

  add(x, y) {
    const p = Point.create(x, y);
    this.x += p.x;
    this.y += p.y;
    return this;
  }

  update(x, y) {
    const p = Point.create(x, y);
    this.x = p.x;
    this.y = p.y;
    return this;
  }

  translate(dx, dy) {
    const t = Point.create(dx, dy);
    this.x += t.x;
    this.y += t.y;
    return this;
  }
  /**
   * Rotate the point by `degree` around `center`.
   */


  rotate(degree, center) {
    const p = Point.rotate(this, degree, center);
    this.x = p.x;
    this.y = p.y;
    return this;
  }
  /**
   * Scale point by `sx` and `sy` around the given `origin`. If origin is not
   * specified, the point is scaled around `0,0`.
   */


  scale(sx, sy, origin = new Point()) {
    const ref = Point.create(origin);
    this.x = ref.x + sx * (this.x - ref.x);
    this.y = ref.y + sy * (this.y - ref.y);
    return this;
  }
  /**
   * Chooses the point closest to this point from among `points`. If `points`
   * is an empty array, `null` is returned.
   */


  closest(points) {
    if (points.length === 1) {
      return Point.create(points[0]);
    }

    let ret = null;
    let min = Infinity;
    points.forEach(p => {
      const dist = this.squaredDistance(p);

      if (dist < min) {
        ret = p;
        min = dist;
      }
    });
    return ret ? Point.create(ret) : null;
  }
  /**
   * Returns the distance between the point and another point `p`.
   */


  distance(p) {
    return Math.sqrt(this.squaredDistance(p));
  }
  /**
   * Returns the squared distance between the point and another point `p`.
   *
   * Useful for distance comparisons in which real distance is not necessary
   * (saves one `Math.sqrt()` operation).
   */


  squaredDistance(p) {
    const ref = Point.create(p);
    const dx = this.x - ref.x;
    const dy = this.y - ref.y;
    return dx * dx + dy * dy;
  }

  manhattanDistance(p) {
    const ref = Point.create(p);
    return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);
  }
  /**
   * Returns the magnitude of the point vector.
   *
   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
   */


  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p` and
   * the x-axis.
   */


  theta(p = new Point()) {
    const ref = Point.create(p);
    const y = -(ref.y - this.y); // invert the y-axis.

    const x = ref.x - this.x;
    let rad = Math.atan2(y, x); // Correction for III. and IV. quadrant.

    if (rad < 0) {
      rad = 2 * Math.PI + rad;
    }

    return 180 * rad / Math.PI;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p1` and
   * the vector from this point to `p2`.
   *
   * The ordering of points `p1` and `p2` is important.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from `p1` to `p2`) is clockwise, and a value between `180` and
   * `360` when the angle is counterclockwise.
   *
   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
   */


  angleBetween(p1, p2) {
    if (this.equals(p1) || this.equals(p2)) {
      return NaN;
    }

    let angle = this.theta(p2) - this.theta(p1);

    if (angle < 0) {
      angle += 360;
    }

    return angle;
  }
  /**
   * Returns the angle(in degrees) between the line from `(0,0)` and this point
   * and the line from `(0,0)` to `p`.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from this point to `p`) is clockwise, and a value between `180`
   * and `360` when the angle is counterclockwise. Returns `NaN` if called from
   * point `(0,0)` or if `p` is `(0,0)`.
   */


  vectorAngle(p) {
    const zero = new Point(0, 0);
    return zero.angleBetween(this, p);
  }
  /**
   * Converts rectangular to polar coordinates.
   */


  toPolar(origin) {
    this.update(Point.toPolar(this, origin));
    return this;
  }
  /**
   * Returns the change in angle(in degrees) that is the result of moving the
   * point from its previous position to its current position.
   *
   * More specifically, this function computes the angle between the line from
   * the ref point to the previous position of this point(i.e. current position
   * `-dx`, `-dy`) and the line from the `ref` point to the current position of
   * this point.
   *
   * The function returns a positive value between `0` and `180` when the angle
   * (in the direction from previous position of this point to its current
   * position) is clockwise, and a negative value between `0` and `-180` when
   * the angle is counterclockwise.
   *
   * The function returns `0` if the previous and current positions of this
   * point are the same (i.e. both `dx` and `dy` are `0`).
   */


  changeInAngle(dx, dy, ref = new Point()) {
    // Revert the translation and measure the change in angle around x-axis.
    return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);
  }
  /**
   * If the point lies outside the rectangle `rect`, adjust the point so that
   * it becomes the nearest point on the boundary of `rect`.
   */


  adhereToRect(rect) {
    if (!_util__WEBPACK_IMPORTED_MODULE_0__.containsPoint(rect, this)) {
      this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);
      this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);
    }

    return this;
  }
  /**
   * Returns the bearing(cardinal direction) between me and the given point.
   *
   * @see https://en.wikipedia.org/wiki/Cardinal_direction
   */


  bearing(p) {
    const ref = Point.create(p);
    const lat1 = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(this.y);
    const lat2 = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(ref.y);
    const lon1 = this.x;
    const lon2 = ref.x;
    const dLon = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(lon2 - lon1);
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    const brng = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toDeg(Math.atan2(y, x));
    const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
    let index = brng - 22.5;

    if (index < 0) {
      index += 360;
    }

    index = parseInt(index / 45, 10);
    return bearings[index];
  }
  /**
   * Returns the cross product of the vector from me to `p1` and the vector
   * from me to `p2`.
   *
   * The left-hand rule is used because the coordinate system is left-handed.
   */


  cross(p1, p2) {
    if (p1 != null && p2 != null) {
      const a = Point.create(p1);
      const b = Point.create(p2);
      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);
    }

    return NaN;
  }
  /**
   * Returns the dot product of this point with given other point.
   */


  dot(p) {
    const ref = Point.create(p);
    return this.x * ref.x + this.y * ref.y;
  }

  diff(dx, dy) {
    if (typeof dx === 'number') {
      return new Point(this.x - dx, this.y - dy);
    }

    const p = Point.create(dx);
    return new Point(this.x - p.x, this.y - p.y);
  }
  /**
   * Returns an interpolation between me and point `p` for a parametert in
   * the closed interval `[0, 1]`.
   */


  lerp(p, t) {
    const ref = Point.create(p);
    return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);
  }
  /**
   * Normalize the point vector, scale the line segment between `(0, 0)`
   * and the point in order for it to have the given length. If length is
   * not specified, it is considered to be `1`; in that case, a unit vector
   * is computed.
   */


  normalize(length = 1) {
    const scale = length / this.magnitude();
    return this.scale(scale, scale);
  }
  /**
   * Moves this point along the line starting from `ref` to this point by a
   * certain `distance`.
   */


  move(ref, distance) {
    const p = Point.create(ref);
    const rad = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(p.theta(this));
    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);
  }
  /**
   * Returns a point that is the reflection of me with the center of inversion
   * in `ref` point.
   */


  reflection(ref) {
    return Point.create(ref).move(this, this.distance(ref));
  }

  snapToGrid(gx, gy) {
    this.x = _util__WEBPACK_IMPORTED_MODULE_0__.snapToGrid(this.x, gx);
    this.y = _util__WEBPACK_IMPORTED_MODULE_0__.snapToGrid(this.y, gy == null ? gx : gy);
    return this;
  }

  equals(p) {
    const ref = Point.create(p);
    return ref != null && ref.x === this.x && ref.y === this.y;
  }

  clone() {
    return Point.clone(this);
  }
  /**
   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
   */


  toJSON() {
    return Point.toJSON(this);
  }

  serialize() {
    return `${this.x} ${this.y}`;
  }

}

(function (Point) {
  Point.toStringTag = `X6.Geometry.${Point.name}`;

  function isPoint(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Point) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const point = instance;

    if ((tag == null || tag === Point.toStringTag) && typeof point.x === 'number' && typeof point.y === 'number' && typeof point.toPolar === 'function') {
      return true;
    }

    return false;
  }

  Point.isPoint = isPoint;
})(Point || (Point = {}));

(function (Point) {
  function isPointLike(p) {
    return p != null && typeof p === 'object' && typeof p.x === 'number' && typeof p.y === 'number';
  }

  Point.isPointLike = isPointLike;

  function isPointData(p) {
    return p != null && Array.isArray(p) && p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number';
  }

  Point.isPointData = isPointData;
})(Point || (Point = {}));

(function (Point) {
  function create(x, y) {
    if (x == null || typeof x === 'number') {
      return new Point(x, y);
    }

    return clone(x);
  }

  Point.create = create;

  function clone(p) {
    if (Point.isPoint(p)) {
      return new Point(p.x, p.y);
    }

    if (Array.isArray(p)) {
      return new Point(p[0], p[1]);
    }

    return new Point(p.x, p.y);
  }

  Point.clone = clone;

  function toJSON(p) {
    if (Point.isPoint(p)) {
      return {
        x: p.x,
        y: p.y
      };
    }

    if (Array.isArray(p)) {
      return {
        x: p[0],
        y: p[1]
      };
    }

    return {
      x: p.x,
      y: p.y
    };
  }

  Point.toJSON = toJSON;
  /**
   * Returns a new Point object from the given polar coordinates.
   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system
   */

  function fromPolar(r, rad, origin = new Point()) {
    let x = Math.abs(r * Math.cos(rad));
    let y = Math.abs(r * Math.sin(rad));
    const org = clone(origin);
    const deg = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(_angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toDeg(rad));

    if (deg < 90) {
      y = -y;
    } else if (deg < 180) {
      x = -x;
      y = -y;
    } else if (deg < 270) {
      x = -x;
    }

    return new Point(org.x + x, org.y + y);
  }

  Point.fromPolar = fromPolar;
  /**
   * Converts rectangular to polar coordinates.
   */

  function toPolar(point, origin = new Point()) {
    const p = clone(point);
    const o = clone(origin);
    const dx = p.x - o.x;
    const dy = p.y - o.y;
    return new Point(Math.sqrt(dx * dx + dy * dy), // r
    _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(o.theta(p)));
  }

  Point.toPolar = toPolar;

  function equals(p1, p2) {
    if (p1 === p2) {
      return true;
    }

    if (p1 != null && p2 != null) {
      return p1.x === p2.x && p1.y === p2.y;
    }

    return false;
  }

  Point.equals = equals;

  function equalPoints(p1, p2) {
    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {
      return false;
    }

    if (p1 != null && p2 != null) {
      for (let i = 0, ii = p1.length; i < ii; i += 1) {
        if (!equals(p1[i], p2[i])) {
          return false;
        }
      }
    }

    return true;
  }

  Point.equalPoints = equalPoints;
  /**
   * Returns a point with random coordinates that fall within the range
   * `[x1, x2]` and `[y1, y2]`.
   */

  function random(x1, x2, y1, y2) {
    return new Point(_util__WEBPACK_IMPORTED_MODULE_0__.random(x1, x2), _util__WEBPACK_IMPORTED_MODULE_0__.random(y1, y2));
  }

  Point.random = random;

  function rotate(point, angle, center) {
    const rad = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(_angle__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(-angle));
    const sin = Math.sin(rad);
    const cos = Math.cos(rad);
    return rotateEx(point, cos, sin, center);
  }

  Point.rotate = rotate;

  function rotateEx(point, cos, sin, center = new Point()) {
    const source = clone(point);
    const origin = clone(center);
    const dx = source.x - origin.x;
    const dy = source.y - origin.y;
    const x1 = dx * cos - dy * sin;
    const y1 = dy * cos + dx * sin;
    return new Point(x1 + origin.x, y1 + origin.y);
  }

  Point.rotateEx = rotateEx;
})(Point || (Point = {}));

/***/ }),

/***/ 52267:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/polyline.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Polyline": () => (/* binding */ Polyline)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ 99761);
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rectangle */ 87005);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ 75408);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry */ 67634);




class Polyline extends _geometry__WEBPACK_IMPORTED_MODULE_3__.Geometry {
  constructor(points) {
    super();

    if (points != null) {
      if (typeof points === 'string') {
        return Polyline.parse(points);
      }

      this.points = points.map(p => _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(p));
    } else {
      this.points = [];
    }
  }

  get [Symbol.toStringTag]() {
    return Polyline.toStringTag;
  }

  get start() {
    if (this.points.length === 0) {
      return null;
    }

    return this.points[0];
  }

  get end() {
    if (this.points.length === 0) {
      return null;
    }

    return this.points[this.points.length - 1];
  }

  scale(sx, sy, origin = new _point__WEBPACK_IMPORTED_MODULE_0__.Point()) {
    this.points.forEach(p => p.scale(sx, sy, origin));
    return this;
  }

  rotate(angle, origin) {
    this.points.forEach(p => p.rotate(angle, origin));
    return this;
  }

  translate(dx, dy) {
    const t = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(dx, dy);
    this.points.forEach(p => p.translate(t.x, t.y));
    return this;
  }

  bbox() {
    if (this.points.length === 0) {
      return new _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
    }

    let x1 = Infinity;
    let x2 = -Infinity;
    let y1 = Infinity;
    let y2 = -Infinity;
    const points = this.points;

    for (let i = 0, ii = points.length; i < ii; i += 1) {
      const point = points[i];
      const x = point.x;
      const y = point.y;
      if (x < x1) x1 = x;
      if (x > x2) x2 = x;
      if (y < y1) y1 = y;
      if (y > y2) y2 = y;
    }

    return new _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle(x1, y1, x2 - x1, y2 - y1);
  }

  closestPoint(p) {
    const cpLength = this.closestPointLength(p);
    return this.pointAtLength(cpLength);
  }

  closestPointLength(p) {
    const points = this.points;
    const count = points.length;

    if (count === 0 || count === 1) {
      return 0;
    }

    let length = 0;
    let cpLength = 0;
    let minSqrDistance = Infinity;

    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const line = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(points[i], points[i + 1]);
      const lineLength = line.length();
      const cpNormalizedLength = line.closestPointNormalizedLength(p);
      const cp = line.pointAt(cpNormalizedLength);
      const sqrDistance = cp.squaredDistance(p);

      if (sqrDistance < minSqrDistance) {
        minSqrDistance = sqrDistance;
        cpLength = length + cpNormalizedLength * lineLength;
      }

      length += lineLength;
    }

    return cpLength;
  }

  closestPointNormalizedLength(p) {
    const cpLength = this.closestPointLength(p);

    if (cpLength === 0) {
      return 0;
    }

    const length = this.length();

    if (length === 0) {
      return 0;
    }

    return cpLength / length;
  }

  closestPointTangent(p) {
    const cpLength = this.closestPointLength(p);
    return this.tangentAtLength(cpLength);
  }

  containsPoint(p) {
    if (this.points.length === 0) {
      return false;
    }

    const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.clone(p);
    const x = ref.x;
    const y = ref.y;
    const points = this.points;
    const count = points.length;
    let startIndex = count - 1;
    let intersectionCount = 0;

    for (let endIndex = 0; endIndex < count; endIndex += 1) {
      const start = points[startIndex];
      const end = points[endIndex];

      if (ref.equals(start)) {
        return true;
      }

      const segment = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(start, end);

      if (segment.containsPoint(p)) {
        return true;
      } // do we have an intersection?


      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {
        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`
        // (when `y === start.y === end.y`)
        // this conditional branch IS entered when `segment` touches `ray` at only one point
        // (e.g. when `y === start.y !== end.y`)
        // since this branch is entered again for the following segment, the two touches cancel out
        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;

        if (xDifference >= 0) {
          // segment lies at least partially to the right of `p`
          const rayEnd = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x + xDifference, y); // right

          const ray = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(p, rayEnd);

          if (segment.intersectsWithLine(ray)) {
            // an intersection was detected to the right of `p`
            intersectionCount += 1;
          }
        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)

      } // move to check the next polyline segment


      startIndex = endIndex;
    } // returns `true` for odd numbers of intersections (even-odd algorithm)


    return intersectionCount % 2 === 1;
  }

  intersectsWithLine(line) {
    const intersections = [];

    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      const int = line.intersectsWithLine(new _line__WEBPACK_IMPORTED_MODULE_2__.Line(a, b));

      if (int) {
        intersections.push(int);
      }
    }

    return intersections.length > 0 ? intersections : null;
  }

  isDifferentiable() {
    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      const line = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(a, b);

      if (line.isDifferentiable()) {
        return true;
      }
    }

    return false;
  }

  length() {
    let len = 0;

    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
      const a = this.points[i];
      const b = this.points[i + 1];
      len += a.distance(b);
    }

    return len;
  }

  pointAt(ratio) {
    const points = this.points;
    const count = points.length;

    if (count === 0) {
      return null;
    }

    if (count === 1) {
      return points[0].clone();
    }

    if (ratio <= 0) {
      return points[0].clone();
    }

    if (ratio >= 1) {
      return points[count - 1].clone();
    }

    const total = this.length();
    const length = total * ratio;
    return this.pointAtLength(length);
  }

  pointAtLength(length) {
    const points = this.points;
    const count = points.length;

    if (count === 0) {
      return null;
    }

    if (count === 1) {
      return points[0].clone();
    }

    let fromStart = true;

    if (length < 0) {
      fromStart = false;
      length = -length; // eslint-disable-line
    }

    let tmp = 0;

    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const index = fromStart ? i : ii - 1 - i;
      const a = points[index];
      const b = points[index + 1];
      const l = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(a, b);
      const d = a.distance(b);

      if (length <= tmp + d) {
        return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));
      }

      tmp += d;
    }

    const lastPoint = fromStart ? points[count - 1] : points[0];
    return lastPoint.clone();
  }

  tangentAt(ratio) {
    const points = this.points;
    const count = points.length;

    if (count === 0 || count === 1) {
      return null;
    }

    if (ratio < 0) {
      ratio = 0; // eslint-disable-line
    }

    if (ratio > 1) {
      ratio = 1; // eslint-disable-line
    }

    const total = this.length();
    const length = total * ratio;
    return this.tangentAtLength(length);
  }

  tangentAtLength(length) {
    const points = this.points;
    const count = points.length;

    if (count === 0 || count === 1) {
      return null;
    }

    let fromStart = true;

    if (length < 0) {
      fromStart = false;
      length = -length; // eslint-disable-line
    }

    let lastValidLine;
    let tmp = 0;

    for (let i = 0, ii = count - 1; i < ii; i += 1) {
      const index = fromStart ? i : ii - 1 - i;
      const a = points[index];
      const b = points[index + 1];
      const l = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(a, b);
      const d = a.distance(b);

      if (l.isDifferentiable()) {
        // has a tangent line (line length is not 0)
        if (length <= tmp + d) {
          return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));
        }

        lastValidLine = l;
      }

      tmp += d;
    }

    if (lastValidLine) {
      const ratio = fromStart ? 1 : 0;
      return lastValidLine.tangentAt(ratio);
    }

    return null;
  }

  simplify( // TODO: Accept startIndex and endIndex to specify where to start and end simplification
  options = {}) {
    const points = this.points; // we need at least 3 points

    if (points.length < 3) {
      return this;
    }

    const threshold = options.threshold || 0; // start at the beginning of the polyline and go forward

    let currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration
    // as soon as that stops being true, we know we reached the end of the polyline

    while (points[currentIndex + 2]) {
      const firstIndex = currentIndex;
      const middleIndex = currentIndex + 1;
      const lastIndex = currentIndex + 2;
      const firstPoint = points[firstIndex];
      const middlePoint = points[middleIndex];
      const lastPoint = points[lastIndex];
      const chord = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(firstPoint, lastPoint); // = connection between first and last point

      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point

      const closestPointDistance = closestPoint.distance(middlePoint);

      if (closestPointDistance <= threshold) {
        // middle point is close enough to the chord = simplify
        // 1) remove middle point:
        points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points
        //    - do not change `currentIndex`
        //    = (first point stays, point after removed point becomes middle point)
      } else {
        // middle point is far from the chord
        // 1) preserve middle point
        // 2) in next iteration, move `currentIndex` by one step:
        currentIndex += 1; //    = (point after first point becomes first point)
      }
    } // `points` array was modified in-place


    return this;
  }

  toHull() {
    const points = this.points;
    const count = points.length;

    if (count === 0) {
      return new Polyline();
    } // Step 1: find the starting point -- point with
    // the lowest y (if equality, highest x).


    let startPoint = points[0];

    for (let i = 1; i < count; i += 1) {
      if (points[i].y < startPoint.y) {
        startPoint = points[i];
      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
        startPoint = points[i];
      }
    } // Step 2: sort the list of points by angle between line
    // from start point to current point and the x-axis (theta).
    // Step 2a: create the point records = [point, originalIndex, angle]


    const sortedRecords = [];

    for (let i = 0; i < count; i += 1) {
      let angle = startPoint.theta(points[i]);

      if (angle === 0) {
        // Give highest angle to start point.
        // The start point will end up at end of sorted list.
        // The start point will end up at beginning of hull points list.
        angle = 360;
      }

      sortedRecords.push([points[i], i, angle]);
    } // Step 2b: sort the list in place


    sortedRecords.sort((record1, record2) => {
      let ret = record1[2] - record2[2];

      if (ret === 0) {
        ret = record2[1] - record1[1];
      }

      return ret;
    }); // Step 2c: duplicate start record from the top of
    // the stack to the bottom of the stack.

    if (sortedRecords.length > 2) {
      const startPoint = sortedRecords[sortedRecords.length - 1];
      sortedRecords.unshift(startPoint);
    } // Step 3
    // ------
    // Step 3a: go through sorted points in order and find those with
    // right turns, and we want to get our results in clockwise order.
    // Dictionary of points with left turns - cannot be on the hull.


    const insidePoints = {}; // Stack of records with right turns - hull point candidates.

    const hullRecords = [];

    const getKey = record => `${record[0].toString()}@${record[1]}`;

    while (sortedRecords.length !== 0) {
      const currentRecord = sortedRecords.pop();
      const currentPoint = currentRecord[0]; // Check if point has already been discarded.

      if (insidePoints[getKey(currentRecord)]) {
        continue;
      }

      let correctTurnFound = false;

      while (!correctTurnFound) {
        if (hullRecords.length < 2) {
          // Not enough points for comparison, just add current point.
          hullRecords.push(currentRecord);
          correctTurnFound = true;
        } else {
          const lastHullRecord = hullRecords.pop();
          const lastHullPoint = lastHullRecord[0];
          const secondLastHullRecord = hullRecords.pop();
          const secondLastHullPoint = secondLastHullRecord[0];
          const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);

          if (crossProduct < 0) {
            // Found a right turn.
            hullRecords.push(secondLastHullRecord);
            hullRecords.push(lastHullRecord);
            hullRecords.push(currentRecord);
            correctTurnFound = true;
          } else if (crossProduct === 0) {
            // the three points are collinear
            // three options:
            // there may be a 180 or 0 degree angle at lastHullPoint
            // or two of the three points are coincident
            // we have to take rounding errors into account
            const THRESHOLD = 1e-10;
            const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);

            if (Math.abs(angleBetween - 180) < THRESHOLD) {
              // rouding around 180 to 180
              // if the cross product is 0 because the angle is 180 degrees
              // discard last hull point (add to insidePoints)
              // insidePoints.unshift(lastHullPoint);
              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)

              hullRecords.push(secondLastHullRecord); // do not do anything with current point
              // correct turn not found
            } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {
              // if the cross product is 0 because two points are the same
              // discard last hull point (add to insidePoints)
              // insidePoints.unshift(lastHullPoint);
              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)

              hullRecords.push(secondLastHullRecord); // do not do anything with current point
              // correct turn not found
            } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {
              // rounding around 0 and 360 to 0
              // if the cross product is 0 because the angle is 0 degrees
              // remove last hull point from hull BUT do not discard it
              // reenter second-to-last hull point (will be last at next iter)
              hullRecords.push(secondLastHullRecord); // put last hull point back into the sorted point records list

              sortedRecords.push(lastHullRecord); // we are switching the order of the 0deg and 180deg points
              // correct turn not found
            }
          } else {
            // found a left turn
            // discard last hull point (add to insidePoints)
            // insidePoints.unshift(lastHullPoint);
            insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)

            hullRecords.push(secondLastHullRecord); // do not do anything with current point
            // correct turn not found
          }
        }
      }
    } // At this point, hullPointRecords contains the output points in clockwise order
    // the points start with lowest-y,highest-x startPoint, and end at the same point
    // Step 3b: remove duplicated startPointRecord from the end of the array


    if (hullRecords.length > 2) {
      hullRecords.pop();
    } // Step 4: find the lowest originalIndex record and put it at the beginning of hull


    let lowestHullIndex; // the lowest originalIndex on the hull

    let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex

    for (let i = 0, n = hullRecords.length; i < n; i += 1) {
      const currentHullIndex = hullRecords[i][1];

      if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {
        lowestHullIndex = currentHullIndex;
        indexOfLowestHullIndexRecord = i;
      }
    }

    let hullPointRecordsReordered = [];

    if (indexOfLowestHullIndexRecord > 0) {
      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);
      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);
      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
    } else {
      hullPointRecordsReordered = hullRecords;
    }

    const hullPoints = [];

    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {
      hullPoints.push(hullPointRecordsReordered[i][0]);
    }

    return new Polyline(hullPoints);
  }

  equals(p) {
    if (p == null) {
      return false;
    }

    if (p.points.length !== this.points.length) {
      return false;
    }

    return p.points.every((a, i) => a.equals(this.points[i]));
  }

  clone() {
    return new Polyline(this.points.map(p => p.clone()));
  }

  toJSON() {
    return this.points.map(p => p.toJSON());
  }

  serialize() {
    return this.points.map(p => `${p.x}, ${p.y}`).join(' ');
  }

}

(function (Polyline) {
  Polyline.toStringTag = `X6.Geometry.${Polyline.name}`;

  function isPolyline(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Polyline) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const polyline = instance;

    if ((tag == null || tag === Polyline.toStringTag) && typeof polyline.toHull === 'function' && typeof polyline.simplify === 'function') {
      return true;
    }

    return false;
  }

  Polyline.isPolyline = isPolyline;
})(Polyline || (Polyline = {}));

(function (Polyline) {
  function parse(svgString) {
    const str = svgString.trim();

    if (str === '') {
      return new Polyline();
    }

    const points = [];
    const coords = str.split(/\s*,\s*|\s+/);

    for (let i = 0, ii = coords.length; i < ii; i += 2) {
      points.push({
        x: +coords[i],
        y: +coords[i + 1]
      });
    }

    return new Polyline(points);
  }

  Polyline.parse = parse;
})(Polyline || (Polyline = {}));

/***/ }),

/***/ 87005:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/rectangle.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rectangle": () => (/* binding */ Rectangle)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 86735);
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./angle */ 39092);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ 75408);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ 99761);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometry */ 67634);





class Rectangle extends _geometry__WEBPACK_IMPORTED_MODULE_4__.Geometry {
  constructor(x, y, width, height) {
    super();
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.width = width == null ? 0 : width;
    this.height = height == null ? 0 : height;
  }

  get [Symbol.toStringTag]() {
    return Rectangle.toStringTag;
  }

  get left() {
    return this.x;
  }

  get top() {
    return this.y;
  }

  get right() {
    return this.x + this.width;
  }

  get bottom() {
    return this.y + this.height;
  }

  get origin() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, this.y);
  }

  get topLeft() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, this.y);
  }

  get topCenter() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width / 2, this.y);
  }

  get topRight() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, this.y);
  }

  get center() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width / 2, this.y + this.height / 2);
  }

  get bottomLeft() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, this.y + this.height);
  }

  get bottomCenter() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width / 2, this.y + this.height);
  }

  get bottomRight() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, this.y + this.height);
  }

  get corner() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, this.y + this.height);
  }

  get rightMiddle() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, this.y + this.height / 2);
  }

  get leftMiddle() {
    return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, this.y + this.height / 2);
  }

  get topLine() {
    return new _line__WEBPACK_IMPORTED_MODULE_2__.Line(this.topLeft, this.topRight);
  }

  get rightLine() {
    return new _line__WEBPACK_IMPORTED_MODULE_2__.Line(this.topRight, this.bottomRight);
  }

  get bottomLine() {
    return new _line__WEBPACK_IMPORTED_MODULE_2__.Line(this.bottomLeft, this.bottomRight);
  }

  get leftLine() {
    return new _line__WEBPACK_IMPORTED_MODULE_2__.Line(this.topLeft, this.bottomLeft);
  }

  getOrigin() {
    return this.origin;
  }

  getTopLeft() {
    return this.topLeft;
  }

  getTopCenter() {
    return this.topCenter;
  }

  getTopRight() {
    return this.topRight;
  }

  getCenter() {
    return this.center;
  }

  getCenterX() {
    return this.x + this.width / 2;
  }

  getCenterY() {
    return this.y + this.height / 2;
  }

  getBottomLeft() {
    return this.bottomLeft;
  }

  getBottomCenter() {
    return this.bottomCenter;
  }

  getBottomRight() {
    return this.bottomRight;
  }

  getCorner() {
    return this.corner;
  }

  getRightMiddle() {
    return this.rightMiddle;
  }

  getLeftMiddle() {
    return this.leftMiddle;
  }

  getTopLine() {
    return this.topLine;
  }

  getRightLine() {
    return this.rightLine;
  }

  getBottomLine() {
    return this.bottomLine;
  }

  getLeftLine() {
    return this.leftLine;
  }
  /**
   * Returns a rectangle that is the bounding box of the rectangle.
   *
   * If `angle` is specified, the bounding box calculation will take into
   * account the rotation of the rectangle by angle degrees around its center.
   */


  bbox(angle) {
    if (!angle) {
      return this.clone();
    }

    const rad = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(angle);
    const st = Math.abs(Math.sin(rad));
    const ct = Math.abs(Math.cos(rad));
    const w = this.width * ct + this.height * st;
    const h = this.width * st + this.height * ct;
    return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);
  }

  round(precision = 0) {
    this.x = _util__WEBPACK_IMPORTED_MODULE_0__.round(this.x, precision);
    this.y = _util__WEBPACK_IMPORTED_MODULE_0__.round(this.y, precision);
    this.width = _util__WEBPACK_IMPORTED_MODULE_0__.round(this.width, precision);
    this.height = _util__WEBPACK_IMPORTED_MODULE_0__.round(this.height, precision);
    return this;
  }

  add(x, y, width, height) {
    const rect = Rectangle.create(x, y, width, height);
    const minX = Math.min(this.x, rect.x);
    const minY = Math.min(this.y, rect.y);
    const maxX = Math.max(this.x + this.width, rect.x + rect.width);
    const maxY = Math.max(this.y + this.height, rect.y + rect.height);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
    return this;
  }

  update(x, y, width, height) {
    const rect = Rectangle.create(x, y, width, height);
    this.x = rect.x;
    this.y = rect.y;
    this.width = rect.width;
    this.height = rect.height;
    return this;
  }

  inflate(dx, dy) {
    const w = dx;
    const h = dy != null ? dy : dx;
    this.x -= w;
    this.y -= h;
    this.width += 2 * w;
    this.height += 2 * h;
    return this;
  }

  snapToGrid(gx, gy) {
    const origin = this.origin.snapToGrid(gx, gy);
    const corner = this.corner.snapToGrid(gx, gy);
    this.x = origin.x;
    this.y = origin.y;
    this.width = corner.x - origin.x;
    this.height = corner.y - origin.y;
    return this;
  }

  translate(tx, ty) {
    const p = _point__WEBPACK_IMPORTED_MODULE_3__.Point.create(tx, ty);
    this.x += p.x;
    this.y += p.y;
    return this;
  }

  scale(sx, sy, origin = new _point__WEBPACK_IMPORTED_MODULE_3__.Point()) {
    const pos = this.origin.scale(sx, sy, origin);
    this.x = pos.x;
    this.y = pos.y;
    this.width *= sx;
    this.height *= sy;
    return this;
  }

  rotate(degree, center = this.getCenter()) {
    if (degree !== 0) {
      const rad = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(degree);
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      let p1 = this.getOrigin();
      let p2 = this.getTopRight();
      let p3 = this.getBottomRight();
      let p4 = this.getBottomLeft();
      p1 = _point__WEBPACK_IMPORTED_MODULE_3__.Point.rotateEx(p1, cos, sin, center);
      p2 = _point__WEBPACK_IMPORTED_MODULE_3__.Point.rotateEx(p2, cos, sin, center);
      p3 = _point__WEBPACK_IMPORTED_MODULE_3__.Point.rotateEx(p3, cos, sin, center);
      p4 = _point__WEBPACK_IMPORTED_MODULE_3__.Point.rotateEx(p4, cos, sin, center);
      const rect = new Rectangle(p1.x, p1.y, 0, 0);
      rect.add(p2.x, p2.y, 0, 0);
      rect.add(p3.x, p3.y, 0, 0);
      rect.add(p4.x, p4.y, 0, 0);
      this.update(rect);
    }

    return this;
  }

  rotate90() {
    const t = (this.width - this.height) / 2;
    this.x += t;
    this.y -= t;
    const tmp = this.width;
    this.width = this.height;
    this.height = tmp;
    return this;
  }
  /**
   * Translates the rectangle by `rect.x` and `rect.y` and expand it by
   * `rect.width` and `rect.height`.
   */


  moveAndExpand(rect) {
    const ref = Rectangle.clone(rect);
    this.x += ref.x || 0;
    this.y += ref.y || 0;
    this.width += ref.width || 0;
    this.height += ref.height || 0;
    return this;
  }
  /**
   * Returns an object where `sx` and `sy` give the maximum scaling that can be
   * applied to the rectangle so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */


  getMaxScaleToFit(limit, origin = this.center) {
    const rect = Rectangle.clone(limit);
    const ox = origin.x;
    const oy = origin.y; // Find the maximal possible scale for all corners, so when the scale
    // is applied the point is still inside the rectangle.

    let sx1 = Infinity;
    let sx2 = Infinity;
    let sx3 = Infinity;
    let sx4 = Infinity;
    let sy1 = Infinity;
    let sy2 = Infinity;
    let sy3 = Infinity;
    let sy4 = Infinity; // Top Left

    const p1 = rect.topLeft;

    if (p1.x < ox) {
      sx1 = (this.x - ox) / (p1.x - ox);
    }

    if (p1.y < oy) {
      sy1 = (this.y - oy) / (p1.y - oy);
    } // Bottom Right


    const p2 = rect.bottomRight;

    if (p2.x > ox) {
      sx2 = (this.x + this.width - ox) / (p2.x - ox);
    }

    if (p2.y > oy) {
      sy2 = (this.y + this.height - oy) / (p2.y - oy);
    } // Top Right


    const p3 = rect.topRight;

    if (p3.x > ox) {
      sx3 = (this.x + this.width - ox) / (p3.x - ox);
    }

    if (p3.y < oy) {
      sy3 = (this.y - oy) / (p3.y - oy);
    } // Bottom Left


    const p4 = rect.bottomLeft;

    if (p4.x < ox) {
      sx4 = (this.x - ox) / (p4.x - ox);
    }

    if (p4.y > oy) {
      sy4 = (this.y + this.height - oy) / (p4.y - oy);
    }

    return {
      sx: Math.min(sx1, sx2, sx3, sx4),
      sy: Math.min(sy1, sy2, sy3, sy4)
    };
  }
  /**
   * Returns a number that specifies the maximum scaling that can be applied to
   * the rectangle along both axes so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */


  getMaxUniformScaleToFit(limit, origin = this.center) {
    const scale = this.getMaxScaleToFit(limit, origin);
    return Math.min(scale.sx, scale.sy);
  }

  containsPoint(x, y) {
    return _util__WEBPACK_IMPORTED_MODULE_0__.containsPoint(this, _point__WEBPACK_IMPORTED_MODULE_3__.Point.create(x, y));
  }

  containsRect(x, y, width, height) {
    const b = Rectangle.create(x, y, width, height);
    const x1 = this.x;
    const y1 = this.y;
    const w1 = this.width;
    const h1 = this.height;
    const x2 = b.x;
    const y2 = b.y;
    const w2 = b.width;
    const h2 = b.height; // one of the dimensions is 0

    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {
      return false;
    }

    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;
  }
  /**
   * Returns an array of the intersection points of the rectangle and the line.
   * Return `null` if no intersection exists.
   */


  intersectsWithLine(line) {
    const rectLines = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
    const points = [];
    const dedupeArr = [];
    rectLines.forEach(l => {
      const p = line.intersectsWithLine(l);

      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {
        points.push(p);
        dedupeArr.push(p.toString());
      }
    });
    return points.length > 0 ? points : null;
  }
  /**
   * Returns the point on the boundary of the rectangle that is the intersection
   * of the rectangle with a line starting in the center the rectangle ending in
   * the point `p`.
   *
   * If `angle` is specified, the intersection will take into account the
   * rotation of the rectangle by `angle` degrees around its center.
   */


  intersectsWithLineFromCenterToPoint(p, angle) {
    const ref = _point__WEBPACK_IMPORTED_MODULE_3__.Point.clone(p);
    const center = this.center;
    let result = null;

    if (angle != null && angle !== 0) {
      ref.rotate(angle, center);
    }

    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
    const connector = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(center, ref);

    for (let i = sides.length - 1; i >= 0; i -= 1) {
      const intersection = sides[i].intersectsWithLine(connector);

      if (intersection !== null) {
        result = intersection;
        break;
      }
    }

    if (result && angle != null && angle !== 0) {
      result.rotate(-angle, center);
    }

    return result;
  }

  intersectsWithRect(x, y, width, height) {
    const ref = Rectangle.create(x, y, width, height); // no intersection

    if (!this.isIntersectWithRect(ref)) {
      return null;
    }

    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref.origin;
    const rCorner = ref.corner;
    const xx = Math.max(myOrigin.x, rOrigin.x);
    const yy = Math.max(myOrigin.y, rOrigin.y);
    return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);
  }

  isIntersectWithRect(x, y, width, height) {
    const ref = Rectangle.create(x, y, width, height);
    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref.origin;
    const rCorner = ref.corner;

    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {
      return false;
    }

    return true;
  }
  /**
   * Normalize the rectangle, i.e. make it so that it has non-negative
   * width and height. If width is less than `0`, the function swaps left and
   * right corners and if height is less than `0`, the top and bottom corners
   * are swapped.
   */


  normalize() {
    let newx = this.x;
    let newy = this.y;
    let newwidth = this.width;
    let newheight = this.height;

    if (this.width < 0) {
      newx = this.x + this.width;
      newwidth = -this.width;
    }

    if (this.height < 0) {
      newy = this.y + this.height;
      newheight = -this.height;
    }

    this.x = newx;
    this.y = newy;
    this.width = newwidth;
    this.height = newheight;
    return this;
  }
  /**
   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
   */


  union(rect) {
    const ref = Rectangle.clone(rect);
    const myOrigin = this.origin;
    const myCorner = this.corner;
    const rOrigin = ref.origin;
    const rCorner = ref.corner;
    const originX = Math.min(myOrigin.x, rOrigin.x);
    const originY = Math.min(myOrigin.y, rOrigin.y);
    const cornerX = Math.max(myCorner.x, rCorner.x);
    const cornerY = Math.max(myCorner.y, rCorner.y);
    return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);
  }
  /**
   * Returns a string ("top", "left", "right" or "bottom") denoting the side of
   * the rectangle which is nearest to the point `p`.
   */


  getNearestSideToPoint(p) {
    const ref = _point__WEBPACK_IMPORTED_MODULE_3__.Point.clone(p);
    const distLeft = ref.x - this.x;
    const distRight = this.x + this.width - ref.x;
    const distTop = ref.y - this.y;
    const distBottom = this.y + this.height - ref.y;
    let closest = distLeft;
    let side = 'left';

    if (distRight < closest) {
      closest = distRight;
      side = 'right';
    }

    if (distTop < closest) {
      closest = distTop;
      side = 'top';
    }

    if (distBottom < closest) {
      side = 'bottom';
    }

    return side;
  }
  /**
   * Returns a point on the boundary of the rectangle nearest to the point `p`.
   */


  getNearestPointToPoint(p) {
    const ref = _point__WEBPACK_IMPORTED_MODULE_3__.Point.clone(p);

    if (this.containsPoint(ref)) {
      const side = this.getNearestSideToPoint(ref);

      switch (side) {
        case 'right':
          return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, ref.y);

        case 'left':
          return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, ref.y);

        case 'bottom':
          return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(ref.x, this.y + this.height);

        case 'top':
          return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(ref.x, this.y);

        default:
          break;
      }
    }

    return ref.adhereToRect(this);
  }

  equals(rect) {
    return rect != null && rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
  }

  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }

  toJSON() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }

  serialize() {
    return `${this.x} ${this.y} ${this.width} ${this.height}`;
  }

}

(function (Rectangle) {
  Rectangle.toStringTag = `X6.Geometry.${Rectangle.name}`;

  function isRectangle(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Rectangle) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const rect = instance;

    if ((tag == null || tag === Rectangle.toStringTag) && typeof rect.x === 'number' && typeof rect.y === 'number' && typeof rect.width === 'number' && typeof rect.height === 'number' && typeof rect.inflate === 'function' && typeof rect.moveAndExpand === 'function') {
      return true;
    }

    return false;
  }

  Rectangle.isRectangle = isRectangle;
})(Rectangle || (Rectangle = {}));

(function (Rectangle) {
  function isRectangleLike(o) {
    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number' && typeof o.width === 'number' && typeof o.height === 'number';
  }

  Rectangle.isRectangleLike = isRectangleLike;
})(Rectangle || (Rectangle = {}));

(function (Rectangle) {
  function create(x, y, width, height) {
    if (x == null || typeof x === 'number') {
      return new Rectangle(x, y, width, height);
    }

    return clone(x);
  }

  Rectangle.create = create;

  function clone(rect) {
    if (Rectangle.isRectangle(rect)) {
      return rect.clone();
    }

    if (Array.isArray(rect)) {
      return new Rectangle(rect[0], rect[1], rect[2], rect[3]);
    }

    return new Rectangle(rect.x, rect.y, rect.width, rect.height);
  }

  Rectangle.clone = clone;

  function fromSize(size) {
    return new Rectangle(0, 0, size.width, size.height);
  }

  Rectangle.fromSize = fromSize;

  function fromPositionAndSize(pos, size) {
    return new Rectangle(pos.x, pos.y, size.width, size.height);
  }

  Rectangle.fromPositionAndSize = fromPositionAndSize;
  /**
   * Returns a new rectangle from the given ellipse.
   */

  function fromEllipse(ellipse) {
    return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);
  }

  Rectangle.fromEllipse = fromEllipse;
})(Rectangle || (Rectangle = {}));

/***/ }),

/***/ 86735:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/geometry/util.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "containsPoint": () => (/* binding */ containsPoint),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "snapToGrid": () => (/* binding */ snapToGrid),
/* harmony export */   "squaredLength": () => (/* binding */ squaredLength)
/* harmony export */ });
function round(num, precision = 0) {
  return Number.isInteger(num) ? num : +num.toFixed(precision);
}
function random(min, max) {
  let mmin;
  let mmax;

  if (max == null) {
    mmax = min == null ? 1 : min;
    mmin = 0;
  } else {
    mmax = max;
    mmin = min == null ? 0 : min;
  }

  if (mmax < mmin) {
    const temp = mmin;
    mmin = mmax;
    mmax = temp;
  }

  return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);
}
function clamp(value, min, max) {
  if (Number.isNaN(value)) {
    return NaN;
  }

  if (Number.isNaN(min) || Number.isNaN(max)) {
    return 0;
  }

  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
}
function snapToGrid(value, gridSize) {
  return gridSize * Math.round(value / gridSize);
}
function containsPoint(rect, point) {
  return point != null && rect != null && point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height;
}
function squaredLength(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return dx * dx + dy * dy;
}

/***/ }),

/***/ 1357:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/global/config.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Config": () => (/* binding */ Config)
/* harmony export */ });
const Config = {
  prefixCls: 'x6',
  autoInsertCSS: true,
  useCSSSelector: true,
  trackable: false,
  trackInfo: {},

  /**
   * Turn on/off collect information of user client.
   *
   * In order to serve the users better, x6 will send the URL and version
   * information back to the AntV server:https://kcart.alipay.com/web/bi.do
   *
   * Except for URL and G2 version information, no other information will
   * be collected.
   *
   * @param enabled Specifies if seed client information to AntV server.
   */
  track(enabled) {
    Config.trackable = enabled;
  }

};

/***/ }),

/***/ 9789:
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/global/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Config": () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_1__.Config),
/* harmony export */   "Util": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_0__.Util),
/* harmony export */   "version": () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_2__.version)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 40106);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ 1357);
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./version */ 4964);




/***/ }),

/***/ 90920:
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/global/track.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ 1357);
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version */ 4964);



function track() {
  if (_config__WEBPACK_IMPORTED_MODULE_0__.Config.trackable) {
    const host = 'https://kcart.alipay.com/web/bi.do';
    const img = new Image();
    const metadata = Object.assign(Object.assign({}, _config__WEBPACK_IMPORTED_MODULE_0__.Config.trackInfo), {
      version: _version__WEBPACK_IMPORTED_MODULE_1__.version,
      pg: document.URL,
      r: new Date().getTime(),
      x6: true,
      page_type: 'syslog'
    });
    const data = encodeURIComponent(JSON.stringify([metadata]));
    img.src = `${host}?BIProfile=merge&d=${data}`;
  }
}

if (false) {}

/***/ }),

/***/ 40106:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/global/util.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Util": () => (/* binding */ Util)
/* harmony export */ });
/* harmony import */ var _geometry_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/util */ 86735);
/* harmony import */ var _registry_marker_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry/marker/util */ 7996);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ 1357);



var Util;

(function (Util) {
  Util.snapToGrid = _geometry_util__WEBPACK_IMPORTED_MODULE_0__.snapToGrid;
  Util.normalizeMarker = _registry_marker_util__WEBPACK_IMPORTED_MODULE_1__.normalize;

  function prefix(suffix) {
    return `${_config__WEBPACK_IMPORTED_MODULE_2__.Config.prefixCls}-${suffix}`;
  }

  Util.prefix = prefix;
})(Util || (Util = {}));

(function (Util) {
  function makeTree(parent, options, parentNode, collector = []) {
    const children = typeof options.children === 'function' ? options.children(parent) : parent[options.children || 'children'];

    if (!parentNode) {
      parentNode = options.createNode(parent); // eslint-disable-line

      collector.push(parentNode);
    }

    if (Array.isArray(children)) {
      children.forEach(child => {
        const node = options.createNode(child);
        const edge = options.createEdge(parentNode, node);
        collector.push(node, edge);
        this.makeTree(child, options, node, collector);
      });
    }

    return collector;
  }

  Util.makeTree = makeTree;
})(Util || (Util = {}));

/***/ }),

/***/ 4964:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/global/version.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* eslint-disable */

/**
 * Auto generated version file, do not modify it!
 */
const version = '1.33.1';


/***/ }),

/***/ 26028:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/background.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundManager": () => (/* binding */ BackgroundManager)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class BackgroundManager extends _base__WEBPACK_IMPORTED_MODULE_3__.Base {
  get elem() {
    return this.view.background;
  }

  init() {
    this.startListening();

    if (this.options.background) {
      this.draw(this.options.background);
    }
  }

  startListening() {
    this.graph.on('scale', this.update, this);
    this.graph.on('translate', this.update, this);
  }

  stopListening() {
    this.graph.off('scale', this.update, this);
    this.graph.off('translate', this.update, this);
  }

  updateBackgroundImage(options = {}) {
    let backgroundSize = options.size || 'auto auto';
    let backgroundPosition = options.position || 'center';
    const scale = this.graph.transform.getScale();
    const ts = this.graph.translate(); // backgroundPosition

    if (typeof backgroundPosition === 'object') {
      const x = ts.tx + scale.sx * (backgroundPosition.x || 0);
      const y = ts.ty + scale.sy * (backgroundPosition.y || 0);
      backgroundPosition = `${x}px ${y}px`;
    } // backgroundSize


    if (typeof backgroundSize === 'object') {
      backgroundSize = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromSize(backgroundSize).scale(scale.sx, scale.sy);
      backgroundSize = `${backgroundSize.width}px ${backgroundSize.height}px`;
    }

    this.elem.style.backgroundSize = backgroundSize;
    this.elem.style.backgroundPosition = backgroundPosition;
  }

  drawBackgroundImage(img, options = {}) {
    if (!(img instanceof HTMLImageElement)) {
      this.elem.style.backgroundImage = '';
      return;
    } // draw multiple times to show the last image


    const cache = this.optionsCache;

    if (cache && cache.image !== options.image) {
      return;
    }

    let uri;
    const opacity = options.opacity;
    const backgroundSize = options.size;
    let backgroundRepeat = options.repeat || 'no-repeat';
    const pattern = _registry__WEBPACK_IMPORTED_MODULE_2__.Background.registry.get(backgroundRepeat);

    if (typeof pattern === 'function') {
      const quality = options.quality || 1;
      img.width *= quality;
      img.height *= quality;
      const canvas = pattern(img, options);

      if (!(canvas instanceof HTMLCanvasElement)) {
        throw new Error('Background pattern must return an HTML Canvas instance');
      }

      uri = canvas.toDataURL('image/png'); // `repeat` was changed in pattern function

      if (options.repeat && backgroundRepeat !== options.repeat) {
        backgroundRepeat = options.repeat;
      } else {
        backgroundRepeat = 'repeat';
      }

      if (typeof backgroundSize === 'object') {
        // recalculate the tile size if an object passed in
        backgroundSize.width *= canvas.width / img.width;
        backgroundSize.height *= canvas.height / img.height;
      } else if (backgroundSize === undefined) {
        // calcule the tile size if no provided
        options.size = {
          width: canvas.width / quality,
          height: canvas.height / quality
        };
      }
    } else {
      uri = img.src;

      if (backgroundSize === undefined) {
        options.size = {
          width: img.width,
          height: img.height
        };
      }
    }

    if (cache != null && typeof options.size === 'object' && options.image === cache.image && options.repeat === cache.repeat && options.quality === cache.quality) {
      cache.size = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.clone(options.size);
    }

    const style = this.elem.style;
    style.backgroundImage = `url(${uri})`;
    style.backgroundRepeat = backgroundRepeat;
    style.opacity = opacity == null || opacity >= 1 ? '' : `${opacity}`;
    this.updateBackgroundImage(options);
  }

  updateBackgroundColor(color) {
    this.elem.style.backgroundColor = color || '';
  }

  updateBackgroundOptions(options) {
    this.graph.options.background = options;
  }

  update() {
    if (this.optionsCache) {
      this.updateBackgroundImage(this.optionsCache);
    }
  }

  draw(options) {
    const opts = options || {};
    this.updateBackgroundOptions(options);
    this.updateBackgroundColor(opts.color);

    if (opts.image) {
      this.optionsCache = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.clone(opts);
      const img = document.createElement('img');

      img.onload = () => this.drawBackgroundImage(img, options);

      img.setAttribute('crossorigin', 'anonymous');
      img.src = opts.image;
    } else {
      this.drawBackgroundImage(null);
      this.optionsCache = null;
    }
  }

  clear() {
    this.draw();
  }

  dispose() {
    this.clear();
    this.stopListening();
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_3__.Base.dispose()], BackgroundManager.prototype, "dispose", null);

/***/ }),

/***/ 94997:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/base.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Base": () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ 57566);

class Base extends _common__WEBPACK_IMPORTED_MODULE_0__.Disposable {
  constructor(graph) {
    super();
    this.graph = graph;
    this.init();
  }

  get options() {
    return this.graph.options;
  }

  get model() {
    return this.graph.model;
  }

  get view() {
    return this.graph.view;
  }

  init() {}

}

/***/ }),

/***/ 20341:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/clipboard.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClipboardManager": () => (/* binding */ ClipboardManager)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


class ClipboardManager extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
  get commonOptions() {
    const _a = this.instanceOptions,
          {
      enabled
    } = _a,
          others = __rest(_a, ["enabled"]);

    return others;
  }

  get instanceOptions() {
    return this.options.clipboard;
  }

  get cells() {
    return this.widget.cells;
  }

  get disabled() {
    return this.instanceOptions.enabled !== true;
  }

  init() {
    this.widget = this.graph.hook.createClipboard();
    this.widget.deserialize(this.instanceOptions);
  }

  enable() {
    if (this.disabled) {
      this.instanceOptions.enabled = true;
    }
  }

  disable() {
    if (!this.disabled) {
      this.instanceOptions.enabled = false;
    }
  }

  copy(cells, options = {}) {
    if (!this.disabled) {
      this.widget.copy(cells, this.graph, Object.assign(Object.assign({}, this.commonOptions), options));
      this.graph.trigger('clipboard:changed', {
        cells
      });
    }
  }

  cut(cells, options = {}) {
    if (!this.disabled) {
      this.widget.cut(cells, this.graph, Object.assign(Object.assign({}, this.commonOptions), options));
      this.graph.trigger('clipboard:changed', {
        cells
      });
    }
  }

  paste(options = {}, graph = this.graph) {
    if (!this.disabled) {
      return this.widget.paste(graph, Object.assign(Object.assign({}, this.commonOptions), options));
    }

    return [];
  }

  clean(force) {
    if (!this.disabled || force) {
      this.widget.clean();
      this.graph.trigger('clipboard:changed', {
        cells: []
      });
    }
  }

  isEmpty() {
    return this.widget.isEmpty();
  }

  dispose() {
    this.clean(true);
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_0__.Base.dispose()], ClipboardManager.prototype, "dispose", null);

/***/ }),

/***/ 78642:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/coord.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CoordManager": () => (/* binding */ CoordManager)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ 94997);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ 17653);



class CoordManager extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
  getClientMatrix() {
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix(this.view.stage.getScreenCTM());
  }
  /**
   * Returns coordinates of the graph viewport, relative to the window.
   */


  getClientOffset() {
    // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
    const rect = this.view.svg.getBoundingClientRect();
    return new _geometry__WEBPACK_IMPORTED_MODULE_2__.Point(rect.left, rect.top);
  }
  /**
   * Returns coordinates of the graph viewport, relative to the document.
   */


  getPageOffset() {
    // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
    return this.getClientOffset().translate(window.scrollX, window.scrollY);
  }

  snapToGrid(x, y) {
    const p = typeof x === 'number' ? this.clientToLocalPoint(x, y) : this.clientToLocalPoint(x.x, x.y);
    return p.snapToGrid(this.graph.getGridSize());
  }

  localToGraphPoint(x, y) {
    const localPoint = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(x, y);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformPoint(localPoint, this.graph.matrix());
  }

  localToClientPoint(x, y) {
    const localPoint = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(x, y);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformPoint(localPoint, this.getClientMatrix());
  }

  localToPagePoint(x, y) {
    const p = typeof x === 'number' ? this.localToGraphPoint(x, y) : this.localToGraphPoint(x);
    return p.translate(this.getPageOffset());
  }

  localToGraphRect(x, y, width, height) {
    const localRect = _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(x, y, width, height);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformRectangle(localRect, this.graph.matrix());
  }

  localToClientRect(x, y, width, height) {
    const localRect = _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(x, y, width, height);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformRectangle(localRect, this.getClientMatrix());
  }

  localToPageRect(x, y, width, height) {
    const rect = typeof x === 'number' ? this.localToGraphRect(x, y, width, height) : this.localToGraphRect(x);
    return rect.translate(this.getPageOffset());
  }

  graphToLocalPoint(x, y) {
    const graphPoint = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(x, y);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformPoint(graphPoint, this.graph.matrix().inverse());
  }

  clientToLocalPoint(x, y) {
    const clientPoint = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(x, y);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformPoint(clientPoint, this.getClientMatrix().inverse());
  }

  clientToGraphPoint(x, y) {
    const clientPoint = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(x, y);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformPoint(clientPoint, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }

  pageToLocalPoint(x, y) {
    const pagePoint = _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(x, y);
    const graphPoint = pagePoint.diff(this.getPageOffset());
    return this.graphToLocalPoint(graphPoint);
  }

  graphToLocalRect(x, y, width, height) {
    const graphRect = _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(x, y, width, height);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformRectangle(graphRect, this.graph.matrix().inverse());
  }

  clientToLocalRect(x, y, width, height) {
    const clientRect = _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(x, y, width, height);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformRectangle(clientRect, this.getClientMatrix().inverse());
  }

  clientToGraphRect(x, y, width, height) {
    const clientRect = _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(x, y, width, height);
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformRectangle(clientRect, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }

  pageToLocalRect(x, y, width, height) {
    const graphRect = _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(x, y, width, height);
    const pageOffset = this.getPageOffset();
    graphRect.x -= pageOffset.x;
    graphRect.y -= pageOffset.y;
    return this.graphToLocalRect(graphRect);
  }

}

/***/ }),

/***/ 11492:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/css.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSManager": () => (/* binding */ CSSManager)
/* harmony export */ });
/* harmony import */ var _global_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global/config */ 1357);
/* harmony import */ var _style_raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../style/raw */ 23919);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class CSSManager extends _base__WEBPACK_IMPORTED_MODULE_3__.Base {
  init() {
    if (_global_config__WEBPACK_IMPORTED_MODULE_0__.Config.autoInsertCSS) {
      CSSManager.ensure();
    }
  }

  dispose() {
    CSSManager.clean();
  }

}

__decorate([CSSManager.dispose()], CSSManager.prototype, "dispose", null);

(function (CSSManager) {
  let styleElement;
  let counter = 0;

  function ensure() {
    counter += 1;
    if (counter > 1) return;

    if (!_util__WEBPACK_IMPORTED_MODULE_2__.Platform.isApplyingHMR()) {
      styleElement = document.createElement('style');
      styleElement.setAttribute('type', 'text/css');
      styleElement.textContent = _style_raw__WEBPACK_IMPORTED_MODULE_1__.content;
      const head = document.querySelector('head');

      if (head) {
        head.insertBefore(styleElement, head.firstChild);
      }
    }
  }

  CSSManager.ensure = ensure;

  function clean() {
    counter -= 1;
    if (counter > 0) return;

    if (styleElement && styleElement.parentNode) {
      styleElement.parentNode.removeChild(styleElement);
    }

    styleElement = null;
  }

  CSSManager.clean = clean;
})(CSSManager || (CSSManager = {}));

/***/ }),

/***/ 68898:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/decorator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Decorator": () => (/* binding */ Decorator)
/* harmony export */ });
var Decorator;

(function (Decorator) {
  function checkScroller(err, warning) {
    return (target, methodName, descriptor) => {
      const raw = descriptor.value;

      descriptor.value = function (...args) {
        const scroller = this.scroller.widget;

        if (scroller == null) {
          const msg = `Shoule enable scroller to use method '${methodName}'`;

          if (err !== false) {
            console.error(msg);
            throw new Error(msg);
          }

          if (warning !== false) {
            console.warn(msg);
          }

          return this;
        }

        return raw.call(this, ...args);
      };
    };
  }

  Decorator.checkScroller = checkScroller;
})(Decorator || (Decorator = {}));

/***/ }),

/***/ 70656:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/defs.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefsManager": () => (/* binding */ DefsManager)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../view */ 29818);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ 94997);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





class DefsManager extends _base__WEBPACK_IMPORTED_MODULE_3__.Base {
  get cid() {
    return this.graph.view.cid;
  }

  get svg() {
    return this.view.svg;
  }

  get defs() {
    return this.view.defs;
  }

  isDefined(id) {
    return this.svg.getElementById(id) != null;
  }

  filter(options) {
    let filterId = options.id;
    const name = options.name;

    if (!filterId) {
      filterId = `filter-${name}-${this.cid}-${_util__WEBPACK_IMPORTED_MODULE_0__.StringExt.hashcode(JSON.stringify(options))}`;
    }

    if (!this.isDefined(filterId)) {
      const fn = _registry__WEBPACK_IMPORTED_MODULE_1__.Filter.registry.get(name);

      if (fn == null) {
        return _registry__WEBPACK_IMPORTED_MODULE_1__.Filter.registry.onNotFound(name);
      }

      const markup = fn(options.args || {}); // Set the filter area to be 3x the bounding box of the cell
      // and center the filter around the cell.

      const attrs = Object.assign(Object.assign({
        x: -1,
        y: -1,
        width: 3,
        height: 3,
        filterUnits: 'objectBoundingBox'
      }, options.attrs), {
        id: filterId
      });
      _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create(_view__WEBPACK_IMPORTED_MODULE_2__.Markup.sanitize(markup), attrs).appendTo(this.defs);
    }

    return filterId;
  }

  gradient(options) {
    let id = options.id;
    const type = options.type;

    if (!id) {
      id = `gradient-${type}-${this.cid}-${_util__WEBPACK_IMPORTED_MODULE_0__.StringExt.hashcode(JSON.stringify(options))}`;
    }

    if (!this.isDefined(id)) {
      const stops = options.stops;
      const arr = stops.map(stop => {
        const opacity = stop.opacity != null && Number.isFinite(stop.opacity) ? stop.opacity : 1;
        return `<stop offset="${stop.offset}" stop-color="${stop.color}" stop-opacity="${opacity}"/>`;
      });
      const markup = `<${type}>${arr.join('')}</${type}>`;
      const attrs = Object.assign({
        id
      }, options.attrs);
      _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create(markup, attrs).appendTo(this.defs);
    }

    return id;
  }

  marker(options) {
    const {
      id,
      refX,
      refY,
      markerUnits,
      markerOrient,
      tagName,
      children
    } = options,
          attrs = __rest(options, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);

    let markerId = id;

    if (!markerId) {
      markerId = `marker-${this.cid}-${_util__WEBPACK_IMPORTED_MODULE_0__.StringExt.hashcode(JSON.stringify(options))}`;
    }

    if (!this.isDefined(markerId)) {
      if (tagName !== 'path') {
        // remove unnecessary d attribute inherit from standard edge.
        delete attrs.d;
      }

      const pathMarker = _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create('marker', {
        refX,
        refY,
        id: markerId,
        overflow: 'visible',
        orient: markerOrient != null ? markerOrient : 'auto',
        markerUnits: markerUnits || 'userSpaceOnUse'
      }, children ? children.map(_a => {
        var {
          tagName
        } = _a,
            other = __rest(_a, ["tagName"]);

        return _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create(`${tagName}` || 'path', _util__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(Object.assign(Object.assign({}, attrs), other)));
      }) : [_util__WEBPACK_IMPORTED_MODULE_0__.Vector.create(tagName || 'path', _util__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(attrs))]);
      this.defs.appendChild(pathMarker.node);
    }

    return markerId;
  }

  remove(id) {
    const elem = this.svg.getElementById(id);

    if (elem && elem.parentNode) {
      elem.parentNode.removeChild(elem);
    }
  }

}

/***/ }),

/***/ 76465:
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/format.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FormatManager": () => (/* binding */ FormatManager)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ 94997);




class FormatManager extends _base__WEBPACK_IMPORTED_MODULE_3__.Base {
  toSVG(callback, options = {}) {
    this.graph.trigger('before:export', options);
    const rawSVG = this.view.svg;
    const vSVG = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(rawSVG).clone();
    let clonedSVG = vSVG.node;
    const vStage = vSVG.findOne(`.${this.view.prefixClassName('graph-svg-stage')}`);
    const viewBox = options.viewBox || this.graph.graphToLocal(this.graph.getContentBBox());
    const dimension = options.preserveDimensions;

    if (dimension) {
      const size = typeof dimension === 'boolean' ? viewBox : dimension;
      vSVG.attr({
        width: size.width,
        height: size.height
      });
    }

    vSVG.removeAttribute('style').attr('viewBox', [viewBox.x, viewBox.y, viewBox.width, viewBox.height].join(' '));
    vStage.removeAttribute('transform'); // Stores all the CSS declarations from external stylesheets to the
    // `style` attribute of the SVG document nodes.
    // This is achieved in three steps.
    // -----------------------------------
    // 1. Disabling all the stylesheets in the page and therefore collecting
    //    only default style values. This, together with the step 2, makes it
    //    possible to discard default CSS property values and store only those
    //    that differ.
    //
    // 2. Enabling back all the stylesheets in the page and collecting styles
    //    that differ from the default values.
    //
    // 3. Applying the difference between default values and the ones set by
    //    custom stylesheets onto the `style` attribute of each of the nodes
    //    in SVG.

    if (options.copyStyles !== false) {
      const document = rawSVG.ownerDocument;
      const raws = Array.from(rawSVG.querySelectorAll('*'));
      const clones = Array.from(clonedSVG.querySelectorAll('*'));
      const styleSheetCount = document.styleSheets.length;
      const styleSheetsCopy = [];

      for (let k = styleSheetCount - 1; k >= 0; k -= 1) {
        // There is a bug (bugSS) in Chrome 14 and Safari. When you set
        // `stylesheet.disable = true` it will also remove it from
        // `document.styleSheets`. So we need to store all stylesheets before
        // we disable them. Later on we put them back to `document.styleSheets`
        // if needed.
        // See the bug `https://code.google.com/p/chromium/issues/detail?id=88310`.
        styleSheetsCopy[k] = document.styleSheets[k];
        document.styleSheets[k].disabled = true;
      }

      const defaultComputedStyles = {};
      raws.forEach((elem, index) => {
        const computedStyle = window.getComputedStyle(elem, null); // We're making a deep copy of the `computedStyle` so that it's not affected
        // by that next step when all the stylesheets are re-enabled again.

        const defaultComputedStyle = {};
        Object.keys(computedStyle).forEach(property => {
          defaultComputedStyle[property] = computedStyle.getPropertyValue(property);
        });
        defaultComputedStyles[index] = defaultComputedStyle;
      }); // Copy all stylesheets back

      if (styleSheetCount !== document.styleSheets.length) {
        styleSheetsCopy.forEach((copy, index) => {
          document.styleSheets[index] = copy;
        });
      }

      for (let i = 0; i < styleSheetCount; i += 1) {
        document.styleSheets[i].disabled = false;
      }

      const customStyles = {};
      raws.forEach((elem, index) => {
        const computedStyle = window.getComputedStyle(elem, null);
        const defaultComputedStyle = defaultComputedStyles[index];
        const customStyle = {};
        Object.keys(computedStyle).forEach(property => {
          if (!_util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isNumeric(property) && computedStyle.getPropertyValue(property) !== defaultComputedStyle[property]) {
            customStyle[property] = computedStyle.getPropertyValue(property);
          }
        });
        customStyles[index] = customStyle;
      });
      clones.forEach((elem, index) => {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(elem).css(customStyles[index]);
      });
    }

    const stylesheet = options.stylesheet;

    if (typeof stylesheet === 'string') {
      const cDATASection = rawSVG.ownerDocument.implementation.createDocument(null, 'xml', null).createCDATASection(stylesheet);
      vSVG.prepend(_util__WEBPACK_IMPORTED_MODULE_1__.Vector.create('style', {
        type: 'text/css'
      }, [cDATASection]));
    }

    const format = () => {
      const beforeSerialize = options.beforeSerialize;

      if (typeof beforeSerialize === 'function') {
        const ret = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(beforeSerialize, this.graph, clonedSVG);

        if (ret instanceof SVGSVGElement) {
          clonedSVG = ret;
        }
      }

      const dataUri = new XMLSerializer().serializeToString(clonedSVG).replace(/&nbsp;/g, '\u00a0');
      this.graph.trigger('after:export', options);
      callback(dataUri);
    };

    if (options.serializeImages) {
      const deferrals = vSVG.find('image').map(vImage => {
        return new Promise(resolve => {
          const url = vImage.attr('xlink:href') || vImage.attr('href');
          _util__WEBPACK_IMPORTED_MODULE_1__.DataUri.imageToDataUri(url, (err, dataUri) => {
            if (!err && dataUri) {
              vImage.attr('xlink:href', dataUri);
            }

            resolve();
          });
        });
      });
      Promise.all(deferrals).then(format);
    } else {
      format();
    }
  }

  toDataURL(callback, options) {
    let viewBox = options.viewBox || this.graph.getContentBBox();
    const padding = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizeSides(options.padding);

    if (options.width && options.height) {
      if (padding.left + padding.right >= options.width) {
        padding.left = padding.right = 0;
      }

      if (padding.top + padding.bottom >= options.height) {
        padding.top = padding.bottom = 0;
      }
    }

    const expanding = new _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle(-padding.left, -padding.top, padding.left + padding.right, padding.top + padding.bottom);

    if (options.width && options.height) {
      const width = viewBox.width + padding.left + padding.right;
      const height = viewBox.height + padding.top + padding.bottom;
      expanding.scale(width / options.width, height / options.height);
    }

    viewBox = _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(viewBox).moveAndExpand(expanding);
    const rawSize = typeof options.width === 'number' && typeof options.height === 'number' ? {
      width: options.width,
      height: options.height
    } : viewBox;
    let scale = options.ratio ? parseFloat(options.ratio) : 1;

    if (!Number.isFinite(scale) || scale === 0) {
      scale = 1;
    }

    const size = {
      width: Math.max(Math.round(rawSize.width * scale), 1),
      height: Math.max(Math.round(rawSize.height * scale), 1)
    };
    {
      const imgDataCanvas = document.createElement('canvas');
      const context2D = imgDataCanvas.getContext('2d');
      imgDataCanvas.width = size.width;
      imgDataCanvas.height = size.height;
      const x = size.width - 1;
      const y = size.height - 1;
      context2D.fillStyle = 'rgb(1,1,1)';
      context2D.fillRect(x, y, 1, 1);
      const data = context2D.getImageData(x, y, 1, 1).data;

      if (data[0] !== 1 || data[1] !== 1 || data[2] !== 1) {
        throw new Error('size exceeded');
      }
    }
    const img = new Image();

    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = size.width;
      canvas.height = size.height;
      const context = canvas.getContext('2d');
      context.fillStyle = options.backgroundColor || 'white';
      context.fillRect(0, 0, size.width, size.height);

      try {
        context.drawImage(img, 0, 0, size.width, size.height);
        const dataUri = canvas.toDataURL(options.type, options.quality);
        callback(dataUri);
      } catch (error) {// pass
      }
    };

    this.toSVG(dataUri => {
      img.src = `data:image/svg+xml,${encodeURIComponent(dataUri)}`;
    }, Object.assign(Object.assign({}, options), {
      viewBox,
      serializeImages: true,
      preserveDimensions: Object.assign({}, size)
    }));
  }

  toPNG(callback, options = {}) {
    this.toDataURL(callback, Object.assign(Object.assign({}, options), {
      type: 'image/png'
    }));
  }

  toJPEG(callback, options = {}) {
    this.toDataURL(callback, Object.assign(Object.assign({}, options), {
      type: 'image/jpeg'
    }));
  }

}

/***/ }),

/***/ 77947:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/graph.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Graph": () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ 57566);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _model_cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/cell */ 30936);
/* harmony import */ var _model_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/node */ 21738);
/* harmony import */ var _model_edge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/edge */ 51257);
/* harmony import */ var _view_cell__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../view/cell */ 58670);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _shape_standard_html__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shape/standard/html */ 74057);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base */ 94997);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./view */ 716);
/* harmony import */ var _decorator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./decorator */ 68898);
/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./css */ 11492);
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./hook */ 39941);
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./options */ 94805);
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./defs */ 70656);
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./grid */ 65154);
/* harmony import */ var _coord__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./coord */ 78642);
/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./keyboard */ 37003);
/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./print */ 75068);
/* harmony import */ var _mousewheel__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./mousewheel */ 52222);
/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./format */ 76465);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./renderer */ 47801);
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./history */ 42);
/* harmony import */ var _minimap__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./minimap */ 55933);
/* harmony import */ var _snapline__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./snapline */ 61871);
/* harmony import */ var _scroller__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./scroller */ 86949);
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./selection */ 93330);
/* harmony import */ var _highlight__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./highlight */ 95358);
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./transform */ 33795);
/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clipboard */ 20341);
/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./background */ 26028);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
































class Graph extends _common__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
  constructor(options) {
    super();
    this.options = _options__WEBPACK_IMPORTED_MODULE_13__.Options.get(options);
    this.css = new _css__WEBPACK_IMPORTED_MODULE_11__.CSSManager(this);
    this.hook = new _hook__WEBPACK_IMPORTED_MODULE_12__.Hook(this);
    this.view = this.hook.createView();
    this.defs = this.hook.createDefsManager();
    this.coord = this.hook.createCoordManager();
    this.transform = this.hook.createTransformManager();
    this.knob = this.hook.createKnobManager();
    this.highlight = this.hook.createHighlightManager();
    this.grid = this.hook.createGridManager();
    this.background = this.hook.createBackgroundManager();
    this.model = this.hook.createModel();
    this.renderer = this.hook.createRenderer();
    this.clipboard = this.hook.createClipboardManager();
    this.snapline = this.hook.createSnaplineManager();
    this.selection = this.hook.createSelectionManager();
    this.history = this.hook.createHistoryManager();
    this.scroller = this.hook.createScrollerManager();
    this.minimap = this.hook.createMiniMapManager();
    this.keyboard = this.hook.createKeyboard();
    this.mousewheel = this.hook.createMouseWheel();
    this.print = this.hook.createPrintManager();
    this.format = this.hook.createFormatManager();
    this.panning = this.hook.createPanningManager();
    this.size = this.hook.createSizeManager();
  }

  get container() {
    return this.view.container;
  }

  get [Symbol.toStringTag]() {
    return Graph.toStringTag;
  } // #region model


  isNode(cell) {
    return cell.isNode();
  }

  isEdge(cell) {
    return cell.isEdge();
  }

  resetCells(cells, options = {}) {
    this.model.resetCells(cells, options);
    return this;
  }

  clearCells(options = {}) {
    this.model.clear(options);
    return this;
  }

  toJSON(options = {}) {
    return this.model.toJSON(options);
  }

  parseJSON(data) {
    return this.model.parseJSON(data);
  }

  fromJSON(data, options = {}) {
    this.model.fromJSON(data, options);
    return this;
  }

  getCellById(id) {
    return this.model.getCell(id);
  }

  addNode(node, options = {}) {
    return this.model.addNode(node, options);
  }

  addNodes(nodes, options = {}) {
    return this.addCell(nodes.map(node => _model_node__WEBPACK_IMPORTED_MODULE_3__.Node.isNode(node) ? node : this.createNode(node)), options);
  }

  createNode(metadata) {
    return this.model.createNode(metadata);
  }

  removeNode(node, options = {}) {
    return this.model.removeCell(node, options);
  }

  addEdge(edge, options = {}) {
    return this.model.addEdge(edge, options);
  }

  addEdges(edges, options = {}) {
    return this.addCell(edges.map(edge => _model_edge__WEBPACK_IMPORTED_MODULE_4__.Edge.isEdge(edge) ? edge : this.createEdge(edge)), options);
  }

  removeEdge(edge, options = {}) {
    return this.model.removeCell(edge, options);
  }

  createEdge(metadata) {
    return this.model.createEdge(metadata);
  }

  addCell(cell, options = {}) {
    this.model.addCell(cell, options);
    return this;
  }

  removeCell(cell, options = {}) {
    return this.model.removeCell(cell, options);
  }

  removeCells(cells, options = {}) {
    return this.model.removeCells(cells, options);
  }

  removeConnectedEdges(cell, options = {}) {
    return this.model.removeConnectedEdges(cell, options);
  }

  disconnectConnectedEdges(cell, options = {}) {
    this.model.disconnectConnectedEdges(cell, options);
    return this;
  }

  hasCell(cell) {
    return this.model.has(cell);
  }
  /**
   * **Deprecation Notice:** `getCell` is deprecated and will be moved in next
   * major release. Use `getCellById()` instead.
   *
   * @deprecated
   */


  getCell(id) {
    return this.model.getCell(id);
  }

  getCells() {
    return this.model.getCells();
  }

  getCellCount() {
    return this.model.total();
  }
  /**
   * Returns all the nodes in the graph.
   */


  getNodes() {
    return this.model.getNodes();
  }
  /**
   * Returns all the edges in the graph.
   */


  getEdges() {
    return this.model.getEdges();
  }
  /**
   * Returns all outgoing edges for the node.
   */


  getOutgoingEdges(cell) {
    return this.model.getOutgoingEdges(cell);
  }
  /**
   * Returns all incoming edges for the node.
   */


  getIncomingEdges(cell) {
    return this.model.getIncomingEdges(cell);
  }
  /**
   * Returns edges connected with cell.
   */


  getConnectedEdges(cell, options = {}) {
    return this.model.getConnectedEdges(cell, options);
  }
  /**
   * Returns an array of all the roots of the graph.
   */


  getRootNodes() {
    return this.model.getRoots();
  }
  /**
   * Returns an array of all the leafs of the graph.
   */


  getLeafNodes() {
    return this.model.getLeafs();
  }
  /**
   * Returns `true` if the node is a root node, i.e.
   * there is no  edges coming to the node.
   */


  isRootNode(cell) {
    return this.model.isRoot(cell);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e.
   * there is no edges going out from the node.
   */


  isLeafNode(cell) {
    return this.model.isLeaf(cell);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */


  getNeighbors(cell, options = {}) {
    return this.model.getNeighbors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */


  isNeighbor(cell1, cell2, options = {}) {
    return this.model.isNeighbor(cell1, cell2, options);
  }

  getSuccessors(cell, options = {}) {
    return this.model.getSuccessors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */


  isSuccessor(cell1, cell2, options = {}) {
    return this.model.isSuccessor(cell1, cell2, options);
  }

  getPredecessors(cell, options = {}) {
    return this.model.getPredecessors(cell, options);
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */


  isPredecessor(cell1, cell2, options = {}) {
    return this.model.isPredecessor(cell1, cell2, options);
  }

  getCommonAncestor(...cells) {
    return this.model.getCommonAncestor(...cells);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */


  getSubGraph(cells, options = {}) {
    return this.model.getSubGraph(cells, options);
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */


  cloneSubGraph(cells, options = {}) {
    return this.model.cloneSubGraph(cells, options);
  }

  cloneCells(cells) {
    return this.model.cloneCells(cells);
  }

  getNodesFromPoint(x, y) {
    return this.model.getNodesFromPoint(x, y);
  }

  getNodesInArea(x, y, w, h, options) {
    return this.model.getNodesInArea(x, y, w, h, options);
  }

  getNodesUnderNode(node, options = {}) {
    return this.model.getNodesUnderNode(node, options);
  }

  searchCell(cell, iterator, options = {}) {
    this.model.search(cell, iterator, options);
    return this;
  }
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */


  getShortestPath(source, target, options = {}) {
    return this.model.getShortestPath(source, target, options);
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */


  getAllCellsBBox() {
    return this.model.getAllCellsBBox();
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */


  getCellsBBox(cells, options = {}) {
    return this.model.getCellsBBox(cells, options);
  }

  startBatch(name, data = {}) {
    this.model.startBatch(name, data);
  }

  stopBatch(name, data = {}) {
    this.model.stopBatch(name, data);
  }

  batchUpdate(arg1, arg2, arg3) {
    const name = typeof arg1 === 'string' ? arg1 : 'update';
    const execute = typeof arg1 === 'string' ? arg2 : arg1;
    const data = typeof arg2 === 'function' ? arg3 : arg2;
    this.startBatch(name, data);
    const result = execute();
    this.stopBatch(name, data);
    return result;
  }

  updateCellId(cell, newId) {
    return this.model.updateCellId(cell, newId);
  } // #endregion
  // #region view


  isFrozen() {
    return this.renderer.isFrozen();
  }

  freeze(options = {}) {
    this.renderer.freeze(options);
    return this;
  }

  unfreeze(options = {}) {
    this.renderer.unfreeze(options);
    return this;
  }

  isAsync() {
    return this.renderer.isAsync();
  }

  setAsync(async) {
    this.renderer.setAsync(async);
    return this;
  }

  findView(ref) {
    if (_model_cell__WEBPACK_IMPORTED_MODULE_2__.Cell.isCell(ref)) {
      return this.findViewByCell(ref);
    }

    return this.findViewByElem(ref);
  }

  findViews(ref) {
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(ref)) {
      return this.findViewsInArea(ref);
    }

    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(ref)) {
      return this.findViewsFromPoint(ref);
    }

    return [];
  }

  findViewByCell(cell) {
    return this.renderer.findViewByCell(cell);
  }

  findViewByElem(elem) {
    return this.renderer.findViewByElem(elem);
  }

  findViewsFromPoint(x, y) {
    const p = typeof x === 'number' ? {
      x,
      y: y
    } : x;
    return this.renderer.findViewsFromPoint(p);
  }

  findViewsInArea(x, y, width, height, options) {
    const rect = typeof x === 'number' ? {
      x,
      y: y,
      width: width,
      height: height
    } : x;
    const localOptions = typeof x === 'number' ? options : y;
    return this.renderer.findViewsInArea(rect, localOptions);
  }

  isViewMounted(view) {
    return this.renderer.isViewMounted(view);
  }

  getMountedViews() {
    return this.renderer.getMountedViews();
  }

  getUnmountedViews() {
    return this.renderer.getUnmountedViews();
  }

  matrix(mat) {
    if (typeof mat === 'undefined') {
      return this.transform.getMatrix();
    }

    this.transform.setMatrix(mat);
    return this;
  }

  resize(width, height) {
    this.size.resize(width, height);
    return this;
  }

  resizeGraph(width, height) {
    this.size.resizeGraph(width, height);
    return this;
  }

  resizeScroller(width, height) {
    this.size.resizeScroller(width, height);
    return this;
  }

  resizePage(width, height) {
    this.size.resizePage(width, height);
    return this;
  }

  scale(sx, sy = sx, cx = 0, cy = 0) {
    if (typeof sx === 'undefined') {
      return this.transform.getScale();
    }

    this.transform.scale(sx, sy, cx, cy);
    return this;
  }

  zoom(factor, options) {
    const scroller = this.scroller.widget;

    if (scroller) {
      if (typeof factor === 'undefined') {
        return scroller.zoom();
      }

      scroller.zoom(factor, options);
    } else {
      if (typeof factor === 'undefined') {
        return this.transform.getZoom();
      }

      this.transform.zoom(factor, options);
    }

    return this;
  }

  zoomTo(factor, options = {}) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.zoom(factor, Object.assign(Object.assign({}, options), {
        absolute: true
      }));
    } else {
      this.transform.zoom(factor, Object.assign(Object.assign({}, options), {
        absolute: true
      }));
    }

    return this;
  }

  zoomToRect(rect, options = {}) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.zoomToRect(rect, options);
    } else {
      this.transform.zoomToRect(rect, options);
    }

    return this;
  }

  zoomToFit(options = {}) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.zoomToFit(options);
    } else {
      this.transform.zoomToFit(options);
    }

    return this;
  }

  rotate(angle, cx, cy) {
    if (typeof angle === 'undefined') {
      return this.transform.getRotation();
    }

    this.transform.rotate(angle, cx, cy);
    return this;
  }

  translate(tx, ty) {
    if (typeof tx === 'undefined') {
      return this.transform.getTranslation();
    }

    this.transform.translate(tx, ty);
    return this;
  }

  translateBy(dx, dy) {
    const ts = this.translate();
    const tx = ts.tx + dx;
    const ty = ts.ty + dy;
    return this.translate(tx, ty);
  }
  /**
   * **Deprecation Notice:** `getArea` is deprecated and will be moved in next
   * major release. Use `getGraphArea()` instead.
   *
   * @deprecated
   */


  getArea() {
    return this.transform.getGraphArea();
  }

  getGraphArea() {
    return this.transform.getGraphArea();
  }

  getContentArea(options = {}) {
    return this.transform.getContentArea(options);
  }

  getContentBBox(options = {}) {
    return this.transform.getContentBBox(options);
  }

  fitToContent(gridWidth, gridHeight, padding, options) {
    return this.transform.fitToContent(gridWidth, gridHeight, padding, options);
  }

  scaleContentToFit(options = {}) {
    this.transform.scaleContentToFit(options);
    return this;
  }
  /**
   * Position the center of graph to the center of the viewport.
   */


  center(optons) {
    return this.centerPoint(optons);
  }

  centerPoint(x, y, options) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.centerPoint(x, y, options);
    } else {
      this.transform.centerPoint(x, y);
    }

    return this;
  }

  centerContent(options) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.centerContent(options);
    } else {
      this.transform.centerContent(options);
    }

    return this;
  }

  centerCell(cell, options) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.centerCell(cell, options);
    } else {
      this.transform.centerCell(cell);
    }

    return this;
  }

  positionPoint(point, x, y, options = {}) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.positionPoint(point, x, y, options);
    } else {
      this.transform.positionPoint(point, x, y);
    }

    return this;
  }

  positionRect(rect, direction, options) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.positionRect(rect, direction, options);
    } else {
      this.transform.positionRect(rect, direction);
    }

    return this;
  }

  positionCell(cell, direction, options) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.positionCell(cell, direction, options);
    } else {
      this.transform.positionCell(cell, direction);
    }

    return this;
  }

  positionContent(pos, options) {
    const scroller = this.scroller.widget;

    if (scroller) {
      scroller.positionContent(pos, options);
    } else {
      this.transform.positionContent(pos, options);
    }

    return this;
  } // #endregion
  // #region coord


  getClientMatrix() {
    return this.coord.getClientMatrix();
  }
  /**
   * Returns coordinates of the graph viewport, relative to the window.
   */


  getClientOffset() {
    return this.coord.getClientOffset();
  }
  /**
   * Returns coordinates of the graph viewport, relative to the document.
   */


  getPageOffset() {
    return this.coord.getPageOffset();
  }

  snapToGrid(x, y) {
    return this.coord.snapToGrid(x, y);
  }

  pageToLocal(x, y, width, height) {
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
      return this.coord.pageToLocalRect(x);
    }

    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
      return this.coord.pageToLocalRect(x, y, width, height);
    }

    return this.coord.pageToLocalPoint(x, y);
  }

  localToPage(x, y, width, height) {
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
      return this.coord.localToPageRect(x);
    }

    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
      return this.coord.localToPageRect(x, y, width, height);
    }

    return this.coord.localToPagePoint(x, y);
  }

  clientToLocal(x, y, width, height) {
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
      return this.coord.clientToLocalRect(x);
    }

    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
      return this.coord.clientToLocalRect(x, y, width, height);
    }

    return this.coord.clientToLocalPoint(x, y);
  }

  localToClient(x, y, width, height) {
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
      return this.coord.localToClientRect(x);
    }

    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
      return this.coord.localToClientRect(x, y, width, height);
    }

    return this.coord.localToClientPoint(x, y);
  }

  localToGraph(x, y, width, height) {
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
      return this.coord.localToGraphRect(x);
    }

    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
      return this.coord.localToGraphRect(x, y, width, height);
    }

    return this.coord.localToGraphPoint(x, y);
  }

  graphToLocal(x, y, width, height) {
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
      return this.coord.graphToLocalRect(x);
    }

    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
      return this.coord.graphToLocalRect(x, y, width, height);
    }

    return this.coord.graphToLocalPoint(x, y);
  }

  clientToGraph(x, y, width, height) {
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
      return this.coord.clientToGraphRect(x);
    }

    if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
      return this.coord.clientToGraphRect(x, y, width, height);
    }

    return this.coord.clientToGraphPoint(x, y);
  } // #endregion
  // #region defs


  defineFilter(options) {
    return this.defs.filter(options);
  }

  defineGradient(options) {
    return this.defs.gradient(options);
  }

  defineMarker(options) {
    return this.defs.marker(options);
  } // #endregion
  // #region grid


  getGridSize() {
    return this.grid.getGridSize();
  }

  setGridSize(gridSize) {
    this.grid.setGridSize(gridSize);
    return this;
  }

  showGrid() {
    this.grid.show();
    return this;
  }

  hideGrid() {
    this.grid.hide();
    return this;
  }

  clearGrid() {
    this.grid.clear();
    return this;
  }

  drawGrid(options) {
    this.grid.draw(options);
    return this;
  } // #endregion
  // #region background


  updateBackground() {
    this.background.update();
    return this;
  }

  drawBackground(options, onGraph) {
    const scroller = this.scroller.widget;

    if (scroller != null && (this.options.background == null || !onGraph)) {
      scroller.backgroundManager.draw(options);
    } else {
      this.background.draw(options);
    }

    return this;
  }

  clearBackground(onGraph) {
    const scroller = this.scroller.widget;

    if (scroller != null && (this.options.background == null || !onGraph)) {
      scroller.backgroundManager.clear();
    } else {
      this.background.clear();
    }

    return this;
  } // #endregion
  // #region clipboard


  isClipboardEnabled() {
    return !this.clipboard.disabled;
  }

  enableClipboard() {
    this.clipboard.enable();
    return this;
  }

  disableClipboard() {
    this.clipboard.disable();
    return this;
  }

  toggleClipboard(enabled) {
    if (enabled != null) {
      if (enabled !== this.isClipboardEnabled()) {
        if (enabled) {
          this.enableClipboard();
        } else {
          this.disableClipboard();
        }
      }
    } else if (this.isClipboardEnabled()) {
      this.disableClipboard();
    } else {
      this.enableClipboard();
    }

    return this;
  }

  isClipboardEmpty() {
    return this.clipboard.isEmpty();
  }

  getCellsInClipboard() {
    return this.clipboard.cells;
  }

  cleanClipboard() {
    this.clipboard.clean();
    return this;
  }

  copy(cells, options = {}) {
    this.clipboard.copy(cells, options);
    return this;
  }

  cut(cells, options = {}) {
    this.clipboard.cut(cells, options);
    return this;
  }

  paste(options = {}, graph = this) {
    return this.clipboard.paste(options, graph);
  } // #endregion
  // #region redo/undo


  isHistoryEnabled() {
    return !this.history.disabled;
  }

  enableHistory() {
    this.history.enable();
    return this;
  }

  disableHistory() {
    this.history.disable();
    return this;
  }

  toggleHistory(enabled) {
    if (enabled != null) {
      if (enabled !== this.isHistoryEnabled()) {
        if (enabled) {
          this.enableHistory();
        } else {
          this.disableHistory();
        }
      }
    } else if (this.isHistoryEnabled()) {
      this.disableHistory();
    } else {
      this.enableHistory();
    }

    return this;
  }

  undo(options = {}) {
    this.history.undo(options);
    return this;
  }

  undoAndCancel(options = {}) {
    this.history.cancel(options);
    return this;
  }

  redo(options = {}) {
    this.history.redo(options);
    return this;
  }

  canUndo() {
    return this.history.canUndo();
  }

  canRedo() {
    return this.history.canRedo();
  }

  cleanHistory(options = {}) {
    this.history.clean(options);
  } // #endregion
  // #region keyboard


  isKeyboardEnabled() {
    return !this.keyboard.disabled;
  }

  enableKeyboard() {
    this.keyboard.enable();
    return this;
  }

  disableKeyboard() {
    this.keyboard.disable();
    return this;
  }

  toggleKeyboard(enabled) {
    if (enabled != null) {
      if (enabled !== this.isKeyboardEnabled()) {
        if (enabled) {
          this.enableKeyboard();
        } else {
          this.disableKeyboard();
        }
      }
    } else if (this.isKeyboardEnabled()) {
      this.disableKeyboard();
    } else {
      this.enableKeyboard();
    }

    return this;
  }

  bindKey(keys, callback, action) {
    this.keyboard.on(keys, callback, action);
    return this;
  }

  unbindKey(keys, action) {
    this.keyboard.off(keys, action);
    return this;
  } // #endregion
  // #region mousewheel


  isMouseWheelEnabled() {
    return !this.mousewheel.disabled;
  }

  enableMouseWheel() {
    this.mousewheel.enable();
    return this;
  }

  disableMouseWheel() {
    this.mousewheel.disable();
    return this;
  }

  toggleMouseWheel(enabled) {
    if (enabled == null) {
      if (this.isMouseWheelEnabled()) {
        this.disableMouseWheel();
      } else {
        this.enableMouseWheel();
      }
    } else if (enabled) {
      this.enableMouseWheel();
    } else {
      this.disableMouseWheel();
    }

    return this;
  } // #endregion
  // #region panning


  isPannable() {
    const scroller = this.scroller.widget;

    if (scroller) {
      return this.scroller.pannable;
    }

    return this.panning.pannable;
  }

  enablePanning() {
    const scroller = this.scroller.widget;

    if (scroller) {
      this.scroller.enablePanning();
    } else {
      this.panning.enablePanning();
    }

    return this;
  }

  disablePanning() {
    const scroller = this.scroller.widget;

    if (scroller) {
      this.scroller.disablePanning();
    } else {
      this.panning.disablePanning();
    }

    return this;
  }

  togglePanning(pannable) {
    if (pannable == null) {
      if (this.isPannable()) {
        this.disablePanning();
      } else {
        this.enablePanning();
      }
    } else if (pannable !== this.isPannable()) {
      if (pannable) {
        this.enablePanning();
      } else {
        this.disablePanning();
      }
    }

    return this;
  } // #endregion
  // #region scroller


  lockScroller() {
    var _a;

    (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.lock();
  }

  unlockScroller() {
    var _a;

    (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.unlock();
  }

  updateScroller() {
    var _a;

    (_a = this.scroller.widget) === null || _a === void 0 ? void 0 : _a.update();
  }

  getScrollbarPosition() {
    const scroller = this.scroller.widget;
    return scroller.scrollbarPosition();
  }

  setScrollbarPosition(left, top, options) {
    const scroller = this.scroller.widget;
    scroller.scrollbarPosition(left, top, options);
    return this;
  }
  /**
   * Try to scroll to ensure that the position (x,y) on the graph (in local
   * coordinates) is at the center of the viewport. If only one of the
   * coordinates is specified, only scroll in the specified dimension and
   * keep the other coordinate unchanged.
   */


  scrollToPoint(x, y, options) {
    const scroller = this.scroller.widget;
    scroller.scrollToPoint(x, y, options);
    return this;
  }
  /**
   * Try to scroll to ensure that the center of graph content is at the
   * center of the viewport.
   */


  scrollToContent(options) {
    const scroller = this.scroller.widget;
    scroller.scrollToContent(options);
    return this;
  }
  /**
   * Try to scroll to ensure that the center of cell is at the center of
   * the viewport.
   */


  scrollToCell(cell, options) {
    const scroller = this.scroller.widget;
    scroller.scrollToCell(cell, options);
    return this;
  }

  transitionToPoint(x, y, options) {
    const scroller = this.scroller.widget;
    scroller.transitionToPoint(x, y, options);
    return this;
  }

  transitionToRect(rect, options = {}) {
    const scroller = this.scroller.widget;
    scroller.transitionToRect(rect, options);
    return this;
  } // #endregion
  // #region selection


  isSelectionEnabled() {
    return !this.selection.disabled;
  }

  enableSelection() {
    this.selection.enable();
    return this;
  }

  disableSelection() {
    this.selection.disable();
    return this;
  }

  toggleSelection(enabled) {
    if (enabled != null) {
      if (enabled !== this.isSelectionEnabled()) {
        if (enabled) {
          this.enableSelection();
        } else {
          this.disableSelection();
        }
      }
    } else if (this.isSelectionEnabled()) {
      this.disableSelection();
    } else {
      this.enableSelection();
    }

    return this;
  }

  isMultipleSelection() {
    return this.selection.isMultiple();
  }

  enableMultipleSelection() {
    this.selection.enableMultiple();
    return this;
  }

  disableMultipleSelection() {
    this.selection.disableMultiple();
    return this;
  }

  toggleMultipleSelection(multiple) {
    if (multiple != null) {
      if (multiple !== this.isMultipleSelection()) {
        if (multiple) {
          this.enableMultipleSelection();
        } else {
          this.disableMultipleSelection();
        }
      }
    } else if (this.isMultipleSelection()) {
      this.disableMultipleSelection();
    } else {
      this.enableMultipleSelection();
    }

    return this;
  }

  isSelectionMovable() {
    return this.selection.widget.options.movable !== false;
  }

  enableSelectionMovable() {
    this.selection.widget.options.movable = true;
    return this;
  }

  disableSelectionMovable() {
    this.selection.widget.options.movable = false;
    return this;
  }

  toggleSelectionMovable(movable) {
    if (movable != null) {
      if (movable !== this.isSelectionMovable()) {
        if (movable) {
          this.enableSelectionMovable();
        } else {
          this.disableSelectionMovable();
        }
      }
    } else if (this.isSelectionMovable()) {
      this.disableSelectionMovable();
    } else {
      this.enableSelectionMovable();
    }

    return this;
  }

  isRubberbandEnabled() {
    return !this.selection.rubberbandDisabled;
  }

  enableRubberband() {
    this.selection.enableRubberband();
    return this;
  }

  disableRubberband() {
    this.selection.disableRubberband();
    return this;
  }

  toggleRubberband(enabled) {
    if (enabled != null) {
      if (enabled !== this.isRubberbandEnabled()) {
        if (enabled) {
          this.enableRubberband();
        } else {
          this.disableRubberband();
        }
      }
    } else if (this.isRubberbandEnabled()) {
      this.disableRubberband();
    } else {
      this.enableRubberband();
    }

    return this;
  }

  isStrictRubberband() {
    return this.selection.widget.options.strict === true;
  }

  enableStrictRubberband() {
    this.selection.widget.options.strict = true;
    return this;
  }

  disableStrictRubberband() {
    this.selection.widget.options.strict = false;
    return this;
  }

  toggleStrictRubberband(strict) {
    if (strict != null) {
      if (strict !== this.isStrictRubberband()) {
        if (strict) {
          this.enableStrictRubberband();
        } else {
          this.disableStrictRubberband();
        }
      }
    } else if (this.isStrictRubberband()) {
      this.disableStrictRubberband();
    } else {
      this.enableStrictRubberband();
    }

    return this;
  }

  setRubberbandModifiers(modifiers) {
    this.selection.setModifiers(modifiers);
  }

  setSelectionFilter(filter) {
    this.selection.setFilter(filter);
    return this;
  }

  setSelectionDisplayContent(content) {
    this.selection.setContent(content);
    return this;
  }

  isSelectionEmpty() {
    return this.selection.isEmpty();
  }

  cleanSelection(options) {
    this.selection.clean(options);
    return this;
  }

  resetSelection(cells, options) {
    this.selection.reset(cells, options);
    return this;
  }

  getSelectedCells() {
    return this.selection.cells;
  }

  getSelectedCellCount() {
    return this.selection.length;
  }

  isSelected(cell) {
    return this.selection.isSelected(cell);
  }

  select(cells, options) {
    this.selection.select(cells, options);
    return this;
  }

  unselect(cells, options) {
    this.selection.unselect(cells, options);
    return this;
  } // #endregion
  // #region snapline


  isSnaplineEnabled() {
    return !this.snapline.widget.disabled;
  }

  enableSnapline() {
    this.snapline.widget.enable();
    return this;
  }

  disableSnapline() {
    this.snapline.widget.disable();
    return this;
  }

  toggleSnapline(enabled) {
    if (enabled != null) {
      if (enabled !== this.isSnaplineEnabled()) {
        if (enabled) {
          this.enableSnapline();
        } else {
          this.disableSnapline();
        }
      }
    } else {
      if (this.isSnaplineEnabled()) {
        this.disableSnapline();
      } else {
        this.enableSnapline();
      }

      return this;
    }
  }

  hideSnapline() {
    this.snapline.widget.hide();
    return this;
  }

  setSnaplineFilter(filter) {
    this.snapline.widget.setFilter(filter);
    return this;
  }

  isSnaplineOnResizingEnabled() {
    return this.snapline.widget.options.resizing === true;
  }

  enableSnaplineOnResizing() {
    this.snapline.widget.options.resizing = true;
    return this;
  }

  disableSnaplineOnResizing() {
    this.snapline.widget.options.resizing = false;
    return this;
  }

  toggleSnaplineOnResizing(enableOnResizing) {
    if (enableOnResizing != null) {
      if (enableOnResizing !== this.isSnaplineOnResizingEnabled()) {
        if (enableOnResizing) {
          this.enableSnaplineOnResizing();
        } else {
          this.disableSnaplineOnResizing();
        }
      }
    } else if (this.isSnaplineOnResizingEnabled()) {
      this.disableSnaplineOnResizing();
    } else {
      this.enableSnaplineOnResizing();
    }

    return this;
  }
  /**
   * @deprecated
   * @see Snapline.Options.sharp
   */


  isSharpSnapline() {
    return this.snapline.widget.options.sharp === true;
  }
  /**
   * @deprecated
   * @see Snapline.Options.sharp
   */


  enableSharpSnapline() {
    this.snapline.widget.options.sharp = true;
    return this;
  }
  /**
   * @deprecated
   * @see Snapline.Options.sharp
   */


  disableSharpSnapline() {
    this.snapline.widget.options.sharp = false;
    return this;
  }
  /**
   * @deprecated
   * @see Snapline.Options.sharp
   */


  toggleSharpSnapline(sharp) {
    if (sharp != null) {
      if (sharp !== this.isSharpSnapline()) {
        if (sharp) {
          this.enableSharpSnapline();
        } else {
          this.disableSharpSnapline();
        }
      }
    } else if (this.isSharpSnapline()) {
      this.disableSharpSnapline();
    } else {
      this.enableSharpSnapline();
    }

    return this;
  }

  getSnaplineTolerance() {
    return this.snapline.widget.options.tolerance;
  }

  setSnaplineTolerance(tolerance) {
    this.snapline.widget.options.tolerance = tolerance;
    return this;
  } // #endregion
  // #region tools


  removeTools() {
    this.emit('tools:remove');
    return this;
  }

  hideTools() {
    this.emit('tools:hide');
    return this;
  }

  showTools() {
    this.emit('tools:show');
    return this;
  } // #endregion
  // #region format


  toSVG(callback, options = {}) {
    this.format.toSVG(callback, options);
  }

  toDataURL(callback, options) {
    this.format.toDataURL(callback, options);
  }

  toPNG(callback, options = {}) {
    this.format.toPNG(callback, options);
  }

  toJPEG(callback, options = {}) {
    this.format.toJPEG(callback, options);
  } // #endregion
  // #region print


  printPreview(options) {
    this.print.show(options);
  } // #endregion
  // #region dispose


  dispose() {
    this.clearCells();
    this.off();
    this.css.dispose();
    this.hook.dispose();
    this.defs.dispose();
    this.grid.dispose();
    this.coord.dispose();
    this.transform.dispose();
    this.knob.dispose();
    this.highlight.dispose();
    this.background.dispose();
    this.clipboard.dispose();
    this.snapline.dispose();
    this.selection.dispose();
    this.history.dispose();
    this.keyboard.dispose();
    this.mousewheel.dispose();
    this.print.dispose();
    this.format.dispose();
    this.minimap.dispose();
    this.panning.dispose();
    this.scroller.dispose();
    this.view.dispose();
    this.renderer.dispose();
    this.size.dispose();
  }

}

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "lockScroller", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "unlockScroller", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "updateScroller", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "getScrollbarPosition", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "setScrollbarPosition", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "scrollToPoint", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "scrollToContent", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "scrollToCell", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "transitionToPoint", null);

__decorate([_decorator__WEBPACK_IMPORTED_MODULE_10__.Decorator.checkScroller()], Graph.prototype, "transitionToRect", null);

__decorate([_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()], Graph.prototype, "dispose", null);

(function (Graph) {
  /* eslint-disable @typescript-eslint/no-unused-vars */
  Graph.View = _view__WEBPACK_IMPORTED_MODULE_9__.GraphView;
  Graph.Hook = _hook__WEBPACK_IMPORTED_MODULE_12__.Hook;
  Graph.Renderer = _renderer__WEBPACK_IMPORTED_MODULE_21__.Renderer;
  Graph.Keyboard = _keyboard__WEBPACK_IMPORTED_MODULE_17__.Keyboard;
  Graph.MouseWheel = _mousewheel__WEBPACK_IMPORTED_MODULE_19__.MouseWheel;
  Graph.BaseManager = _base__WEBPACK_IMPORTED_MODULE_8__.Base;
  Graph.DefsManager = _defs__WEBPACK_IMPORTED_MODULE_14__.DefsManager;
  Graph.GridManager = _grid__WEBPACK_IMPORTED_MODULE_15__.GridManager;
  Graph.CoordManager = _coord__WEBPACK_IMPORTED_MODULE_16__.CoordManager;
  Graph.PrintManager = _print__WEBPACK_IMPORTED_MODULE_18__.PrintManager;
  Graph.FormatManager = _format__WEBPACK_IMPORTED_MODULE_20__.FormatManager;
  Graph.MiniMapManager = _minimap__WEBPACK_IMPORTED_MODULE_23__.MiniMapManager;
  Graph.HistoryManager = _history__WEBPACK_IMPORTED_MODULE_22__.HistoryManager;
  Graph.SnaplineManager = _snapline__WEBPACK_IMPORTED_MODULE_24__.SnaplineManager;
  Graph.ScrollerManager = _scroller__WEBPACK_IMPORTED_MODULE_25__.ScrollerManager;
  Graph.ClipboardManager = _clipboard__WEBPACK_IMPORTED_MODULE_29__.ClipboardManager;
  Graph.TransformManager = _transform__WEBPACK_IMPORTED_MODULE_28__.TransformManager;
  Graph.HighlightManager = _highlight__WEBPACK_IMPORTED_MODULE_27__.HighlightManager;
  Graph.BackgroundManager = _background__WEBPACK_IMPORTED_MODULE_30__.BackgroundManager;
  Graph.SelectionManager = _selection__WEBPACK_IMPORTED_MODULE_26__.SelectionManager;
})(Graph || (Graph = {}));

(function (Graph) {
  Graph.toStringTag = `X6.${Graph.name}`;

  function isGraph(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Graph) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const graph = instance;

    if ((tag == null || tag === Graph.toStringTag) && graph.hook != null && graph.view != null && graph.model != null) {
      return true;
    }

    return false;
  }

  Graph.isGraph = isGraph;
})(Graph || (Graph = {}));

(function (Graph) {
  function render(options, data) {
    const graph = options instanceof HTMLElement ? new Graph({
      container: options
    }) : new Graph(options);

    if (data != null) {
      graph.fromJSON(data);
    }

    return graph;
  }

  Graph.render = render;
})(Graph || (Graph = {}));

(function (Graph) {
  Graph.registerNode = _model_node__WEBPACK_IMPORTED_MODULE_3__.Node.registry.register;
  Graph.registerEdge = _model_edge__WEBPACK_IMPORTED_MODULE_4__.Edge.registry.register;
  Graph.registerView = _view_cell__WEBPACK_IMPORTED_MODULE_5__.CellView.registry.register;
  Graph.registerAttr = _registry__WEBPACK_IMPORTED_MODULE_6__.Attr.registry.register;
  Graph.registerGrid = _registry__WEBPACK_IMPORTED_MODULE_6__.Grid.registry.register;
  Graph.registerFilter = _registry__WEBPACK_IMPORTED_MODULE_6__.Filter.registry.register;
  Graph.registerNodeTool = _registry__WEBPACK_IMPORTED_MODULE_6__.NodeTool.registry.register;
  Graph.registerEdgeTool = _registry__WEBPACK_IMPORTED_MODULE_6__.EdgeTool.registry.register;
  Graph.registerBackground = _registry__WEBPACK_IMPORTED_MODULE_6__.Background.registry.register;
  Graph.registerHighlighter = _registry__WEBPACK_IMPORTED_MODULE_6__.Highlighter.registry.register;
  Graph.registerPortLayout = _registry__WEBPACK_IMPORTED_MODULE_6__.PortLayout.registry.register;
  Graph.registerPortLabelLayout = _registry__WEBPACK_IMPORTED_MODULE_6__.PortLabelLayout.registry.register;
  Graph.registerMarker = _registry__WEBPACK_IMPORTED_MODULE_6__.Marker.registry.register;
  Graph.registerRouter = _registry__WEBPACK_IMPORTED_MODULE_6__.Router.registry.register;
  Graph.registerConnector = _registry__WEBPACK_IMPORTED_MODULE_6__.Connector.registry.register;
  Graph.registerAnchor = _registry__WEBPACK_IMPORTED_MODULE_6__.NodeAnchor.registry.register;
  Graph.registerEdgeAnchor = _registry__WEBPACK_IMPORTED_MODULE_6__.EdgeAnchor.registry.register;
  Graph.registerConnectionPoint = _registry__WEBPACK_IMPORTED_MODULE_6__.ConnectionPoint.registry.register;
  Graph.registerConnectionStrategy = _registry__WEBPACK_IMPORTED_MODULE_6__.ConnectionStrategy.registry.register;
  Graph.registerHTMLComponent = _shape_standard_html__WEBPACK_IMPORTED_MODULE_7__.HTML.componentRegistry.register;
})(Graph || (Graph = {}));

(function (Graph) {
  Graph.unregisterNode = _model_node__WEBPACK_IMPORTED_MODULE_3__.Node.registry.unregister;
  Graph.unregisterEdge = _model_edge__WEBPACK_IMPORTED_MODULE_4__.Edge.registry.unregister;
  Graph.unregisterView = _view_cell__WEBPACK_IMPORTED_MODULE_5__.CellView.registry.unregister;
  Graph.unregisterAttr = _registry__WEBPACK_IMPORTED_MODULE_6__.Attr.registry.unregister;
  Graph.unregisterGrid = _registry__WEBPACK_IMPORTED_MODULE_6__.Grid.registry.unregister;
  Graph.unregisterFilter = _registry__WEBPACK_IMPORTED_MODULE_6__.Filter.registry.unregister;
  Graph.unregisterNodeTool = _registry__WEBPACK_IMPORTED_MODULE_6__.NodeTool.registry.unregister;
  Graph.unregisterEdgeTool = _registry__WEBPACK_IMPORTED_MODULE_6__.EdgeTool.registry.unregister;
  Graph.unregisterBackground = _registry__WEBPACK_IMPORTED_MODULE_6__.Background.registry.unregister;
  Graph.unregisterHighlighter = _registry__WEBPACK_IMPORTED_MODULE_6__.Highlighter.registry.unregister;
  Graph.unregisterPortLayout = _registry__WEBPACK_IMPORTED_MODULE_6__.PortLayout.registry.unregister;
  Graph.unregisterPortLabelLayout = _registry__WEBPACK_IMPORTED_MODULE_6__.PortLabelLayout.registry.unregister;
  Graph.unregisterMarker = _registry__WEBPACK_IMPORTED_MODULE_6__.Marker.registry.unregister;
  Graph.unregisterRouter = _registry__WEBPACK_IMPORTED_MODULE_6__.Router.registry.unregister;
  Graph.unregisterConnector = _registry__WEBPACK_IMPORTED_MODULE_6__.Connector.registry.unregister;
  Graph.unregisterAnchor = _registry__WEBPACK_IMPORTED_MODULE_6__.NodeAnchor.registry.unregister;
  Graph.unregisterEdgeAnchor = _registry__WEBPACK_IMPORTED_MODULE_6__.EdgeAnchor.registry.unregister;
  Graph.unregisterConnectionPoint = _registry__WEBPACK_IMPORTED_MODULE_6__.ConnectionPoint.registry.unregister;
  Graph.unregisterConnectionStrategy = _registry__WEBPACK_IMPORTED_MODULE_6__.ConnectionStrategy.registry.unregister;
  Graph.unregisterHTMLComponent = _shape_standard_html__WEBPACK_IMPORTED_MODULE_7__.HTML.componentRegistry.unregister;
})(Graph || (Graph = {}));

/***/ }),

/***/ 65154:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/grid.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GridManager": () => (/* binding */ GridManager)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




class GridManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
  get elem() {
    return this.view.grid;
  }

  get grid() {
    return this.options.grid;
  }

  init() {
    this.startListening();
    this.draw(this.grid);
  }

  startListening() {
    this.graph.on('scale', this.update, this);
    this.graph.on('translate', this.update, this);
  }

  stopListening() {
    this.graph.off('scale', this.update, this);
    this.graph.off('translate', this.update, this);
  }

  setVisible(visible) {
    if (this.grid.visible !== visible) {
      this.grid.visible = visible;
      this.update();
    }
  }

  getGridSize() {
    return this.grid.size;
  }

  setGridSize(size) {
    this.grid.size = Math.max(size, 1);
    this.update();
  }

  show() {
    this.setVisible(true);
    this.update();
  }

  hide() {
    this.setVisible(false);
    this.update();
  }

  clear() {
    this.elem.style.backgroundImage = '';
  }

  draw(options) {
    this.clear();
    this.instance = null;
    Object.assign(this.grid, options);
    this.patterns = this.resolveGrid(options);
    this.update();
  }

  update(options = {}) {
    const gridSize = this.grid.size;

    if (gridSize <= 1 || !this.grid.visible) {
      return this.clear();
    }

    const ctm = this.graph.matrix();
    const grid = this.getInstance();
    const items = Array.isArray(options) ? options : [options];
    this.patterns.forEach((settings, index) => {
      const id = `pattern_${index}`;
      const sx = ctm.a || 1;
      const sy = ctm.d || 1;

      const {
        update,
        markup
      } = settings,
            others = __rest(settings, ["update", "markup"]);

      const options = Object.assign(Object.assign(Object.assign({}, others), items[index]), {
        sx,
        sy,
        ox: ctm.e || 0,
        oy: ctm.f || 0,
        width: gridSize * sx,
        height: gridSize * sy
      });

      if (!grid.has(id)) {
        grid.add(id, _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create('pattern', {
          id,
          patternUnits: 'userSpaceOnUse'
        }, _util__WEBPACK_IMPORTED_MODULE_1__.Vector.createVectors(markup)).node);
      }

      const patternElem = grid.get(id);

      if (typeof update === 'function') {
        update(patternElem.childNodes[0], options);
      }

      let x = options.ox % options.width;

      if (x < 0) {
        x += options.width;
      }

      let y = options.oy % options.height;

      if (y < 0) {
        y += options.height;
      }

      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.attr(patternElem, {
        x,
        y,
        width: options.width,
        height: options.height
      });
    });
    const base64 = new XMLSerializer().serializeToString(grid.root);
    const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;
    this.elem.style.backgroundImage = url;
  }

  getInstance() {
    if (!this.instance) {
      this.instance = new _registry__WEBPACK_IMPORTED_MODULE_0__.Grid();
    }

    return this.instance;
  }

  resolveGrid(options) {
    if (!options) {
      return [];
    }

    const type = options.type;

    if (type == null) {
      return [Object.assign(Object.assign({}, _registry__WEBPACK_IMPORTED_MODULE_0__.Grid.presets.dot), options.args)];
    }

    const items = _registry__WEBPACK_IMPORTED_MODULE_0__.Grid.registry.get(type);

    if (items) {
      let args = options.args || [];

      if (!Array.isArray(args)) {
        args = [args];
      }

      return Array.isArray(items) ? items.map((item, index) => Object.assign(Object.assign({}, item), args[index])) : [Object.assign(Object.assign({}, items), args[0])];
    }

    return _registry__WEBPACK_IMPORTED_MODULE_0__.Grid.registry.onNotFound(type);
  }

  dispose() {
    this.stopListening();
    this.clear();
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_2__.Base.dispose()], GridManager.prototype, "dispose", null);

/***/ }),

/***/ 95358:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/highlight.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HighlightManager": () => (/* binding */ HighlightManager)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class HighlightManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
  constructor() {
    super(...arguments);
    this.highlights = {};
  }

  init() {
    this.startListening();
  }

  startListening() {
    this.graph.on('cell:highlight', this.onCellHighlight, this);
    this.graph.on('cell:unhighlight', this.onCellUnhighlight, this);
  }

  stopListening() {
    this.graph.off('cell:highlight', this.onCellHighlight, this);
    this.graph.off('cell:unhighlight', this.onCellUnhighlight, this);
  }

  onCellHighlight({
    view: cellView,
    magnet,
    options = {}
  }) {
    const resolved = this.resolveHighlighter(options);

    if (!resolved) {
      return;
    }

    const key = this.getHighlighterId(magnet, resolved);

    if (!this.highlights[key]) {
      const highlighter = resolved.highlighter;
      highlighter.highlight(cellView, magnet, Object.assign({}, resolved.args));
      this.highlights[key] = {
        cellView,
        magnet,
        highlighter,
        args: resolved.args
      };
    }
  }

  onCellUnhighlight({
    magnet,
    options = {}
  }) {
    const resolved = this.resolveHighlighter(options);

    if (!resolved) {
      return;
    }

    const id = this.getHighlighterId(magnet, resolved);
    this.unhighlight(id);
  }

  resolveHighlighter(options) {
    const graphOptions = this.options;
    let highlighterDef = options.highlighter;

    if (highlighterDef == null) {
      // check for built-in types
      const type = options.type;
      highlighterDef = type && graphOptions.highlighting[type] || graphOptions.highlighting.default;
    }

    if (highlighterDef == null) {
      return null;
    }

    const def = typeof highlighterDef === 'string' ? {
      name: highlighterDef
    } : highlighterDef;
    const name = def.name;
    const highlighter = _registry__WEBPACK_IMPORTED_MODULE_1__.Highlighter.registry.get(name);

    if (highlighter == null) {
      return _registry__WEBPACK_IMPORTED_MODULE_1__.Highlighter.registry.onNotFound(name);
    }

    _registry__WEBPACK_IMPORTED_MODULE_1__.Highlighter.check(name, highlighter);
    return {
      name,
      highlighter,
      args: def.args || {}
    };
  }

  getHighlighterId(magnet, options) {
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.ensureId(magnet);
    return options.name + magnet.id + JSON.stringify(options.args);
  }

  unhighlight(id) {
    const highlight = this.highlights[id];

    if (highlight) {
      highlight.highlighter.unhighlight(highlight.cellView, highlight.magnet, highlight.args);
      delete this.highlights[id];
    }
  }

  dispose() {
    Object.keys(this.highlights).forEach(id => this.unhighlight(id));
    this.stopListening();
  }

}

__decorate([HighlightManager.dispose()], HighlightManager.prototype, "dispose", null);

/***/ }),

/***/ 42:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/history.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HistoryManager": () => (/* binding */ HistoryManager)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ 57566);
/* harmony import */ var _model_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/model */ 69314);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




class HistoryManager extends _common__WEBPACK_IMPORTED_MODULE_1__.Basecoat {
  constructor(options) {
    super();
    this.batchCommands = null;
    this.batchLevel = 0;
    this.lastBatchIndex = -1;
    this.freezed = false;
    this.handlers = [];
    this.graph = options.graph;
    this.model = options.graph.model;
    this.options = Util.getOptions(options);
    this.validator = new HistoryManager.Validator({
      history: this,
      cancelInvalid: this.options.cancelInvalid
    });
    this.clean();
    this.startListening();
  }

  get disabled() {
    return this.options.enabled !== true;
  }

  enable() {
    if (this.disabled) {
      this.options.enabled = true;
    }
  }

  disable() {
    if (!this.disabled) {
      this.options.enabled = false;
    }
  }

  undo(options = {}) {
    if (!this.disabled) {
      const cmd = this.undoStack.pop();

      if (cmd) {
        this.revertCommand(cmd, options);
        this.redoStack.push(cmd);
        this.notify('undo', cmd, options);
      }
    }

    return this;
  }

  redo(options = {}) {
    if (!this.disabled) {
      const cmd = this.redoStack.pop();

      if (cmd) {
        this.applyCommand(cmd, options);
        this.undoStack.push(cmd);
        this.notify('redo', cmd, options);
      }
    }

    return this;
  }
  /**
   * Same as `undo()` but does not store the undo-ed command to the
   * `redoStack`. Canceled command therefore cannot be redo-ed.
   */


  cancel(options = {}) {
    if (!this.disabled) {
      const cmd = this.undoStack.pop();

      if (cmd) {
        this.revertCommand(cmd, options);
        this.redoStack = [];
        this.notify('cancel', cmd, options);
      }
    }

    return this;
  }

  clean(options = {}) {
    this.undoStack = [];
    this.redoStack = [];
    this.notify('clean', null, options);
    return this;
  }

  canUndo() {
    return !this.disabled && this.undoStack.length > 0;
  }

  canRedo() {
    return !this.disabled && this.redoStack.length > 0;
  }

  validate(events, ...callbacks) {
    this.validator.validate(events, ...callbacks);
    return this;
  }

  dispose() {
    this.validator.dispose();
    this.clean();
    this.stopListening();
  }

  startListening() {
    this.model.on('batch:start', this.initBatchCommand, this);
    this.model.on('batch:stop', this.storeBatchCommand, this);

    if (this.options.eventNames) {
      this.options.eventNames.forEach((name, index) => {
        this.handlers[index] = this.addCommand.bind(this, name);
        this.model.on(name, this.handlers[index]);
      });
    }

    this.validator.on('invalid', args => this.trigger('invalid', args));
  }

  stopListening() {
    this.model.off('batch:start', this.initBatchCommand, this);
    this.model.off('batch:stop', this.storeBatchCommand, this);

    if (this.options.eventNames) {
      this.options.eventNames.forEach((name, index) => {
        this.model.off(name, this.handlers[index]);
      });
      this.handlers.length = 0;
    }

    this.validator.off('invalid');
  }

  createCommand(options) {
    return {
      batch: options ? options.batch : false,
      data: {}
    };
  }

  revertCommand(cmd, options) {
    this.freezed = true;
    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];

    for (let i = cmds.length - 1; i >= 0; i -= 1) {
      const cmd = cmds[i];
      const localOptions = Object.assign(Object.assign({}, options), _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.pick(cmd.options, this.options.revertOptionsList || []));
      this.executeCommand(cmd, true, localOptions);
    }

    this.freezed = false;
  }

  applyCommand(cmd, options) {
    this.freezed = true;
    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];

    for (let i = 0; i < cmds.length; i += 1) {
      const cmd = cmds[i];
      const localOptions = Object.assign(Object.assign({}, options), _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.pick(cmd.options, this.options.applyOptionsList || []));
      this.executeCommand(cmd, false, localOptions);
    }

    this.freezed = false;
  }

  executeCommand(cmd, revert, options) {
    const model = this.model; // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)

    const cell = model.getCell(cmd.data.id);
    const event = cmd.event;

    if (Util.isAddEvent(event) && revert || Util.isRemoveEvent(event) && !revert) {
      cell.remove(options);
    } else if (Util.isAddEvent(event) && !revert || Util.isRemoveEvent(event) && revert) {
      const data = cmd.data;

      if (data.node) {
        model.addNode(data.props, options);
      } else if (data.edge) {
        model.addEdge(data.props, options);
      }
    } else if (Util.isChangeEvent(event)) {
      const data = cmd.data;
      const key = data.key;

      if (key) {
        const value = revert ? data.prev[key] : data.next[key];
        cell.prop(key, value, options);
      }
    } else {
      const executeCommand = this.options.executeCommand;

      if (executeCommand) {
        _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(executeCommand, this, cmd, revert, options);
      }
    }
  }

  addCommand(event, args) {
    if (this.freezed || this.disabled) {
      return;
    }

    const eventArgs = args;
    const options = eventArgs.options || {};

    if (options.dryrun) {
      return;
    }

    if (Util.isAddEvent(event) && this.options.ignoreAdd || Util.isRemoveEvent(event) && this.options.ignoreRemove || Util.isChangeEvent(event) && this.options.ignoreChange) {
      return;
    } // before
    // ------


    const before = this.options.beforeAddCommand;

    if (before != null && _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(before, this, event, args) === false) {
      return;
    }

    if (event === 'cell:change:*') {
      // eslint-disable-next-line
      event = `cell:change:${eventArgs.key}`;
    }

    const cell = eventArgs.cell;
    const isModelChange = _model_model__WEBPACK_IMPORTED_MODULE_2__.Model.isModel(cell);
    let cmd;

    if (this.batchCommands) {
      // In most cases we are working with same object, doing
      // same action etc. translate an object piece by piece.
      cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)]; // Check if we are start working with new object or performing different
      // action with it. Note, that command is uninitialized when lastCmdIndex
      // equals -1. In that case we are done, command we were looking for is
      // already set

      const diffId = isModelChange && !cmd.modelChange || cmd.data.id !== cell.id;
      const diffName = cmd.event !== event;

      if (this.lastBatchIndex >= 0 && (diffId || diffName)) {
        // Trying to find command first, which was performing same
        // action with the object as we are doing now with cell.
        const index = this.batchCommands.findIndex(cmd => (isModelChange && cmd.modelChange || cmd.data.id === cell.id) && cmd.event === event);

        if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {
          cmd = this.createCommand({
            batch: true
          });
        } else {
          cmd = this.batchCommands[index];
          this.batchCommands.splice(index, 1);
        }

        this.batchCommands.push(cmd);
        this.lastBatchIndex = this.batchCommands.length - 1;
      }
    } else {
      cmd = this.createCommand({
        batch: false
      });
    } // add & remove
    // ------------


    if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {
      const data = cmd.data;
      cmd.event = event;
      cmd.options = options;
      data.id = cell.id;
      data.props = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(cell.toJSON());

      if (cell.isEdge()) {
        data.edge = true;
      } else if (cell.isNode()) {
        data.node = true;
      }

      return this.push(cmd, options);
    } // change:*
    // --------


    if (Util.isChangeEvent(event)) {
      const key = args.key;
      const data = cmd.data;

      if (!cmd.batch || !cmd.event) {
        // Do this only once. Set previous data and action (also
        // serves as a flag so that we don't repeat this branche).
        cmd.event = event;
        cmd.options = options;
        data.key = key;

        if (data.prev == null) {
          data.prev = {};
        }

        data.prev[key] = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.clone(cell.previous(key));

        if (isModelChange) {
          cmd.modelChange = true;
        } else {
          data.id = cell.id;
        }
      }

      if (data.next == null) {
        data.next = {};
      }

      data.next[key] = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.clone(cell.prop(key));
      return this.push(cmd, options);
    } // others
    // ------


    const afterAddCommand = this.options.afterAddCommand;

    if (afterAddCommand) {
      _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(afterAddCommand, this, event, args, cmd);
    }

    this.push(cmd, options);
  }
  /**
   * Gather multiple changes into a single command. These commands could
   * be reverted with single `undo()` call. From the moment the function
   * is called every change made on model is not stored into the undoStack.
   * Changes are temporarily kept until `storeBatchCommand()` is called.
   */
  // eslint-disable-next-line


  initBatchCommand(options) {
    if (this.freezed) {
      return;
    }

    if (this.batchCommands) {
      this.batchLevel += 1;
    } else {
      this.batchCommands = [this.createCommand({
        batch: true
      })];
      this.batchLevel = 0;
      this.lastBatchIndex = -1;
    }
  }
  /**
   * Store changes temporarily kept in the undoStack. You have to call this
   * function as many times as `initBatchCommand()` been called.
   */


  storeBatchCommand(options) {
    if (this.freezed) {
      return;
    }

    if (this.batchCommands && this.batchLevel <= 0) {
      const cmds = this.filterBatchCommand(this.batchCommands);

      if (cmds.length > 0) {
        this.redoStack = [];
        this.undoStack.push(cmds);
        this.notify('add', cmds, options);
      }

      this.batchCommands = null;
      this.lastBatchIndex = -1;
      this.batchLevel = 0;
    } else if (this.batchCommands && this.batchLevel > 0) {
      this.batchLevel -= 1;
    }
  }

  filterBatchCommand(batchCommands) {
    let cmds = batchCommands.slice();
    const result = [];

    while (cmds.length > 0) {
      const cmd = cmds.shift();
      const evt = cmd.event;
      const id = cmd.data.id;

      if (evt != null && (id != null || cmd.modelChange)) {
        if (Util.isAddEvent(evt)) {
          const index = cmds.findIndex(c => Util.isRemoveEvent(c.event) && c.data.id === id);

          if (index >= 0) {
            cmds = cmds.filter((c, i) => index < i || c.data.id !== id);
            continue;
          }
        } else if (Util.isRemoveEvent(evt)) {
          const index = cmds.findIndex(c => Util.isAddEvent(c.event) && c.data.id === id);

          if (index >= 0) {
            cmds.splice(index, 1);
            continue;
          }
        } else if (Util.isChangeEvent(evt)) {
          const data = cmd.data;

          if (_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(data.prev, data.next)) {
            continue;
          }
        } else {// pass
        }

        result.push(cmd);
      }
    }

    return result;
  }

  notify(event, cmd, options) {
    const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];
    this.emit(event, {
      cmds,
      options
    });
    this.emit('change', {
      cmds,
      options
    });
  }

  push(cmd, options) {
    this.redoStack = [];

    if (cmd.batch) {
      this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);
      this.emit('batch', {
        cmd,
        options
      });
    } else {
      this.undoStack.push(cmd);
      this.notify('add', cmd, options);
    }
  }

}

__decorate([_common__WEBPACK_IMPORTED_MODULE_1__.Basecoat.dispose()], HistoryManager.prototype, "dispose", null);

(function (HistoryManager) {
  /**
   * Runs a set of callbacks to determine if a command is valid. This is
   * useful for checking if a certain action in your application does
   * lead to an invalid state of the graph.
   */
  class Validator extends _common__WEBPACK_IMPORTED_MODULE_1__.Basecoat {
    constructor(options) {
      super();
      this.map = {};
      this.command = options.history;
      this.cancelInvalid = options.cancelInvalid !== false;
      this.command.on('add', this.onCommandAdded, this);
    }

    onCommandAdded({
      cmds
    }) {
      return Array.isArray(cmds) ? cmds.every(cmd => this.isValidCommand(cmd)) : this.isValidCommand(cmds);
    }

    isValidCommand(cmd) {
      if (cmd.options && cmd.options.validation === false) {
        return true;
      }

      const callbacks = cmd.event && this.map[cmd.event] || [];
      let handoverErr = null;
      callbacks.forEach(routes => {
        let i = 0;

        const rollup = err => {
          const fn = routes[i];
          i += 1;

          try {
            if (fn) {
              fn(err, cmd, rollup);
            } else {
              handoverErr = err;
              return;
            }
          } catch (err) {
            rollup(err);
          }
        };

        rollup(handoverErr);
      });

      if (handoverErr) {
        if (this.cancelInvalid) {
          this.command.cancel();
        }

        this.emit('invalid', {
          err: handoverErr
        });
        return false;
      }

      return true;
    }

    validate(events, ...callbacks) {
      const evts = Array.isArray(events) ? events : events.split(/\s+/);
      callbacks.forEach(callback => {
        if (typeof callback !== 'function') {
          throw new Error(`${evts.join(' ')} requires callback functions.`);
        }
      });
      evts.forEach(event => {
        if (this.map[event] == null) {
          this.map[event] = [];
        }

        this.map[event].push(callbacks);
      });
      return this;
    }

    dispose() {
      this.command.off('add', this.onCommandAdded, this);
    }

  }

  __decorate([_common__WEBPACK_IMPORTED_MODULE_1__.Basecoat.dispose()], Validator.prototype, "dispose", null);

  HistoryManager.Validator = Validator;
})(HistoryManager || (HistoryManager = {}));

var Util;

(function (Util) {
  function isAddEvent(event) {
    return event === 'cell:added';
  }

  Util.isAddEvent = isAddEvent;

  function isRemoveEvent(event) {
    return event === 'cell:removed';
  }

  Util.isRemoveEvent = isRemoveEvent;

  function isChangeEvent(event) {
    return event != null && event.startsWith('cell:change:');
  }

  Util.isChangeEvent = isChangeEvent;

  function getOptions(options) {
    const {
      graph
    } = options,
          others = __rest(options, ["graph"]);

    const reservedNames = ['cell:added', 'cell:removed', 'cell:change:*'];
    const batchEvents = ['batch:start', 'batch:stop'];
    const eventNames = options.eventNames ? options.eventNames.filter(event => !(Util.isChangeEvent(event) || reservedNames.includes(event) || batchEvents.includes(event))) : reservedNames;
    return Object.assign(Object.assign({}, others), {
      eventNames,
      applyOptionsList: options.applyOptionsList || ['propertyPath'],
      revertOptionsList: options.revertOptionsList || ['propertyPath']
    });
  }

  Util.getOptions = getOptions;

  function sortBatchCommands(cmds) {
    const results = [];

    for (let i = 0, ii = cmds.length; i < ii; i += 1) {
      const cmd = cmds[i];
      let index = null;

      if (Util.isAddEvent(cmd.event)) {
        const id = cmd.data.id;

        for (let j = 0; j < i; j += 1) {
          if (cmds[j].data.id === id) {
            index = j;
            break;
          }
        }
      }

      if (index !== null) {
        results.splice(index, 0, cmd);
      } else {
        results.push(cmd);
      }
    }

    return results;
  }

  Util.sortBatchCommands = sortBatchCommands;
})(Util || (Util = {}));

/***/ }),

/***/ 39941:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/hook.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hook": () => (/* binding */ Hook)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _model_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/model */ 69314);
/* harmony import */ var _view_cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../view/cell */ 58670);
/* harmony import */ var _view_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/node */ 78415);
/* harmony import */ var _view_edge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../view/edge */ 32325);
/* harmony import */ var _addon_knob__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../addon/knob */ 68792);
/* harmony import */ var _addon_minimap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../addon/minimap */ 31009);
/* harmony import */ var _addon_snapline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../addon/snapline */ 29733);
/* harmony import */ var _addon_scroller__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../addon/scroller */ 55644);
/* harmony import */ var _addon_selection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../addon/selection */ 42601);
/* harmony import */ var _addon_clipboard__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../addon/clipboard */ 23677);
/* harmony import */ var _addon_transform__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../addon/transform */ 14748);
/* harmony import */ var _shape_standard_html__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../shape/standard/html */ 74057);
/* harmony import */ var _shape_standard_edge__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../shape/standard/edge */ 34973);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./base */ 94997);
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./options */ 94805);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./renderer */ 47801);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./view */ 716);
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./defs */ 70656);
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./grid */ 65154);
/* harmony import */ var _coord__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./coord */ 78642);
/* harmony import */ var _snapline__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./snapline */ 61871);
/* harmony import */ var _scroller__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./scroller */ 86949);
/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./clipboard */ 20341);
/* harmony import */ var _highlight__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./highlight */ 95358);
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./transform */ 33795);
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./selection */ 93330);
/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./background */ 26028);
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./history */ 42);
/* harmony import */ var _minimap__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./minimap */ 55933);
/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./keyboard */ 37003);
/* harmony import */ var _mousewheel__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./mousewheel */ 52222);
/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./print */ 75068);
/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./format */ 76465);
/* harmony import */ var _knob__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./knob */ 72355);
/* harmony import */ var _panning__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./panning */ 17830);
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./size */ 2682);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






































var Decorator;

(function (Decorator) {
  function hook(nullable, hookName) {
    return (target, methodName, descriptor) => {
      const raw = descriptor.value;
      const name = hookName || methodName;

      descriptor.value = function (...args) {
        const hook = this.options[name];

        if (hook != null) {
          this.getNativeValue = raw.bind(this, ...args);
          const ret = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(hook, this.graph, ...args);
          this.getNativeValue = null;

          if (ret != null || nullable === true && ret === null) {
            return ret;
          }
        }

        return raw.call(this, ...args);
      };
    };
  }

  Decorator.hook = hook;

  function after(hookName) {
    return (target, methodName, descriptor) => {
      const raw = descriptor.value;
      const name = hookName || methodName;

      descriptor.value = function (...args) {
        let ret = raw.call(this, ...args);
        const hook = this.options[name];

        if (hook != null) {
          ret = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(hook, this.graph, ...args) && ret;
        }

        return ret;
      };
    };
  }

  Decorator.after = after;
})(Decorator || (Decorator = {}));

class Hook extends _base__WEBPACK_IMPORTED_MODULE_14__.Base {
  createModel() {
    if (this.options.model) {
      return this.options.model;
    }

    const model = new _model_model__WEBPACK_IMPORTED_MODULE_1__.Model();
    model.graph = this.graph;
    return model;
  }

  createView() {
    return new _view__WEBPACK_IMPORTED_MODULE_17__.GraphView(this.graph);
  }

  createRenderer() {
    return new _renderer__WEBPACK_IMPORTED_MODULE_16__.Renderer(this.graph);
  }

  createDefsManager() {
    return new _defs__WEBPACK_IMPORTED_MODULE_18__.DefsManager(this.graph);
  }

  createGridManager() {
    return new _grid__WEBPACK_IMPORTED_MODULE_19__.GridManager(this.graph);
  }

  createCoordManager() {
    return new _coord__WEBPACK_IMPORTED_MODULE_20__.CoordManager(this.graph);
  }

  createKnobManager() {
    return new _knob__WEBPACK_IMPORTED_MODULE_34__.KnobManager(this.graph);
  }

  createTransform(node, widgetOptions) {
    const options = this.getTransformOptions(node);

    if (options.resizable || options.rotatable) {
      return new _addon_transform__WEBPACK_IMPORTED_MODULE_11__.Transform(Object.assign(Object.assign({
        node,
        graph: this.graph
      }, options), widgetOptions));
    }

    if (options.clearAll) {
      _addon_transform__WEBPACK_IMPORTED_MODULE_11__.Transform.removeInstances(this.graph);
    }

    return null;
  }

  createKnob(node, widgetOptions) {
    const options = _options__WEBPACK_IMPORTED_MODULE_15__.Options.parseOptionGroup(this.graph, node, this.options.knob);
    const localOptions = Object.assign(Object.assign({}, options), widgetOptions);

    if (localOptions.clearAll) {
      _addon_knob__WEBPACK_IMPORTED_MODULE_5__.Knob.removeInstances(this.graph);
    }

    localOptions.clearAll = false;
    const knob = node.prop('knob');
    const widgets = [];
    const meta = Array.isArray(knob) ? knob : [knob];
    meta.forEach((knob, index) => {
      if (knob) {
        if (knob.enabled === false) {
          return;
        }

        if (typeof knob.enabled === 'function' && knob.enabled.call(this.graph, node) === false) {
          return;
        }
      } else {
        return;
      }

      if (options.enabled) {
        widgets.push(new _addon_knob__WEBPACK_IMPORTED_MODULE_5__.Knob(Object.assign({
          node,
          index,
          graph: this.graph
        }, localOptions)));
      }
    });
    return widgets;
  }

  getTransformOptions(node) {
    const resizing = _options__WEBPACK_IMPORTED_MODULE_15__.Options.parseOptionGroup(this.graph, node, this.options.resizing);
    const rotating = _options__WEBPACK_IMPORTED_MODULE_15__.Options.parseOptionGroup(this.graph, node, this.options.rotating);
    const transforming = _options__WEBPACK_IMPORTED_MODULE_15__.Options.parseOptionGroup(this.graph, node, this.options.transforming);
    const options = Object.assign(Object.assign({}, transforming), {
      resizable: resizing.enabled,
      minWidth: resizing.minWidth,
      maxWidth: resizing.maxWidth,
      minHeight: resizing.minHeight,
      maxHeight: resizing.maxHeight,
      orthogonalResizing: resizing.orthogonal,
      restrictedResizing: resizing.restrict != null ? resizing.restrict : resizing.restricted,
      autoScrollOnResizing: resizing.autoScroll,
      preserveAspectRatio: resizing.preserveAspectRatio,
      allowReverse: resizing.allowReverse,
      rotatable: rotating.enabled,
      rotateGrid: rotating.grid
    });
    return options;
  }

  createTransformManager() {
    return new _transform__WEBPACK_IMPORTED_MODULE_25__.TransformManager(this.graph);
  }

  createHighlightManager() {
    return new _highlight__WEBPACK_IMPORTED_MODULE_24__.HighlightManager(this.graph);
  }

  createBackgroundManager() {
    return new _background__WEBPACK_IMPORTED_MODULE_27__.BackgroundManager(this.graph);
  }

  createClipboard() {
    return new _addon_clipboard__WEBPACK_IMPORTED_MODULE_10__.Clipboard();
  }

  createClipboardManager() {
    return new _clipboard__WEBPACK_IMPORTED_MODULE_23__.ClipboardManager(this.graph);
  }

  createSnapline() {
    return new _addon_snapline__WEBPACK_IMPORTED_MODULE_7__.Snapline(Object.assign({
      graph: this.graph
    }, this.options.snapline));
  }

  createSnaplineManager() {
    return new _snapline__WEBPACK_IMPORTED_MODULE_21__.SnaplineManager(this.graph);
  }

  createSelection() {
    return new _addon_selection__WEBPACK_IMPORTED_MODULE_9__.Selection(Object.assign({
      graph: this.graph
    }, this.options.selecting));
  }

  createSelectionManager() {
    return new _selection__WEBPACK_IMPORTED_MODULE_26__.SelectionManager(this.graph);
  } // eslint-disable-next-line


  allowRubberband(e) {
    return true;
  }

  createHistoryManager() {
    return new _history__WEBPACK_IMPORTED_MODULE_28__.HistoryManager(Object.assign({
      graph: this.graph
    }, this.options.history));
  }

  createScroller() {
    if (this.options.scroller.enabled) {
      return new _addon_scroller__WEBPACK_IMPORTED_MODULE_8__.Scroller(Object.assign({
        graph: this.graph
      }, this.options.scroller));
    }

    return null;
  }

  createScrollerManager() {
    return new _scroller__WEBPACK_IMPORTED_MODULE_22__.ScrollerManager(this.graph);
  } // eslint-disable-next-line


  allowPanning(e) {
    return true;
  }

  createMiniMap() {
    const _a = this.options.minimap,
          {
      enabled
    } = _a,
          options = __rest(_a, ["enabled"]);

    if (enabled) {
      return new _addon_minimap__WEBPACK_IMPORTED_MODULE_6__.MiniMap(Object.assign({
        graph: this.graph
      }, options));
    }

    return null;
  }

  createMiniMapManager() {
    return new _minimap__WEBPACK_IMPORTED_MODULE_29__.MiniMapManager(this.graph);
  }

  createKeyboard() {
    return new _keyboard__WEBPACK_IMPORTED_MODULE_30__.Keyboard(Object.assign({
      graph: this.graph
    }, this.options.keyboard));
  }

  createMouseWheel() {
    return new _mousewheel__WEBPACK_IMPORTED_MODULE_31__.MouseWheel(Object.assign({
      graph: this.graph
    }, this.options.mousewheel));
  }

  createPrintManager() {
    return new _print__WEBPACK_IMPORTED_MODULE_32__.PrintManager(this.graph);
  }

  createFormatManager() {
    return new _format__WEBPACK_IMPORTED_MODULE_33__.FormatManager(this.graph);
  }

  createPanningManager() {
    return new _panning__WEBPACK_IMPORTED_MODULE_35__.PanningManager(this.graph);
  }

  createSizeManager() {
    return new _size__WEBPACK_IMPORTED_MODULE_36__.SizeManager(this.graph);
  }

  allowConnectToBlank(edge) {
    const options = this.options.connecting;
    const allowBlank = options.allowBlank != null ? options.allowBlank : options.dangling;

    if (typeof allowBlank !== 'function') {
      return !!allowBlank;
    }

    const edgeView = this.graph.findViewByCell(edge);
    const sourceCell = edge.getSourceCell();
    const targetCell = edge.getTargetCell();
    const sourceView = this.graph.findViewByCell(sourceCell);
    const targetView = this.graph.findViewByCell(targetCell);
    return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(allowBlank, this.graph, {
      edge,
      edgeView,
      sourceCell,
      targetCell,
      sourceView,
      targetView,
      sourcePort: edge.getSourcePortId(),
      targetPort: edge.getTargetPortId(),
      sourceMagnet: edgeView.sourceMagnet,
      targetMagnet: edgeView.targetMagnet
    });
  }

  validateEdge(edge, type, initialTerminal) {
    if (!this.allowConnectToBlank(edge)) {
      const sourceId = edge.getSourceCellId();
      const targetId = edge.getTargetCellId();

      if (!(sourceId && targetId)) {
        return false;
      }
    }

    const validate = this.options.connecting.validateEdge;

    if (validate) {
      return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(validate, this.graph, {
        edge,
        type,
        previous: initialTerminal
      });
    }

    return true;
  }

  validateMagnet(cellView, magnet, e) {
    if (magnet.getAttribute('magnet') !== 'passive') {
      const validate = this.options.connecting.validateMagnet;

      if (validate) {
        return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(validate, this.graph, {
          e,
          magnet,
          view: cellView,
          cell: cellView.cell
        });
      }

      return true;
    }

    return false;
  }

  getDefaultEdge(sourceView, sourceMagnet) {
    let edge;
    const create = this.options.connecting.createEdge;

    if (create) {
      edge = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(create, this.graph, {
        sourceMagnet,
        sourceView,
        sourceCell: sourceView.cell
      });
    }

    if (edge == null) {
      edge = new _shape_standard_edge__WEBPACK_IMPORTED_MODULE_13__.Edge();
    }

    return edge;
  }

  validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {
    const options = this.options.connecting;
    const allowLoop = options.allowLoop;
    const allowNode = options.allowNode;
    const allowEdge = options.allowEdge;
    const allowPort = options.allowPort;
    const allowMulti = options.allowMulti != null ? options.allowMulti : options.multi;
    const validate = options.validateConnection;
    const edge = edgeView ? edgeView.cell : null;
    const terminalView = terminalType === 'target' ? targetView : sourceView;
    const terminalMagnet = terminalType === 'target' ? targetMagnet : sourceMagnet;
    let valid = true;

    const doValidate = validate => {
      const sourcePort = terminalType === 'source' ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getSourcePortId() : null;
      const targetPort = terminalType === 'target' ? candidateTerminal ? candidateTerminal.port : null : edge ? edge.getTargetPortId() : null;
      return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(validate, this.graph, {
        edge,
        edgeView,
        sourceView,
        targetView,
        sourcePort,
        targetPort,
        sourceMagnet,
        targetMagnet,
        sourceCell: sourceView ? sourceView.cell : null,
        targetCell: targetView ? targetView.cell : null,
        type: terminalType
      });
    };

    if (allowLoop != null) {
      if (typeof allowLoop === 'boolean') {
        if (!allowLoop && sourceView === targetView) {
          valid = false;
        }
      } else {
        valid = doValidate(allowLoop);
      }
    }

    if (valid && allowPort != null) {
      if (typeof allowPort === 'boolean') {
        if (!allowPort && terminalMagnet) {
          valid = false;
        }
      } else {
        valid = doValidate(allowPort);
      }
    }

    if (valid && allowEdge != null) {
      if (typeof allowEdge === 'boolean') {
        if (!allowEdge && _view_edge__WEBPACK_IMPORTED_MODULE_4__.EdgeView.isEdgeView(terminalView)) {
          valid = false;
        }
      } else {
        valid = doValidate(allowEdge);
      }
    } // When judging nodes, the influence of the ports should be excluded,
    // because the ports and nodes have the same terminalView


    if (valid && allowNode != null && terminalMagnet == null) {
      if (typeof allowNode === 'boolean') {
        if (!allowNode && _view_node__WEBPACK_IMPORTED_MODULE_3__.NodeView.isNodeView(terminalView)) {
          valid = false;
        }
      } else {
        valid = doValidate(allowNode);
      }
    }

    if (valid && allowMulti != null && edgeView) {
      const edge = edgeView.cell;
      const source = terminalType === 'source' ? candidateTerminal : edge.getSource();
      const target = terminalType === 'target' ? candidateTerminal : edge.getTarget();
      const terminalCell = candidateTerminal ? this.graph.getCellById(candidateTerminal.cell) : null;

      if (source && target && source.cell && target.cell && terminalCell) {
        if (typeof allowMulti === 'function') {
          valid = doValidate(allowMulti);
        } else {
          const connectedEdges = this.model.getConnectedEdges(terminalCell, {
            outgoing: terminalType === 'source',
            incoming: terminalType === 'target'
          });

          if (connectedEdges.length) {
            if (allowMulti === 'withPort') {
              const exist = connectedEdges.some(link => {
                const s = link.getSource();
                const t = link.getTarget();
                return s && t && s.cell === source.cell && t.cell === target.cell && s.port != null && s.port === source.port && t.port != null && t.port === target.port;
              });

              if (exist) {
                valid = false;
              }
            } else if (!allowMulti) {
              const exist = connectedEdges.some(link => {
                const s = link.getSource();
                const t = link.getTarget();
                return s && t && s.cell === source.cell && t.cell === target.cell;
              });

              if (exist) {
                valid = false;
              }
            }
          }
        }
      }
    }

    if (valid && validate != null) {
      valid = doValidate(validate);
    }

    return valid;
  }

  getRestrictArea(view) {
    const restrict = this.options.translating.restrict;
    const area = typeof restrict === 'function' ? _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(restrict, this.graph, view) : restrict;

    if (typeof area === 'number') {
      return this.graph.transform.getGraphArea().inflate(area);
    }

    if (area === true) {
      return this.graph.transform.getGraphArea();
    }

    return area || null;
  }

  onViewUpdated(view, flag, options) {
    if (flag & _renderer__WEBPACK_IMPORTED_MODULE_16__.Renderer.FLAG_INSERT || options.mounting) {
      return;
    }

    this.graph.renderer.requestConnectedEdgesUpdate(view, options);
  }

  onViewPostponed(view, flag, options) {
    return this.graph.renderer.forcePostponedViewUpdate(view, flag);
  }

  getCellView(cell) {
    return null;
  }

  createCellView(cell) {
    const options = {
      graph: this.graph
    };
    const ctor = this.getCellView(cell);

    if (ctor) {
      return new ctor(cell, options); // eslint-disable-line new-cap
    }

    const view = cell.view;

    if (view != null && typeof view === 'string') {
      const def = _view_cell__WEBPACK_IMPORTED_MODULE_2__.CellView.registry.get(view);

      if (def) {
        return new def(cell, options); // eslint-disable-line new-cap
      }

      return _view_cell__WEBPACK_IMPORTED_MODULE_2__.CellView.registry.onNotFound(view);
    }

    if (cell.isNode()) {
      return new _view_node__WEBPACK_IMPORTED_MODULE_3__.NodeView(cell, options);
    }

    if (cell.isEdge()) {
      return new _view_edge__WEBPACK_IMPORTED_MODULE_4__.EdgeView(cell, options);
    }

    return null;
  }

  getHTMLComponent(node) {
    let ret = node.getHTML();

    if (typeof ret === 'string') {
      ret = _shape_standard_html__WEBPACK_IMPORTED_MODULE_12__.HTML.componentRegistry.get(ret) || ret;
    }

    if (_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(ret)) {
      ret = ret.render;
    }

    if (typeof ret === 'function') {
      return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(ret, this.graph, node);
    }

    return ret;
  }

  shouldUpdateHTMLComponent(node) {
    let html = node.getHTML();

    if (typeof html === 'string') {
      html = _shape_standard_html__WEBPACK_IMPORTED_MODULE_12__.HTML.componentRegistry.get(html) || html;
    }

    if (_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(html)) {
      const shouldUpdate = html.shouldComponentUpdate;

      if (typeof shouldUpdate === 'function') {
        return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(shouldUpdate, this.graph, node);
      }

      return !!shouldUpdate;
    }

    return false;
  }

  onEdgeLabelRendered(args) {} // eslint-disable-line


  onPortRendered(args) {} // eslint-disable-line


  onToolItemCreated(args) {} // eslint-disable-line


}

__decorate([Decorator.hook()], Hook.prototype, "createModel", null);

__decorate([Decorator.hook()], Hook.prototype, "createView", null);

__decorate([Decorator.hook()], Hook.prototype, "createRenderer", null);

__decorate([Decorator.hook()], Hook.prototype, "createDefsManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createGridManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createCoordManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createKnobManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createTransform", null);

__decorate([Decorator.hook()], Hook.prototype, "createKnob", null);

__decorate([Decorator.hook()], Hook.prototype, "createTransformManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createHighlightManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createBackgroundManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createClipboard", null);

__decorate([Decorator.hook()], Hook.prototype, "createClipboardManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createSnapline", null);

__decorate([Decorator.hook()], Hook.prototype, "createSnaplineManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createSelection", null);

__decorate([Decorator.hook()], Hook.prototype, "createSelectionManager", null);

__decorate([Decorator.hook()], Hook.prototype, "allowRubberband", null);

__decorate([Decorator.hook()], Hook.prototype, "createHistoryManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createScroller", null);

__decorate([Decorator.hook()], Hook.prototype, "createScrollerManager", null);

__decorate([Decorator.hook()], Hook.prototype, "allowPanning", null);

__decorate([Decorator.hook()], Hook.prototype, "createMiniMap", null);

__decorate([Decorator.hook()], Hook.prototype, "createMiniMapManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createKeyboard", null);

__decorate([Decorator.hook()], Hook.prototype, "createMouseWheel", null);

__decorate([Decorator.hook()], Hook.prototype, "createPrintManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createFormatManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createPanningManager", null);

__decorate([Decorator.hook()], Hook.prototype, "createSizeManager", null);

__decorate([Decorator.after()], Hook.prototype, "onViewUpdated", null);

__decorate([Decorator.after()], Hook.prototype, "onViewPostponed", null);

__decorate([Decorator.hook()], Hook.prototype, "getCellView", null);

__decorate([Decorator.hook(true)], Hook.prototype, "createCellView", null);

__decorate([Decorator.hook()], Hook.prototype, "getHTMLComponent", null);

__decorate([Decorator.hook()], Hook.prototype, "shouldUpdateHTMLComponent", null);

__decorate([Decorator.hook()], Hook.prototype, "onEdgeLabelRendered", null);

__decorate([Decorator.hook()], Hook.prototype, "onPortRendered", null);

__decorate([Decorator.hook()], Hook.prototype, "onToolItemCreated", null);

/***/ }),

/***/ 24598:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Graph": () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_0__.Graph)
/* harmony export */ });
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph */ 77947);


/***/ }),

/***/ 37003:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/keyboard.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Keyboard": () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var mousetrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mousetrap */ 69729);
/* harmony import */ var mousetrap__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mousetrap__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ 57566);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class Keyboard extends _common__WEBPACK_IMPORTED_MODULE_2__.Disposable {
  constructor(options) {
    super();
    this.options = options;
    const scroller = this.graph.scroller.widget;
    this.container = scroller ? scroller.container : this.graph.container;

    if (options.global) {
      this.target = document;
    } else {
      this.target = this.container;

      if (!this.disabled) {
        // ensure the container focusable
        this.target.setAttribute('tabindex', '-1');
      } // change to mouseup event，prevent page stalling caused by focus


      this.graph.on('cell:mouseup', this.focus, this);
      this.graph.on('blank:mouseup', this.focus, this);
    }

    this.mousetrap = Keyboard.createMousetrap(this);
  }

  get graph() {
    return this.options.graph;
  }

  get disabled() {
    return this.options.enabled !== true;
  }

  enable() {
    if (this.disabled) {
      this.options.enabled = true;
      this.graph.options.keyboard.enabled = true;

      if (this.target instanceof HTMLElement) {
        this.target.setAttribute('tabindex', '-1');
      }
    }
  }

  disable() {
    if (!this.disabled) {
      this.options.enabled = false;
      this.graph.options.keyboard.enabled = false;

      if (this.target instanceof HTMLElement) {
        this.target.removeAttribute('tabindex');
      }
    }
  }

  on(keys, callback, action) {
    this.mousetrap.bind(this.getKeys(keys), callback, action);
  }

  off(keys, action) {
    this.mousetrap.unbind(this.getKeys(keys), action);
  }

  focus(e) {
    const isInputEvent = this.isInputEvent(e.e);

    if (isInputEvent) {
      return;
    }

    const target = this.target;
    target.focus({
      preventScroll: true
    });
  }

  getKeys(keys) {
    return (Array.isArray(keys) ? keys : [keys]).map(key => this.formatkey(key));
  }

  formatkey(key) {
    const formated = key.toLowerCase().replace(/\s/g, '').replace('delete', 'del').replace('cmd', 'command');
    const formatFn = this.options.format;

    if (formatFn) {
      return _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(formatFn, this.graph, formated);
    }

    return formated;
  }

  isGraphEvent(e) {
    const target = e.srcElement || e.target;
    const currentTarget = e.currentTarget;

    if (target) {
      if (target === this.target || currentTarget === this.target || target === document.body) {
        return true;
      }

      return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.contains(this.container, target);
    }

    return false;
  }

  isInputEvent(e) {
    const target = e.target;
    const tagName = target && target.tagName.toLowerCase();
    return ['input', 'textarea'].includes(tagName);
  }

  isEnabledForEvent(e) {
    const allowed = !this.disabled && this.isGraphEvent(e);
    const isInputEvent = this.isInputEvent(e);

    if (allowed) {
      const code = e.keyCode || e.which;

      if (isInputEvent && (code === 8 || code === 46)) {
        return false;
      }

      if (this.options.guard) {
        return _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(this.options.guard, this.graph, e);
      }
    }

    return allowed;
  }

  dispose() {
    this.mousetrap.reset();
  }

}

__decorate([_common__WEBPACK_IMPORTED_MODULE_2__.Disposable.dispose()], Keyboard.prototype, "dispose", null);

(function (Keyboard) {
  function createMousetrap(keyboard) {
    const mousetrap = new (mousetrap__WEBPACK_IMPORTED_MODULE_0___default())(keyboard.target);
    const stopCallback = mousetrap.stopCallback;

    mousetrap.stopCallback = (e, elem, combo) => {
      if (keyboard.isEnabledForEvent(e)) {
        if (stopCallback) {
          return stopCallback.call(mousetrap, e, elem, combo);
        }

        return false;
      }

      return true;
    };

    return mousetrap;
  }

  Keyboard.createMousetrap = createMousetrap;
})(Keyboard || (Keyboard = {}));

/***/ }),

/***/ 72355:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/knob.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KnobManager": () => (/* binding */ KnobManager)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ 94997);

class KnobManager extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
  constructor() {
    super(...arguments);
    this.widgets = new Map();
  }

  get isSelectionEnabled() {
    return this.options.selecting.enabled === true;
  }

  init() {
    this.startListening();
  }

  startListening() {
    this.graph.on('node:mouseup', this.onNodeMouseUp, this);
    this.graph.on('node:selected', this.onNodeSelected, this);
    this.graph.on('node:unselected', this.onNodeUnSelected, this);
  }

  stopListening() {
    this.graph.off('node:mouseup', this.onNodeMouseUp, this);
    this.graph.off('node:selected', this.onNodeSelected, this);
    this.graph.off('node:unselected', this.onNodeUnSelected, this);
  }

  onNodeMouseUp({
    node
  }) {
    if (!this.isSelectionEnabled) {
      const widgets = this.graph.hook.createKnob(node, {
        clearAll: true
      });

      if (widgets) {
        this.widgets.set(node, widgets);
      }
    }
  }

  onNodeSelected({
    node
  }) {
    if (this.isSelectionEnabled) {
      const widgets = this.graph.hook.createKnob(node, {
        clearAll: false
      });

      if (widgets) {
        this.widgets.set(node, widgets);
      }
    }
  }

  onNodeUnSelected({
    node
  }) {
    if (this.isSelectionEnabled) {
      const widgets = this.widgets.get(node);

      if (widgets) {
        widgets.forEach(widget => widget.dispose());
      }

      this.widgets.delete(node);
    }
  }

}

/***/ }),

/***/ 55933:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/minimap.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MiniMapManager": () => (/* binding */ MiniMapManager)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class MiniMapManager extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
  get widgetOptions() {
    return this.options.minimap;
  }

  init() {
    this.widget = this.graph.hook.createMiniMap();
  }

  dispose() {
    if (this.widget) {
      this.widget.dispose();
    }
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_0__.Base.dispose()], MiniMapManager.prototype, "dispose", null);

/***/ }),

/***/ 52222:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/mousewheel.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MouseWheel": () => (/* binding */ MouseWheel)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ 64060);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ 57566);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class MouseWheel extends _common__WEBPACK_IMPORTED_MODULE_2__.Disposable {
  constructor(options) {
    super();
    this.options = options;
    this.cumulatedFactor = 1;
    const scroller = this.graph.scroller.widget;
    this.container = scroller ? scroller.container : this.graph.container;
    this.target = this.options.global ? document : this.container;
    this.mousewheelHandle = new _util__WEBPACK_IMPORTED_MODULE_1__.Dom.MouseWheelHandle(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));

    if (this.options.enabled) {
      this.enable(true);
    }
  }

  get graph() {
    return this.options.graph;
  }

  get disabled() {
    return this.options.enabled !== true;
  }

  enable(force) {
    if (this.disabled || force) {
      this.options.enabled = true;
      this.graph.options.mousewheel.enabled = true;
      this.mousewheelHandle.enable();
    }
  }

  disable() {
    if (!this.disabled) {
      this.options.enabled = false;
      this.graph.options.mousewheel.enabled = false;
      this.mousewheelHandle.disable();
    }
  }

  allowMouseWheel(evt) {
    const e = evt.originalEvent || evt;
    const guard = this.options.guard;
    return (guard == null || guard.call(this.graph, e)) && _types__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.options.modifiers);
  }

  onMouseWheel(evt) {
    const e = evt.originalEvent || evt;
    const guard = this.options.guard;

    if ((guard == null || guard.call(this.graph, e)) && _types__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.options.modifiers)) {
      const factor = this.options.factor || 1.2;

      if (this.currentScale == null) {
        this.startPos = {
          x: evt.clientX,
          y: evt.clientY
        };
        this.currentScale = this.graph.scroller.widget ? this.graph.scroller.widget.zoom() : this.graph.transform.getScale().sx;
      }

      const delta = evt.deltaY;

      if (delta < 0) {
        // zoomin
        // ------
        // Switches to 1% zoom steps below 15%
        if (this.currentScale < 0.15) {
          this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale;
        } else {
          // Uses to 5% zoom steps for better grid rendering in
          // webkit and to avoid rounding errors for zoom steps
          this.cumulatedFactor = Math.round(this.currentScale * factor * 20) / 20 / this.currentScale;
        }
      } else {
        // zoomout
        // -------
        // Switches to 1% zoom steps below 15%
        if (this.currentScale <= 0.15) {
          this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale;
        } else {
          // Uses to 5% zoom steps for better grid rendering in
          // webkit and to avoid rounding errors for zoom steps
          this.cumulatedFactor = Math.round(this.currentScale * (1 / factor) * 20) / 20 / this.currentScale;
        }
      }

      this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) / this.currentScale);
      const scroller = this.graph.scroller.widget;
      const currentScale = this.currentScale;
      let targetScale = this.graph.transform.clampScale(currentScale * this.cumulatedFactor);
      const minScale = this.options.minScale || Number.MIN_SAFE_INTEGER;
      const maxScale = this.options.maxScale || Number.MAX_SAFE_INTEGER;
      targetScale = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.clamp(targetScale, minScale, maxScale);

      if (targetScale !== currentScale) {
        if (scroller) {
          if (this.options.zoomAtMousePosition) {
            const origin = this.graph.coord.clientToLocalPoint(this.startPos);
            scroller.zoom(targetScale, {
              absolute: true,
              center: origin.clone()
            });
          } else {
            scroller.zoom(targetScale, {
              absolute: true
            });
          }
        } else {
          if (this.options.zoomAtMousePosition) {
            const origin = this.graph.coord.clientToGraphPoint(this.startPos);
            this.graph.transform.zoom(targetScale, {
              absolute: true,
              center: origin.clone(),
              ui: true
            });
          } else {
            this.graph.transform.zoom(targetScale, {
              absolute: true,
              ui: true
            });
          }
        }
      }

      this.currentScale = null;
      this.cumulatedFactor = 1;
    }
  }

  dispose() {
    this.disable();
  }

}

__decorate([_common__WEBPACK_IMPORTED_MODULE_2__.Disposable.dispose()], MouseWheel.prototype, "dispose", null);

/***/ }),

/***/ 94805:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/options.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Options": () => (/* binding */ Options)
/* harmony export */ });
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../global */ 9789);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _shape_standard_edge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shape/standard/edge */ 34973);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




var Options;

(function (Options) {
  function parseOptionGroup(graph, arg, options) {
    const result = {};
    Object.keys(options || {}).forEach(key => {
      const val = options[key];
      result[key] = typeof val === 'function' ? val.call(graph, arg) : val;
    });
    return result;
  }

  Options.parseOptionGroup = parseOptionGroup;
})(Options || (Options = {}));

(function (Options) {
  function get(options) {
    const {
      grid,
      panning,
      selecting,
      embedding,
      snapline,
      resizing,
      rotating,
      knob,
      clipboard,
      history,
      scroller,
      minimap,
      keyboard,
      mousewheel
    } = options,
          others = __rest(options // size
    // ----
    , ["grid", "panning", "selecting", "embedding", "snapline", "resizing", "rotating", "knob", "clipboard", "history", "scroller", "minimap", "keyboard", "mousewheel"]); // size
    // ----


    const container = options.container;

    if (container != null) {
      if (others.width == null) {
        others.width = container.clientWidth;
      }

      if (others.height == null) {
        others.height = container.clientHeight;
      }
    } else {
      throw new Error(`Ensure the container of the graph is specified and valid`);
    }

    const result = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, Options.defaults, others); // grid
    // ----

    const defaultGrid = {
      size: 10,
      visible: false
    };

    if (typeof grid === 'number') {
      result.grid = {
        size: grid,
        visible: false
      };
    } else if (typeof grid === 'boolean') {
      result.grid = Object.assign(Object.assign({}, defaultGrid), {
        visible: grid
      });
    } else {
      result.grid = Object.assign(Object.assign({}, defaultGrid), grid);
    } // booleas
    // -------


    const booleas = ['panning', 'selecting', 'embedding', 'snapline', 'resizing', 'rotating', 'knob', 'clipboard', 'history', 'scroller', 'minimap', 'keyboard', 'mousewheel'];
    booleas.forEach(key => {
      const val = options[key];

      if (typeof val === 'boolean') {
        result[key].enabled = val;
      } else {
        result[key] = Object.assign(Object.assign({}, result[key]), val);
      }
    }); // background
    // ----------

    if (result.background && result.scroller.enabled && result.scroller.background == null) {
      result.scroller.background = result.background;
      delete result.background;
    }

    return result;
  }

  Options.get = get;
})(Options || (Options = {}));

(function (Options) {
  Options.defaults = {
    x: 0,
    y: 0,
    grid: {
      size: 10,
      visible: false
    },
    scaling: {
      min: 0.01,
      max: 16
    },
    background: false,
    highlighting: {
      default: {
        name: 'stroke',
        args: {
          padding: 3
        }
      },
      nodeAvailable: {
        name: 'className',
        args: {
          className: _global__WEBPACK_IMPORTED_MODULE_0__.Util.prefix('available-node')
        }
      },
      magnetAvailable: {
        name: 'className',
        args: {
          className: _global__WEBPACK_IMPORTED_MODULE_0__.Util.prefix('available-magnet')
        }
      }
    },
    connecting: {
      snap: false,
      multi: true,
      // TODO: Unannotation the next line when the `multi` option was removed in the next major version.
      // allowMulti: true,
      dangling: true,
      // TODO: Unannotation the next line when the `dangling` option was removed in the next major version.
      // allowBlank: true,
      allowLoop: true,
      allowNode: true,
      allowEdge: false,
      allowPort: true,
      highlight: false,
      anchor: 'center',
      edgeAnchor: 'ratio',
      connectionPoint: 'boundary',
      strategy: null,
      router: 'normal',
      connector: 'normal',

      validateConnection({
        type,
        sourceView,
        targetView
      }) {
        const view = type === 'target' ? targetView : sourceView;
        return view != null;
      },

      createEdge() {
        return new _shape_standard_edge__WEBPACK_IMPORTED_MODULE_2__.Edge();
      }

    },
    transforming: {
      clearAll: true,
      clearOnBlankMouseDown: true
    },
    resizing: {
      enabled: false,
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_SAFE_INTEGER,
      maxHeight: Number.MAX_SAFE_INTEGER,
      orthogonal: true,
      restricted: false,
      autoScroll: true,
      preserveAspectRatio: false,
      allowReverse: true
    },
    rotating: {
      enabled: false,
      grid: 15
    },
    translating: {
      restrict: false
    },
    knob: {
      enabled: false,
      clearAll: true,
      clearOnBlankMouseDown: true
    },
    embedding: {
      enabled: false,
      findParent: 'bbox',
      frontOnly: true,
      validate: () => true
    },
    selecting: {
      enabled: false,
      rubberband: false,
      rubberNode: true,
      rubberEdge: false,
      pointerEvents: 'auto',
      multiple: true,
      multipleSelectionModifiers: ['ctrl', 'meta'],
      movable: true,
      strict: false,
      useCellGeometry: false,
      selectCellOnMoved: false,
      selectNodeOnMoved: false,
      selectEdgeOnMoved: false,
      content: null,
      handles: null
    },
    panning: {
      enabled: false,
      eventTypes: ['leftMouseDown']
    },
    snapline: {
      enabled: false
    },
    clipboard: {
      enabled: false
    },
    history: {
      enabled: false
    },
    scroller: {
      enabled: false
    },
    keyboard: {
      enabled: false
    },
    mousewheel: {
      enabled: false,
      factor: 1.2,
      zoomAtMousePosition: true
    },
    async: false,
    frozen: false,
    sorting: 'exact',
    moveThreshold: 0,
    clickThreshold: 0,
    magnetThreshold: 0,
    preventDefaultDblClick: true,
    preventDefaultMouseDown: false,
    preventDefaultContextMenu: true,
    preventDefaultBlankAction: true,
    interacting: {
      edgeLabelMovable: false
    },
    guard: () => false
  };
})(Options || (Options = {}));

/***/ }),

/***/ 17830:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/panning.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PanningManager": () => (/* binding */ PanningManager)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ 64060);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class PanningManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
  get widgetOptions() {
    return this.options.panning;
  }

  get pannable() {
    return this.widgetOptions && this.widgetOptions.enabled === true;
  }

  init() {
    this.startListening();
    this.updateClassName();
  }

  startListening() {
    const eventTypes = this.widgetOptions.eventTypes;

    if (!eventTypes) {
      return;
    }

    if (eventTypes.includes('leftMouseDown')) {
      this.graph.on('blank:mousedown', this.preparePanning, this);
      this.graph.on('node:unhandled:mousedown', this.preparePanning, this);
      this.graph.on('edge:unhandled:mousedown', this.preparePanning, this);
    }

    if (eventTypes.includes('rightMouseDown')) {
      this.onRightMouseDown = this.onRightMouseDown.bind(this);
      this.view.$(this.graph.container).on('mousedown', this.onRightMouseDown);
    }

    if (eventTypes.includes('mouseWheel')) {
      this.mousewheelHandle = new _util__WEBPACK_IMPORTED_MODULE_1__.Dom.MouseWheelHandle(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
      this.mousewheelHandle.enable();
    }
  }

  stopListening() {
    const eventTypes = this.widgetOptions.eventTypes;

    if (!eventTypes) {
      return;
    }

    if (eventTypes.includes('leftMouseDown')) {
      this.graph.off('blank:mousedown', this.preparePanning, this);
      this.graph.off('node:unhandled:mousedown', this.preparePanning, this);
      this.graph.off('edge:unhandled:mousedown', this.preparePanning, this);
    }

    if (eventTypes.includes('rightMouseDown')) {
      this.view.$(this.graph.container).off('mousedown', this.onRightMouseDown);
    }

    if (eventTypes.includes('mouseWheel')) {
      if (this.mousewheelHandle) {
        this.mousewheelHandle.disable();
      }
    }
  }

  preparePanning({
    e
  }) {
    if (this.allowPanning(e, true) || this.allowPanning(e) && !this.graph.selection.allowRubberband(e, true)) {
      this.startPanning(e);
    }
  }

  allowPanning(e, strict) {
    return this.pannable && _types__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict) && this.graph.hook.allowPanning(e);
  }

  startPanning(evt) {
    const e = this.view.normalizeEvent(evt);
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    this.panning = true;
    this.updateClassName();
    this.view.$(document.body).on({
      'mousemove.panning touchmove.panning': this.pan.bind(this),
      'mouseup.panning touchend.panning': this.stopPanning.bind(this),
      'mouseleave.panning': this.stopPanning.bind(this)
    });
    this.view.$(window).on('mouseup.panning', this.stopPanning.bind(this));
  }

  pan(evt) {
    const e = this.view.normalizeEvent(evt);
    const dx = e.clientX - this.clientX;
    const dy = e.clientY - this.clientY;
    this.clientX = e.clientX;
    this.clientY = e.clientY;
    const ts = this.graph.transform.getTranslation();
    const tx = ts.tx + dx;
    const ty = ts.ty + dy;
    this.graph.transform.translate(tx, ty, {
      ui: true
    });
  } // eslint-disable-next-line


  stopPanning(e) {
    this.panning = false;
    this.updateClassName();
    this.view.$(document.body).off('.panning');
    this.view.$(window).off('.panning');
  }

  updateClassName() {
    const container = this.view.container;
    const panning = this.view.prefixClassName('graph-panning');
    const pannable = this.view.prefixClassName('graph-pannable');

    if (this.pannable) {
      if (this.panning) {
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.addClass(container, panning);
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.removeClass(container, pannable);
      } else {
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.removeClass(container, panning);
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.addClass(container, pannable);
      }
    } else {
      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.removeClass(container, panning);
      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.removeClass(container, pannable);
    }
  }

  onRightMouseDown(e) {
    if (e.button === 2 && this.allowPanning(e, true)) {
      this.startPanning(e);
    }
  }

  allowMouseWheel(e) {
    return this.pannable && !e.ctrlKey;
  }

  onMouseWheel(e, deltaX, deltaY) {
    if (!e.ctrlKey) {
      this.graph.translateBy(-deltaX, -deltaY);
    }
  }

  autoPanning(x, y) {
    const buffer = 10;
    const graphArea = this.graph.getGraphArea();
    let dx = 0;
    let dy = 0;

    if (x <= graphArea.left + buffer) {
      dx = -buffer;
    }

    if (y <= graphArea.top + buffer) {
      dy = -buffer;
    }

    if (x >= graphArea.right - buffer) {
      dx = buffer;
    }

    if (y >= graphArea.bottom - buffer) {
      dy = buffer;
    }

    if (dx !== 0 || dy !== 0) {
      this.graph.translateBy(-dx, -dy);
    }
  }

  enablePanning() {
    if (!this.pannable) {
      this.widgetOptions.enabled = true;
      this.updateClassName();
    }
  }

  disablePanning() {
    if (this.pannable) {
      this.widgetOptions.enabled = false;
      this.updateClassName();
    }
  }

  dispose() {
    this.stopListening();
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_2__.Base.dispose()], PanningManager.prototype, "dispose", null);

/***/ }),

/***/ 75068:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/print.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrintManager": () => (/* binding */ PrintManager)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class PrintManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
  show(options = {}) {
    const localOptions = Object.assign(Object.assign({}, PrintManager.defaultOptions), options);
    const $pages = this.createPrintPages(localOptions);
    localOptions.ready($pages, $pages => this.showPrintWindow($pages, localOptions), {
      sheetSize: this.getSheetSize(localOptions)
    });
  }

  get className() {
    return this.view.prefixClassName('graph-print');
  }

  showPrintWindow($pages, options) {
    if ($pages) {
      const $body = (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)(document.body);
      const $container = (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)(this.view.container);
      const bodyClassName = this.view.prefixClassName('graph-printing');
      $body.addClass(bodyClassName);
      const $detached = $container.children().detach();
      $pages.forEach($page => {
        $page.removeClass(`${this.className}-preview`).addClass(`${this.className}-ready`).appendTo($body);
      });
      let ret = false;

      const cb = () => {
        if (!ret) {
          ret = true;
          $body.removeClass(bodyClassName);
          $pages.forEach($page => $page.remove());
          $container.append($detached);
          (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)(`#${this.styleSheetId}`).remove();
          this.graph.trigger('after:print', options);
          (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)(window).off('afterprint', cb);
        }
      };

      (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)(window).one('afterprint', cb);
      setTimeout(cb, 200);
      window.print();
    }
  }

  createPrintPage(pageArea, options) {
    this.graph.trigger('before:print', options);
    const $page = (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)('<div/>').addClass(this.className);
    const $wrap = (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)('<div/>').addClass(this.view.prefixClassName('graph-print-inner')).css('position', 'relative');

    if (options.size) {
      $page.addClass(`${this.className}-size-${options.size}`);
    }

    const vSVG = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(this.view.svg).clone();
    const vStage = vSVG.findOne(`.${this.view.prefixClassName('graph-svg-stage')}`);
    $wrap.append(vSVG.node);
    const sheetSize = this.getSheetSize(options);
    const graphArea = this.graph.transform.getGraphArea();
    const s = this.graph.transform.getScale();
    const ts = this.graph.translate();
    const matrix = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix().translate(ts.tx / s.sx, ts.ty / s.sy);
    const info = this.getPageInfo(graphArea, pageArea, sheetSize);
    const scale = info.scale;
    const bbox = info.bbox;
    $wrap.css({
      left: 0,
      top: 0
    });
    vSVG.attr({
      width: bbox.width * scale,
      height: bbox.height * scale,
      style: 'position:relative',
      viewBox: [bbox.x, bbox.y, bbox.width, bbox.height].join(' ')
    });
    vStage.attr('transform', _util__WEBPACK_IMPORTED_MODULE_1__.Dom.matrixToTransformString(matrix));
    $page.append($wrap);
    $page.addClass(`${this.className}-preview`);
    return {
      $page,
      sheetSize
    };
  }

  createPrintPages(options) {
    let ret;
    const area = this.getPrintArea(options);
    const $pages = [];

    if (options.page) {
      const pageSize = this.getPageSize(area, options.page);
      const pageAreas = this.getPageAreas(area, pageSize);
      pageAreas.forEach(pageArea => {
        ret = this.createPrintPage(pageArea, options);
        $pages.push(ret.$page);
      });
    } else {
      ret = this.createPrintPage(area, options);
      $pages.push(ret.$page);
    }

    if (ret) {
      const size = {
        width: ret.sheetSize.cssWidth,
        height: ret.sheetSize.cssHeight
      };
      this.updatePrintStyle(size, options);
    }

    return $pages;
  }

  get styleSheetId() {
    return this.view.prefixClassName('graph-print-style');
  }

  updatePrintStyle(size, options) {
    const sizeCSS = Object.keys(size).reduce((memo, key) => `${memo} ${key}:${size[key]};`, '');
    const margin = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizeSides(options.margin);
    const marginUnit = options.marginUnit || '';
    const sheetUnit = options.sheetUnit || '';
    const css = `
      @media print {
        .${this.className}.${this.className}-ready {
          ${sizeCSS}
        }

        @page {
          margin:
          ${[margin.top + marginUnit, margin.right + marginUnit, margin.bottom + marginUnit, margin.left + marginUnit].join(' ')};
          size: ${options.sheet.width + sheetUnit} ${options.sheet.height + sheetUnit};

        .${this.className}.${this.className}-preview {
          ${sizeCSS}
        }
      }`;
    const id = this.styleSheetId;
    const $style = (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)(`#${id}`);

    if ($style.length) {
      $style.html(css);
    } else {
      (0,_util__WEBPACK_IMPORTED_MODULE_1__.JQuery)('head').append(`'<style type="text/css" id="${id}">${css}</style>'`);
    }
  }

  getPrintArea(options) {
    let area = options.area;

    if (!area) {
      const padding = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizeSides(options.padding);
      area = this.graph.getContentArea().moveAndExpand({
        x: -padding.left,
        y: -padding.top,
        width: padding.left + padding.right,
        height: padding.top + padding.bottom
      });
    }

    return area;
  }

  getPageSize(area, poster) {
    if (typeof poster === 'object') {
      const raw = poster;
      const page = {
        width: raw.width,
        height: raw.height
      };

      if (page.width == null) {
        page.width = Math.ceil(area.width / (raw.columns || 1));
      }

      if (page.height == null) {
        page.height = Math.ceil(area.height / (raw.rows || 1));
      }

      return page;
    }

    return {
      width: area.width,
      height: area.height
    };
  }

  getPageAreas(area, pageSize) {
    const pages = [];
    const width = pageSize.width;
    const height = pageSize.height;

    for (let w = 0, n = 0; w < area.height && n < 200; w += height, n += 1) {
      for (let h = 0, m = 0; h < area.width && m < 200; h += width, m += 1) {
        pages.push(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(area.x + h, area.y + w, width, height));
      }
    }

    return pages;
  }

  getSheetSize(options) {
    const sheet = options.sheet;
    const margin = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizeSides(options.margin);
    const marginUnit = options.marginUnit || '';
    const sheetUnit = options.sheetUnit || '';
    const cssWidth = // eslint-disable-next-line
    `calc(${sheet.width}${sheetUnit} - ${margin.left + margin.right}${marginUnit})`;
    const cssHeight = // eslint-disable-next-line
    `calc(${sheet.height}${sheetUnit} - ${margin.top + margin.bottom}${marginUnit})`;
    const ret = _util__WEBPACK_IMPORTED_MODULE_1__.Unit.measure(cssWidth, cssHeight);
    return {
      cssWidth,
      cssHeight,
      width: ret.width,
      height: ret.height
    };
  }

  getPageInfo(graphArea, pageArea, sheetSize) {
    const bbox = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(pageArea.x - graphArea.x, pageArea.y - graphArea.y, pageArea.width, pageArea.height);
    const pageRatio = bbox.width / bbox.height;
    const graphRatio = sheetSize.width / sheetSize.height;
    return {
      bbox,
      scale: graphRatio < pageRatio ? sheetSize.width / bbox.width : sheetSize.height / bbox.height,
      fitHorizontal: graphRatio < pageRatio
    };
  }

  dispose() {}

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_2__.Base.dispose()], PrintManager.prototype, "dispose", null);

(function (PrintManager) {
  PrintManager.defaultOptions = {
    page: false,
    sheet: {
      width: 210,
      height: 297
    },
    sheetUnit: 'mm',
    margin: 0.4,
    marginUnit: 'in',
    padding: 5,
    ready: ($pages, readyToPrint) => readyToPrint($pages)
  };
})(PrintManager || (PrintManager = {}));

/***/ }),

/***/ 47801:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/renderer.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Renderer": () => (/* binding */ Renderer)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model */ 59502);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view */ 29818);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class Renderer extends _base__WEBPACK_IMPORTED_MODULE_4__.Base {
  init() {
    this.resetUpdates();
    this.startListening(); // Renders existing cells in the model.

    this.resetViews(this.model.getCells()); // Starts rendering loop.

    if (!this.isFrozen() && this.isAsync()) {
      this.updateViewsAsync();
    }
  }

  startListening() {
    this.model.on('sorted', this.onSortModel, this);
    this.model.on('reseted', this.onModelReseted, this);
    this.model.on('batch:stop', this.onBatchStop, this);
    this.model.on('cell:added', this.onCellAdded, this);
    this.model.on('cell:removed', this.onCellRemoved, this);
    this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);
    this.model.on('cell:change:visible', this.onCellVisibleChanged, this);
  }

  stopListening() {
    this.model.off('sorted', this.onSortModel, this);
    this.model.off('reseted', this.onModelReseted, this);
    this.model.off('batch:stop', this.onBatchStop, this);
    this.model.off('cell:added', this.onCellAdded, this);
    this.model.off('cell:removed', this.onCellRemoved, this);
    this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);
    this.model.off('cell:change:visible', this.onCellVisibleChanged, this);
  }

  resetUpdates() {
    this.updates = {
      priorities: [{}, {}, {}],
      mounted: {},
      mountedCids: [],
      unmounted: {},
      unmountedCids: [],
      count: 0,
      sort: false,
      frozen: false,
      freezeKey: null,
      animationId: null
    };
  }

  onSortModel() {
    if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {
      return;
    }

    this.sortViews();
  }

  onModelReseted({
    options
  }) {
    this.removeZPivots();
    this.resetViews(this.model.getCells(), options);
  }

  onBatchStop({
    name,
    data
  }) {
    if (this.isFrozen()) {
      return;
    }

    const model = this.model;

    if (!this.isAsync()) {
      const updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;

      if (updateDelayingBatches.includes(name) && !model.hasActiveBatch(updateDelayingBatches)) {
        this.updateViews(data);
      }
    }

    const sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;

    if (sortDelayingBatches.includes(name) && !model.hasActiveBatch(sortDelayingBatches)) {
      this.sortViews();
    }
  }

  onCellAdded({
    cell,
    options
  }) {
    const position = options.position;

    if (this.isAsync() || typeof position !== 'number') {
      this.renderView(cell, options);
    } else {
      if (options.maxPosition === position) {
        this.freeze({
          key: 'addCells'
        });
      }

      this.renderView(cell, options);

      if (position === 0) {
        this.unfreeze({
          key: 'addCells'
        });
      }
    }
  }

  onCellRemoved({
    cell,
    options
  }) {
    const view = this.findViewByCell(cell);

    if (view) {
      this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);
    }
  }

  onCellZIndexChanged({
    cell,
    options
  }) {
    if (this.options.sorting === 'approx') {
      const view = this.findViewByCell(cell);

      if (view) {
        this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);
      }
    }
  }

  onCellVisibleChanged({
    cell,
    current: visible,
    options
  }) {
    // Hide connected edges before cell
    if (!visible) {
      this.processEdgeOnTerminalVisibleChanged(cell, false);
    }

    const view = this.findViewByCell(cell);

    if (!visible && view) {
      this.removeView(cell);
    } else if (visible && view == null) {
      this.renderView(cell, options);
    } // Show connected edges after cell rendered


    if (visible) {
      this.processEdgeOnTerminalVisibleChanged(cell, true);
    } // this.sortViews()

  }

  processEdgeOnTerminalVisibleChanged(node, visible) {
    const getOpposite = (edge, currentTerminal) => {
      const sourceId = edge.getSourceCellId();

      if (sourceId !== currentTerminal.id) {
        return edge.getSourceCell();
      }

      const targetId = edge.getTargetCellId();

      if (targetId !== currentTerminal.id) {
        return edge.getTargetCell();
      }

      return null;
    };

    this.model.getConnectedEdges(node).forEach(edge => {
      const opposite = getOpposite(edge, node);

      if (opposite == null || opposite.isVisible()) {
        visible ? edge.show() : edge.hide();
      }
    });
  }

  isEdgeTerminalVisible(edge, terminal) {
    const cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();
    const cell = cellId ? this.model.getCell(cellId) : null;

    if (cell && !cell.isVisible()) {
      return false;
    }

    return true;
  }

  requestConnectedEdgesUpdate(view, options = {}) {
    if (_view__WEBPACK_IMPORTED_MODULE_3__.CellView.isCellView(view)) {
      const cell = view.cell;
      const edges = this.model.getConnectedEdges(cell);

      for (let j = 0, n = edges.length; j < n; j += 1) {
        const edge = edges[j];
        const edgeView = this.findViewByCell(edge);

        if (!edgeView) {
          continue;
        }

        const flagLabels = ['update'];

        if (edge.getTargetCell() === cell) {
          flagLabels.push('target');
        }

        if (edge.getSourceCell() === cell) {
          flagLabels.push('source');
        }

        this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);
      }
    }
  }

  forcePostponedViewUpdate(view, flag) {
    if (!view || !_view__WEBPACK_IMPORTED_MODULE_3__.CellView.isCellView(view)) {
      return false;
    }

    const cell = view.cell;

    if (cell.isNode()) {
      return false;
    }

    const edgeView = view;

    if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {
      // EdgeView is waiting for the source/target cellView to be rendered.
      // This can happen when the cells are not in the viewport.
      let sourceFlag = 0;
      const sourceView = this.findViewByCell(cell.getSourceCell());

      if (sourceView && !this.isViewMounted(sourceView)) {
        sourceFlag = this.dumpView(sourceView);
        edgeView.updateTerminalMagnet('source');
      }

      let targetFlag = 0;
      const targetView = this.findViewByCell(cell.getTargetCell());

      if (targetView && !this.isViewMounted(targetView)) {
        targetFlag = this.dumpView(targetView);
        edgeView.updateTerminalMagnet('target');
      }

      if (sourceFlag === 0 && targetFlag === 0) {
        // If leftover flag is 0, all view updates were done.
        return !this.dumpView(edgeView);
      }
    }

    return false;
  }

  scheduleViewUpdate(view, flag, priority, options = {}) {
    const cid = view.cid;
    const updates = this.updates;
    let cache = updates.priorities[priority];

    if (!cache) {
      cache = updates.priorities[priority] = {};
    }

    const currentFlag = cache[cid] || 0;

    if ((currentFlag & flag) === flag) {
      return;
    }

    if (!currentFlag) {
      updates.count += 1;
    }

    if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {
      // When a view is removed we need to remove the
      // insert flag as this is a reinsert.
      cache[cid] ^= Renderer.FLAG_INSERT;
    } else if (flag & Renderer.FLAG_INSERT && currentFlag & Renderer.FLAG_REMOVE) {
      // When a view is added we need to remove the remove
      // flag as this is view was previously removed.
      cache[cid] ^= Renderer.FLAG_REMOVE;
    }

    cache[cid] |= flag;
    this.graph.hook.onViewUpdated(view, flag, options);
  }

  requestViewUpdate(view, flag, priority, options = {}) {
    this.scheduleViewUpdate(view, flag, priority, options);
    const isAsync = this.isAsync();

    if (this.isFrozen() || isAsync && options.async !== false || this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {
      return;
    }

    const stats = this.updateViews(options);

    if (isAsync) {
      this.graph.trigger('render:done', {
        stats,
        options
      });
    }
  }
  /**
   * Adds view into the DOM and update it.
   */


  dumpView(view, options = {}) {
    if (view == null) {
      return 0;
    }

    const cid = view.cid;
    const updates = this.updates;
    const cache = updates.priorities[view.priority];
    const flag = this.registerMountedView(view) | cache[cid];
    delete cache[cid];

    if (!flag) {
      return 0;
    }

    return this.updateView(view, flag, options);
  }
  /**
   * Adds all views into the DOM and update them.
   */


  dumpViews(options = {}) {
    this.checkView(options);
    this.updateViews(options);
  }
  /**
   * Ensure the view associated with the cell is attached
   * to the DOM and updated.
   */


  requireView(cell, options = {}) {
    const view = this.findViewByCell(cell);

    if (view == null) {
      return null;
    }

    this.dumpView(view, options);
    return view;
  }

  updateView(view, flag, options = {}) {
    if (view == null) {
      return 0;
    }

    if (_view__WEBPACK_IMPORTED_MODULE_3__.CellView.isCellView(view)) {
      if (flag & Renderer.FLAG_REMOVE) {
        this.removeView(view.cell);
        return 0;
      }

      if (flag & Renderer.FLAG_INSERT) {
        this.insertView(view);
        flag ^= Renderer.FLAG_INSERT; // eslint-disable-line
      }
    }

    if (!flag) {
      return 0;
    }

    return view.confirmUpdate(flag, options);
  }

  updateViews(options = {}) {
    let result;
    let batchCount = 0;
    let updatedCount = 0;
    let priority = Renderer.MIN_PRIORITY;

    do {
      result = this.updateViewsBatch(options);
      batchCount += 1;
      updatedCount += result.updatedCount;
      priority = Math.min(result.priority, priority);
    } while (!result.empty);

    return {
      priority,
      batchCount,
      updatedCount
    };
  }

  updateViewsBatch(options = {}) {
    const updates = this.updates;
    const priorities = updates.priorities;
    const batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;
    let empty = true;
    let priority = Renderer.MIN_PRIORITY;
    let mountedCount = 0;
    let unmountedCount = 0;
    let updatedCount = 0;
    let postponedCount = 0;
    let checkView = options.checkView || this.options.checkView;

    if (typeof checkView !== 'function') {
      checkView = null;
    } // eslint-disable-next-line


    main: for (let p = 0, n = priorities.length; p < n; p += 1) {
      const cache = priorities[p]; // eslint-disable-next-line

      for (const cid in cache) {
        if (updatedCount >= batchSize) {
          empty = false; // goto next batch

          break main; // eslint-disable-line no-labels
        }

        const view = _view__WEBPACK_IMPORTED_MODULE_3__.View.views[cid];

        if (!view) {
          delete cache[cid];
          continue;
        }

        let currentFlag = cache[cid]; // Do not check a view for viewport if we are about to remove the view.

        if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {
          const isUnmounted = (cid in updates.unmounted);

          if (checkView && !_util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(checkView, this.graph, {
            view: view,
            unmounted: isUnmounted
          })) {
            // Unmount view
            if (!isUnmounted) {
              this.registerUnmountedView(view);
              view.unmount();
            }

            updates.unmounted[cid] |= currentFlag;
            delete cache[cid];
            unmountedCount += 1;
            continue;
          } // Mount view


          if (isUnmounted) {
            currentFlag |= Renderer.FLAG_INSERT;
            mountedCount += 1;
          }

          currentFlag |= this.registerMountedView(view);
        }

        const cellView = view;
        let leftoverFlag = this.updateView(view, currentFlag, options);

        if (leftoverFlag > 0) {
          const cell = cellView.cell;

          if (cell && cell.isEdge()) {
            // remove edge view when source cell is invisible
            if (cellView.hasAction(leftoverFlag, 'source') && !this.isEdgeTerminalVisible(cell, 'source')) {
              leftoverFlag = cellView.removeAction(leftoverFlag, 'source');
              leftoverFlag |= Renderer.FLAG_REMOVE;
            } // remove edge view when target cell is invisible


            if (cellView.hasAction(leftoverFlag, 'target') && !this.isEdgeTerminalVisible(cell, 'target')) {
              leftoverFlag = cellView.removeAction(leftoverFlag, 'target');
              leftoverFlag |= Renderer.FLAG_REMOVE;
            }
          }
        }

        if (leftoverFlag > 0) {
          // update has not finished
          cache[cid] = leftoverFlag;

          if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) || cache[cid]) {
            postponedCount += 1;
            empty = false;
            continue;
          }
        }

        if (priority > p) {
          priority = p;
        }

        updatedCount += 1;
        delete cache[cid];
      }
    }

    return {
      empty,
      priority,
      mountedCount,
      unmountedCount,
      updatedCount,
      postponedCount
    };
  }

  updateViewsAsync(options = {}, data = {
    processed: 0,
    priority: Renderer.MIN_PRIORITY
  }) {
    const updates = this.updates;
    const animationId = updates.animationId;

    if (animationId) {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.cancelAnimationFrame(animationId);

      if (data.processed === 0) {
        const beforeFn = options.before;

        if (typeof beforeFn === 'function') {
          _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(beforeFn, this.graph, this.graph);
        }
      }

      const stats = this.updateViewsBatch(options);
      const checkout = this.checkViewImpl({
        checkView: options.checkView,
        mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,
        unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount
      });
      let processed = data.processed;
      const total = updates.count;
      const mountedCount = checkout.mountedCount;
      const unmountedCount = checkout.unmountedCount;

      if (stats.updatedCount > 0) {
        // Some updates have been just processed
        processed += stats.updatedCount + stats.unmountedCount;
        data.priority = Math.min(stats.priority, data.priority);

        if (stats.empty && mountedCount === 0) {
          stats.priority = data.priority;
          stats.mountedCount += mountedCount;
          stats.unmountedCount += unmountedCount;
          this.graph.trigger('render:done', {
            stats,
            options
          });
          data.processed = 0;
          updates.count = 0;
        } else {
          data.processed = processed;
        }
      } // Progress callback


      const progressFn = options.progress;

      if (total && typeof progressFn === 'function') {
        _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(progressFn, this.graph, {
          total,
          done: stats.empty,
          current: processed
        });
      } // The current frame could have been canceled in a callback


      if (updates.animationId !== animationId) {
        return;
      }
    }

    updates.animationId = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.requestAnimationFrame(() => {
      this.updateViewsAsync(options, data);
    });
  }

  registerMountedView(view) {
    const cid = view.cid;
    const updates = this.updates;

    if (cid in updates.mounted) {
      return 0;
    }

    updates.mounted[cid] = true;
    updates.mountedCids.push(cid);
    const flag = updates.unmounted[cid] || 0;
    delete updates.unmounted[cid];
    return flag;
  }

  registerUnmountedView(view) {
    const cid = view.cid;
    const updates = this.updates;

    if (cid in updates.unmounted) {
      return 0;
    }

    updates.unmounted[cid] |= Renderer.FLAG_INSERT;
    const flag = updates.unmounted[cid];
    updates.unmountedCids.push(cid);
    delete updates.mounted[cid];
    return flag;
  }

  isViewMounted(view) {
    if (view == null) {
      return false;
    }

    const cid = view.cid;
    return cid in this.updates.mounted;
  }

  getMountedViews() {
    return Object.keys(this.updates.mounted).map(cid => _view__WEBPACK_IMPORTED_MODULE_3__.CellView.views[cid]);
  }

  getUnmountedViews() {
    return Object.keys(this.updates.unmounted).map(cid => _view__WEBPACK_IMPORTED_MODULE_3__.CellView.views[cid]);
  }

  checkMountedViews(viewportFn, batchSize) {
    let unmountCount = 0;

    if (typeof viewportFn !== 'function') {
      return unmountCount;
    }

    const updates = this.updates;
    const mounted = updates.mounted;
    const mountedCids = updates.mountedCids;
    const size = batchSize == null ? mountedCids.length : Math.min(mountedCids.length, batchSize);

    for (let i = 0; i < size; i += 1) {
      const cid = mountedCids[i];

      if (!(cid in mounted)) {
        continue;
      }

      const view = _view__WEBPACK_IMPORTED_MODULE_3__.CellView.views[cid];

      if (view == null) {
        continue;
      }

      const shouldMount = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(viewportFn, this.graph, {
        view: view,
        unmounted: true
      });

      if (shouldMount) {
        // Push at the end of all mounted ids
        mountedCids.push(cid);
        continue;
      }

      unmountCount += 1;
      const flag = this.registerUnmountedView(view);

      if (flag) {
        view.unmount();
      }
    } // Get rid of views, that have been unmounted


    mountedCids.splice(0, size);
    return unmountCount;
  }

  checkUnmountedViews(checkView, batchSize) {
    let mountCount = 0;

    if (typeof checkView !== 'function') {
      checkView = null; // eslint-disable-line
    }

    const updates = this.updates;
    const unmounted = updates.unmounted;
    const unmountedCids = updates.unmountedCids;
    const size = batchSize == null ? unmountedCids.length : Math.min(unmountedCids.length, batchSize);

    for (let i = 0; i < size; i += 1) {
      const cid = unmountedCids[i];

      if (!(cid in unmounted)) {
        continue;
      }

      const view = _view__WEBPACK_IMPORTED_MODULE_3__.CellView.views[cid];

      if (view == null) {
        continue;
      }

      if (checkView && !_util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(checkView, this.graph, {
        view,
        unmounted: false
      })) {
        unmountedCids.push(cid);
        continue;
      }

      mountCount += 1;
      const flag = this.registerMountedView(view);

      if (flag) {
        this.scheduleViewUpdate(view, flag, view.priority, {
          mounting: true
        });
      }
    } // Get rid of views, that have been mounted


    unmountedCids.splice(0, size);
    return mountCount;
  }

  checkViewImpl(options = {
    mountedBatchSize: Number.MAX_SAFE_INTEGER,
    unmountedBatchSize: Number.MAX_SAFE_INTEGER
  }) {
    const checkView = options.checkView || this.options.checkView;
    const unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);
    const mountedCount = this.checkUnmountedViews(checkView, // Do not check views, that have been just unmounted
    // and pushed at the end of the cids array
    unmountedCount > 0 ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize) : options.mountedBatchSize);
    return {
      mountedCount,
      unmountedCount
    };
  }
  /**
   * Determine every view in the graph should be attached/detached.
   */


  checkView(options = {}) {
    return this.checkViewImpl(options);
  }

  isFrozen() {
    return !!this.options.frozen;
  }
  /**
   * Freeze the graph then the graph does not automatically re-render upon
   * changes in the graph. This is useful when adding large numbers of cells.
   */


  freeze(options = {}) {
    const key = options.key;
    const updates = this.updates;
    const frozen = this.options.frozen;
    const freezeKey = updates.freezeKey;

    if (key && key !== freezeKey) {
      if (frozen && freezeKey) {
        // key passed, but the graph is already freezed with another key
        return;
      }

      updates.frozen = frozen;
      updates.freezeKey = key;
    }

    this.options.frozen = true;
    const animationId = updates.animationId;
    updates.animationId = null;

    if (this.isAsync() && animationId != null) {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.cancelAnimationFrame(animationId);
    }

    this.graph.trigger('freeze', {
      key
    });
  }

  unfreeze(options = {}) {
    const key = options.key;
    const updates = this.updates;
    const freezeKey = updates.freezeKey; // key passed, but the graph is already freezed with another key

    if (key && freezeKey && key !== freezeKey) {
      return;
    }

    updates.freezeKey = null; // key passed, but the graph is already freezed

    if (key && key === freezeKey && updates.frozen) {
      return;
    }

    const callback = () => {
      this.options.frozen = updates.frozen = false;

      if (updates.sort) {
        this.sortViews();
        updates.sort = false;
      }

      const afterFn = options.after;

      if (afterFn) {
        _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(afterFn, this.graph, this.graph);
      }

      this.graph.trigger('unfreeze', {
        key
      });
    };

    if (this.isAsync()) {
      this.freeze();
      const onProgress = options.progress;
      this.updateViewsAsync(Object.assign(Object.assign({}, options), {
        progress: ({
          done,
          current,
          total
        }) => {
          if (onProgress) {
            _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(onProgress, this.graph, {
              done,
              current,
              total
            });
          } // sort views after async render


          if (done) {
            callback();
          }
        }
      }));
    } else {
      this.updateViews(options);
      callback();
    }
  }

  isAsync() {
    return !!this.options.async;
  }

  setAsync(async) {
    this.options.async = async;
  }

  onRemove() {
    this.freeze();
    this.removeViews();
  }

  resetViews(cells = [], options = {}) {
    this.resetUpdates();
    this.removeViews();
    this.freeze({
      key: 'reset'
    });

    for (let i = 0, n = cells.length; i < n; i += 1) {
      this.renderView(cells[i], options);
    }

    this.unfreeze({
      key: 'reset'
    });
    this.sortViews();
  }

  removeView(cell) {
    const view = this.views[cell.id];

    if (view) {
      const cid = view.cid;
      const updates = this.updates;
      const mounted = updates.mounted;
      const unmounted = updates.unmounted;
      view.remove();
      delete this.views[cell.id];
      delete mounted[cid];
      delete unmounted[cid];
    }

    return view;
  }

  removeViews() {
    if (this.views) {
      Object.keys(this.views).forEach(id => {
        const view = this.views[id];

        if (view) {
          this.removeView(view.cell);
        }
      });
    }

    this.views = {};
  }

  renderView(cell, options = {}) {
    const id = cell.id;
    const views = this.views;
    let flag = 0;
    let view = views[id];

    if (!cell.isVisible()) {
      return;
    }

    if (cell.isEdge()) {
      if (!this.isEdgeTerminalVisible(cell, 'source') || !this.isEdgeTerminalVisible(cell, 'target')) {
        return;
      }
    }

    if (view) {
      flag = Renderer.FLAG_INSERT;
    } else {
      const tmp = this.graph.hook.createCellView(cell);

      if (tmp) {
        view = views[cell.id] = tmp;
        view.graph = this.graph;
        flag = this.registerUnmountedView(view) | view.getBootstrapFlag();
      }
    }

    if (view) {
      this.requestViewUpdate(view, flag, view.priority, options);
    }
  }

  isExactSorting() {
    return this.options.sorting === 'exact';
  }

  sortViews() {
    if (!this.isExactSorting()) {
      return;
    }

    if (this.isFrozen()) {
      // sort views once unfrozen
      this.updates.sort = true;
      return;
    }

    this.sortViewsExact();
  }

  sortElements(elems, comparator) {
    // Highly inspired by the jquery.sortElements plugin by Padolsey.
    // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.
    const placements = elems.map(elem => {
      const parentNode = elem.parentNode; // Since the element itself will change position, we have
      // to have some way of storing it's original position in
      // the DOM. The easiest way is to have a 'flag' node:

      const nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);
      return targetNode => {
        if (parentNode === targetNode) {
          throw new Error("You can't sort elements if any one is a descendant of another.");
        } // Insert before flag


        parentNode.insertBefore(targetNode, nextSibling); // Remove flag

        parentNode.removeChild(nextSibling);
      };
    });
    elems.sort(comparator).forEach((elem, index) => placements[index](elem));
  }

  sortViewsExact() {
    // const elems = this.view.stage.querySelectorAll('[data-cell-id]')
    // const length = elems.length
    // const cells = []
    // for (let i = 0; i < length; i++) {
    //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')
    //   cells.push({
    //     id: cell.id,
    //     zIndex: cell.getZIndex() || 0,
    //     elem: elems[i],
    //   })
    // }
    // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)
    // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves
    // if (moves && moves.length) {
    //   moves.forEach((move) => {
    //     if (move.type) {
    //       const elem = move.item.elem as Element
    //       const parentNode = elem.parentNode
    //       const index = move.index
    //       if (parentNode) {
    //         if (index === length - 1) {
    //           parentNode.appendChild(elem)
    //         } else if (index < length - 1) {
    //           parentNode.insertBefore(elem, elems[index + 1])
    //         }
    //       }
    //     }
    //   })
    // }
    // Run insertion sort algorithm in order to efficiently sort DOM
    // elements according to their associated cell `zIndex` attribute.
    const elems = this.view.$(this.view.stage).children('[data-cell-id]').toArray();
    const model = this.model;
    this.sortElements(elems, (a, b) => {
      const cellA = model.getCell(a.getAttribute('data-cell-id') || '');
      const cellB = model.getCell(b.getAttribute('data-cell-id') || '');
      const z1 = cellA.getZIndex() || 0;
      const z2 = cellB.getZIndex() || 0;
      return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;
    });
  }

  addZPivot(zIndex = 0) {
    if (this.zPivots == null) {
      this.zPivots = {};
    }

    const pivots = this.zPivots;
    let pivot = pivots[zIndex];

    if (pivot) {
      return pivot;
    }

    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);
    let neighborZ = -Infinity; // eslint-disable-next-line

    for (const key in pivots) {
      const currentZ = +key;

      if (currentZ < zIndex && currentZ > neighborZ) {
        neighborZ = currentZ;

        if (neighborZ === zIndex - 1) {
          continue;
        }
      }
    }

    const layer = this.view.stage;

    if (neighborZ !== -Infinity) {
      const neighborPivot = pivots[neighborZ];
      layer.insertBefore(pivot, neighborPivot.nextSibling);
    } else {
      layer.insertBefore(pivot, layer.firstChild);
    }

    return pivot;
  }

  removeZPivots() {
    if (this.zPivots) {
      Object.keys(this.zPivots).forEach(z => {
        const elem = this.zPivots[z];

        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      });
    }

    this.zPivots = {};
  }

  insertView(view) {
    const stage = this.view.stage;

    switch (this.options.sorting) {
      case 'approx':
        {
          const zIndex = view.cell.getZIndex();
          const pivot = this.addZPivot(zIndex);
          stage.insertBefore(view.container, pivot);
          break;
        }

      case 'exact':
      default:
        stage.appendChild(view.container);
        break;
    }
  }

  findViewByCell(cell) {
    if (cell == null) {
      return null;
    }

    const id = _model__WEBPACK_IMPORTED_MODULE_2__.Cell.isCell(cell) ? cell.id : cell;
    return this.views[id];
  }

  findViewByElem(elem) {
    if (elem == null) {
      return null;
    }

    const target = typeof elem === 'string' ? this.view.stage.querySelector(elem) : elem instanceof Element ? elem : elem[0];

    if (target) {
      const id = this.view.findAttr('data-cell-id', target);

      if (id) {
        return this.views[id];
      }
    }

    return null;
  }

  findViewsFromPoint(p) {
    const ref = {
      x: p.x,
      y: p.y
    };
    return this.model.getCells().map(cell => this.findViewByCell(cell)).filter(view => {
      if (view != null) {
        return _util__WEBPACK_IMPORTED_MODULE_0__.Dom.getBBox(view.container, {
          target: this.view.stage
        }).containsPoint(ref);
      }

      return false;
    });
  }

  findEdgeViewsInArea(rect, options = {}) {
    const area = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rect);
    return this.model.getEdges().map(edge => this.findViewByCell(edge)).filter(view => {
      if (view) {
        const bbox = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.getBBox(view.container, {
          target: this.view.stage
        });

        if (bbox.width === 0) {
          bbox.inflate(1, 0);
        } else if (bbox.height === 0) {
          bbox.inflate(0, 1);
        }

        return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);
      }

      return false;
    });
  }

  findViewsInArea(rect, options = {}) {
    const area = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rect);
    return this.model.getNodes().map(node => this.findViewByCell(node)).filter(view => {
      if (view) {
        const bbox = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.getBBox(view.container, {
          target: this.view.stage
        });
        return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);
      }

      return false;
    });
  }

  dispose() {
    this.resetUpdates();
    this.stopListening();
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_4__.Base.dispose()], Renderer.prototype, "dispose", null);

(function (Renderer) {
  Renderer.FLAG_INSERT = 1 << 30;
  Renderer.FLAG_REMOVE = 1 << 29;
  Renderer.MOUNT_BATCH_SIZE = 1000;
  Renderer.UPDATE_BATCH_SIZE = 1000;
  Renderer.MIN_PRIORITY = 2;
  Renderer.SORT_DELAYING_BATCHES = ['add', 'to-front', 'to-back'];
  Renderer.UPDATE_DELAYING_BATCHES = ['translate'];
})(Renderer || (Renderer = {}));

/***/ }),

/***/ 86949:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/scroller.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollerManager": () => (/* binding */ ScrollerManager)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types */ 64060);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class ScrollerManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
  get widgetOptions() {
    return this.options.scroller;
  }

  get pannable() {
    if (this.widgetOptions) {
      if (typeof this.widgetOptions.pannable === 'object') {
        return this.widgetOptions.pannable.enabled;
      }

      return !!this.widgetOptions.pannable;
    }

    return false;
  }

  init() {
    this.widget = this.graph.hook.createScroller();
    this.startListening();
    this.updateClassName();

    if (this.widget) {
      this.widget.center();
    }
  }

  startListening() {
    let eventTypes = [];
    const pannable = this.widgetOptions.pannable;

    if (typeof pannable === 'object') {
      eventTypes = pannable.eventTypes || [];
    } else {
      eventTypes = ['leftMouseDown'];
    }

    if (eventTypes.includes('leftMouseDown')) {
      this.graph.on('blank:mousedown', this.preparePanning, this);
      this.graph.on('node:unhandled:mousedown', this.preparePanning, this);
      this.graph.on('edge:unhandled:mousedown', this.preparePanning, this);
    }

    if (eventTypes.includes('rightMouseDown')) {
      this.onRightMouseDown = this.onRightMouseDown.bind(this);
      this.view.$(this.widget.container).on('mousedown', this.onRightMouseDown);
    }
  }

  stopListening() {
    let eventTypes = [];
    const pannable = this.widgetOptions.pannable;

    if (typeof pannable === 'object') {
      eventTypes = pannable.eventTypes || [];
    } else {
      eventTypes = ['leftMouseDown'];
    }

    if (eventTypes.includes('leftMouseDown')) {
      this.graph.off('blank:mousedown', this.preparePanning, this);
      this.graph.off('node:unhandled:mousedown', this.preparePanning, this);
      this.graph.off('edge:unhandled:mousedown', this.preparePanning, this);
    }

    if (eventTypes.includes('rightMouseDown')) {
      this.view.$(this.widget.container).off('mousedown', this.onRightMouseDown);
    }
  }

  onRightMouseDown(e) {
    if (e.button === 2 && this.allowPanning(e, true) && this.widget) {
      this.updateClassName(true);
      this.widget.startPanning(e);
      this.widget.once('pan:stop', () => this.updateClassName(false));
    }
  }

  preparePanning({
    e
  }) {
    if (this.widget) {
      if (this.allowPanning(e, true) || this.allowPanning(e) && !this.graph.selection.allowRubberband(e, true)) {
        this.updateClassName(true);
        this.widget.startPanning(e);
        this.widget.once('pan:stop', () => this.updateClassName(false));
      }
    }
  }

  allowPanning(e, strict) {
    return this.widget && this.pannable && _types__WEBPACK_IMPORTED_MODULE_1__.ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict) && this.graph.hook.allowPanning(e);
  }

  updateClassName(isPanning) {
    if (this.widget == null) {
      return;
    }

    const container = this.widget.container;
    const pannable = this.view.prefixClassName('graph-scroller-pannable');

    if (this.pannable) {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(container, pannable);
      container.dataset.panning = (!!isPanning).toString(); // Use dataset to control scroller panning style to avoid reflow caused by changing classList
    } else {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(container, pannable);
    }
  }

  enablePanning() {
    if (!this.pannable) {
      this.widgetOptions.pannable = true;
      this.updateClassName(); // if (
      //   ModifierKey.equals(
      //     this.graph.options.scroller.modifiers,
      //     this.graph.options.selecting.modifiers,
      //   )
      // ) {
      //   this.graph.selection.disableRubberband()
      // }
    }
  }

  disablePanning() {
    if (this.pannable) {
      this.widgetOptions.pannable = false;
      this.updateClassName();
    }
  }

  lock() {
    if (this.widget) {
      this.widget.lock();
    }
  }

  unlock() {
    if (this.widget) {
      this.widget.unlock();
    }
  }

  update() {
    if (this.widget) {
      this.widget.update();
    }
  }

  enableAutoResize() {
    if (this.widget) {
      this.widget.enableAutoResize();
    }
  }

  disableAutoResize() {
    if (this.widget) {
      this.widget.disableAutoResize();
    }
  }

  resize(width, height) {
    if (this.widget) {
      this.widget.resize(width, height);
    }
  }

  dispose() {
    if (this.widget) {
      this.widget.dispose();
    }

    this.stopListening();
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_2__.Base.dispose()], ScrollerManager.prototype, "dispose", null);

/***/ }),

/***/ 93330:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/selection.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectionManager": () => (/* binding */ SelectionManager)
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ 64060);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class SelectionManager extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
  constructor() {
    super(...arguments);
    this.movedMap = new WeakMap();
    this.unselectMap = new WeakMap();
  }

  get widgetOptions() {
    return this.options.selecting;
  }

  get rubberbandDisabled() {
    return this.widgetOptions.enabled !== true || this.widgetOptions.rubberband !== true;
  }

  get disabled() {
    return this.widgetOptions.enabled !== true;
  }

  get length() {
    return this.widget.length;
  }

  get cells() {
    return this.widget.cells;
  }

  init() {
    this.widget = this.graph.hook.createSelection();
    this.startListening();
  }

  startListening() {
    this.graph.on('blank:mousedown', this.onBlankMouseDown, this);
    this.graph.on('blank:click', this.onBlankClick, this);
    this.graph.on('cell:mousemove', this.onCellMouseMove, this);
    this.graph.on('cell:mouseup', this.onCellMouseUp, this);
    this.widget.on('box:mousedown', this.onBoxMouseDown, this);
  }

  stopListening() {
    this.graph.off('blank:mousedown', this.onBlankMouseDown, this);
    this.graph.off('blank:click', this.onBlankClick, this);
    this.graph.off('cell:mousemove', this.onCellMouseMove, this);
    this.graph.off('cell:mouseup', this.onCellMouseUp, this);
    this.widget.off('box:mousedown', this.onBoxMouseDown, this);
  }

  onBlankMouseDown({
    e
  }) {
    if (this.allowRubberband(e, true) || this.allowRubberband(e) && !this.graph.scroller.allowPanning(e, true) && !this.graph.panning.allowPanning(e, true)) {
      this.startRubberband(e);
    }
  }

  onBlankClick() {
    this.clean();
  }

  allowRubberband(e, strict) {
    return !this.rubberbandDisabled && _types__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict) && this.graph.hook.allowRubberband(e);
  }

  allowMultipleSelection(e) {
    return this.isMultiple() && _types__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.widgetOptions.multipleSelectionModifiers);
  }

  onCellMouseMove({
    cell
  }) {
    this.movedMap.set(cell, true);
  }

  onCellMouseUp({
    e,
    cell
  }) {
    const options = this.widgetOptions;
    let disabled = this.disabled;

    if (!disabled && this.movedMap.has(cell)) {
      disabled = options.selectCellOnMoved === false;

      if (!disabled) {
        disabled = options.selectNodeOnMoved === false && cell.isNode();
      }

      if (!disabled) {
        disabled = options.selectEdgeOnMoved === false && cell.isEdge();
      }
    }

    if (!disabled) {
      if (!this.allowMultipleSelection(e)) {
        this.reset(cell);
      } else if (this.unselectMap.has(cell)) {
        this.unselectMap.delete(cell);
      } else if (this.isSelected(cell)) {
        this.unselect(cell);
      } else {
        this.select(cell);
      }
    }

    this.movedMap.delete(cell);
  }

  onBoxMouseDown({
    e,
    cell
  }) {
    if (!this.disabled) {
      if (this.allowMultipleSelection(e)) {
        this.unselect(cell);
        this.unselectMap.set(cell, true);
      }
    }
  }

  isEmpty() {
    return this.length <= 0;
  }

  isSelected(cell) {
    return this.widget.isSelected(cell);
  }

  getCells(cells) {
    return (Array.isArray(cells) ? cells : [cells]).map(cell => typeof cell === 'string' ? this.graph.getCellById(cell) : cell).filter(cell => cell != null);
  }

  select(cells, options = {}) {
    const selected = this.getCells(cells);

    if (selected.length) {
      if (this.isMultiple()) {
        this.widget.select(selected, options);
      } else {
        this.reset(selected.slice(0, 1), options);
      }
    }

    return this;
  }

  unselect(cells, options = {}) {
    this.widget.unselect(this.getCells(cells), options);
    return this;
  }

  reset(cells, options = {}) {
    this.widget.reset(cells ? this.getCells(cells) : [], options);
    return this;
  }

  clean(options = {}) {
    this.widget.clean(options);
    return this;
  }

  enable() {
    if (this.disabled) {
      this.widgetOptions.enabled = true;
    }

    return this;
  }

  disable() {
    if (!this.disabled) {
      this.widgetOptions.enabled = false;
    }

    return this;
  }

  startRubberband(e) {
    if (!this.rubberbandDisabled) {
      this.widget.startSelecting(e);
    }

    return this;
  }

  enableRubberband() {
    if (this.rubberbandDisabled) {
      this.widgetOptions.rubberband = true; // if (
      //   ModifierKey.equals(
      //     this.graph.options.scroller.modifiers,
      //     this.graph.options.selecting.modifiers,
      //   )
      // ) {
      //   this.graph.scroller.disablePanning()
      // }
    }

    return this;
  }

  disableRubberband() {
    if (!this.rubberbandDisabled) {
      this.widgetOptions.rubberband = false;
    }

    return this;
  }

  isMultiple() {
    return this.widgetOptions.multiple !== false;
  }

  enableMultiple() {
    this.widgetOptions.multiple = true;
    return this;
  }

  disableMultiple() {
    this.widgetOptions.multiple = false;
    return this;
  }

  setModifiers(modifiers) {
    this.widgetOptions.modifiers = modifiers;
    return this;
  }

  setContent(content) {
    this.widget.setContent(content);
    return this;
  }

  setFilter(filter) {
    this.widget.setFilter(filter);
    return this;
  }

  dispose() {
    this.stopListening();
    this.widget.dispose();
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_1__.Base.dispose()], SelectionManager.prototype, "dispose", null);

/***/ }),

/***/ 2682:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/size.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SizeManager": () => (/* binding */ SizeManager)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ 94997);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class SizeManager extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
  hasScroller() {
    return this.graph.scroller.widget != null;
  }

  getContainer() {
    return this.hasScroller() ? this.graph.scroller.widget.container : this.graph.container;
  }

  init() {
    const autoResize = this.options.autoResize;

    if (autoResize) {
      const target = typeof autoResize === 'boolean' ? this.getContainer() : autoResize;
      _util__WEBPACK_IMPORTED_MODULE_1__.SizeSensor.bind(target, () => {
        const container = this.getContainer(); // container is border-box

        const width = container.offsetWidth;
        const height = container.offsetHeight;
        this.resize(width, height);
      });
    }
  }

  resize(width, height) {
    if (this.hasScroller()) {
      this.resizeScroller(width, height);
    } else {
      this.resizeGraph(width, height);
    }
  }

  resizeGraph(width, height) {
    this.graph.transform.resize(width, height);
  }

  resizeScroller(width, height) {
    this.graph.scroller.resize(width, height);
  }

  resizePage(width, height) {
    const instance = this.graph.scroller.widget;

    if (instance) {
      instance.updatePageSize(width, height);
    }
  }

  dispose() {
    _util__WEBPACK_IMPORTED_MODULE_1__.SizeSensor.clear(this.getContainer());
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_0__.Base.dispose()], SizeManager.prototype, "dispose", null);

/***/ }),

/***/ 61871:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/snapline.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SnaplineManager": () => (/* binding */ SnaplineManager)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class SnaplineManager extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
  constructor() {
    super(...arguments);
    this.widget = this.graph.hook.createSnapline();
  }

  dispose() {
    this.widget.dispose();
  }

}

__decorate([_base__WEBPACK_IMPORTED_MODULE_0__.Base.dispose()], SnaplineManager.prototype, "dispose", null);

/***/ }),

/***/ 33795:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/transform.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformManager": () => (/* binding */ TransformManager)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ 94997);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class TransformManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
  constructor() {
    super(...arguments);
    this.widgets = new Map();
  }

  get container() {
    return this.graph.view.container;
  }

  get viewport() {
    return this.graph.view.viewport;
  }

  get isSelectionEnabled() {
    return this.options.selecting.enabled === true;
  }

  init() {
    this.startListening();
    this.resize();
  }

  startListening() {
    this.graph.on('node:mouseup', this.onNodeMouseUp, this);
    this.graph.on('node:selected', this.onNodeSelected, this);
    this.graph.on('node:unselected', this.onNodeUnSelected, this);
  }

  stopListening() {
    this.graph.off('node:mouseup', this.onNodeMouseUp, this);
    this.graph.off('node:selected', this.onNodeSelected, this);
    this.graph.off('node:unselected', this.onNodeUnSelected, this);
  }

  onNodeMouseUp({
    node
  }) {
    if (!this.isSelectionEnabled) {
      const widget = this.graph.hook.createTransform(node, {
        clearAll: true
      });

      if (widget) {
        this.widgets.set(node, widget);
      }
    }
  }

  onNodeSelected({
    node
  }) {
    if (this.isSelectionEnabled) {
      const widget = this.graph.hook.createTransform(node, {
        clearAll: false
      });

      if (widget) {
        this.widgets.set(node, widget);
      }
    }
  }

  onNodeUnSelected({
    node
  }) {
    if (this.isSelectionEnabled) {
      const widget = this.widgets.get(node);

      if (widget) {
        widget.dispose();
      }

      this.widgets.delete(node);
    }
  }
  /**
   * Returns the current transformation matrix of the graph.
   */


  getMatrix() {
    const transform = this.viewport.getAttribute('transform');

    if (transform !== this.viewportTransformString) {
      // `getCTM`: top-left relative to the SVG element
      // `getScreenCTM`: top-left relative to the document
      this.viewportMatrix = this.viewport.getCTM();
      this.viewportTransformString = transform;
    } // Clone the cached current transformation matrix.
    // If no matrix previously stored the identity matrix is returned.


    return _util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix(this.viewportMatrix);
  }
  /**
   * Sets new transformation with the given `matrix`
   */


  setMatrix(matrix) {
    const ctm = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix(matrix);
    const transform = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToTransformString(ctm);
    this.viewport.setAttribute('transform', transform);
    this.viewportMatrix = ctm;
    this.viewportTransformString = transform;
  }

  resize(width, height) {
    let w = width === undefined ? this.options.width : width;
    let h = height === undefined ? this.options.height : height;
    this.options.width = w;
    this.options.height = h;

    if (typeof w === 'number') {
      w = Math.round(w);
    }

    if (typeof h === 'number') {
      h = Math.round(h);
    }

    this.container.style.width = w == null ? '' : `${w}px`;
    this.container.style.height = h == null ? '' : `${h}px`;
    const size = this.getComputedSize();
    this.graph.trigger('resize', Object.assign({}, size));
    return this;
  }

  getComputedSize() {
    let w = this.options.width;
    let h = this.options.height;

    if (!_util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isNumber(w)) {
      w = this.container.clientWidth;
    }

    if (!_util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isNumber(h)) {
      h = this.container.clientHeight;
    }

    return {
      width: w,
      height: h
    };
  }

  getScale() {
    return _util__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToScale(this.getMatrix());
  }

  scale(sx, sy = sx, ox = 0, oy = 0, options = {}) {
    sx = this.clampScale(sx); // eslint-disable-line

    sy = this.clampScale(sy); // eslint-disable-line

    if (ox || oy) {
      const ts = this.getTranslation();
      const tx = ts.tx - ox * (sx - 1);
      const ty = ts.ty - oy * (sy - 1);

      if (tx !== ts.tx || ty !== ts.ty) {
        this.translate(tx, ty);
      }
    }

    const matrix = this.getMatrix();
    matrix.a = sx;
    matrix.d = sy;
    this.setMatrix(matrix);
    this.graph.trigger('scale', Object.assign({
      sx,
      sy,
      ox,
      oy
    }, options));
    return this;
  }

  clampScale(scale) {
    const range = this.graph.options.scaling;
    return _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(scale, range.min || 0.01, range.max || 16);
  }

  getZoom() {
    return this.getScale().sx;
  }

  zoom(factor, options) {
    options = options || {}; // eslint-disable-line

    let sx = factor;
    let sy = factor;
    const scale = this.getScale();
    const clientSize = this.getComputedSize();
    let cx = clientSize.width / 2;
    let cy = clientSize.height / 2;

    if (!options.absolute) {
      sx += scale.sx;
      sy += scale.sy;
    }

    if (options.scaleGrid) {
      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
    }

    if (options.maxScale) {
      sx = Math.min(options.maxScale, sx);
      sy = Math.min(options.maxScale, sy);
    }

    if (options.minScale) {
      sx = Math.max(options.minScale, sx);
      sy = Math.max(options.minScale, sy);
    }

    if (options.center) {
      cx = options.center.x;
      cy = options.center.y;
    }

    sx = this.clampScale(sx);
    sy = this.clampScale(sy);

    if (cx || cy) {
      const ts = this.getTranslation();
      const tx = cx - (cx - ts.tx) * (sx / scale.sx);
      const ty = cy - (cy - ts.ty) * (sy / scale.sy);

      if (tx !== ts.tx || ty !== ts.ty) {
        this.translate(tx, ty, {
          ui: options.ui
        });
      }
    }

    this.scale(sx, sy, 0, 0, {
      ui: options.ui
    });
    return this;
  }

  getRotation() {
    return _util__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToRotation(this.getMatrix());
  }

  rotate(angle, cx, cy) {
    if (cx == null || cy == null) {
      const bbox = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.getBBox(this.graph.view.stage);
      cx = bbox.width / 2; // eslint-disable-line

      cy = bbox.height / 2; // eslint-disable-line
    }

    const ctm = this.getMatrix().translate(cx, cy).rotate(angle).translate(-cx, -cy);
    this.setMatrix(ctm);
    return this;
  }

  getTranslation() {
    return _util__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToTranslation(this.getMatrix());
  }

  translate(tx, ty, options = {}) {
    const matrix = this.getMatrix();
    matrix.e = tx || 0;
    matrix.f = ty || 0;
    this.setMatrix(matrix);
    const ts = this.getTranslation();
    this.options.x = ts.tx;
    this.options.y = ts.ty;
    this.graph.trigger('translate', Object.assign(Object.assign({}, ts), options));
    return this;
  }

  setOrigin(ox, oy) {
    return this.translate(ox || 0, oy || 0);
  }

  fitToContent(gridWidth, gridHeight, padding, options) {
    if (typeof gridWidth === 'object') {
      const opts = gridWidth;
      gridWidth = opts.gridWidth || 1; // eslint-disable-line

      gridHeight = opts.gridHeight || 1; // eslint-disable-line

      padding = opts.padding || 0; // eslint-disable-line

      options = opts; // eslint-disable-line
    } else {
      gridWidth = gridWidth || 1; // eslint-disable-line

      gridHeight = gridHeight || 1; // eslint-disable-line

      padding = padding || 0; // eslint-disable-line

      if (options == null) {
        options = {}; // eslint-disable-line
      }
    }

    const paddings = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(padding);
    const border = options.border || 0;
    const contentArea = options.contentArea ? _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(options.contentArea) : this.getContentArea(options);

    if (border > 0) {
      contentArea.inflate(border);
    }

    const scale = this.getScale();
    const translate = this.getTranslation();
    const sx = scale.sx;
    const sy = scale.sy;
    contentArea.x *= sx;
    contentArea.y *= sy;
    contentArea.width *= sx;
    contentArea.height *= sy;
    let width = Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) * gridWidth;
    let height = Math.max(Math.ceil((contentArea.height + contentArea.y) / gridHeight), 1) * gridHeight;
    let tx = 0;
    let ty = 0;

    if (options.allowNewOrigin === 'negative' && contentArea.x < 0 || options.allowNewOrigin === 'positive' && contentArea.x >= 0 || options.allowNewOrigin === 'any') {
      tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth;
      tx += paddings.left;
      width += tx;
    }

    if (options.allowNewOrigin === 'negative' && contentArea.y < 0 || options.allowNewOrigin === 'positive' && contentArea.y >= 0 || options.allowNewOrigin === 'any') {
      ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight;
      ty += paddings.top;
      height += ty;
    }

    width += paddings.right;
    height += paddings.bottom; // Make sure the resulting width and height are greater than minimum.

    width = Math.max(width, options.minWidth || 0);
    height = Math.max(height, options.minHeight || 0); // Make sure the resulting width and height are lesser than maximum.

    width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER);
    height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER);
    const size = this.getComputedSize();
    const sizeChanged = width !== size.width || height !== size.height;
    const originChanged = tx !== translate.tx || ty !== translate.ty; // Change the dimensions only if there is a size discrepency or an origin change

    if (originChanged) {
      this.translate(tx, ty);
    }

    if (sizeChanged) {
      this.resize(width, height);
    }

    return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(-tx / sx, -ty / sy, width / sx, height / sy);
  }

  scaleContentToFit(options = {}) {
    this.scaleContentToFitImpl(options);
  }

  scaleContentToFitImpl(options = {}, translate = true) {
    let contentBBox;
    let contentLocalOrigin;

    if (options.contentArea) {
      const contentArea = options.contentArea;
      contentBBox = this.graph.localToGraph(contentArea);
      contentLocalOrigin = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(contentArea);
    } else {
      contentBBox = this.getContentBBox(options);
      contentLocalOrigin = this.graph.graphToLocal(contentBBox);
    }

    if (!contentBBox.width || !contentBBox.height) {
      return;
    }

    const padding = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(options.padding);
    const minScale = options.minScale || 0;
    const maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;
    const minScaleX = options.minScaleX || minScale;
    const maxScaleX = options.maxScaleX || maxScale;
    const minScaleY = options.minScaleY || minScale;
    const maxScaleY = options.maxScaleY || maxScale;
    let fittingBox;

    if (options.viewportArea) {
      fittingBox = options.viewportArea;
    } else {
      const computedSize = this.getComputedSize();
      const currentTranslate = this.getTranslation();
      fittingBox = {
        x: currentTranslate.tx,
        y: currentTranslate.ty,
        width: computedSize.width,
        height: computedSize.height
      };
    }

    fittingBox = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(fittingBox).moveAndExpand({
      x: padding.left,
      y: padding.top,
      width: -padding.left - padding.right,
      height: -padding.top - padding.bottom
    });
    const currentScale = this.getScale();
    let newSX = fittingBox.width / contentBBox.width * currentScale.sx;
    let newSY = fittingBox.height / contentBBox.height * currentScale.sy;

    if (options.preserveAspectRatio !== false) {
      newSX = newSY = Math.min(newSX, newSY);
    } // snap scale to a grid


    const gridSize = options.scaleGrid;

    if (gridSize) {
      newSX = gridSize * Math.floor(newSX / gridSize);
      newSY = gridSize * Math.floor(newSY / gridSize);
    } // scale min/max boundaries


    newSX = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(newSX, minScaleX, maxScaleX);
    newSY = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(newSY, minScaleY, maxScaleY);
    this.scale(newSX, newSY);

    if (translate) {
      const origin = this.options;
      const newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x;
      const newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y;
      this.translate(newOX, newOY);
    }
  }

  getContentArea(options = {}) {
    if (options.useCellGeometry) {
      return this.model.getAllCellsBBox() || new _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
    }

    return _util__WEBPACK_IMPORTED_MODULE_0__.Dom.getBBox(this.graph.view.stage);
  }

  getContentBBox(options = {}) {
    return this.graph.localToGraph(this.getContentArea(options));
  }

  getGraphArea() {
    const rect = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromSize(this.getComputedSize());
    return this.graph.graphToLocal(rect);
  }

  zoomToRect(rect, options = {}) {
    const area = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rect);
    const graph = this.graph;
    options.contentArea = area;

    if (options.viewportArea == null) {
      options.viewportArea = {
        x: graph.options.x,
        y: graph.options.y,
        width: this.options.width,
        height: this.options.height
      };
    }

    this.scaleContentToFitImpl(options, false);
    const center = area.getCenter();
    this.centerPoint(center.x, center.y);
    return this;
  }

  zoomToFit(options = {}) {
    return this.zoomToRect(this.getContentArea(options), options);
  }

  centerPoint(x, y) {
    const clientSize = this.getComputedSize();
    const scale = this.getScale();
    const ts = this.getTranslation();
    const cx = clientSize.width / 2;
    const cy = clientSize.height / 2;
    x = typeof x === 'number' ? x : cx; // eslint-disable-line

    y = typeof y === 'number' ? y : cy; // eslint-disable-line

    x = cx - x * scale.sx; // eslint-disable-line

    y = cy - y * scale.sy; // eslint-disable-line

    if (ts.tx !== x || ts.ty !== y) {
      this.translate(x, y);
    }
  }

  centerContent(options) {
    const rect = this.graph.getContentArea(options);
    const center = rect.getCenter();
    this.centerPoint(center.x, center.y);
  }

  centerCell(cell) {
    return this.positionCell(cell, 'center');
  }

  positionPoint(point, x, y) {
    const clientSize = this.getComputedSize(); // eslint-disable-next-line

    x = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(x, Math.max(0, clientSize.width));

    if (x < 0) {
      x = clientSize.width + x; // eslint-disable-line
    } // eslint-disable-next-line


    y = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(y, Math.max(0, clientSize.height));

    if (y < 0) {
      y = clientSize.height + y; // eslint-disable-line
    }

    const ts = this.getTranslation();
    const scale = this.getScale();
    const dx = x - point.x * scale.sx;
    const dy = y - point.y * scale.sy;

    if (ts.tx !== dx || ts.ty !== dy) {
      this.translate(dx, dy);
    }
  }

  positionRect(rect, pos) {
    const bbox = _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rect);

    switch (pos) {
      case 'center':
        return this.positionPoint(bbox.getCenter(), '50%', '50%');

      case 'top':
        return this.positionPoint(bbox.getTopCenter(), '50%', 0);

      case 'top-right':
        return this.positionPoint(bbox.getTopRight(), '100%', 0);

      case 'right':
        return this.positionPoint(bbox.getRightMiddle(), '100%', '50%');

      case 'bottom-right':
        return this.positionPoint(bbox.getBottomRight(), '100%', '100%');

      case 'bottom':
        return this.positionPoint(bbox.getBottomCenter(), '50%', '100%');

      case 'bottom-left':
        return this.positionPoint(bbox.getBottomLeft(), 0, '100%');

      case 'left':
        return this.positionPoint(bbox.getLeftMiddle(), 0, '50%');

      case 'top-left':
        return this.positionPoint(bbox.getTopLeft(), 0, 0);

      default:
        return this;
    }
  }

  positionCell(cell, pos) {
    const bbox = cell.getBBox();
    return this.positionRect(bbox, pos);
  }

  positionContent(pos, options) {
    const rect = this.graph.getContentArea(options);
    return this.positionRect(rect, pos);
  }

  dispose() {
    this.widgets.forEach(widget => widget.dispose());
    this.widgets.clear();
    this.stopListening();
  }

}

__decorate([TransformManager.dispose()], TransformManager.prototype, "dispose", null);

/***/ }),

/***/ 716:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/view.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphView": () => (/* binding */ GraphView)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model */ 59502);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global */ 9789);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../view */ 29818);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class GraphView extends _view__WEBPACK_IMPORTED_MODULE_4__.View {
  constructor(graph) {
    super();
    this.graph = graph;
    const {
      selectors,
      fragment
    } = _view__WEBPACK_IMPORTED_MODULE_4__.Markup.parseJSONMarkup(GraphView.markup);
    this.background = selectors.background;
    this.grid = selectors.grid;
    this.svg = selectors.svg;
    this.defs = selectors.defs;
    this.viewport = selectors.viewport;
    this.primer = selectors.primer;
    this.stage = selectors.stage;
    this.decorator = selectors.decorator;
    this.overlay = selectors.overlay;
    this.container = this.options.container;
    this.restore = GraphView.snapshoot(this.container);
    this.$(this.container).addClass(this.prefixClassName('graph')).append(fragment);
    this.delegateEvents();
  }

  get model() {
    return this.graph.model;
  }

  get options() {
    return this.graph.options;
  }

  delegateEvents() {
    const ctor = this.constructor;
    super.delegateEvents(ctor.events);
    return this;
  }
  /**
   * Guard the specified event. If the event is not interesting, it
   * returns `true`, otherwise returns `false`.
   */


  guard(e, view) {
    // handled as `contextmenu` type
    if (e.type === 'mousedown' && e.button === 2) {
      return true;
    }

    if (this.options.guard && this.options.guard(e, view)) {
      return true;
    }

    if (e.data && e.data.guarded !== undefined) {
      return e.data.guarded;
    }

    if (view && view.cell && _model__WEBPACK_IMPORTED_MODULE_2__.Cell.isCell(view.cell)) {
      return false;
    }

    if (this.svg === e.target || this.container === e.target || jquery__WEBPACK_IMPORTED_MODULE_0___default().contains(this.svg, e.target)) {
      return false;
    }

    return true;
  }

  findView(elem) {
    return this.graph.renderer.findViewByElem(elem);
  }

  onDblClick(evt) {
    if (this.options.preventDefaultDblClick) {
      evt.preventDefault();
    }

    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.guard(e, view)) {
      return;
    }

    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);

    if (view) {
      view.onDblClick(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger('blank:dblclick', {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }

  onClick(evt) {
    if (this.getMouseMovedCount(evt) <= this.options.clickThreshold) {
      const e = this.normalizeEvent(evt);
      const view = this.findView(e.target);

      if (this.guard(e, view)) {
        return;
      }

      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);

      if (view) {
        view.onClick(e, localPoint.x, localPoint.y);
      } else {
        this.graph.trigger('blank:click', {
          e,
          x: localPoint.x,
          y: localPoint.y
        });
      }
    }
  }

  isPreventDefaultContextMenu(evt, view) {
    let preventDefaultContextMenu = this.options.preventDefaultContextMenu;

    if (typeof preventDefaultContextMenu === 'function') {
      preventDefaultContextMenu = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(preventDefaultContextMenu, this.graph, {
        view
      });
    }

    return preventDefaultContextMenu;
  }

  onContextMenu(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.isPreventDefaultContextMenu(e, view)) {
      evt.preventDefault();
    }

    if (this.guard(e, view)) {
      return;
    }

    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);

    if (view) {
      view.onContextMenu(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger('blank:contextmenu', {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }

  delegateDragEvents(e, view) {
    if (e.data == null) {
      e.data = {};
    }

    this.setEventData(e, {
      currentView: view || null,
      mouseMovedCount: 0,
      startPosition: {
        x: e.clientX,
        y: e.clientY
      }
    });
    const ctor = this.constructor;
    this.delegateDocumentEvents(ctor.documentEvents, e.data);
    this.undelegateEvents();
  }

  getMouseMovedCount(e) {
    const data = this.getEventData(e);
    return data.mouseMovedCount || 0;
  }

  onMouseDown(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.guard(e, view)) {
      return;
    }

    if (this.options.preventDefaultMouseDown) {
      e.preventDefault();
    }

    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);

    if (view) {
      view.onMouseDown(e, localPoint.x, localPoint.y);
    } else {
      if (this.options.preventDefaultBlankAction) {
        e.preventDefault();
      }

      this.graph.trigger('blank:mousedown', {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }

    this.delegateDragEvents(e, view);
  }

  onMouseMove(evt) {
    const data = this.getEventData(evt);
    const startPosition = data.startPosition;

    if (startPosition && startPosition.x === evt.clientX && startPosition.y === evt.clientY) {
      return;
    }

    if (data.mouseMovedCount == null) {
      data.mouseMovedCount = 0;
    }

    data.mouseMovedCount += 1;
    const mouseMovedCount = data.mouseMovedCount;

    if (mouseMovedCount <= this.options.moveThreshold) {
      return;
    }

    const e = this.normalizeEvent(evt);
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    const view = data.currentView;

    if (view) {
      view.onMouseMove(e, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger('blank:mousemove', {
        e,
        x: localPoint.x,
        y: localPoint.y
      });
    }

    this.setEventData(e, data);
  }

  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const normalized = this.normalizeEvent(e);
    const localPoint = this.graph.snapToGrid(normalized.clientX, normalized.clientY);
    const data = this.getEventData(e);
    const view = data.currentView;

    if (view) {
      view.onMouseUp(normalized, localPoint.x, localPoint.y);
    } else {
      this.graph.trigger('blank:mouseup', {
        e: normalized,
        x: localPoint.x,
        y: localPoint.y
      });
    }

    if (!e.isPropagationStopped()) {
      this.onClick(jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(e, {
        type: 'click',
        data: e.data
      }));
    }

    e.stopImmediatePropagation();
    this.delegateEvents();
  }

  onMouseOver(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.guard(e, view)) {
      return;
    }

    if (view) {
      view.onMouseOver(e);
    } else {
      // prevent border of paper from triggering this
      if (this.container === e.target) {
        return;
      }

      this.graph.trigger('blank:mouseover', {
        e
      });
    }
  }

  onMouseOut(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.guard(e, view)) {
      return;
    }

    if (view) {
      view.onMouseOut(e);
    } else {
      if (this.container === e.target) {
        return;
      }

      this.graph.trigger('blank:mouseout', {
        e
      });
    }
  }

  onMouseEnter(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.guard(e, view)) {
      return;
    }

    const relatedView = this.graph.renderer.findViewByElem(e.relatedTarget);

    if (view) {
      if (relatedView === view) {
        // mouse moved from tool to view
        return;
      }

      view.onMouseEnter(e);
    } else {
      if (relatedView) {
        return;
      }

      this.graph.trigger('graph:mouseenter', {
        e
      });
    }
  }

  onMouseLeave(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.guard(e, view)) {
      return;
    }

    const relatedView = this.graph.renderer.findViewByElem(e.relatedTarget);

    if (view) {
      if (relatedView === view) {
        // mouse moved from view to tool
        return;
      }

      view.onMouseLeave(e);
    } else {
      if (relatedView) {
        return;
      }

      this.graph.trigger('graph:mouseleave', {
        e
      });
    }
  }

  onMouseWheel(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.guard(e, view)) {
      return;
    }

    const originalEvent = e.originalEvent;
    const localPoint = this.graph.snapToGrid(originalEvent.clientX, originalEvent.clientY);
    const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta || -originalEvent.detail));

    if (view) {
      view.onMouseWheel(e, localPoint.x, localPoint.y, delta);
    } else {
      this.graph.trigger('blank:mousewheel', {
        e,
        delta,
        x: localPoint.x,
        y: localPoint.y
      });
    }
  }

  onCustomEvent(evt) {
    const elem = evt.currentTarget;
    const event = elem.getAttribute('event') || elem.getAttribute('data-event');

    if (event) {
      const view = this.findView(elem);

      if (view) {
        const e = this.normalizeEvent(evt);

        if (this.guard(e, view)) {
          return;
        }

        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        view.onCustomEvent(e, event, localPoint.x, localPoint.y);
      }
    }
  }

  handleMagnetEvent(evt, handler) {
    const magnetElem = evt.currentTarget;
    const magnetValue = magnetElem.getAttribute('magnet');

    if (magnetValue && magnetValue.toLowerCase() !== 'false') {
      const view = this.findView(magnetElem);

      if (view) {
        const e = this.normalizeEvent(evt);

        if (this.guard(e, view)) {
          return;
        }

        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(handler, this.graph, view, e, magnetElem, localPoint.x, localPoint.y);
      }
    }
  }

  onMagnetMouseDown(e) {
    this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
      view.onMagnetMouseDown(e, magnet, x, y);
    });
  }

  onMagnetDblClick(e) {
    this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
      view.onMagnetDblClick(e, magnet, x, y);
    });
  }

  onMagnetContextMenu(evt) {
    const e = this.normalizeEvent(evt);
    const view = this.findView(e.target);

    if (this.isPreventDefaultContextMenu(e, view)) {
      e.preventDefault();
    }

    this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
      view.onMagnetContextMenu(e, magnet, x, y);
    });
  }

  onLabelMouseDown(evt) {
    const labelNode = evt.currentTarget;
    const view = this.findView(labelNode);

    if (view) {
      const e = this.normalizeEvent(evt);

      if (this.guard(e, view)) {
        return;
      }

      const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
      view.onLabelMouseDown(e, localPoint.x, localPoint.y);
    }
  }

  onImageDragStart() {
    // This is the only way to prevent image dragging in Firefox that works.
    // Setting -moz-user-select: none, draggable="false" attribute or
    // user-drag: none didn't help.
    return false;
  }

  dispose() {
    this.undelegateEvents();
    this.undelegateDocumentEvents();
    this.restore();

    this.restore = () => {};
  }

}

__decorate([_view__WEBPACK_IMPORTED_MODULE_4__.View.dispose()], GraphView.prototype, "dispose", null);

(function (GraphView) {
  const prefixCls = `${_global__WEBPACK_IMPORTED_MODULE_3__.Config.prefixCls}-graph`;
  GraphView.markup = [{
    ns: _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.xhtml,
    tagName: 'div',
    selector: 'background',
    className: `${prefixCls}-background`
  }, {
    ns: _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.xhtml,
    tagName: 'div',
    selector: 'grid',
    className: `${prefixCls}-grid`
  }, {
    ns: _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.svg,
    tagName: 'svg',
    selector: 'svg',
    className: `${prefixCls}-svg`,
    attrs: {
      width: '100%',
      height: '100%',
      'xmlns:xlink': _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.xlink
    },
    children: [{
      tagName: 'defs',
      selector: 'defs'
    }, {
      tagName: 'g',
      selector: 'viewport',
      className: `${prefixCls}-svg-viewport`,
      children: [{
        tagName: 'g',
        selector: 'primer',
        className: `${prefixCls}-svg-primer`
      }, {
        tagName: 'g',
        selector: 'stage',
        className: `${prefixCls}-svg-stage`
      }, {
        tagName: 'g',
        selector: 'decorator',
        className: `${prefixCls}-svg-decorator`
      }, {
        tagName: 'g',
        selector: 'overlay',
        className: `${prefixCls}-svg-overlay`
      }]
    }]
  }];

  function snapshoot(elem) {
    const cloned = elem.cloneNode();
    elem.childNodes.forEach(child => cloned.appendChild(child));
    return () => {
      // remove all children
      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.empty(elem); // remove all attributes

      while (elem.attributes.length > 0) {
        elem.removeAttribute(elem.attributes[0].name);
      } // restore attributes


      for (let i = 0, l = cloned.attributes.length; i < l; i += 1) {
        const attr = cloned.attributes[i];
        elem.setAttribute(attr.name, attr.value);
      } // restore children


      cloned.childNodes.forEach(child => elem.appendChild(child));
    };
  }

  GraphView.snapshoot = snapshoot;
})(GraphView || (GraphView = {}));

(function (GraphView) {
  const prefixCls = _global__WEBPACK_IMPORTED_MODULE_3__.Config.prefixCls;
  GraphView.events = {
    dblclick: 'onDblClick',
    contextmenu: 'onContextMenu',
    touchstart: 'onMouseDown',
    mousedown: 'onMouseDown',
    mouseover: 'onMouseOver',
    mouseout: 'onMouseOut',
    mouseenter: 'onMouseEnter',
    mouseleave: 'onMouseLeave',
    mousewheel: 'onMouseWheel',
    DOMMouseScroll: 'onMouseWheel',
    [`mouseenter  .${prefixCls}-cell`]: 'onMouseEnter',
    [`mouseleave  .${prefixCls}-cell`]: 'onMouseLeave',
    [`mouseenter  .${prefixCls}-cell-tools`]: 'onMouseEnter',
    [`mouseleave  .${prefixCls}-cell-tools`]: 'onMouseLeave',
    [`mousedown   .${prefixCls}-cell [event]`]: 'onCustomEvent',
    [`touchstart  .${prefixCls}-cell [event]`]: 'onCustomEvent',
    [`mousedown   .${prefixCls}-cell [data-event]`]: 'onCustomEvent',
    [`touchstart  .${prefixCls}-cell [data-event]`]: 'onCustomEvent',
    [`dblclick    .${prefixCls}-cell [magnet]`]: 'onMagnetDblClick',
    [`contextmenu .${prefixCls}-cell [magnet]`]: 'onMagnetContextMenu',
    [`mousedown   .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',
    [`touchstart  .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',
    [`dblclick    .${prefixCls}-cell [data-magnet]`]: 'onMagnetDblClick',
    [`contextmenu .${prefixCls}-cell [data-magnet]`]: 'onMagnetContextMenu',
    [`mousedown   .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',
    [`touchstart  .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',
    [`dragstart   .${prefixCls}-cell image`]: 'onImageDragStart',
    [`mousedown   .${prefixCls}-edge .${prefixCls}-edge-label`]: 'onLabelMouseDown',
    [`touchstart  .${prefixCls}-edge .${prefixCls}-edge-label`]: 'onLabelMouseDown'
  };
  GraphView.documentEvents = {
    mousemove: 'onMouseMove',
    touchmove: 'onMouseMove',
    mouseup: 'onMouseUp',
    touchend: 'onMouseUp',
    touchcancel: 'onMouseUp'
  };
})(GraphView || (GraphView = {}));

/***/ }),

/***/ 4038:
/*!*******************************************!*\
  !*** ./node_modules/@antv/x6/es/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Addon": () => (/* reexport module object */ _addon__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   "Angle": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Angle),
/* harmony export */   "ArrayExt": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.ArrayExt),
/* harmony export */   "Basecoat": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Basecoat),
/* harmony export */   "Cell": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_7__.Cell),
/* harmony export */   "CellView": () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_8__.CellView),
/* harmony export */   "Collection": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_7__.Collection),
/* harmony export */   "Color": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Color),
/* harmony export */   "Config": () => (/* reexport safe */ _global__WEBPACK_IMPORTED_MODULE_10__.Config),
/* harmony export */   "Curve": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Curve),
/* harmony export */   "DataUri": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.DataUri),
/* harmony export */   "Dictionary": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Dictionary),
/* harmony export */   "Dijkstra": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Dijkstra),
/* harmony export */   "Disablable": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Disablable),
/* harmony export */   "Disposable": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Disposable),
/* harmony export */   "DisposableDelegate": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.DisposableDelegate),
/* harmony export */   "DisposableSet": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.DisposableSet),
/* harmony export */   "Dom": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.Dom),
/* harmony export */   "Edge": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_7__.Edge),
/* harmony export */   "EdgeView": () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_8__.EdgeView),
/* harmony export */   "Ellipse": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Ellipse),
/* harmony export */   "Events": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Events),
/* harmony export */   "FunctionExt": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.FunctionExt),
/* harmony export */   "Graph": () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_9__.Graph),
/* harmony export */   "Interp": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Interp),
/* harmony export */   "JQuery": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.JQuery),
/* harmony export */   "JSONExt": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.JSONExt),
/* harmony export */   "Lang": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.Lang),
/* harmony export */   "Line": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Line),
/* harmony export */   "LocalStorage": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.LocalStorage),
/* harmony export */   "Markup": () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_8__.Markup),
/* harmony export */   "Model": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_7__.Model),
/* harmony export */   "Node": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_7__.Node),
/* harmony export */   "NodeView": () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_8__.NodeView),
/* harmony export */   "NumberExt": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.NumberExt),
/* harmony export */   "ObjectExt": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.ObjectExt),
/* harmony export */   "Path": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Path),
/* harmony export */   "Platform": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.Platform),
/* harmony export */   "Point": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Point),
/* harmony export */   "Polyline": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Polyline),
/* harmony export */   "PriorityQueue": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.PriorityQueue),
/* harmony export */   "Rectangle": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Rectangle),
/* harmony export */   "Registry": () => (/* reexport module object */ _registry__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   "Scheduler": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.Scheduler),
/* harmony export */   "Segment": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_6__.Segment),
/* harmony export */   "Shape": () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_0__.Shape),
/* harmony export */   "SizeSensor": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.SizeSensor),
/* harmony export */   "StringExt": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.StringExt),
/* harmony export */   "Text": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.Text),
/* harmony export */   "Timing": () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_5__.Timing),
/* harmony export */   "ToolsView": () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_8__.ToolsView),
/* harmony export */   "Unit": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.Unit),
/* harmony export */   "Util": () => (/* reexport safe */ _global__WEBPACK_IMPORTED_MODULE_10__.Util),
/* harmony export */   "Vector": () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_4__.Vector),
/* harmony export */   "View": () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_8__.View),
/* harmony export */   "version": () => (/* reexport safe */ _global__WEBPACK_IMPORTED_MODULE_10__.version)
/* harmony export */ });
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape */ 37623);
/* harmony import */ var _addon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addon */ 78955);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./registry */ 73306);
/* harmony import */ var _global_track__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./global/track */ 90920);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ 44650);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common */ 57566);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geometry */ 17653);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./model */ 59502);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./view */ 29818);
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./graph */ 24598);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./global */ 9789);


 // start track
// -----------











/***/ }),

/***/ 75444:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/layout/grid.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "grid": () => (/* binding */ grid)
/* harmony export */ });
/* harmony import */ var _model_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/model */ 69314);

function grid(cells, options = {}) {
  const model = _model_model__WEBPACK_IMPORTED_MODULE_0__.Model.isModel(cells) ? cells : new _model_model__WEBPACK_IMPORTED_MODULE_0__.Model().resetCells(cells, {
    sort: false,
    dryrun: true
  });
  const nodes = model.getNodes();
  const columns = options.columns || 1;
  const rows = Math.ceil(nodes.length / columns);
  const dx = options.dx || 0;
  const dy = options.dy || 0;
  const centre = options.center !== false;
  const resizeToFit = options.resizeToFit === true;
  const marginX = options.marginX || 0;
  const marginY = options.marginY || 0;
  const columnWidths = [];
  let columnWidth = options.columnWidth;

  if (columnWidth === 'compact') {
    for (let j = 0; j < columns; j += 1) {
      const items = GridLayout.getNodesInColumn(nodes, j, columns);
      columnWidths.push(GridLayout.getMaxDim(items, 'width') + dx);
    }
  } else {
    if (columnWidth == null || columnWidth === 'auto') {
      columnWidth = GridLayout.getMaxDim(nodes, 'width') + dx;
    }

    for (let i = 0; i < columns; i += 1) {
      columnWidths.push(columnWidth);
    }
  }

  const columnLefts = GridLayout.accumulate(columnWidths, marginX);
  const rowHeights = [];
  let rowHeight = options.rowHeight;

  if (rowHeight === 'compact') {
    for (let i = 0; i < rows; i += 1) {
      const items = GridLayout.getNodesInRow(nodes, i, columns);
      rowHeights.push(GridLayout.getMaxDim(items, 'height') + dy);
    }
  } else {
    if (rowHeight == null || rowHeight === 'auto') {
      rowHeight = GridLayout.getMaxDim(nodes, 'height') + dy;
    }

    for (let i = 0; i < rows; i += 1) {
      rowHeights.push(rowHeight);
    }
  }

  const rowTops = GridLayout.accumulate(rowHeights, marginY);
  model.startBatch('layout');
  nodes.forEach((node, index) => {
    const rowIndex = index % columns;
    const columnIndex = Math.floor(index / columns);
    const columnWidth = columnWidths[rowIndex];
    const rowHeight = rowHeights[columnIndex];
    let cx = 0;
    let cy = 0;
    let size = node.getSize();

    if (resizeToFit) {
      let width = columnWidth - 2 * dx;
      let height = rowHeight - 2 * dy;
      const calcHeight = size.height * (size.width ? width / size.width : 1);
      const calcWidth = size.width * (size.height ? height / size.height : 1);

      if (rowHeight < calcHeight) {
        width = calcWidth;
      } else {
        height = calcHeight;
      }

      size = {
        width,
        height
      };
      node.setSize(size, options);
    }

    if (centre) {
      cx = (columnWidth - size.width) / 2;
      cy = (rowHeight - size.height) / 2;
    }

    node.position(columnLefts[rowIndex] + dx + cx, rowTops[columnIndex] + dy + cy, options);
  });
  model.stopBatch('layout');
}
var GridLayout;

(function (GridLayout) {
  function getMaxDim(nodes, name) {
    return nodes.reduce((memo, node) => Math.max(node.getSize()[name], memo), 0);
  }

  GridLayout.getMaxDim = getMaxDim;

  function getNodesInRow(nodes, rowIndex, columnCount) {
    const res = [];

    for (let i = columnCount * rowIndex, ii = i + columnCount; i < ii; i += 1) {
      res.push(nodes[i]);
    }

    return res;
  }

  GridLayout.getNodesInRow = getNodesInRow;

  function getNodesInColumn(nodes, columnIndex, columnCount) {
    const res = [];

    for (let i = columnIndex, ii = nodes.length; i < ii; i += columnCount) {
      res.push(nodes[i]);
    }

    return res;
  }

  GridLayout.getNodesInColumn = getNodesInColumn;

  function accumulate(items, start) {
    return items.reduce((memo, item, i) => {
      memo.push(memo[i] + item);
      return memo;
    }, [start || 0]);
  }

  GridLayout.accumulate = accumulate;
})(GridLayout || (GridLayout = {}));

/***/ }),

/***/ 1603:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/animation.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": () => (/* binding */ Animation)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ 57566);


class Animation {
  constructor(cell) {
    this.cell = cell;
    this.ids = {};
    this.cache = {};
  }

  get() {
    return Object.keys(this.ids);
  }

  start(path, targetValue, options = {}, delim = '/') {
    const startValue = this.cell.getPropByPath(path);
    const localOptions = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.defaults(options, Animation.defaultOptions);
    const timing = this.getTiming(localOptions.timing);
    const interpolate = this.getInterp(localOptions.interp, startValue, targetValue);
    let startTime = 0;
    const key = Array.isArray(path) ? path.join(delim) : path;
    const paths = Array.isArray(path) ? path : path.split(delim);

    const iterate = () => {
      const now = new Date().getTime();

      if (startTime === 0) {
        startTime = now;
      }

      const elaspe = now - startTime;
      let progress = elaspe / localOptions.duration;

      if (progress < 1) {
        this.ids[key] = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.requestAnimationFrame(iterate);
      } else {
        progress = 1;
      }

      const currentValue = interpolate(timing(progress));
      this.cell.setPropByPath(paths, currentValue);

      if (options.progress) {
        options.progress(Object.assign({
          progress,
          currentValue
        }, this.getArgs(key)));
      }

      if (progress === 1) {
        // TODO: remove in the next major version
        this.cell.notify('transition:end', this.getArgs(key));
        this.cell.notify('transition:complete', this.getArgs(key));
        options.complete && options.complete(this.getArgs(key));
        this.cell.notify('transition:finish', this.getArgs(key));
        options.finish && options.finish(this.getArgs(key));
        this.clean(key);
      }
    };

    setTimeout(() => {
      this.stop(path, undefined, delim);
      this.cache[key] = {
        startValue,
        targetValue,
        options: localOptions
      };
      this.ids[key] = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.requestAnimationFrame(iterate); // TODO: remove in the next major version

      this.cell.notify('transition:begin', this.getArgs(key));
      this.cell.notify('transition:start', this.getArgs(key));
      options.start && options.start(this.getArgs(key));
    }, options.delay);
    return this.stop.bind(this, path, delim, options);
  }

  stop(path, options = {}, delim = '/') {
    const paths = Array.isArray(path) ? path : path.split(delim);
    Object.keys(this.ids).filter(key => _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(paths, key.split(delim).slice(0, paths.length))).forEach(key => {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.cancelAnimationFrame(this.ids[key]);
      const data = this.cache[key];
      const commonArgs = this.getArgs(key);
      const localOptions = Object.assign(Object.assign({}, data.options), options);
      const jumpedToEnd = localOptions.jumpedToEnd;

      if (jumpedToEnd && data.targetValue != null) {
        this.cell.setPropByPath(key, data.targetValue);
        this.cell.notify('transition:end', Object.assign({}, commonArgs));
        this.cell.notify('transition:complete', Object.assign({}, commonArgs));
        localOptions.complete && localOptions.complete(Object.assign({}, commonArgs));
      }

      const stopArgs = Object.assign({
        jumpedToEnd
      }, commonArgs);
      this.cell.notify('transition:stop', Object.assign({}, stopArgs));
      localOptions.stop && localOptions.stop(Object.assign({}, stopArgs));
      this.cell.notify('transition:finish', Object.assign({}, commonArgs));
      localOptions.finish && localOptions.finish(Object.assign({}, commonArgs));
      this.clean(key);
    });
    return this;
  }

  clean(key) {
    delete this.ids[key];
    delete this.cache[key];
  }

  getTiming(timing) {
    return typeof timing === 'string' ? _common__WEBPACK_IMPORTED_MODULE_1__.Timing[timing] : timing;
  }

  getInterp(interp, startValue, targetValue) {
    if (interp) {
      return interp(startValue, targetValue);
    }

    if (typeof targetValue === 'number') {
      return _common__WEBPACK_IMPORTED_MODULE_1__.Interp.number(startValue, targetValue);
    }

    if (typeof targetValue === 'string') {
      if (targetValue[0] === '#') {
        return _common__WEBPACK_IMPORTED_MODULE_1__.Interp.color(startValue, targetValue);
      }

      return _common__WEBPACK_IMPORTED_MODULE_1__.Interp.unit(startValue, targetValue);
    }

    return _common__WEBPACK_IMPORTED_MODULE_1__.Interp.object(startValue, targetValue);
  }

  getArgs(key) {
    const data = this.cache[key];
    return {
      path: key,
      startValue: data.startValue,
      targetValue: data.targetValue,
      cell: this.cell
    };
  }

}

(function (Animation) {
  Animation.defaultOptions = {
    delay: 10,
    duration: 100,
    timing: 'linear'
  };
})(Animation || (Animation = {}));

/***/ }),

/***/ 30936:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/cell.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cell": () => (/* binding */ Cell)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ 57566);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./animation */ 1603);
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./store */ 78497);
/* eslint-disable no-underscore-dangle */
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







class Cell extends _common__WEBPACK_IMPORTED_MODULE_2__.Basecoat {
  constructor(metadata = {}) {
    super();
    const ctor = this.constructor;
    const defaults = ctor.getDefaults(true);
    const props = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, this.preprocess(defaults), this.preprocess(metadata));
    this.id = props.id || _util__WEBPACK_IMPORTED_MODULE_0__.StringExt.uuid();
    this.store = new _store__WEBPACK_IMPORTED_MODULE_5__.Store(props);
    this.animation = new _animation__WEBPACK_IMPORTED_MODULE_4__.Animation(this);
    this.setup();
    this.init();
    this.postprocess(metadata);
  }

  static config(presets) {
    const {
      markup,
      propHooks,
      attrHooks
    } = presets,
          others = __rest(presets, ["markup", "propHooks", "attrHooks"]);

    if (markup != null) {
      this.markup = markup;
    }

    if (propHooks) {
      this.propHooks = this.propHooks.slice();

      if (Array.isArray(propHooks)) {
        this.propHooks.push(...propHooks);
      } else if (typeof propHooks === 'function') {
        this.propHooks.push(propHooks);
      } else {
        Object.keys(propHooks).forEach(name => {
          const hook = propHooks[name];

          if (typeof hook === 'function') {
            this.propHooks.push(hook);
          }
        });
      }
    }

    if (attrHooks) {
      this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);
    }

    this.defaults = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, this.defaults, others);
  }

  static getMarkup() {
    return this.markup;
  }

  static getDefaults(raw) {
    return raw ? this.defaults : _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.defaults);
  }

  static getAttrHooks() {
    return this.attrHooks;
  }

  static applyPropHooks(cell, metadata) {
    return this.propHooks.reduce((memo, hook) => {
      return hook ? _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(hook, cell, memo) : memo;
    }, metadata);
  } // #endregion


  get [Symbol.toStringTag]() {
    return Cell.toStringTag;
  }

  init() {} // #region model


  get model() {
    return this._model;
  }

  set model(model) {
    if (this._model !== model) {
      this._model = model;
    }
  } // #endregion


  preprocess(metadata, ignoreIdCheck) {
    const id = metadata.id;
    const ctor = this.constructor;
    const props = ctor.applyPropHooks(this, metadata);

    if (id == null && ignoreIdCheck !== true) {
      props.id = _util__WEBPACK_IMPORTED_MODULE_0__.StringExt.uuid();
    }

    return props;
  }

  postprocess(metadata) {} // eslint-disable-line


  setup() {
    this.store.on('change:*', metadata => {
      const {
        key,
        current,
        previous,
        options
      } = metadata;
      this.notify('change:*', {
        key,
        options,
        current,
        previous,
        cell: this
      });
      this.notify(`change:${key}`, {
        options,
        current,
        previous,
        cell: this
      });
      const type = key;

      if (type === 'source' || type === 'target') {
        this.notify(`change:terminal`, {
          type,
          current,
          previous,
          options,
          cell: this
        });
      }
    });
    this.store.on('changed', ({
      options
    }) => this.notify('changed', {
      options,
      cell: this
    }));
  }

  notify(name, args) {
    this.trigger(name, args);
    const model = this.model;

    if (model) {
      model.notify(`cell:${name}`, args);

      if (this.isNode()) {
        model.notify(`node:${name}`, Object.assign(Object.assign({}, args), {
          node: this
        }));
      } else if (this.isEdge()) {
        model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), {
          edge: this
        }));
      }
    }

    return this;
  }

  isNode() {
    return false;
  }

  isEdge() {
    return false;
  }

  isSameStore(cell) {
    return this.store === cell.store;
  }

  get view() {
    return this.store.get('view');
  }

  get shape() {
    return this.store.get('shape', '');
  }

  getProp(key, defaultValue) {
    if (key == null) {
      return this.store.get();
    }

    return this.store.get(key, defaultValue);
  }

  setProp(key, value, options) {
    if (typeof key === 'string') {
      this.store.set(key, value, options);
    } else {
      const props = this.preprocess(key, true);
      this.store.set(_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, this.getProp(), props), value);
      this.postprocess(key);
    }

    return this;
  }

  removeProp(key, options) {
    if (typeof key === 'string' || Array.isArray(key)) {
      this.store.removeByPath(key, options);
    } else {
      this.store.remove(options);
    }

    return this;
  }

  hasChanged(key) {
    return key == null ? this.store.hasChanged() : this.store.hasChanged(key);
  }

  getPropByPath(path) {
    return this.store.getByPath(path);
  }

  setPropByPath(path, value, options = {}) {
    if (this.model) {
      // update inner reference
      if (path === 'children') {
        this._children = value ? value.map(id => this.model.getCell(id)).filter(child => child != null) : null;
      } else if (path === 'parent') {
        this._parent = value ? this.model.getCell(value) : null;
      }
    }

    this.store.setByPath(path, value, options);
    return this;
  }

  removePropByPath(path, options = {}) {
    const paths = Array.isArray(path) ? path : path.split('/'); // Once a property is removed from the `attrs` the CellView will
    // recognize a `dirty` flag and re-render itself in order to remove
    // the attribute from SVGElement.

    if (paths[0] === 'attrs') {
      options.dirty = true;
    }

    this.store.removeByPath(paths, options);
    return this;
  }

  prop(key, value, options) {
    if (key == null) {
      return this.getProp();
    }

    if (typeof key === 'string' || Array.isArray(key)) {
      if (arguments.length === 1) {
        return this.getPropByPath(key);
      }

      if (value == null) {
        return this.removePropByPath(key, options || {});
      }

      return this.setPropByPath(key, value, options || {});
    }

    return this.setProp(key, value || {});
  }

  previous(name) {
    return this.store.getPrevious(name);
  } // #endregion
  // #region zIndex


  get zIndex() {
    return this.getZIndex();
  }

  set zIndex(z) {
    if (z == null) {
      this.removeZIndex();
    } else {
      this.setZIndex(z);
    }
  }

  getZIndex() {
    return this.store.get('zIndex');
  }

  setZIndex(z, options = {}) {
    this.store.set('zIndex', z, options);
    return this;
  }

  removeZIndex(options = {}) {
    this.store.remove('zIndex', options);
    return this;
  }

  toFront(options = {}) {
    const model = this.model;

    if (model) {
      let z = model.getMaxZIndex();
      let cells;

      if (options.deep) {
        cells = this.getDescendants({
          deep: true,
          breadthFirst: true
        });
        cells.unshift(this);
      } else {
        cells = [this];
      }

      z = z - cells.length + 1;
      const count = model.total();
      let changed = model.indexOf(this) !== count - cells.length;

      if (!changed) {
        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);
      }

      if (changed) {
        this.batchUpdate('to-front', () => {
          z += cells.length;
          cells.forEach((cell, index) => {
            cell.setZIndex(z + index, options);
          });
        });
      }
    }

    return this;
  }

  toBack(options = {}) {
    const model = this.model;

    if (model) {
      let z = model.getMinZIndex();
      let cells;

      if (options.deep) {
        cells = this.getDescendants({
          deep: true,
          breadthFirst: true
        });
        cells.unshift(this);
      } else {
        cells = [this];
      }

      let changed = model.indexOf(this) !== 0;

      if (!changed) {
        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);
      }

      if (changed) {
        this.batchUpdate('to-back', () => {
          z -= cells.length;
          cells.forEach((cell, index) => {
            cell.setZIndex(z + index, options);
          });
        });
      }
    }

    return this;
  } // #endregion
  // #region markup


  get markup() {
    return this.getMarkup();
  }

  set markup(value) {
    if (value == null) {
      this.removeMarkup();
    } else {
      this.setMarkup(value);
    }
  }

  getMarkup() {
    let markup = this.store.get('markup');

    if (markup == null) {
      const ctor = this.constructor;
      markup = ctor.getMarkup();
    }

    return markup;
  }

  setMarkup(markup, options = {}) {
    this.store.set('markup', markup, options);
    return this;
  }

  removeMarkup(options = {}) {
    this.store.remove('markup', options);
    return this;
  } // #endregion
  // #region attrs


  get attrs() {
    return this.getAttrs();
  }

  set attrs(value) {
    if (value == null) {
      this.removeAttrs();
    } else {
      this.setAttrs(value);
    }
  }

  getAttrs() {
    const result = this.store.get('attrs');
    return result ? Object.assign({}, result) : {};
  }

  setAttrs(attrs, options = {}) {
    if (attrs == null) {
      this.removeAttrs(options);
    } else {
      const set = attrs => this.store.set('attrs', attrs, options);

      if (options.overwrite === true) {
        set(attrs);
      } else {
        const prev = this.getAttrs();

        if (options.deep === false) {
          set(Object.assign(Object.assign({}, prev), attrs));
        } else {
          set(_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, prev, attrs));
        }
      }
    }

    return this;
  }

  replaceAttrs(attrs, options = {}) {
    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {
      overwrite: true
    }));
  }

  updateAttrs(attrs, options = {}) {
    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {
      deep: false
    }));
  }

  removeAttrs(options = {}) {
    this.store.remove('attrs', options);
    return this;
  }

  getAttrDefinition(attrName) {
    if (!attrName) {
      return null;
    }

    const ctor = this.constructor;
    const hooks = ctor.getAttrHooks() || {};
    let definition = hooks[attrName] || _registry__WEBPACK_IMPORTED_MODULE_3__.Attr.registry.get(attrName);

    if (!definition) {
      const name = _util__WEBPACK_IMPORTED_MODULE_0__.StringExt.camelCase(attrName);
      definition = hooks[name] || _registry__WEBPACK_IMPORTED_MODULE_3__.Attr.registry.get(name);
    }

    return definition || null;
  }

  getAttrByPath(path) {
    if (path == null || path === '') {
      return this.getAttrs();
    }

    return this.getPropByPath(this.prefixAttrPath(path));
  }

  setAttrByPath(path, value, options = {}) {
    this.setPropByPath(this.prefixAttrPath(path), value, options);
    return this;
  }

  removeAttrByPath(path, options = {}) {
    this.removePropByPath(this.prefixAttrPath(path), options);
    return this;
  }

  prefixAttrPath(path) {
    return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;
  }

  attr(path, value, options) {
    if (path == null) {
      return this.getAttrByPath();
    }

    if (typeof path === 'string' || Array.isArray(path)) {
      if (arguments.length === 1) {
        return this.getAttrByPath(path);
      }

      if (value == null) {
        return this.removeAttrByPath(path, options || {});
      }

      return this.setAttrByPath(path, value, options || {});
    }

    return this.setAttrs(path, value || {});
  } // #endregion
  // #region visible


  get visible() {
    return this.isVisible();
  }

  set visible(value) {
    this.setVisible(value);
  }

  setVisible(visible, options = {}) {
    this.store.set('visible', visible, options);
    return this;
  }

  isVisible() {
    return this.store.get('visible') !== false;
  }

  show(options = {}) {
    if (!this.isVisible()) {
      this.setVisible(true, options);
    }

    return this;
  }

  hide(options = {}) {
    if (this.isVisible()) {
      this.setVisible(false, options);
    }

    return this;
  }

  toggleVisible(isVisible, options = {}) {
    const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();
    const localOptions = typeof isVisible === 'boolean' ? options : isVisible;

    if (visible) {
      this.show(localOptions);
    } else {
      this.hide(localOptions);
    }

    return this;
  } // #endregion
  // #region data


  get data() {
    return this.getData();
  }

  set data(val) {
    this.setData(val);
  }

  getData() {
    return this.store.get('data');
  }

  setData(data, options = {}) {
    if (data == null) {
      this.removeData(options);
    } else {
      const set = data => this.store.set('data', data, options);

      if (options.overwrite === true) {
        set(data);
      } else {
        const prev = this.getData();

        if (options.deep === false) {
          set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);
        } else {
          set(_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, prev, data));
        }
      }
    }

    return this;
  }

  replaceData(data, options = {}) {
    return this.setData(data, Object.assign(Object.assign({}, options), {
      overwrite: true
    }));
  }

  updateData(data, options = {}) {
    return this.setData(data, Object.assign(Object.assign({}, options), {
      deep: false
    }));
  }

  removeData(options = {}) {
    this.store.remove('data', options);
    return this;
  } // #endregion
  // #region parent children


  get parent() {
    return this.getParent();
  }

  get children() {
    return this.getChildren();
  }

  getParentId() {
    return this.store.get('parent');
  }

  getParent() {
    const parentId = this.getParentId();

    if (parentId && this.model) {
      const parent = this.model.getCell(parentId);
      this._parent = parent;
      return parent;
    }

    return null;
  }

  getChildren() {
    const childrenIds = this.store.get('children');

    if (childrenIds && childrenIds.length && this.model) {
      const children = childrenIds.map(id => {
        var _a;

        return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id);
      }).filter(cell => cell != null);
      this._children = children;
      return [...children];
    }

    return null;
  }

  hasParent() {
    return this.parent != null;
  }

  isParentOf(child) {
    return child != null && child.getParent() === this;
  }

  isChildOf(parent) {
    return parent != null && this.getParent() === parent;
  }

  eachChild(iterator, context) {
    if (this.children) {
      this.children.forEach(iterator, context);
    }

    return this;
  }

  filterChild(filter, context) {
    return this.children ? this.children.filter(filter, context) : [];
  }

  getChildCount() {
    return this.children == null ? 0 : this.children.length;
  }

  getChildIndex(child) {
    return this.children == null ? -1 : this.children.indexOf(child);
  }

  getChildAt(index) {
    return this.children != null && index >= 0 ? this.children[index] : null;
  }

  getAncestors(options = {}) {
    const ancestors = [];
    let parent = this.getParent();

    while (parent) {
      ancestors.push(parent);
      parent = options.deep !== false ? parent.getParent() : null;
    }

    return ancestors;
  }

  getDescendants(options = {}) {
    if (options.deep !== false) {
      // breadth first
      if (options.breadthFirst) {
        const cells = [];
        const queue = this.getChildren() || [];

        while (queue.length > 0) {
          const parent = queue.shift();
          const children = parent.getChildren();
          cells.push(parent);

          if (children) {
            queue.push(...children);
          }
        }

        return cells;
      } // depth first


      {
        const cells = this.getChildren() || [];
        cells.forEach(cell => {
          cells.push(...cell.getDescendants(options));
        });
        return cells;
      }
    }

    return this.getChildren() || [];
  }

  isDescendantOf(ancestor, options = {}) {
    if (ancestor == null) {
      return false;
    }

    if (options.deep !== false) {
      let current = this.getParent();

      while (current) {
        if (current === ancestor) {
          return true;
        }

        current = current.getParent();
      }

      return false;
    }

    return this.isChildOf(ancestor);
  }

  isAncestorOf(descendant, options = {}) {
    if (descendant == null) {
      return false;
    }

    return descendant.isDescendantOf(this, options);
  }

  contains(cell) {
    return this.isAncestorOf(cell);
  }

  getCommonAncestor(...cells) {
    return Cell.getCommonAncestor(this, ...cells);
  }

  setParent(parent, options = {}) {
    this._parent = parent;

    if (parent) {
      this.store.set('parent', parent.id, options);
    } else {
      this.store.remove('parent', options);
    }

    return this;
  }

  setChildren(children, options = {}) {
    this._children = children;

    if (children != null) {
      this.store.set('children', children.map(child => child.id), options);
    } else {
      this.store.remove('children', options);
    }

    return this;
  }

  unembed(child, options = {}) {
    const children = this.children;

    if (children != null && child != null) {
      const index = this.getChildIndex(child);

      if (index !== -1) {
        children.splice(index, 1);
        child.setParent(null, options);
        this.setChildren(children, options);
      }
    }

    return this;
  }

  embed(child, options = {}) {
    child.addTo(this, options);
    return this;
  }

  addTo(target, options = {}) {
    if (Cell.isCell(target)) {
      target.addChild(this, options);
    } else {
      target.addCell(this, options);
    }

    return this;
  }

  insertTo(parent, index, options = {}) {
    parent.insertChild(this, index, options);
    return this;
  }

  addChild(child, options = {}) {
    return this.insertChild(child, undefined, options);
  }

  insertChild(child, index, options = {}) {
    if (child != null && child !== this) {
      const oldParent = child.getParent();
      const changed = this !== oldParent;
      let pos = index;

      if (pos == null) {
        pos = this.getChildCount();

        if (!changed) {
          pos -= 1;
        }
      } // remove from old parent


      if (oldParent) {
        const children = oldParent.getChildren();

        if (children) {
          const index = children.indexOf(child);

          if (index >= 0) {
            child.setParent(null, options);
            children.splice(index, 1);
            oldParent.setChildren(children, options);
          }
        }
      }

      let children = this.children;

      if (children == null) {
        children = [];
        children.push(child);
      } else {
        children.splice(pos, 0, child);
      }

      child.setParent(this, options);
      this.setChildren(children, options);

      if (changed && this.model) {
        const incomings = this.model.getIncomingEdges(this);
        const outgoings = this.model.getOutgoingEdges(this);

        if (incomings) {
          incomings.forEach(edge => edge.updateParent(options));
        }

        if (outgoings) {
          outgoings.forEach(edge => edge.updateParent(options));
        }
      }

      if (this.model) {
        this.model.addCell(child, options);
      }
    }

    return this;
  }

  removeFromParent(options = {}) {
    const parent = this.getParent();

    if (parent != null) {
      const index = parent.getChildIndex(this);
      parent.removeChildAt(index, options);
    }

    return this;
  }

  removeChild(child, options = {}) {
    const index = this.getChildIndex(child);
    return this.removeChildAt(index, options);
  }

  removeChildAt(index, options = {}) {
    const child = this.getChildAt(index);
    const children = this.children;

    if (children != null && child != null) {
      this.unembed(child, options);
      child.remove(options);
    }

    return child;
  }

  remove(options = {}) {
    this.batchUpdate('remove', () => {
      const parent = this.getParent();

      if (parent) {
        parent.removeChild(this, options);
      }

      if (options.deep !== false) {
        this.eachChild(child => child.remove(options));
      }

      if (this.model) {
        this.model.removeCell(this, options);
      }
    });
    return this;
  }

  transition(path, target, options = {}, delim = '/') {
    return this.animation.start(path, target, options, delim);
  }

  stopTransition(path, options, delim = '/') {
    this.animation.stop(path, options, delim);
    return this;
  }

  getTransitions() {
    return this.animation.get();
  } // #endregion
  // #region transform
  // eslint-disable-next-line


  translate(tx, ty, options) {
    return this;
  }

  scale(sx, // eslint-disable-line
  sy, // eslint-disable-line
  origin, // eslint-disable-line
  options) {
    return this;
  }

  addTools(items, obj, options) {
    const toolItems = Array.isArray(items) ? items : [items];
    const name = typeof obj === 'string' ? obj : null;
    const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};

    if (config.reset) {
      return this.setTools({
        name,
        items: toolItems,
        local: config.local
      }, config);
    }

    let tools = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.getTools());

    if (tools == null || name == null || tools.name === name) {
      if (tools == null) {
        tools = {};
      }

      if (!tools.items) {
        tools.items = [];
      }

      tools.name = name;
      tools.items = [...tools.items, ...toolItems];
      return this.setTools(Object.assign({}, tools), config);
    }
  }

  setTools(tools, options = {}) {
    if (tools == null) {
      this.removeTools();
    } else {
      this.store.set('tools', Cell.normalizeTools(tools), options);
    }

    return this;
  }

  getTools() {
    return this.store.get('tools');
  }

  removeTools(options = {}) {
    this.store.remove('tools', options);
    return this;
  }

  hasTools(name) {
    const tools = this.getTools();

    if (tools == null) {
      return false;
    }

    if (name == null) {
      return true;
    }

    return tools.name === name;
  }

  hasTool(name) {
    const tools = this.getTools();

    if (tools == null) {
      return false;
    }

    return tools.items.some(item => typeof item === 'string' ? item === name : item.name === name);
  }

  removeTool(nameOrIndex, options = {}) {
    const tools = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.getTools());

    if (tools) {
      let updated = false;
      const items = tools.items.slice();

      const remove = index => {
        items.splice(index, 1);
        updated = true;
      };

      if (typeof nameOrIndex === 'number') {
        remove(nameOrIndex);
      } else {
        for (let i = items.length - 1; i >= 0; i -= 1) {
          const item = items[i];
          const exist = typeof item === 'string' ? item === nameOrIndex : item.name === nameOrIndex;

          if (exist) {
            remove(i);
          }
        }
      }

      if (updated) {
        tools.items = items;
        this.setTools(tools, options);
      }
    }

    return this;
  } // #endregion
  // #region common
  // eslint-disable-next-line


  getBBox(options) {
    return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
  } // eslint-disable-next-line


  getConnectionPoint(edge, type) {
    return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
  }

  toJSON(options = {}) {
    const props = Object.assign({}, this.store.get());
    const toString = Object.prototype.toString;
    const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';

    if (!props.shape) {
      const ctor = this.constructor;
      throw new Error(`Unable to serialize ${cellType} missing "shape" prop, check the ${cellType} "${ctor.name || toString.call(ctor)}"`);
    }

    const ctor = this.constructor;
    const diff = options.diff === true;
    const attrs = props.attrs || {};
    const presets = ctor.getDefaults(true); // When `options.diff` is `true`, we should process the custom options,
    // such as `width`, `height` etc. to ensure the comparing work correctly.

    const defaults = diff ? this.preprocess(presets, true) : presets;
    const defaultAttrs = defaults.attrs || {};
    const finalAttrs = {};
    Object.keys(props).forEach(key => {
      const val = props[key];

      if (val != null && !Array.isArray(val) && typeof val === 'object' && !_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(val)) {
        throw new Error(`Can only serialize ${cellType} with plain-object props, but got a "${toString.call(val)}" type of key "${key}" on ${cellType} "${this.id}"`);
      }

      if (key !== 'attrs' && key !== 'shape' && diff) {
        const preset = defaults[key];

        if (_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(val, preset)) {
          delete props[key];
        }
      }
    });
    Object.keys(attrs).forEach(key => {
      const attr = attrs[key];
      const defaultAttr = defaultAttrs[key];
      Object.keys(attr).forEach(name => {
        const value = attr[name];
        const defaultValue = defaultAttr ? defaultAttr[name] : null;

        if (value != null && typeof value === 'object' && !Array.isArray(value)) {
          Object.keys(value).forEach(subName => {
            const subValue = value[subName];

            if (defaultAttr == null || defaultValue == null || !_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(defaultValue) || !_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(defaultValue[subName], subValue)) {
              if (finalAttrs[key] == null) {
                finalAttrs[key] = {};
              }

              if (finalAttrs[key][name] == null) {
                finalAttrs[key][name] = {};
              }

              const tmp = finalAttrs[key][name];
              tmp[subName] = subValue;
            }
          });
        } else if (defaultAttr == null || !_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(defaultValue, value)) {
          // `value` is not an object, default attribute with `key` does not
          // exist or it is different than the attribute value set on the cell.
          if (finalAttrs[key] == null) {
            finalAttrs[key] = {};
          }

          finalAttrs[key][name] = value;
        }
      });
    });
    const finalProps = Object.assign(Object.assign({}, props), {
      attrs: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs
    });

    if (finalProps.attrs == null) {
      delete finalProps.attrs;
    }

    const ret = finalProps;

    if (ret.angle === 0) {
      delete ret.angle;
    }

    return _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(ret);
  }

  clone(options = {}) {
    if (!options.deep) {
      const data = Object.assign({}, this.store.get());

      if (!options.keepId) {
        delete data.id;
      }

      delete data.parent;
      delete data.children;
      const ctor = this.constructor;
      return new ctor(data); // eslint-disable-line new-cap
    } // Deep cloning. Clone the cell itself and all its children.


    const map = Cell.deepClone(this);
    return map[this.id];
  }

  findView(graph) {
    return graph.renderer.findViewByCell(this);
  } // #endregion
  // #region batch


  startBatch(name, data = {}, model = this.model) {
    this.notify('batch:start', {
      name,
      data,
      cell: this
    });

    if (model) {
      model.startBatch(name, Object.assign(Object.assign({}, data), {
        cell: this
      }));
    }

    return this;
  }

  stopBatch(name, data = {}, model = this.model) {
    if (model) {
      model.stopBatch(name, Object.assign(Object.assign({}, data), {
        cell: this
      }));
    }

    this.notify('batch:stop', {
      name,
      data,
      cell: this
    });
    return this;
  }

  batchUpdate(name, execute, data) {
    // The model is null after cell was removed(remove batch).
    // So we should temp save model to trigger pairing batch event.
    const model = this.model;
    this.startBatch(name, data, model);
    const result = execute();
    this.stopBatch(name, data, model);
    return result;
  } // #endregion
  // #region IDisposable


  dispose() {
    this.removeFromParent();
    this.store.dispose();
  }

}
Cell.defaults = {};
Cell.attrHooks = {};
Cell.propHooks = [];

__decorate([_common__WEBPACK_IMPORTED_MODULE_2__.Basecoat.dispose()], Cell.prototype, "dispose", null);

(function (Cell) {
  function normalizeTools(raw) {
    if (typeof raw === 'string') {
      return {
        items: [raw]
      };
    }

    if (Array.isArray(raw)) {
      return {
        items: raw
      };
    }

    if (raw.items) {
      return raw;
    }

    return {
      items: [raw]
    };
  }

  Cell.normalizeTools = normalizeTools;
})(Cell || (Cell = {}));

(function (Cell) {
  Cell.toStringTag = `X6.${Cell.name}`;

  function isCell(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Cell) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const cell = instance;

    if ((tag == null || tag === Cell.toStringTag) && typeof cell.isNode === 'function' && typeof cell.isEdge === 'function' && typeof cell.prop === 'function' && typeof cell.attr === 'function') {
      return true;
    }

    return false;
  }

  Cell.isCell = isCell;
})(Cell || (Cell = {}));

(function (Cell) {
  function getCommonAncestor(...cells) {
    const ancestors = cells.filter(cell => cell != null).map(cell => cell.getAncestors()).sort((a, b) => {
      return a.length - b.length;
    });
    const first = ancestors.shift();
    return first.find(cell => ancestors.every(item => item.includes(cell))) || null;
  }

  Cell.getCommonAncestor = getCommonAncestor;

  function getCellsBBox(cells, options = {}) {
    let bbox = null;

    for (let i = 0, ii = cells.length; i < ii; i += 1) {
      const cell = cells[i];
      let rect = cell.getBBox(options);

      if (rect) {
        if (cell.isNode()) {
          const angle = cell.getAngle();

          if (angle != null && angle !== 0) {
            rect = rect.bbox(angle);
          }
        }

        bbox = bbox == null ? rect : bbox.union(rect);
      }
    }

    return bbox;
  }

  Cell.getCellsBBox = getCellsBBox;

  function deepClone(cell) {
    const cells = [cell, ...cell.getDescendants({
      deep: true
    })];
    return Cell.cloneCells(cells);
  }

  Cell.deepClone = deepClone;

  function cloneCells(cells) {
    const inputs = _util__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.uniq(cells);
    const cloneMap = inputs.reduce((map, cell) => {
      map[cell.id] = cell.clone();
      return map;
    }, {});
    inputs.forEach(cell => {
      const clone = cloneMap[cell.id];

      if (clone.isEdge()) {
        const sourceId = clone.getSourceCellId();
        const targetId = clone.getTargetCellId();

        if (sourceId && cloneMap[sourceId]) {
          // Source is a node and the node is among the clones.
          // Then update the source of the cloned edge.
          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), {
            cell: cloneMap[sourceId].id
          }));
        }

        if (targetId && cloneMap[targetId]) {
          // Target is a node and the node is among the clones.
          // Then update the target of the cloned edge.
          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), {
            cell: cloneMap[targetId].id
          }));
        }
      } // Find the parent of the original cell


      const parent = cell.getParent();

      if (parent && cloneMap[parent.id]) {
        clone.setParent(cloneMap[parent.id]);
      } // Find the children of the original cell


      const children = cell.getChildren();

      if (children && children.length) {
        const embeds = children.reduce((memo, child) => {
          // Embedded cells that are not being cloned can not be carried
          // over with other embedded cells.
          if (cloneMap[child.id]) {
            memo.push(cloneMap[child.id]);
          }

          return memo;
        }, []);

        if (embeds.length > 0) {
          clone.setChildren(embeds);
        }
      }
    });
    return cloneMap;
  }

  Cell.cloneCells = cloneCells;
})(Cell || (Cell = {}));

(function (Cell) {
  Cell.config({
    propHooks(_a) {
      var {
        tools
      } = _a,
          metadata = __rest(_a, ["tools"]);

      if (tools) {
        metadata.tools = Cell.normalizeTools(tools);
      }

      return metadata;
    }

  });
})(Cell || (Cell = {}));

/***/ }),

/***/ 62919:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/collection.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Collection": () => (/* binding */ Collection)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ 57566);


class Collection extends _common__WEBPACK_IMPORTED_MODULE_1__.Basecoat {
  constructor(cells, options = {}) {
    super();
    this.length = 0;
    this.comparator = options.comparator || 'zIndex';
    this.clean();

    if (cells) {
      this.reset(cells, {
        silent: true
      });
    }
  }

  toJSON() {
    return this.cells.map(cell => cell.toJSON());
  }

  add(cells, index, options) {
    let localIndex;
    let localOptions;

    if (typeof index === 'number') {
      localIndex = index;
      localOptions = Object.assign({
        merge: false
      }, options);
    } else {
      localIndex = this.length;
      localOptions = Object.assign({
        merge: false
      }, index);
    }

    if (localIndex > this.length) {
      localIndex = this.length;
    }

    if (localIndex < 0) {
      localIndex += this.length + 1;
    }

    const entities = Array.isArray(cells) ? cells : [cells];
    const sortable = this.comparator && typeof index !== 'number' && localOptions.sort !== false;
    const sortAttr = this.comparator || null;
    let sort = false;
    const added = [];
    const merged = [];
    entities.forEach(cell => {
      const existing = this.get(cell);

      if (existing) {
        if (localOptions.merge && !cell.isSameStore(existing)) {
          existing.setProp(cell.getProp(), options); // merge

          merged.push(existing);

          if (sortable && !sort) {
            if (sortAttr == null || typeof sortAttr === 'function') {
              sort = existing.hasChanged();
            } else if (typeof sortAttr === 'string') {
              sort = existing.hasChanged(sortAttr);
            } else {
              sort = sortAttr.some(key => existing.hasChanged(key));
            }
          }
        }
      } else {
        added.push(cell);
        this.reference(cell);
      }
    });

    if (added.length) {
      if (sortable) {
        sort = true;
      }

      this.cells.splice(localIndex, 0, ...added);
      this.length = this.cells.length;
    }

    if (sort) {
      this.sort({
        silent: true
      });
    }

    if (!localOptions.silent) {
      added.forEach((cell, i) => {
        const args = {
          cell,
          index: localIndex + i,
          options: localOptions
        };
        this.trigger('added', args);

        if (!localOptions.dryrun) {
          cell.notify('added', Object.assign({}, args));
        }
      });

      if (sort) {
        this.trigger('sorted');
      }

      if (added.length || merged.length) {
        this.trigger('updated', {
          added,
          merged,
          removed: [],
          options: localOptions
        });
      }
    }

    return this;
  }

  remove(cells, options = {}) {
    const arr = Array.isArray(cells) ? cells : [cells];
    const removed = this.removeCells(arr, options);

    if (!options.silent && removed.length > 0) {
      this.trigger('updated', {
        options,
        removed,
        added: [],
        merged: []
      });
    }

    return Array.isArray(cells) ? removed : removed[0];
  }

  removeCells(cells, options) {
    const removed = [];

    for (let i = 0; i < cells.length; i += 1) {
      const cell = this.get(cells[i]);

      if (cell == null) {
        continue;
      }

      const index = this.cells.indexOf(cell);
      this.cells.splice(index, 1);
      this.length -= 1;
      delete this.map[cell.id];
      removed.push(cell);
      this.unreference(cell);

      if (!options.dryrun) {
        cell.remove();
      }

      if (!options.silent) {
        this.trigger('removed', {
          cell,
          index,
          options
        });

        if (!options.dryrun) {
          cell.notify('removed', {
            cell,
            index,
            options
          });
        }
      }
    }

    return removed;
  }

  reset(cells, options = {}) {
    const previous = this.cells.slice();
    previous.forEach(cell => this.unreference(cell));
    this.clean();
    this.add(cells, Object.assign({
      silent: true
    }, options));

    if (!options.silent) {
      const current = this.cells.slice();
      this.trigger('reseted', {
        options,
        previous,
        current
      });
      const added = [];
      const removed = [];
      current.forEach(a => {
        const exist = previous.some(b => b.id === a.id);

        if (!exist) {
          added.push(a);
        }
      });
      previous.forEach(a => {
        const exist = current.some(b => b.id === a.id);

        if (!exist) {
          removed.push(a);
        }
      });
      this.trigger('updated', {
        options,
        added,
        removed,
        merged: []
      });
    }

    return this;
  }

  push(cell, options) {
    return this.add(cell, this.length, options);
  }

  pop(options) {
    const cell = this.at(this.length - 1);
    return this.remove(cell, options);
  }

  unshift(cell, options) {
    return this.add(cell, 0, options);
  }

  shift(options) {
    const cell = this.at(0);
    return this.remove(cell, options);
  }

  get(cell) {
    if (cell == null) {
      return null;
    }

    const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;
    return this.map[id] || null;
  }

  has(cell) {
    return this.get(cell) != null;
  }

  at(index) {
    if (index < 0) {
      index += this.length; // eslint-disable-line
    }

    return this.cells[index] || null;
  }

  first() {
    return this.at(0);
  }

  last() {
    return this.at(-1);
  }

  indexOf(cell) {
    return this.cells.indexOf(cell);
  }

  toArray() {
    return this.cells.slice();
  }

  sort(options = {}) {
    if (this.comparator != null) {
      this.cells = _util__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortBy(this.cells, this.comparator);

      if (!options.silent) {
        this.trigger('sorted');
      }
    }

    return this;
  }

  clone() {
    const constructor = this.constructor;
    return new constructor(this.cells.slice(), {
      comparator: this.comparator
    });
  }

  reference(cell) {
    this.map[cell.id] = cell;
    cell.on('*', this.notifyCellEvent, this);
  }

  unreference(cell) {
    cell.off('*', this.notifyCellEvent, this);
    delete this.map[cell.id];
  }

  notifyCellEvent(name, args) {
    const cell = args.cell;
    this.trigger(`cell:${name}`, args);

    if (cell) {
      if (cell.isNode()) {
        this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), {
          node: cell
        }));
      } else if (cell.isEdge()) {
        this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), {
          edge: cell
        }));
      }
    }
  }

  clean() {
    this.length = 0;
    this.cells = [];
    this.map = {};
  }

}

/***/ }),

/***/ 51257:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/edge.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Edge": () => (/* binding */ Edge)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _view_markup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/markup */ 8676);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./registry */ 81964);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cell */ 30936);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







class Edge extends _cell__WEBPACK_IMPORTED_MODULE_5__.Cell {
  constructor(metadata = {}) {
    super(metadata);
  }

  get [Symbol.toStringTag]() {
    return Edge.toStringTag;
  }

  preprocess(metadata, ignoreIdCheck) {
    const {
      source,
      sourceCell,
      sourcePort,
      sourcePoint,
      target,
      targetCell,
      targetPort,
      targetPoint
    } = metadata,
          others = __rest(metadata, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]);

    const data = others;

    const isValidId = val => typeof val === 'string' || typeof val === 'number';

    if (source != null) {
      if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(source)) {
        data.source = {
          cell: source.id
        };
      } else if (isValidId(source)) {
        data.source = {
          cell: source
        };
      } else if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(source)) {
        data.source = source.toJSON();
      } else if (Array.isArray(source)) {
        data.source = {
          x: source[0],
          y: source[1]
        };
      } else {
        const cell = source.cell;

        if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(cell)) {
          data.source = Object.assign(Object.assign({}, source), {
            cell: cell.id
          });
        } else {
          data.source = source;
        }
      }
    }

    if (sourceCell != null || sourcePort != null) {
      let terminal = data.source;

      if (sourceCell != null) {
        const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;

        if (terminal) {
          terminal.cell = id;
        } else {
          terminal = data.source = {
            cell: id
          };
        }
      }

      if (sourcePort != null && terminal) {
        terminal.port = sourcePort;
      }
    } else if (sourcePoint != null) {
      data.source = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(sourcePoint).toJSON();
    }

    if (target != null) {
      if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(target)) {
        data.target = {
          cell: target.id
        };
      } else if (isValidId(target)) {
        data.target = {
          cell: target
        };
      } else if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(target)) {
        data.target = target.toJSON();
      } else if (Array.isArray(target)) {
        data.target = {
          x: target[0],
          y: target[1]
        };
      } else {
        const cell = target.cell;

        if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(cell)) {
          data.target = Object.assign(Object.assign({}, target), {
            cell: cell.id
          });
        } else {
          data.target = target;
        }
      }
    }

    if (targetCell != null || targetPort != null) {
      let terminal = data.target;

      if (targetCell != null) {
        const id = isValidId(targetCell) ? targetCell : targetCell.id;

        if (terminal) {
          terminal.cell = id;
        } else {
          terminal = data.target = {
            cell: id
          };
        }
      }

      if (targetPort != null && terminal) {
        terminal.port = targetPort;
      }
    } else if (targetPoint != null) {
      data.target = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(targetPoint).toJSON();
    }

    return super.preprocess(data, ignoreIdCheck);
  }

  setup() {
    super.setup();
    this.on('change:labels', args => this.onLabelsChanged(args));
    this.on('change:vertices', args => this.onVertexsChanged(args));
  }

  isEdge() {
    return true;
  } // #region terminal


  disconnect(options = {}) {
    this.store.set({
      source: {
        x: 0,
        y: 0
      },
      target: {
        x: 0,
        y: 0
      }
    }, options);
    return this;
  }

  get source() {
    return this.getSource();
  }

  set source(data) {
    this.setSource(data);
  }

  getSource() {
    return this.getTerminal('source');
  }

  getSourceCellId() {
    return this.source.cell;
  }

  getSourcePortId() {
    return this.source.port;
  }

  setSource(source, args, options = {}) {
    return this.setTerminal('source', source, args, options);
  }

  get target() {
    return this.getTarget();
  }

  set target(data) {
    this.setTarget(data);
  }

  getTarget() {
    return this.getTerminal('target');
  }

  getTargetCellId() {
    return this.target.cell;
  }

  getTargetPortId() {
    return this.target.port;
  }

  setTarget(target, args, options = {}) {
    return this.setTerminal('target', target, args, options);
  }

  getTerminal(type) {
    return Object.assign({}, this.store.get(type));
  }

  setTerminal(type, terminal, args, options = {}) {
    // `terminal` is a cell
    if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(terminal)) {
      this.store.set(type, _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, args, {
        cell: terminal.id
      }), options);
      return this;
    } // `terminal` is a point-like object


    const p = terminal;

    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(terminal) || p.x != null && p.y != null) {
      this.store.set(type, _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, args, {
        x: p.x,
        y: p.y
      }), options);
      return this;
    } // `terminal` is an object


    this.store.set(type, _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(terminal), options);
    return this;
  }

  getSourcePoint() {
    return this.getTerminalPoint('source');
  }

  getTargetPoint() {
    return this.getTerminalPoint('target');
  }

  getTerminalPoint(type) {
    const terminal = this[type];

    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(terminal)) {
      return _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(terminal);
    }

    const cell = this.getTerminalCell(type);

    if (cell) {
      return cell.getConnectionPoint(this, type);
    }

    return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
  }

  getSourceCell() {
    return this.getTerminalCell('source');
  }

  getTargetCell() {
    return this.getTerminalCell('target');
  }

  getTerminalCell(type) {
    if (this.model) {
      const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();

      if (cellId) {
        return this.model.getCell(cellId);
      }
    }

    return null;
  }

  getSourceNode() {
    return this.getTerminalNode('source');
  }

  getTargetNode() {
    return this.getTerminalNode('target');
  }

  getTerminalNode(type) {
    let cell = this; // eslint-disable-line

    const visited = {};

    while (cell && cell.isEdge()) {
      if (visited[cell.id]) {
        return null;
      }

      visited[cell.id] = true;
      cell = cell.getTerminalCell(type);
    }

    return cell && cell.isNode() ? cell : null;
  } // #endregion
  // #region router


  get router() {
    return this.getRouter();
  }

  set router(data) {
    if (data == null) {
      this.removeRouter();
    } else {
      this.setRouter(data);
    }
  }

  getRouter() {
    return this.store.get('router');
  }

  setRouter(name, args, options) {
    if (typeof name === 'object') {
      this.store.set('router', name, args);
    } else {
      this.store.set('router', {
        name,
        args
      }, options);
    }

    return this;
  }

  removeRouter(options = {}) {
    this.store.remove('router', options);
    return this;
  } // #endregion
  // #region connector


  get connector() {
    return this.getConnector();
  }

  set connector(data) {
    if (data == null) {
      this.removeConnector();
    } else {
      this.setConnector(data);
    }
  }

  getConnector() {
    return this.store.get('connector');
  }

  setConnector(name, args, options) {
    if (typeof name === 'object') {
      this.store.set('connector', name, args);
    } else {
      this.store.set('connector', {
        name,
        args
      }, options);
    }

    return this;
  }

  removeConnector(options = {}) {
    return this.store.remove('connector', options);
  } // #endregion
  // #region strategy


  get strategy() {
    return this.getStrategy();
  }

  set strategy(data) {
    if (data == null) {
      this.removeStrategy();
    } else {
      this.setStrategy(data);
    }
  }

  getStrategy() {
    return this.store.get('strategy');
  }

  setStrategy(name, args, options) {
    if (typeof name === 'object') {
      this.store.set('strategy', name, args);
    } else {
      this.store.set('strategy', {
        name,
        args
      }, options);
    }

    return this;
  }

  removeStrategy(options = {}) {
    return this.store.remove('strategy', options);
  } // #endregion
  // #region labels


  getDefaultLabel() {
    const ctor = this.constructor;
    const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};
    return _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(defaults);
  }

  get labels() {
    return this.getLabels();
  }

  set labels(labels) {
    this.setLabels(labels);
  }

  getLabels() {
    return [...this.store.get('labels', [])].map(item => this.parseLabel(item));
  }

  setLabels(labels, options = {}) {
    this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);
    return this;
  }

  insertLabel(label, index, options = {}) {
    const labels = this.getLabels();
    const len = labels.length;
    let idx = index != null && Number.isFinite(index) ? index : len;

    if (idx < 0) {
      idx = len + idx + 1;
    }

    labels.splice(idx, 0, this.parseLabel(label));
    return this.setLabels(labels, options);
  }

  appendLabel(label, options = {}) {
    return this.insertLabel(label, -1, options);
  }

  getLabelAt(index) {
    const labels = this.getLabels();

    if (index != null && Number.isFinite(index)) {
      return this.parseLabel(labels[index]);
    }

    return null;
  }

  setLabelAt(index, label, options = {}) {
    if (index != null && Number.isFinite(index)) {
      const labels = this.getLabels();
      labels[index] = this.parseLabel(label);
      this.setLabels(labels, options);
    }

    return this;
  }

  removeLabelAt(index, options = {}) {
    const labels = this.getLabels();
    const idx = index != null && Number.isFinite(index) ? index : -1;
    const removed = labels.splice(idx, 1);
    this.setLabels(labels, options);
    return removed.length ? removed[0] : null;
  }

  parseLabel(label) {
    if (typeof label === 'string') {
      const ctor = this.constructor;
      return ctor.parseStringLabel(label);
    }

    return label;
  }

  onLabelsChanged({
    previous,
    current
  }) {
    const added = previous && current ? current.filter(label1 => {
      if (!previous.find(label2 => label1 === label2 || _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(label1, label2))) {
        return label1;
      }

      return null;
    }) : current ? [...current] : [];
    const removed = previous && current ? previous.filter(label1 => {
      if (!current.find(label2 => label1 === label2 || _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(label1, label2))) {
        return label1;
      }

      return null;
    }) : previous ? [...previous] : [];

    if (added.length > 0) {
      this.notify('labels:added', {
        added,
        cell: this,
        edge: this
      });
    }

    if (removed.length > 0) {
      this.notify('labels:removed', {
        removed,
        cell: this,
        edge: this
      });
    }
  } // #endregion
  // #region vertices


  get vertexMarkup() {
    return this.getVertexMarkup();
  }

  set vertexMarkup(markup) {
    this.setVertexMarkup(markup);
  }

  getDefaultVertexMarkup() {
    return this.store.get('defaultVertexMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getEdgeVertexMarkup();
  }

  getVertexMarkup() {
    return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();
  }

  setVertexMarkup(markup, options = {}) {
    this.store.set('vertexMarkup', _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.clone(markup), options);
    return this;
  }

  get vertices() {
    return this.getVertices();
  }

  set vertices(vertices) {
    this.setVertices(vertices);
  }

  getVertices() {
    return [...this.store.get('vertices', [])];
  }

  setVertices(vertices, options = {}) {
    const points = Array.isArray(vertices) ? vertices : [vertices];
    this.store.set('vertices', points.map(p => _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.toJSON(p)), options);
    return this;
  }

  insertVertex(vertice, index, options = {}) {
    const vertices = this.getVertices();
    const len = vertices.length;
    let idx = index != null && Number.isFinite(index) ? index : len;

    if (idx < 0) {
      idx = len + idx + 1;
    }

    vertices.splice(idx, 0, _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.toJSON(vertice));
    return this.setVertices(vertices, options);
  }

  appendVertex(vertex, options = {}) {
    return this.insertVertex(vertex, -1, options);
  }

  getVertexAt(index) {
    if (index != null && Number.isFinite(index)) {
      const vertices = this.getVertices();
      return vertices[index];
    }

    return null;
  }

  setVertexAt(index, vertice, options = {}) {
    if (index != null && Number.isFinite(index)) {
      const vertices = this.getVertices();
      vertices[index] = vertice;
      this.setVertices(vertices, options);
    }

    return this;
  }

  removeVertexAt(index, options = {}) {
    const vertices = this.getVertices();
    const idx = index != null && Number.isFinite(index) ? index : -1;
    vertices.splice(idx, 1);
    return this.setVertices(vertices, options);
  }

  onVertexsChanged({
    previous,
    current
  }) {
    const added = previous && current ? current.filter(p1 => {
      if (!previous.find(p2 => _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.equals(p1, p2))) {
        return p1;
      }

      return null;
    }) : current ? [...current] : [];
    const removed = previous && current ? previous.filter(p1 => {
      if (!current.find(p2 => _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.equals(p1, p2))) {
        return p1;
      }

      return null;
    }) : previous ? [...previous] : [];

    if (added.length > 0) {
      this.notify('vertexs:added', {
        added,
        cell: this,
        edge: this
      });
    }

    if (removed.length > 0) {
      this.notify('vertexs:removed', {
        removed,
        cell: this,
        edge: this
      });
    }
  } // #endregion
  // #region markup


  getDefaultMarkup() {
    return this.store.get('defaultMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getEdgeMarkup();
  }

  getMarkup() {
    return super.getMarkup() || this.getDefaultMarkup();
  } // #endregion
  // #region toolMarkup


  get toolMarkup() {
    return this.getToolMarkup();
  }

  set toolMarkup(markup) {
    this.setToolMarkup(markup);
  }

  getDefaultToolMarkup() {
    return this.store.get('defaultToolMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getEdgeToolMarkup();
  }

  getToolMarkup() {
    return this.store.get('toolMarkup') || this.getDefaultToolMarkup();
  }

  setToolMarkup(markup, options = {}) {
    this.store.set('toolMarkup', markup, options);
    return this;
  }

  get doubleToolMarkup() {
    return this.getDoubleToolMarkup();
  }

  set doubleToolMarkup(markup) {
    this.setDoubleToolMarkup(markup);
  }

  getDefaultDoubleToolMarkup() {
    return this.store.get('defaultDoubleToolMarkup');
  }

  getDoubleToolMarkup() {
    return this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup();
  }

  setDoubleToolMarkup(markup, options = {}) {
    this.store.set('doubleToolMarkup', markup, options);
    return this;
  } // #endregion
  // #region arrowheadMarkup


  get arrowheadMarkup() {
    return this.getArrowheadMarkup();
  }

  set arrowheadMarkup(markup) {
    this.setArrowheadMarkup(markup);
  }

  getDefaultArrowheadMarkup() {
    return this.store.get('defaultArrowheadMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getEdgeArrowheadMarkup();
  }

  getArrowheadMarkup() {
    return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();
  }

  setArrowheadMarkup(markup, options = {}) {
    this.store.set('arrowheadMarkup', markup, options);
    return this;
  } // #endregion
  // #region transform

  /**
   * Translate the edge vertices (and source and target if they are points)
   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
   */


  translate(tx, ty, options = {}) {
    options.translateBy = options.translateBy || this.id;
    options.tx = tx;
    options.ty = ty;
    return this.applyToPoints(p => ({
      x: (p.x || 0) + tx,
      y: (p.y || 0) + ty
    }), options);
  }
  /**
   * Scales the edge's points (vertices) relative to the given origin.
   */


  scale(sx, sy, origin, options = {}) {
    return this.applyToPoints(p => {
      return _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(p).scale(sx, sy, origin).toJSON();
    }, options);
  }

  applyToPoints(worker, options = {}) {
    const attrs = {};
    const source = this.getSource();
    const target = this.getTarget();

    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(source)) {
      attrs.source = worker(source);
    }

    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(target)) {
      attrs.target = worker(target);
    }

    const vertices = this.getVertices();

    if (vertices.length > 0) {
      attrs.vertices = vertices.map(worker);
    }

    this.store.set(attrs, options);
    return this;
  } // #endregion
  // #region common


  getBBox() {
    return this.getPolyline().bbox();
  }

  getConnectionPoint() {
    return this.getPolyline().pointAt(0.5);
  }

  getPolyline() {
    const points = [this.getSourcePoint(), ...this.getVertices().map(vertice => _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(vertice)), this.getTargetPoint()];
    return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Polyline(points);
  }

  updateParent(options) {
    let newParent = null;
    const source = this.getSourceCell();
    const target = this.getTargetCell();
    const prevParent = this.getParent();

    if (source && target) {
      if (source === target || source.isDescendantOf(target)) {
        newParent = target;
      } else if (target.isDescendantOf(source)) {
        newParent = source;
      } else {
        newParent = _cell__WEBPACK_IMPORTED_MODULE_5__.Cell.getCommonAncestor(source, target);
      }
    } // Unembeds the edge if source and target has no common
    // ancestor or common ancestor changed


    if (prevParent && (!newParent || newParent.id !== prevParent.id)) {
      prevParent.unembed(this, options);
    }

    if (newParent) {
      newParent.embed(this, options);
    }

    return newParent;
  }

  hasLoop(options = {}) {
    const source = this.getSource();
    const target = this.getTarget();
    const sourceId = source.cell;
    const targetId = target.cell;

    if (!sourceId || !targetId) {
      return false;
    }

    let loop = sourceId === targetId; // Note that there in the deep mode a edge can have a loop,
    // even if it connects only a parent and its embed.
    // A loop "target equals source" is valid in both shallow and deep mode.
    // eslint-disable-next-line

    if (!loop && options.deep && this._model) {
      const sourceCell = this.getSourceCell();
      const targetCell = this.getTargetCell();

      if (sourceCell && targetCell) {
        loop = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);
      }
    }

    return loop;
  }

  getFragmentAncestor() {
    const cells = [this, this.getSourceNode(), this.getTargetNode()].filter(item => item != null);
    return this.getCommonAncestor(...cells);
  }

  isFragmentDescendantOf(cell) {
    const ancestor = this.getFragmentAncestor();
    return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));
  }

}
Edge.defaults = {};

(function (Edge) {
  function equalTerminals(a, b) {
    const a1 = a;
    const b1 = b;

    if (a1.cell === b1.cell) {
      return a1.port === b1.port || a1.port == null && b1.port == null;
    }

    return false;
  }

  Edge.equalTerminals = equalTerminals;
})(Edge || (Edge = {}));

(function (Edge) {
  Edge.defaultLabel = {
    markup: [{
      tagName: 'rect',
      selector: 'body'
    }, {
      tagName: 'text',
      selector: 'label'
    }],
    attrs: {
      text: {
        fill: '#000',
        fontSize: 14,
        textAnchor: 'middle',
        textVerticalAnchor: 'middle',
        pointerEvents: 'none'
      },
      rect: {
        ref: 'label',
        fill: '#fff',
        rx: 3,
        ry: 3,
        refWidth: 1,
        refHeight: 1,
        refX: 0,
        refY: 0
      }
    },
    position: {
      distance: 0.5
    }
  };

  function parseStringLabel(text) {
    return {
      attrs: {
        label: {
          text
        }
      }
    };
  }

  Edge.parseStringLabel = parseStringLabel;
})(Edge || (Edge = {}));

(function (Edge) {
  Edge.toStringTag = `X6.${Edge.name}`;

  function isEdge(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Edge) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const edge = instance;

    if ((tag == null || tag === Edge.toStringTag) && typeof edge.isNode === 'function' && typeof edge.isEdge === 'function' && typeof edge.prop === 'function' && typeof edge.attr === 'function' && typeof edge.disconnect === 'function' && typeof edge.getSource === 'function' && typeof edge.getTarget === 'function') {
      return true;
    }

    return false;
  }

  Edge.isEdge = isEdge;
})(Edge || (Edge = {}));

(function (Edge) {
  Edge.registry = _registry__WEBPACK_IMPORTED_MODULE_2__.Registry.create({
    type: 'edge',

    process(shape, options) {
      if (_registry__WEBPACK_IMPORTED_MODULE_4__.ShareRegistry.exist(shape, false)) {
        throw new Error(`Edge with name '${shape}' was registered by anthor Node`);
      }

      if (typeof options === 'function') {
        options.config({
          shape
        });
        return options;
      }

      let parent = Edge; // default inherit from 'dege'

      const {
        inherit = 'edge'
      } = options,
            others = __rest(options, ["inherit"]);

      if (typeof inherit === 'string') {
        const base = this.get(inherit || 'edge');

        if (base == null && inherit) {
          this.onNotFound(inherit, 'inherited');
        } else {
          parent = base;
        }
      } else {
        parent = inherit;
      }

      if (others.constructorName == null) {
        others.constructorName = shape;
      }

      const ctor = parent.define.call(parent, others);
      ctor.config({
        shape
      });
      return ctor;
    }

  });
  _registry__WEBPACK_IMPORTED_MODULE_4__.ShareRegistry.setEdgeRegistry(Edge.registry);
})(Edge || (Edge = {}));

(function (Edge) {
  let counter = 0;

  function getClassName(name) {
    if (name) {
      return _util__WEBPACK_IMPORTED_MODULE_0__.StringExt.pascalCase(name);
    }

    counter += 1;
    return `CustomEdge${counter}`;
  }

  function define(config) {
    const {
      constructorName,
      overwrite
    } = config,
          others = __rest(config, ["constructorName", "overwrite"]);

    const ctor = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.createClass(getClassName(constructorName || others.shape), this);
    ctor.config(others);

    if (others.shape) {
      Edge.registry.register(others.shape, ctor, overwrite);
    }

    return ctor;
  }

  Edge.define = define;

  function create(options) {
    const shape = options.shape || 'edge';
    const Ctor = Edge.registry.get(shape);

    if (Ctor) {
      return new Ctor(options);
    }

    return Edge.registry.onNotFound(shape);
  }

  Edge.create = create;
})(Edge || (Edge = {}));

(function (Edge) {
  const shape = 'basic.edge';
  Edge.config({
    shape,

    propHooks(metadata) {
      const {
        label,
        vertices
      } = metadata,
            others = __rest(metadata, ["label", "vertices"]);

      if (label) {
        if (others.labels == null) {
          others.labels = [];
        }

        const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;
        others.labels.push(formated);
      }

      if (vertices) {
        if (Array.isArray(vertices)) {
          others.vertices = vertices.map(item => _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(item).toJSON());
        }
      }

      return others;
    }

  });
  Edge.registry.register(shape, Edge);
})(Edge || (Edge = {}));

/***/ }),

/***/ 59502:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cell": () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.Cell),
/* harmony export */   "Collection": () => (/* reexport safe */ _collection__WEBPACK_IMPORTED_MODULE_4__.Collection),
/* harmony export */   "Edge": () => (/* reexport safe */ _edge__WEBPACK_IMPORTED_MODULE_2__.Edge),
/* harmony export */   "Model": () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_3__.Model),
/* harmony export */   "Node": () => (/* reexport safe */ _node__WEBPACK_IMPORTED_MODULE_1__.Node)
/* harmony export */ });
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ 30936);
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node */ 21738);
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edge */ 51257);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model */ 69314);
/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collection */ 62919);






/***/ }),

/***/ 69314:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/model.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Model": () => (/* binding */ Model)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common */ 57566);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cell */ 30936);
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./edge */ 51257);
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node */ 21738);
/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./collection */ 62919);







class Model extends _common__WEBPACK_IMPORTED_MODULE_1__.Basecoat {
  constructor(cells = []) {
    super();
    this.batches = {};
    this.addings = new WeakMap();
    this.nodes = {};
    this.edges = {};
    this.outgoings = {};
    this.incomings = {};
    this.collection = new _collection__WEBPACK_IMPORTED_MODULE_6__.Collection(cells);
    this.setup();
  }

  get [Symbol.toStringTag]() {
    return Model.toStringTag;
  }

  notify(name, args) {
    this.trigger(name, args);
    const graph = this.graph;

    if (graph) {
      if (name === 'sorted' || name === 'reseted' || name === 'updated') {
        graph.trigger(`model:${name}`, args);
      } else {
        graph.trigger(name, args);
      }
    }

    return this;
  }

  setup() {
    const collection = this.collection;
    collection.on('sorted', () => this.notify('sorted', null));
    collection.on('updated', args => this.notify('updated', args));
    collection.on('cell:change:zIndex', () => this.sortOnChangeZ());
    collection.on('added', ({
      cell
    }) => {
      this.onCellAdded(cell);
    });
    collection.on('removed', args => {
      const cell = args.cell;
      this.onCellRemoved(cell, args.options); // Should trigger remove-event manually after cell was removed.

      this.notify('cell:removed', args);

      if (cell.isNode()) {
        this.notify('node:removed', Object.assign(Object.assign({}, args), {
          node: cell
        }));
      } else if (cell.isEdge()) {
        this.notify('edge:removed', Object.assign(Object.assign({}, args), {
          edge: cell
        }));
      }
    });
    collection.on('reseted', args => {
      this.onReset(args.current);
      this.notify('reseted', args);
    });
    collection.on('edge:change:source', ({
      edge
    }) => this.onEdgeTerminalChanged(edge, 'source'));
    collection.on('edge:change:target', ({
      edge
    }) => {
      this.onEdgeTerminalChanged(edge, 'target');
    });
  }

  sortOnChangeZ() {
    this.collection.sort();
  }

  onCellAdded(cell) {
    const cellId = cell.id;

    if (cell.isEdge()) {
      // Auto update edge's parent
      cell.updateParent();
      this.edges[cellId] = true;
      this.onEdgeTerminalChanged(cell, 'source');
      this.onEdgeTerminalChanged(cell, 'target');
    } else {
      this.nodes[cellId] = true;
    }
  }

  onCellRemoved(cell, options) {
    const cellId = cell.id;

    if (cell.isEdge()) {
      delete this.edges[cellId];
      const source = cell.getSource();
      const target = cell.getTarget();

      if (source && source.cell) {
        const cache = this.outgoings[source.cell];
        const index = cache ? cache.indexOf(cellId) : -1;

        if (index >= 0) {
          cache.splice(index, 1);

          if (cache.length === 0) {
            delete this.outgoings[source.cell];
          }
        }
      }

      if (target && target.cell) {
        const cache = this.incomings[target.cell];
        const index = cache ? cache.indexOf(cellId) : -1;

        if (index >= 0) {
          cache.splice(index, 1);

          if (cache.length === 0) {
            delete this.incomings[target.cell];
          }
        }
      }
    } else {
      delete this.nodes[cellId];
    }

    if (!options.clear) {
      if (options.disconnectEdges) {
        this.disconnectConnectedEdges(cell, options);
      } else {
        this.removeConnectedEdges(cell, options);
      }
    }

    if (cell.model === this) {
      cell.model = null;
    }
  }

  onReset(cells) {
    this.nodes = {};
    this.edges = {};
    this.outgoings = {};
    this.incomings = {};
    cells.forEach(cell => this.onCellAdded(cell));
  }

  onEdgeTerminalChanged(edge, type) {
    const ref = type === 'source' ? this.outgoings : this.incomings;
    const prev = edge.previous(type);

    if (prev && prev.cell) {
      const cellId = _cell__WEBPACK_IMPORTED_MODULE_3__.Cell.isCell(prev.cell) ? prev.cell.id : prev.cell;
      const cache = ref[cellId];
      const index = cache ? cache.indexOf(edge.id) : -1;

      if (index >= 0) {
        cache.splice(index, 1);

        if (cache.length === 0) {
          delete ref[cellId];
        }
      }
    }

    const terminal = edge.getTerminal(type);

    if (terminal && terminal.cell) {
      const terminalId = _cell__WEBPACK_IMPORTED_MODULE_3__.Cell.isCell(terminal.cell) ? terminal.cell.id : terminal.cell;
      const cache = ref[terminalId] || [];
      const index = cache.indexOf(edge.id);

      if (index === -1) {
        cache.push(edge.id);
      }

      ref[terminalId] = cache;
    }
  }

  prepareCell(cell, options) {
    if (!cell.model && (!options || !options.dryrun)) {
      cell.model = this;
    }

    if (cell.zIndex == null) {
      cell.setZIndex(this.getMaxZIndex() + 1, {
        silent: true
      });
    }

    return cell;
  }

  resetCells(cells, options = {}) {
    // Do not update model at this time. Because if we just update the graph
    // with the same json-data, the edge will reference to the old nodes.
    cells.map(cell => this.prepareCell(cell, Object.assign(Object.assign({}, options), {
      dryrun: true
    })));
    this.collection.reset(cells, options); // Update model and trigger edge update it's references

    cells.map(cell => this.prepareCell(cell, {
      options
    }));
    return this;
  }

  clear(options = {}) {
    const raw = this.getCells();

    if (raw.length === 0) {
      return this;
    }

    const localOptions = Object.assign(Object.assign({}, options), {
      clear: true
    });
    this.batchUpdate('clear', () => {
      // The nodes come after the edges.
      const cells = raw.sort((a, b) => {
        const v1 = a.isEdge() ? 1 : 2;
        const v2 = b.isEdge() ? 1 : 2;
        return v1 - v2;
      });

      while (cells.length > 0) {
        // Note that all the edges are removed first, so it's safe to
        // remove the nodes without removing the connected edges first.
        const cell = cells.shift();

        if (cell) {
          cell.remove(localOptions);
        }
      }
    }, localOptions);
    return this;
  }

  addNode(metadata, options = {}) {
    const node = _node__WEBPACK_IMPORTED_MODULE_5__.Node.isNode(metadata) ? metadata : this.createNode(metadata);
    this.addCell(node, options);
    return node;
  }

  createNode(metadata) {
    return _node__WEBPACK_IMPORTED_MODULE_5__.Node.create(metadata);
  }

  addEdge(metadata, options = {}) {
    const edge = _edge__WEBPACK_IMPORTED_MODULE_4__.Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);
    this.addCell(edge, options);
    return edge;
  }

  createEdge(metadata) {
    return _edge__WEBPACK_IMPORTED_MODULE_4__.Edge.create(metadata);
  }

  addCell(cell, options = {}) {
    if (Array.isArray(cell)) {
      return this.addCells(cell, options);
    }

    if (!this.collection.has(cell) && !this.addings.has(cell)) {
      this.addings.set(cell, true);
      this.collection.add(this.prepareCell(cell, options), options);
      cell.eachChild(child => this.addCell(child, options));
      this.addings.delete(cell);
    }

    return this;
  }

  addCells(cells, options = {}) {
    const count = cells.length;

    if (count === 0) {
      return this;
    }

    const localOptions = Object.assign(Object.assign({}, options), {
      position: count - 1,
      maxPosition: count - 1
    });
    this.startBatch('add', Object.assign(Object.assign({}, localOptions), {
      cells
    }));
    cells.forEach(cell => {
      this.addCell(cell, localOptions);
      localOptions.position -= 1;
    });
    this.stopBatch('add', Object.assign(Object.assign({}, localOptions), {
      cells
    }));
    return this;
  }

  removeCell(obj, options = {}) {
    const cell = typeof obj === 'string' ? this.getCell(obj) : obj;

    if (cell && this.has(cell)) {
      return this.collection.remove(cell, options);
    }

    return null;
  }

  updateCellId(cell, newId) {
    this.startBatch('update', {
      id: newId
    });
    cell.prop('id', newId);
    const newCell = cell.clone({
      keepId: true
    });
    this.addCell(newCell); // update connected edge terminal

    const edges = this.getConnectedEdges(cell);
    edges.forEach(edge => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();

      if (sourceCell === cell) {
        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), {
          cell: newId
        }));
      }

      if (targetCell === cell) {
        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {
          cell: newId
        }));
      }
    });
    this.removeCell(cell);
    this.stopBatch('update', {
      id: newId
    });
    return newCell;
  }

  removeCells(cells, options = {}) {
    if (cells.length) {
      return this.batchUpdate('remove', () => {
        return cells.map(cell => this.removeCell(cell, options));
      });
    }

    return [];
  }

  removeConnectedEdges(cell, options = {}) {
    const edges = this.getConnectedEdges(cell);
    edges.forEach(edge => {
      edge.remove(options);
    });
    return edges;
  }

  disconnectConnectedEdges(cell, options = {}) {
    const cellId = typeof cell === 'string' ? cell : cell.id;
    this.getConnectedEdges(cell).forEach(edge => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();

      if (sourceCell && sourceCell.id === cellId) {
        edge.setSource({
          x: 0,
          y: 0
        }, options);
      }

      if (targetCell && targetCell.id === cellId) {
        edge.setTarget({
          x: 0,
          y: 0
        }, options);
      }
    });
  }

  has(obj) {
    return this.collection.has(obj);
  }

  total() {
    return this.collection.length;
  }

  indexOf(cell) {
    return this.collection.indexOf(cell);
  }
  /**
   * Returns a cell from the graph by its id.
   */


  getCell(id) {
    return this.collection.get(id);
  }
  /**
   * Returns all the nodes and edges in the graph.
   */


  getCells() {
    return this.collection.toArray();
  }
  /**
   * Returns the first cell (node or edge) in the graph. The first cell is
   * defined as the cell with the lowest `zIndex`.
   */


  getFirstCell() {
    return this.collection.first();
  }
  /**
   * Returns the last cell (node or edge) in the graph. The last cell is
   * defined as the cell with the highest `zIndex`.
   */


  getLastCell() {
    return this.collection.last();
  }
  /**
   * Returns the lowest `zIndex` value in the graph.
   */


  getMinZIndex() {
    const first = this.collection.first();
    return first ? first.getZIndex() || 0 : 0;
  }
  /**
   * Returns the highest `zIndex` value in the graph.
   */


  getMaxZIndex() {
    const last = this.collection.last();
    return last ? last.getZIndex() || 0 : 0;
  }

  getCellsFromCache(cache) {
    return cache ? Object.keys(cache).map(id => this.getCell(id)).filter(cell => cell != null) : [];
  }
  /**
   * Returns all the nodes in the graph.
   */


  getNodes() {
    return this.getCellsFromCache(this.nodes);
  }
  /**
   * Returns all the edges in the graph.
   */


  getEdges() {
    return this.getCellsFromCache(this.edges);
  }
  /**
   * Returns all outgoing edges for the node.
   */


  getOutgoingEdges(cell) {
    const cellId = typeof cell === 'string' ? cell : cell.id;
    const cellIds = this.outgoings[cellId];
    return cellIds ? cellIds.map(id => this.getCell(id)).filter(cell => cell && cell.isEdge()) : null;
  }
  /**
   * Returns all incoming edges for the node.
   */


  getIncomingEdges(cell) {
    const cellId = typeof cell === 'string' ? cell : cell.id;
    const cellIds = this.incomings[cellId];
    return cellIds ? cellIds.map(id => this.getCell(id)).filter(cell => cell && cell.isEdge()) : null;
  }
  /**
   * Returns edges connected with cell.
   */


  getConnectedEdges(cell, options = {}) {
    const result = [];
    const node = typeof cell === 'string' ? this.getCell(cell) : cell;

    if (node == null) {
      return result;
    }

    const cache = {};
    const indirect = options.indirect;
    let incoming = options.incoming;
    let outgoing = options.outgoing;

    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }

    const collect = (cell, isOutgoing) => {
      const edges = isOutgoing ? this.getOutgoingEdges(cell) : this.getIncomingEdges(cell);

      if (edges != null) {
        edges.forEach(edge => {
          if (cache[edge.id]) {
            return;
          }

          result.push(edge);
          cache[edge.id] = true;

          if (indirect) {
            if (incoming) {
              collect(edge, false);
            }

            if (outgoing) {
              collect(edge, true);
            }
          }
        });
      }

      if (indirect && cell.isEdge()) {
        const terminal = isOutgoing ? cell.getTargetCell() : cell.getSourceCell();

        if (terminal && terminal.isEdge()) {
          if (!cache[terminal.id]) {
            result.push(terminal);
            collect(terminal, isOutgoing);
          }
        }
      }
    };

    if (outgoing) {
      collect(node, true);
    }

    if (incoming) {
      collect(node, false);
    }

    if (options.deep) {
      const descendants = node.getDescendants({
        deep: true
      });
      const embedsCache = {};
      descendants.forEach(cell => {
        if (cell.isNode()) {
          embedsCache[cell.id] = true;
        }
      });

      const collectSub = (cell, isOutgoing) => {
        const edges = isOutgoing ? this.getOutgoingEdges(cell.id) : this.getIncomingEdges(cell.id);

        if (edges != null) {
          edges.forEach(edge => {
            if (!cache[edge.id]) {
              const sourceCell = edge.getSourceCell();
              const targetCell = edge.getTargetCell();

              if (!options.enclosed && sourceCell && embedsCache[sourceCell.id] && targetCell && embedsCache[targetCell.id]) {
                return;
              }

              result.push(edge);
              cache[edge.id] = true;
            }
          });
        }
      };

      descendants.forEach(cell => {
        if (cell.isEdge()) {
          return;
        }

        if (outgoing) {
          collectSub(cell, true);
        }

        if (incoming) {
          collectSub(cell, false);
        }
      });
    }

    return result;
  }

  isBoundary(cell, isOrigin) {
    const node = typeof cell === 'string' ? this.getCell(cell) : cell;
    const arr = isOrigin ? this.getIncomingEdges(node) : this.getOutgoingEdges(node);
    return arr == null || arr.length === 0;
  }

  getBoundaryNodes(isOrigin) {
    const result = [];
    Object.keys(this.nodes).forEach(nodeId => {
      if (this.isBoundary(nodeId, isOrigin)) {
        const node = this.getCell(nodeId);

        if (node) {
          result.push(node);
        }
      }
    });
    return result;
  }
  /**
   * Returns an array of all the roots of the graph.
   */


  getRoots() {
    return this.getBoundaryNodes(true);
  }
  /**
   * Returns an array of all the leafs of the graph.
   */


  getLeafs() {
    return this.getBoundaryNodes(false);
  }
  /**
   * Returns `true` if the node is a root node, i.e. there is no edges
   * coming to the node.
   */


  isRoot(cell) {
    return this.isBoundary(cell, true);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e. there is no edges
   * going out from the node.
   */


  isLeaf(cell) {
    return this.isBoundary(cell, false);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */


  getNeighbors(cell, options = {}) {
    let incoming = options.incoming;
    let outgoing = options.outgoing;

    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }

    const edges = this.getConnectedEdges(cell, options);
    const map = edges.reduce((memo, edge) => {
      const hasLoop = edge.hasLoop(options);
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();

      if (incoming && sourceCell && sourceCell.isNode() && !memo[sourceCell.id]) {
        if (hasLoop || sourceCell !== cell && (!options.deep || !sourceCell.isDescendantOf(cell))) {
          memo[sourceCell.id] = sourceCell;
        }
      }

      if (outgoing && targetCell && targetCell.isNode() && !memo[targetCell.id]) {
        if (hasLoop || targetCell !== cell && (!options.deep || !targetCell.isDescendantOf(cell))) {
          memo[targetCell.id] = targetCell;
        }
      }

      return memo;
    }, {});

    if (cell.isEdge()) {
      if (incoming) {
        const sourceCell = cell.getSourceCell();

        if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {
          map[sourceCell.id] = sourceCell;
        }
      }

      if (outgoing) {
        const targetCell = cell.getTargetCell();

        if (targetCell && targetCell.isNode() && !map[targetCell.id]) {
          map[targetCell.id] = targetCell;
        }
      }
    }

    return Object.keys(map).map(id => map[id]);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */


  isNeighbor(cell1, cell2, options = {}) {
    let incoming = options.incoming;
    let outgoing = options.outgoing;

    if (incoming == null && outgoing == null) {
      incoming = outgoing = true;
    }

    return this.getConnectedEdges(cell1, options).some(edge => {
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();

      if (incoming && sourceCell && sourceCell.id === cell2.id) {
        return true;
      }

      if (outgoing && targetCell && targetCell.id === cell2.id) {
        return true;
      }

      return false;
    });
  }

  getSuccessors(cell, options = {}) {
    const successors = [];
    this.search(cell, (curr, distance) => {
      if (curr !== cell && this.matchDistance(distance, options.distance)) {
        successors.push(curr);
      }
    }, Object.assign(Object.assign({}, options), {
      outgoing: true
    }));
    return successors;
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */


  isSuccessor(cell1, cell2, options = {}) {
    let result = false;
    this.search(cell1, (curr, distance) => {
      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {
        result = true;
        return false;
      }
    }, Object.assign(Object.assign({}, options), {
      outgoing: true
    }));
    return result;
  }

  getPredecessors(cell, options = {}) {
    const predecessors = [];
    this.search(cell, (curr, distance) => {
      if (curr !== cell && this.matchDistance(distance, options.distance)) {
        predecessors.push(curr);
      }
    }, Object.assign(Object.assign({}, options), {
      incoming: true
    }));
    return predecessors;
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */


  isPredecessor(cell1, cell2, options = {}) {
    let result = false;
    this.search(cell1, (curr, distance) => {
      if (curr === cell2 && curr !== cell1 && this.matchDistance(distance, options.distance)) {
        result = true;
        return false;
      }
    }, Object.assign(Object.assign({}, options), {
      incoming: true
    }));
    return result;
  }

  matchDistance(distance, preset) {
    if (preset == null) {
      return true;
    }

    if (typeof preset === 'function') {
      return preset(distance);
    }

    if (Array.isArray(preset) && preset.includes(distance)) {
      return true;
    }

    return distance === preset;
  }
  /**
   * Returns the common ancestor of the passed cells.
   */


  getCommonAncestor(...cells) {
    const arr = [];
    cells.forEach(item => {
      if (item) {
        if (Array.isArray(item)) {
          arr.push(...item);
        } else {
          arr.push(item);
        }
      }
    });
    return _cell__WEBPACK_IMPORTED_MODULE_3__.Cell.getCommonAncestor(...arr);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */


  getSubGraph(cells, options = {}) {
    const subgraph = [];
    const cache = {};
    const nodes = [];
    const edges = [];

    const collect = cell => {
      if (!cache[cell.id]) {
        subgraph.push(cell);
        cache[cell.id] = cell;

        if (cell.isEdge()) {
          edges.push(cell);
        }

        if (cell.isNode()) {
          nodes.push(cell);
        }
      }
    };

    cells.forEach(cell => {
      collect(cell);

      if (options.deep) {
        const descendants = cell.getDescendants({
          deep: true
        });
        descendants.forEach(descendant => collect(descendant));
      }
    });
    edges.forEach(edge => {
      // For edges, include their source & target
      const sourceCell = edge.getSourceCell();
      const targetCell = edge.getTargetCell();

      if (sourceCell && !cache[sourceCell.id]) {
        subgraph.push(sourceCell);
        cache[sourceCell.id] = sourceCell;

        if (sourceCell.isNode()) {
          nodes.push(sourceCell);
        }
      }

      if (targetCell && !cache[targetCell.id]) {
        subgraph.push(targetCell);
        cache[targetCell.id] = targetCell;

        if (targetCell.isNode()) {
          nodes.push(targetCell);
        }
      }
    });
    nodes.forEach(node => {
      // For nodes, include their connected edges if their source/target
      // is in the subgraph.
      const edges = this.getConnectedEdges(node, options);
      edges.forEach(edge => {
        const sourceCell = edge.getSourceCell();
        const targetCell = edge.getTargetCell();

        if (!cache[edge.id] && sourceCell && cache[sourceCell.id] && targetCell && cache[targetCell.id]) {
          subgraph.push(edge);
          cache[edge.id] = edge;
        }
      });
    });
    return subgraph;
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */


  cloneSubGraph(cells, options = {}) {
    const subgraph = this.getSubGraph(cells, options);
    return this.cloneCells(subgraph);
  }

  cloneCells(cells) {
    return _cell__WEBPACK_IMPORTED_MODULE_3__.Cell.cloneCells(cells);
  }

  getNodesFromPoint(x, y) {
    const p = typeof x === 'number' ? {
      x,
      y: y || 0
    } : x;
    return this.getNodes().filter(node => {
      return node.getBBox().containsPoint(p);
    });
  }

  getNodesInArea(x, y, w, h, options) {
    const rect = typeof x === 'number' ? new _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle(x, y, w, h) : _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(x);
    const opts = typeof x === 'number' ? options : y;
    const strict = opts && opts.strict;
    return this.getNodes().filter(node => {
      const bbox = node.getBBox();
      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);
    });
  }

  getEdgesInArea(x, y, w, h, options) {
    const rect = typeof x === 'number' ? new _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle(x, y, w, h) : _geometry__WEBPACK_IMPORTED_MODULE_2__.Rectangle.create(x);
    const opts = typeof x === 'number' ? options : y;
    const strict = opts && opts.strict;
    return this.getEdges().filter(edge => {
      const bbox = edge.getBBox();

      if (bbox.width === 0) {
        bbox.inflate(1, 0);
      } else if (bbox.height === 0) {
        bbox.inflate(0, 1);
      }

      return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);
    });
  }

  getNodesUnderNode(node, options = {}) {
    const bbox = node.getBBox();
    const nodes = options.by == null || options.by === 'bbox' ? this.getNodesInArea(bbox) : this.getNodesFromPoint(bbox[options.by]);
    return nodes.filter(curr => node.id !== curr.id && !curr.isDescendantOf(node));
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */


  getAllCellsBBox() {
    return this.getCellsBBox(this.getCells());
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */


  getCellsBBox(cells, options = {}) {
    return _cell__WEBPACK_IMPORTED_MODULE_3__.Cell.getCellsBBox(cells, options);
  } // #region search


  search(cell, iterator, options = {}) {
    if (options.breadthFirst) {
      this.breadthFirstSearch(cell, iterator, options);
    } else {
      this.depthFirstSearch(cell, iterator, options);
    }
  }

  breadthFirstSearch(cell, iterator, options = {}) {
    const queue = [];
    const visited = {};
    const distance = {};
    queue.push(cell);
    distance[cell.id] = 0;

    while (queue.length > 0) {
      const next = queue.shift();

      if (next == null || visited[next.id]) {
        continue;
      }

      visited[next.id] = true;

      if (_util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(iterator, this, next, distance[next.id]) === false) {
        continue;
      }

      const neighbors = this.getNeighbors(next, options);
      neighbors.forEach(neighbor => {
        distance[neighbor.id] = distance[next.id] + 1;
        queue.push(neighbor);
      });
    }
  }

  depthFirstSearch(cell, iterator, options = {}) {
    const queue = [];
    const visited = {};
    const distance = {};
    queue.push(cell);
    distance[cell.id] = 0;

    while (queue.length > 0) {
      const next = queue.pop();

      if (next == null || visited[next.id]) {
        continue;
      }

      visited[next.id] = true;

      if (_util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(iterator, this, next, distance[next.id]) === false) {
        continue;
      }

      const neighbors = this.getNeighbors(next, options);
      const lastIndex = queue.length;
      neighbors.forEach(neighbor => {
        distance[neighbor.id] = distance[next.id] + 1;
        queue.splice(lastIndex, 0, neighbor);
      });
    }
  } // #endregion
  // #region shortest path

  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */


  getShortestPath(source, target, options = {}) {
    const adjacencyList = {};
    this.getEdges().forEach(edge => {
      const sourceId = edge.getSourceCellId();
      const targetId = edge.getTargetCellId();

      if (sourceId && targetId) {
        if (!adjacencyList[sourceId]) {
          adjacencyList[sourceId] = [];
        }

        if (!adjacencyList[targetId]) {
          adjacencyList[targetId] = [];
        }

        adjacencyList[sourceId].push(targetId);

        if (!options.directed) {
          adjacencyList[targetId].push(sourceId);
        }
      }
    });
    const sourceId = typeof source === 'string' ? source : source.id;
    const previous = _common__WEBPACK_IMPORTED_MODULE_1__.Dijkstra.run(adjacencyList, sourceId, options.weight);
    const path = [];
    let targetId = typeof target === 'string' ? target : target.id;

    if (previous[targetId]) {
      path.push(targetId);
    }

    while (targetId = previous[targetId]) {
      path.unshift(targetId);
    }

    return path;
  } // #endregion
  // #region transform

  /**
   * Translate all cells in the graph by `tx` and `ty` pixels.
   */


  translate(tx, ty, options) {
    this.getCells().filter(cell => !cell.hasParent()).forEach(cell => cell.translate(tx, ty, options));
    return this;
  }

  resize(width, height, options) {
    return this.resizeCells(width, height, this.getCells(), options);
  }

  resizeCells(width, height, cells, options = {}) {
    const bbox = this.getCellsBBox(cells);

    if (bbox) {
      const sx = Math.max(width / bbox.width, 0);
      const sy = Math.max(height / bbox.height, 0);
      const origin = bbox.getOrigin();
      cells.forEach(cell => cell.scale(sx, sy, origin, options));
    }

    return this;
  } // #endregion
  // #region serialize/deserialize


  toJSON(options = {}) {
    return Model.toJSON(this.getCells(), options);
  }

  parseJSON(data) {
    return Model.fromJSON(data);
  }

  fromJSON(data, options = {}) {
    const cells = this.parseJSON(data);
    this.resetCells(cells, options);
    return this;
  } // #endregion
  // #region batch


  startBatch(name, data = {}) {
    this.batches[name] = (this.batches[name] || 0) + 1;
    this.notify('batch:start', {
      name,
      data
    });
    return this;
  }

  stopBatch(name, data = {}) {
    this.batches[name] = (this.batches[name] || 0) - 1;
    this.notify('batch:stop', {
      name,
      data
    });
    return this;
  }

  batchUpdate(name, execute, data = {}) {
    this.startBatch(name, data);
    const result = execute();
    this.stopBatch(name, data);
    return result;
  }

  hasActiveBatch(name = Object.keys(this.batches)) {
    const names = Array.isArray(name) ? name : [name];
    return names.some(batch => this.batches[batch] > 0);
  }

}

(function (Model) {
  Model.toStringTag = `X6.${Model.name}`;

  function isModel(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Model) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const model = instance;

    if ((tag == null || tag === Model.toStringTag) && typeof model.addNode === 'function' && typeof model.addEdge === 'function' && model.collection != null) {
      return true;
    }

    return false;
  }

  Model.isModel = isModel;
})(Model || (Model = {}));

(function (Model) {
  function toJSON(cells, options = {}) {
    return {
      cells: cells.map(cell => cell.toJSON(options))
    };
  }

  Model.toJSON = toJSON;

  function fromJSON(data) {
    const cells = [];

    if (Array.isArray(data)) {
      cells.push(...data);
    } else {
      if (data.cells) {
        cells.push(...data.cells);
      }

      if (data.nodes) {
        data.nodes.forEach(node => {
          if (node.shape == null) {
            node.shape = 'rect';
          }

          cells.push(node);
        });
      }

      if (data.edges) {
        data.edges.forEach(edge => {
          if (edge.shape == null) {
            edge.shape = 'edge';
          }

          cells.push(edge);
        });
      }
    }

    return cells.map(cell => {
      const type = cell.shape;

      if (type) {
        if (_node__WEBPACK_IMPORTED_MODULE_5__.Node.registry.exist(type)) {
          return _node__WEBPACK_IMPORTED_MODULE_5__.Node.create(cell);
        }

        if (_edge__WEBPACK_IMPORTED_MODULE_4__.Edge.registry.exist(type)) {
          return _edge__WEBPACK_IMPORTED_MODULE_4__.Edge.create(cell);
        }
      }

      throw new Error('The `shape` should be specified when creating a node/edge instance');
    });
  }

  Model.fromJSON = fromJSON;
})(Model || (Model = {}));

/***/ }),

/***/ 21738:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/node.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Node": () => (/* binding */ Node)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _view_markup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/markup */ 8676);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cell */ 30936);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./registry */ 81964);
/* harmony import */ var _port__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./port */ 78316);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common */ 57566);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};









class Node extends _cell__WEBPACK_IMPORTED_MODULE_4__.Cell {
  constructor(metadata = {}) {
    super(metadata);
    this.initPorts();
  }

  get [Symbol.toStringTag]() {
    return Node.toStringTag;
  }

  preprocess(metadata, ignoreIdCheck) {
    const {
      x,
      y,
      width,
      height
    } = metadata,
          others = __rest(metadata, ["x", "y", "width", "height"]);

    if (x != null || y != null) {
      const position = others.position;
      others.position = Object.assign(Object.assign({}, position), {
        x: x != null ? x : position ? position.x : 0,
        y: y != null ? y : position ? position.y : 0
      });
    }

    if (width != null || height != null) {
      const size = others.size;
      others.size = Object.assign(Object.assign({}, size), {
        width: width != null ? width : size ? size.width : 0,
        height: height != null ? height : size ? size.height : 0
      });
    }

    return super.preprocess(others, ignoreIdCheck);
  }

  isNode() {
    return true;
  }

  size(width, height, options) {
    if (width === undefined) {
      return this.getSize();
    }

    if (typeof width === 'number') {
      return this.setSize(width, height, options);
    }

    return this.setSize(width, height);
  }

  getSize() {
    const size = this.store.get('size');
    return size ? Object.assign({}, size) : {
      width: 1,
      height: 1
    };
  }

  setSize(width, height, options) {
    if (typeof width === 'object') {
      this.resize(width.width, width.height, height);
    } else {
      this.resize(width, height, options);
    }

    return this;
  }

  resize(width, height, options = {}) {
    this.startBatch('resize', options);
    const direction = options.direction;

    if (direction) {
      const currentSize = this.getSize();

      switch (direction) {
        case 'left':
        case 'right':
          // Don't change height when resizing horizontally.
          height = currentSize.height; // eslint-disable-line

          break;

        case 'top':
        case 'bottom':
          // Don't change width when resizing vertically.
          width = currentSize.width; // eslint-disable-line

          break;

        default:
          break;
      }

      const map = {
        right: 0,
        'top-right': 0,
        top: 1,
        'top-left': 1,
        left: 2,
        'bottom-left': 2,
        bottom: 3,
        'bottom-right': 3
      };
      let quadrant = map[direction];
      const angle = _geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(this.getAngle() || 0);

      if (options.absolute) {
        // We are taking the node's rotation into account
        quadrant += Math.floor((angle + 45) / 90);
        quadrant %= 4;
      } // This is a rectangle in size of the un-rotated node.


      const bbox = this.getBBox(); // Pick the corner point on the node, which meant to stay on its
      // place before and after the rotation.

      let fixedPoint;

      if (quadrant === 0) {
        fixedPoint = bbox.getBottomLeft();
      } else if (quadrant === 1) {
        fixedPoint = bbox.getCorner();
      } else if (quadrant === 2) {
        fixedPoint = bbox.getTopRight();
      } else {
        fixedPoint = bbox.getOrigin();
      } // Find an image of the previous indent point. This is the position,
      // where is the point actually located on the screen.


      const imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox.getCenter()); // Every point on the element rotates around a circle with the centre of
      // rotation in the middle of the element while the whole element is being
      // rotated. That means that the distance from a point in the corner of
      // the element (supposed its always rect) to the center of the element
      // doesn't change during the rotation and therefore it equals to a
      // distance on un-rotated element.
      // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.

      const radius = Math.sqrt(width * width + height * height) / 2; // Now we are looking for an angle between x-axis and the line starting
      // at image of fixed point and ending at the center of the element.
      // We call this angle `alpha`.
      // The image of a fixed point is located in n-th quadrant. For each
      // quadrant passed going anti-clockwise we have to add 90 degrees.
      // Note that the first quadrant has index 0.
      //
      // 3 | 2
      // --c-- Quadrant positions around the element's center `c`
      // 0 | 1
      //

      let alpha = quadrant * Math.PI / 2; // Add an angle between the beginning of the current quadrant (line
      // parallel with x-axis or y-axis going through the center of the
      // element) and line crossing the indent of the fixed point and the
      // center of the element. This is the angle we need but on the
      // un-rotated element.

      alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height); // Lastly we have to deduct the original angle the element was rotated
      // by and that's it.

      alpha -= _geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(angle); // With this angle and distance we can easily calculate the centre of
      // the un-rotated element.
      // Note that fromPolar constructor accepts an angle in radians.

      const center = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(radius, alpha, imageFixedPoint); // The top left corner on the un-rotated element has to be half a width
      // on the left and half a height to the top from the center. This will
      // be the origin of rectangle we were looking for.

      const origin = center.clone().translate(width / -2, height / -2);
      this.store.set('size', {
        width,
        height
      }, options);
      this.setPosition(origin.x, origin.y, options);
    } else {
      this.store.set('size', {
        width,
        height
      }, options);
    }

    this.stopBatch('resize', options);
    return this;
  }

  scale(sx, sy, origin, options = {}) {
    const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);
    this.startBatch('scale', options);
    this.setPosition(scaledBBox.x, scaledBBox.y, options);
    this.resize(scaledBBox.width, scaledBBox.height, options);
    this.stopBatch('scale');
    return this;
  }

  position(arg0, arg1, arg2) {
    if (typeof arg0 === 'number') {
      return this.setPosition(arg0, arg1, arg2);
    }

    return this.getPosition(arg0);
  }

  getPosition(options = {}) {
    if (options.relative) {
      const parent = this.getParent();

      if (parent != null && parent.isNode()) {
        const currentPosition = this.getPosition();
        const parentPosition = parent.getPosition();
        return {
          x: currentPosition.x - parentPosition.x,
          y: currentPosition.y - parentPosition.y
        };
      }
    }

    const pos = this.store.get('position');
    return pos ? Object.assign({}, pos) : {
      x: 0,
      y: 0
    };
  }

  setPosition(arg0, arg1, arg2 = {}) {
    let x;
    let y;
    let options;

    if (typeof arg0 === 'object') {
      x = arg0.x;
      y = arg0.y;
      options = arg1 || {};
    } else {
      x = arg0;
      y = arg1;
      options = arg2 || {};
    }

    if (options.relative) {
      const parent = this.getParent();

      if (parent != null && parent.isNode()) {
        const parentPosition = parent.getPosition();
        x += parentPosition.x;
        y += parentPosition.y;
      }
    }

    if (options.deep) {
      const currentPosition = this.getPosition();
      this.translate(x - currentPosition.x, y - currentPosition.y, options);
    } else {
      this.store.set('position', {
        x,
        y
      }, options);
    }

    return this;
  }

  translate(tx = 0, ty = 0, options = {}) {
    if (tx === 0 && ty === 0) {
      return this;
    } // Pass the initiator of the translation.


    options.translateBy = options.translateBy || this.id;
    const position = this.getPosition();

    if (options.restrict != null && options.translateBy === this.id) {
      // We are restricting the translation for the element itself only. We get
      // the bounding box of the element including all its embeds.
      // All embeds have to be translated the exact same way as the element.
      const bbox = this.getBBox({
        deep: true
      });
      const ra = options.restrict; // - - - - - - - - - - - - -> ra.x + ra.width
      // - - - -> position.x      |
      // -> bbox.x
      //                ▓▓▓▓▓▓▓   |
      //         ░░░░░░░▓▓▓▓▓▓▓
      //         ░░░░░░░░░        |
      //   ▓▓▓▓▓▓▓▓░░░░░░░
      //   ▓▓▓▓▓▓▓▓               |
      //   <-dx->                     | restricted area right border
      //         <-width->        |   ░ translated element
      //   <- - bbox.width - ->       ▓ embedded element

      const dx = position.x - bbox.x;
      const dy = position.y - bbox.y; // Find the maximal/minimal coordinates that the element can be translated
      // while complies the restrictions.

      const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));
      const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty)); // recalculate the translation taking the restrictions into account.

      tx = x - position.x; // eslint-disable-line

      ty = y - position.y; // eslint-disable-line
    }

    const translatedPosition = {
      x: position.x + tx,
      y: position.y + ty
    }; // To find out by how much an element was translated in event
    // 'change:position' handlers.

    options.tx = tx;
    options.ty = ty;

    if (options.transition) {
      if (typeof options.transition !== 'object') {
        options.transition = {};
      }

      this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), {
        interp: _common__WEBPACK_IMPORTED_MODULE_7__.Interp.object
      }));
      this.eachChild(child => {
        var _a;

        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);

        if (!excluded) {
          child.translate(tx, ty, options);
        }
      });
    } else {
      this.startBatch('translate', options);
      this.store.set('position', translatedPosition, options);
      this.eachChild(child => {
        var _a;

        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);

        if (!excluded) {
          child.translate(tx, ty, options);
        }
      });
      this.stopBatch('translate', options);
    }

    return this;
  }

  angle(val, options) {
    if (val == null) {
      return this.getAngle();
    }

    return this.rotate(val, options);
  }

  getAngle() {
    return this.store.get('angle', 0);
  }

  rotate(angle, options = {}) {
    const currentAngle = this.getAngle();

    if (options.center) {
      const size = this.getSize();
      const position = this.getPosition();
      const center = this.getBBox().getCenter();
      center.rotate(currentAngle - angle, options.center);
      const dx = center.x - size.width / 2 - position.x;
      const dy = center.y - size.height / 2 - position.y;
      this.startBatch('rotate', {
        angle,
        options
      });
      this.setPosition(position.x + dx, position.y + dy, options);
      this.rotate(angle, Object.assign(Object.assign({}, options), {
        center: null
      }));
      this.stopBatch('rotate');
    } else {
      this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);
    }

    return this;
  } // #endregion
  // #region common


  getBBox(options = {}) {
    if (options.deep) {
      const cells = this.getDescendants({
        deep: true,
        breadthFirst: true
      });
      cells.push(this);
      return _cell__WEBPACK_IMPORTED_MODULE_4__.Cell.getCellsBBox(cells);
    }

    return _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());
  }

  getConnectionPoint(edge, type) {
    const bbox = this.getBBox();
    const center = bbox.getCenter();
    const terminal = edge.getTerminal(type);

    if (terminal == null) {
      return center;
    }

    const portId = terminal.port;

    if (!portId || !this.hasPort(portId)) {
      return center;
    }

    const port = this.getPort(portId);

    if (!port || !port.group) {
      return center;
    }

    const layouts = this.getPortsPosition(port.group);
    const position = layouts[portId].position;
    const portCenter = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(position).translate(bbox.getOrigin());
    const angle = this.getAngle();

    if (angle) {
      portCenter.rotate(-angle, center);
    }

    return portCenter;
  }
  /**
   * Sets cell's size and position based on the children bbox and given padding.
   */


  fit(options = {}) {
    const children = this.getChildren() || [];
    const embeds = children.filter(cell => cell.isNode());

    if (embeds.length === 0) {
      return this;
    }

    this.startBatch('fit-embeds', options);

    if (options.deep) {
      embeds.forEach(cell => cell.fit(options));
    }

    let {
      x,
      y,
      width,
      height
    } = _cell__WEBPACK_IMPORTED_MODULE_4__.Cell.getCellsBBox(embeds);
    const padding = _util__WEBPACK_IMPORTED_MODULE_2__.NumberExt.normalizeSides(options.padding);
    x -= padding.left;
    y -= padding.top;
    width += padding.left + padding.right;
    height += padding.bottom + padding.top;
    this.store.set({
      position: {
        x,
        y
      },
      size: {
        width,
        height
      }
    }, options);
    this.stopBatch('fit-embeds');
    return this;
  } // #endregion
  // #region ports


  get portContainerMarkup() {
    return this.getPortContainerMarkup();
  }

  set portContainerMarkup(markup) {
    this.setPortContainerMarkup(markup);
  }

  getDefaultPortContainerMarkup() {
    return this.store.get('defaultPortContainerMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getPortContainerMarkup();
  }

  getPortContainerMarkup() {
    return this.store.get('portContainerMarkup') || this.getDefaultPortContainerMarkup();
  }

  setPortContainerMarkup(markup, options = {}) {
    this.store.set('portContainerMarkup', _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.clone(markup), options);
    return this;
  }

  get portMarkup() {
    return this.getPortMarkup();
  }

  set portMarkup(markup) {
    this.setPortMarkup(markup);
  }

  getDefaultPortMarkup() {
    return this.store.get('defaultPortMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getPortMarkup();
  }

  getPortMarkup() {
    return this.store.get('portMarkup') || this.getDefaultPortMarkup();
  }

  setPortMarkup(markup, options = {}) {
    this.store.set('portMarkup', _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.clone(markup), options);
    return this;
  }

  get portLabelMarkup() {
    return this.getPortLabelMarkup();
  }

  set portLabelMarkup(markup) {
    this.setPortLabelMarkup(markup);
  }

  getDefaultPortLabelMarkup() {
    return this.store.get('defaultPortLabelMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getPortLabelMarkup();
  }

  getPortLabelMarkup() {
    return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();
  }

  setPortLabelMarkup(markup, options = {}) {
    this.store.set('portLabelMarkup', _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.clone(markup), options);
    return this;
  }

  get ports() {
    const res = this.store.get('ports', {
      items: []
    });

    if (res.items == null) {
      res.items = [];
    }

    return res;
  }

  getPorts() {
    return _util__WEBPACK_IMPORTED_MODULE_2__.ObjectExt.cloneDeep(this.ports.items);
  }

  getPortsByGroup(groupName) {
    return this.getPorts().filter(port => port.group === groupName);
  }

  getPort(portId) {
    return _util__WEBPACK_IMPORTED_MODULE_2__.ObjectExt.cloneDeep(this.ports.items.find(port => port.id && port.id === portId));
  }

  getPortAt(index) {
    return this.ports.items[index] || null;
  }

  hasPorts() {
    return this.ports.items.length > 0;
  }

  hasPort(portId) {
    return this.getPortIndex(portId) !== -1;
  }

  getPortIndex(port) {
    const portId = typeof port === 'string' ? port : port.id;
    return portId != null ? this.ports.items.findIndex(item => item.id === portId) : -1;
  }

  getPortsPosition(groupName) {
    const size = this.getSize();
    const layouts = this.port.getPortsLayoutByGroup(groupName, new _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(0, 0, size.width, size.height));
    return layouts.reduce((memo, item) => {
      const layout = item.portLayout;
      memo[item.portId] = {
        position: Object.assign({}, layout.position),
        angle: layout.angle || 0
      };
      return memo;
    }, {});
  }

  getPortProp(portId, path) {
    return this.getPropByPath(this.prefixPortPath(portId, path));
  }

  setPortProp(portId, arg1, arg2, arg3) {
    if (typeof arg1 === 'string' || Array.isArray(arg1)) {
      const path = this.prefixPortPath(portId, arg1);
      const value = arg2;
      return this.setPropByPath(path, value, arg3);
    }

    const path = this.prefixPortPath(portId);
    const value = arg1;
    return this.setPropByPath(path, value, arg2);
  }

  removePortProp(portId, path, options) {
    if (typeof path === 'string' || Array.isArray(path)) {
      return this.removePropByPath(this.prefixPortPath(portId, path), options);
    }

    return this.removePropByPath(this.prefixPortPath(portId), path);
  }

  portProp(portId, path, value, options) {
    if (path == null) {
      return this.getPortProp(portId);
    }

    if (typeof path === 'string' || Array.isArray(path)) {
      if (arguments.length === 2) {
        return this.getPortProp(portId, path);
      }

      if (value == null) {
        return this.removePortProp(portId, path, options);
      }

      return this.setPortProp(portId, path, value, options);
    }

    return this.setPortProp(portId, path, value);
  }

  prefixPortPath(portId, path) {
    const index = this.getPortIndex(portId);

    if (index === -1) {
      throw new Error(`Unable to find port with id: "${portId}"`);
    }

    if (path == null || path === '') {
      return ['ports', 'items', `${index}`];
    }

    if (Array.isArray(path)) {
      return ['ports', 'items', `${index}`, ...path];
    }

    return `ports/items/${index}/${path}`;
  }

  addPort(port, options) {
    const ports = [...this.ports.items];
    ports.push(port);
    this.setPropByPath('ports/items', ports, options);
    return this;
  }

  addPorts(ports, options) {
    this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);
    return this;
  }

  insertPort(index, port, options) {
    const ports = [...this.ports.items];
    ports.splice(index, 0, port);
    this.setPropByPath('ports/items', ports, options);
    return this;
  }

  removePort(port, options = {}) {
    return this.removePortAt(this.getPortIndex(port), options);
  }

  removePortAt(index, options = {}) {
    if (index >= 0) {
      const ports = [...this.ports.items];
      ports.splice(index, 1);
      options.rewrite = true;
      this.setPropByPath('ports/items', ports, options);
    }

    return this;
  }

  removePorts(portsForRemoval, opt) {
    let options;

    if (Array.isArray(portsForRemoval)) {
      options = opt || {};

      if (portsForRemoval.length) {
        options.rewrite = true;
        const currentPorts = [...this.ports.items];
        const remainingPorts = currentPorts.filter(cp => !portsForRemoval.some(p => {
          const id = typeof p === 'string' ? p : p.id;
          return cp.id === id;
        }));
        this.setPropByPath('ports/items', remainingPorts, options);
      }
    } else {
      options = portsForRemoval || {};
      options.rewrite = true;
      this.setPropByPath('ports/items', [], options);
    }

    return this;
  }

  getParsedPorts() {
    return this.port.getPorts();
  }

  getParsedGroups() {
    return this.port.groups;
  }

  getPortsLayoutByGroup(groupName, bbox) {
    return this.port.getPortsLayoutByGroup(groupName, bbox);
  }

  initPorts() {
    this.updatePortData();
    this.on('change:ports', () => {
      this.processRemovedPort();
      this.updatePortData();
    });
  }

  processRemovedPort() {
    const current = this.ports;
    const currentItemsMap = {};
    current.items.forEach(item => {
      if (item.id) {
        currentItemsMap[item.id] = true;
      }
    });
    const removed = {};
    const previous = this.store.getPrevious('ports') || {
      items: []
    };
    previous.items.forEach(item => {
      if (item.id && !currentItemsMap[item.id]) {
        removed[item.id] = true;
      }
    });
    const model = this.model;

    if (model && !_util__WEBPACK_IMPORTED_MODULE_2__.ObjectExt.isEmpty(removed)) {
      const incomings = model.getConnectedEdges(this, {
        incoming: true
      });
      incomings.forEach(edge => {
        const portId = edge.getTargetPortId();

        if (portId && removed[portId]) {
          edge.remove();
        }
      });
      const outgoings = model.getConnectedEdges(this, {
        outgoing: true
      });
      outgoings.forEach(edge => {
        const portId = edge.getSourcePortId();

        if (portId && removed[portId]) {
          edge.remove();
        }
      });
    }
  }

  validatePorts() {
    const ids = {};
    const errors = [];
    this.ports.items.forEach(p => {
      if (typeof p !== 'object') {
        errors.push(`Invalid port ${p}.`);
      }

      if (p.id == null) {
        p.id = this.generatePortId();
      }

      if (ids[p.id]) {
        errors.push('Duplicitied port id.');
      }

      ids[p.id] = true;
    });
    return errors;
  }

  generatePortId() {
    return _util__WEBPACK_IMPORTED_MODULE_2__.StringExt.uuid();
  }

  updatePortData() {
    const err = this.validatePorts();

    if (err.length > 0) {
      this.store.set('ports', this.store.getPrevious('ports'));
      throw new Error(err.join(' '));
    }

    const prev = this.port ? this.port.getPorts() : null;
    this.port = new _port__WEBPACK_IMPORTED_MODULE_6__.PortManager(this.ports);
    const curr = this.port.getPorts();
    const added = prev ? curr.filter(item => {
      if (!prev.find(prevPort => prevPort.id === item.id)) {
        return item;
      }

      return null;
    }) : [...curr];
    const removed = prev ? prev.filter(item => {
      if (!curr.find(curPort => curPort.id === item.id)) {
        return item;
      }

      return null;
    }) : [];

    if (added.length > 0) {
      this.notify('ports:added', {
        added,
        cell: this,
        node: this
      });
    }

    if (removed.length > 0) {
      this.notify('ports:removed', {
        removed,
        cell: this,
        node: this
      });
    }
  }

}
Node.defaults = {
  angle: 0,
  position: {
    x: 0,
    y: 0
  },
  size: {
    width: 1,
    height: 1
  }
};

(function (Node) {
  Node.toStringTag = `X6.${Node.name}`;

  function isNode(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Node) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const node = instance;

    if ((tag == null || tag === Node.toStringTag) && typeof node.isNode === 'function' && typeof node.isEdge === 'function' && typeof node.prop === 'function' && typeof node.attr === 'function' && typeof node.size === 'function' && typeof node.position === 'function') {
      return true;
    }

    return false;
  }

  Node.isNode = isNode;
})(Node || (Node = {}));

(function (Node) {
  Node.config({
    propHooks(_a) {
      var {
        ports
      } = _a,
          metadata = __rest(_a, ["ports"]);

      if (ports) {
        metadata.ports = Array.isArray(ports) ? {
          items: ports
        } : ports;
      }

      return metadata;
    }

  });
})(Node || (Node = {}));

(function (Node) {
  Node.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'node',

    process(shape, options) {
      if (_registry__WEBPACK_IMPORTED_MODULE_5__.ShareRegistry.exist(shape, true)) {
        throw new Error(`Node with name '${shape}' was registered by anthor Edge`);
      }

      if (typeof options === 'function') {
        options.config({
          shape
        });
        return options;
      }

      let parent = Node;

      const {
        inherit
      } = options,
            config = __rest(options, ["inherit"]);

      if (inherit) {
        if (typeof inherit === 'string') {
          const base = this.get(inherit);

          if (base == null) {
            this.onNotFound(inherit, 'inherited');
          } else {
            parent = base;
          }
        } else {
          parent = inherit;
        }
      }

      if (config.constructorName == null) {
        config.constructorName = shape;
      }

      const ctor = parent.define.call(parent, config);
      ctor.config({
        shape
      });
      return ctor;
    }

  });
  _registry__WEBPACK_IMPORTED_MODULE_5__.ShareRegistry.setNodeRegistry(Node.registry);
})(Node || (Node = {}));

(function (Node) {
  let counter = 0;

  function getClassName(name) {
    if (name) {
      return _util__WEBPACK_IMPORTED_MODULE_2__.StringExt.pascalCase(name);
    }

    counter += 1;
    return `CustomNode${counter}`;
  }

  function define(config) {
    const {
      constructorName,
      overwrite
    } = config,
          others = __rest(config, ["constructorName", "overwrite"]);

    const ctor = _util__WEBPACK_IMPORTED_MODULE_2__.ObjectExt.createClass(getClassName(constructorName || others.shape), this);
    ctor.config(others);

    if (others.shape) {
      Node.registry.register(others.shape, ctor, overwrite);
    }

    return ctor;
  }

  Node.define = define;

  function create(options) {
    const shape = options.shape || 'rect';
    const Ctor = Node.registry.get(shape);

    if (Ctor) {
      return new Ctor(options);
    }

    return Node.registry.onNotFound(shape);
  }

  Node.create = create;
})(Node || (Node = {}));

/***/ }),

/***/ 78316:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/port.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PortManager": () => (/* binding */ PortManager)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ 17653);



class PortManager {
  constructor(data) {
    this.ports = [];
    this.groups = {};
    this.init(_util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(data));
  }

  getPorts() {
    return this.ports;
  }

  getGroup(groupName) {
    return groupName != null ? this.groups[groupName] : null;
  }

  getPortsByGroup(groupName) {
    return this.ports.filter(p => p.group === groupName || p.group == null && groupName == null);
  }

  getPortsLayoutByGroup(groupName, elemBBox) {
    const ports = this.getPortsByGroup(groupName);
    const group = groupName ? this.getGroup(groupName) : null;
    const groupPosition = group ? group.position : null;
    const groupPositionName = groupPosition ? groupPosition.name : null;
    let layoutFn;

    if (groupPositionName != null) {
      const fn = _registry__WEBPACK_IMPORTED_MODULE_0__.PortLayout.registry.get(groupPositionName);

      if (fn == null) {
        return _registry__WEBPACK_IMPORTED_MODULE_0__.PortLayout.registry.onNotFound(groupPositionName);
      }

      layoutFn = fn;
    } else {
      layoutFn = _registry__WEBPACK_IMPORTED_MODULE_0__.PortLayout.presets.left;
    }

    const portsArgs = ports.map(port => port && port.position && port.position.args || {});
    const groupArgs = groupPosition && groupPosition.args || {};
    const layouts = layoutFn(portsArgs, elemBBox, groupArgs);
    return layouts.map((portLayout, index) => {
      const port = ports[index];
      return {
        portLayout,
        portId: port.id,
        portSize: port.size,
        portAttrs: port.attrs,
        labelSize: port.label.size,
        labelLayout: this.getPortLabelLayout(port, _geometry__WEBPACK_IMPORTED_MODULE_2__.Point.create(portLayout.position), elemBBox)
      };
    });
  }

  init(data) {
    const {
      groups,
      items
    } = data;

    if (groups != null) {
      Object.keys(groups).forEach(key => {
        this.groups[key] = this.parseGroup(groups[key]);
      });
    }

    if (Array.isArray(items)) {
      items.forEach(item => {
        this.ports.push(this.parsePort(item));
      });
    }
  }

  parseGroup(group) {
    return Object.assign(Object.assign({}, group), {
      label: this.getLabel(group, true),
      position: this.getPortPosition(group.position, true)
    });
  }

  parsePort(port) {
    const result = Object.assign({}, port);
    const group = this.getGroup(port.group) || {};
    result.markup = result.markup || group.markup;
    result.attrs = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, group.attrs, result.attrs);
    result.position = this.createPosition(group, result);
    result.label = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, group.label, this.getLabel(result));
    result.zIndex = this.getZIndex(group, result);
    result.size = Object.assign(Object.assign({}, group.size), result.size);
    return result;
  }

  getZIndex(group, port) {
    if (typeof port.zIndex === 'number') {
      return port.zIndex;
    }

    if (typeof group.zIndex === 'number' || group.zIndex === 'auto') {
      return group.zIndex;
    }

    return 'auto';
  }

  createPosition(group, port) {
    return _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({
      name: 'left',
      args: {}
    }, group.position, {
      args: port.args
    });
  }

  getPortPosition(position, setDefault = false) {
    if (position == null) {
      if (setDefault) {
        return {
          name: 'left',
          args: {}
        };
      }
    } else {
      if (typeof position === 'string') {
        return {
          name: position,
          args: {}
        };
      }

      if (Array.isArray(position)) {
        return {
          name: 'absolute',
          args: {
            x: position[0],
            y: position[1]
          }
        };
      }

      if (typeof position === 'object') {
        return position;
      }
    }

    return {
      args: {}
    };
  }

  getPortLabelPosition(position, setDefault = false) {
    if (position == null) {
      if (setDefault) {
        return {
          name: 'left',
          args: {}
        };
      }
    } else {
      if (typeof position === 'string') {
        return {
          name: position,
          args: {}
        };
      }

      if (typeof position === 'object') {
        return position;
      }
    }

    return {
      args: {}
    };
  }

  getLabel(item, setDefaults = false) {
    const label = item.label || {};
    label.position = this.getPortLabelPosition(label.position, setDefaults);
    return label;
  }

  getPortLabelLayout(port, portPosition, elemBBox) {
    const name = port.label.position.name || 'left';
    const args = port.label.position.args || {};
    const layoutFn = _registry__WEBPACK_IMPORTED_MODULE_0__.PortLabelLayout.registry.get(name) || _registry__WEBPACK_IMPORTED_MODULE_0__.PortLabelLayout.presets.left;

    if (layoutFn) {
      return layoutFn(portPosition, elemBBox, args);
    }

    return null;
  }

}

/***/ }),

/***/ 81964:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/registry.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShareRegistry": () => (/* binding */ ShareRegistry)
/* harmony export */ });
var ShareRegistry;

(function (ShareRegistry) {
  let edgeRegistry;
  let nodeRegistry;

  function exist(name, isNode) {
    return isNode ? edgeRegistry != null && edgeRegistry.exist(name) : nodeRegistry != null && nodeRegistry.exist(name);
  }

  ShareRegistry.exist = exist;

  function setEdgeRegistry(registry) {
    edgeRegistry = registry;
  }

  ShareRegistry.setEdgeRegistry = setEdgeRegistry;

  function setNodeRegistry(registry) {
    nodeRegistry = registry;
  }

  ShareRegistry.setNodeRegistry = setNodeRegistry;
})(ShareRegistry || (ShareRegistry = {}));

/***/ }),

/***/ 78497:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/store.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Store": () => (/* binding */ Store)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ 57566);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class Store extends _common__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
  constructor(data = {}) {
    super();
    this.pending = false;
    this.changing = false;
    this.data = {};
    this.mutate(_util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(data));
    this.changed = {};
  }

  mutate(data, options = {}) {
    const unset = options.unset === true;
    const silent = options.silent === true;
    const changes = [];
    const changing = this.changing;
    this.changing = true;

    if (!changing) {
      this.previous = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.data);
      this.changed = {};
    }

    const current = this.data;
    const previous = this.previous;
    const changed = this.changed;
    Object.keys(data).forEach(k => {
      const key = k;
      const newValue = data[key];

      if (!_util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.isEqual(current[key], newValue)) {
        changes.push(key);
      }

      if (!_util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.isEqual(previous[key], newValue)) {
        changed[key] = newValue;
      } else {
        delete changed[key];
      }

      if (unset) {
        delete current[key];
      } else {
        current[key] = newValue;
      }
    });

    if (!silent && changes.length > 0) {
      this.pending = true;
      this.pendingOptions = options;
      changes.forEach(key => {
        this.emit('change:*', {
          key,
          options,
          store: this,
          current: current[key],
          previous: previous[key]
        });
      });
    }

    if (changing) {
      return this;
    }

    if (!silent) {
      // Changes can be recursively nested within `"change"` events.
      while (this.pending) {
        this.pending = false;
        this.emit('changed', {
          current,
          previous,
          store: this,
          options: this.pendingOptions
        });
      }
    }

    this.pending = false;
    this.changing = false;
    this.pendingOptions = null;
    return this;
  }

  get(key, defaultValue) {
    if (key == null) {
      return this.data;
    }

    const ret = this.data[key];
    return ret == null ? defaultValue : ret;
  }

  getPrevious(key) {
    if (this.previous) {
      const ret = this.previous[key];
      return ret == null ? undefined : ret;
    }

    return undefined;
  }

  set(key, value, options) {
    if (key != null) {
      if (typeof key === 'object') {
        this.mutate(key, value);
      } else {
        this.mutate({
          [key]: value
        }, options);
      }
    }

    return this;
  }

  remove(key, options) {
    const empty = undefined;
    const subset = {};
    let opts;

    if (typeof key === 'string') {
      subset[key] = empty;
      opts = options;
    } else if (Array.isArray(key)) {
      key.forEach(k => subset[k] = empty);
      opts = options;
    } else {
      // eslint-disable-next-line
      for (const key in this.data) {
        subset[key] = empty;
      }

      opts = key;
    }

    this.mutate(subset, Object.assign(Object.assign({}, opts), {
      unset: true
    }));
    return this;
  }

  getByPath(path) {
    return _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.getByPath(this.data, path, '/');
  }

  setByPath(path, value, options = {}) {
    const delim = '/';
    const pathArray = Array.isArray(path) ? [...path] : path.split(delim);
    const pathString = Array.isArray(path) ? path.join(delim) : path;
    const property = pathArray[0];
    const pathArrayLength = pathArray.length;
    options.propertyPath = pathString;
    options.propertyValue = value;
    options.propertyPathArray = pathArray;

    if (pathArrayLength === 1) {
      this.set(property, value, options);
    } else {
      const update = {};
      let diver = update;
      let nextKey = property; // Initialize the nested object. Subobjects are either arrays or objects.
      // An empty array is created if the sub-key is an integer. Otherwise, an
      // empty object is created.

      for (let i = 1; i < pathArrayLength; i += 1) {
        const key = pathArray[i];
        const isArrayIndex = Number.isFinite(Number(key));
        diver = diver[nextKey] = isArrayIndex ? [] : {};
        nextKey = key;
      } // Fills update with the `value` on `path`.


      _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.setByPath(update, pathArray, value, delim);
      const data = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.data); // If rewrite mode enabled, we replace value referenced by path with the
      // new one (we don't merge).

      if (options.rewrite) {
        _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.unsetByPath(data, path, delim);
      }

      const merged = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge(data, update);
      this.set(property, merged[property], options);
    }

    return this;
  }

  removeByPath(path, options) {
    const keys = Array.isArray(path) ? path : path.split('/');
    const key = keys[0];

    if (keys.length === 1) {
      this.remove(key, options);
    } else {
      const paths = keys.slice(1);
      const prop = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.get(key));

      if (prop) {
        _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.unsetByPath(prop, paths);
      }

      this.set(key, prop, options);
    }

    return this;
  }

  hasChanged(key) {
    if (key == null) {
      return Object.keys(this.changed).length > 0;
    }

    return key in this.changed;
  }
  /**
   * Returns an object containing all the data that have changed,
   * or `null` if there are no changes. Useful for determining what
   * parts of a view need to be updated.
   */


  getChanges(diff) {
    if (diff == null) {
      return this.hasChanged() ? _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.changed) : null;
    }

    const old = this.changing ? this.previous : this.data;
    const changed = {};
    let hasChanged; // eslint-disable-next-line

    for (const key in diff) {
      const val = diff[key];

      if (!_util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.isEqual(old[key], val)) {
        changed[key] = val;
        hasChanged = true;
      }
    }

    return hasChanged ? _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(changed) : null;
  }
  /**
   * Returns a copy of the store's `data` object.
   */


  toJSON() {
    return _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.data);
  }

  clone() {
    const constructor = this.constructor;
    return new constructor(this.data);
  }

  dispose() {
    this.off();
    this.data = {};
    this.previous = {};
    this.changed = {};
    this.pending = false;
    this.changing = false;
    this.pendingOptions = null;
    this.trigger('disposed', {
      store: this
    });
  }

}

__decorate([_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()], Store.prototype, "dispose", null);

/***/ }),

/***/ 26500:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/align.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resetOffset": () => (/* binding */ resetOffset),
/* harmony export */   "xAlign": () => (/* binding */ xAlign),
/* harmony export */   "yAlign": () => (/* binding */ yAlign)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);

 // `x-align` when set to `middle` causes centering of the subelement around its new x coordinate.
// `x-align` when set to `right` uses the x coordinate as referenced to the right of the bbox.

const xAlign = {
  offset: offsetWrapper('x', 'width', 'right')
}; // `y-align` when set to `middle` causes centering of the subelement around its new y coordinate.
// `y-align` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.

const yAlign = {
  offset: offsetWrapper('y', 'height', 'bottom')
};
const resetOffset = {
  offset(val, {
    refBBox
  }) {
    return val ? {
      x: -refBBox.x,
      y: -refBBox.y
    } : {
      x: 0,
      y: 0
    };
  }

};

function offsetWrapper(axis, dimension, corner) {
  return (value, {
    refBBox
  }) => {
    const point = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
    let delta;

    if (value === 'middle') {
      delta = refBBox[dimension] / 2;
    } else if (value === corner) {
      delta = refBBox[dimension];
    } else if (typeof value === 'number' && Number.isFinite(value)) {
      delta = value > -1 && value < 1 ? -refBBox[dimension] * value : -value;
    } else if (_util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(value)) {
      delta = refBBox[dimension] * parseFloat(value) / 100;
    } else {
      delta = 0;
    }

    point[axis] = -(refBBox[axis] + delta);
    return point;
  };
}

/***/ }),

/***/ 47921:
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/connection.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "atConnectionLength": () => (/* binding */ atConnectionLength),
/* harmony export */   "atConnectionLengthIgnoreGradient": () => (/* binding */ atConnectionLengthIgnoreGradient),
/* harmony export */   "atConnectionLengthKeepGradient": () => (/* binding */ atConnectionLengthKeepGradient),
/* harmony export */   "atConnectionRatio": () => (/* binding */ atConnectionRatio),
/* harmony export */   "atConnectionRatioIgnoreGradient": () => (/* binding */ atConnectionRatioIgnoreGradient),
/* harmony export */   "atConnectionRatioKeepGradient": () => (/* binding */ atConnectionRatioKeepGradient),
/* harmony export */   "connection": () => (/* binding */ connection)
/* harmony export */ });
const isEdgeView = (val, {
  view
}) => {
  return view.cell.isEdge();
};

const connection = {
  qualify: isEdgeView,

  set(val, args) {
    var _a, _b, _c, _d;

    const view = args.view;
    const reverse = val.reverse || false;
    const stubs = val.stubs || 0;
    let d;

    if (Number.isFinite(stubs) && stubs !== 0) {
      if (!reverse) {
        let offset;

        if (stubs < 0) {
          const len = view.getConnectionLength() || 0;
          offset = (len + stubs) / 2;
        } else {
          offset = stubs;
        }

        const path = view.getConnection();

        if (path) {
          const sourceParts = path.divideAtLength(offset);
          const targetParts = path.divideAtLength(-offset);

          if (sourceParts && targetParts) {
            d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
          }
        }
      } else {
        let offset;
        let length;
        const len = view.getConnectionLength() || 0;

        if (stubs < 0) {
          offset = (len + stubs) / 2;
          length = -stubs;
        } else {
          offset = stubs;
          length = len - stubs * 2;
        }

        const path = view.getConnection();
        d = (_d = (_c = (_b = (_a = path === null || path === void 0 ? void 0 : path.divideAtLength(offset)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.divideAtLength(length)) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.serialize();
      }
    }

    return {
      d: d || view.getConnectionPathData()
    };
  }

};
const atConnectionLengthKeepGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper('getTangentAtLength', {
    rotate: true
  })
};
const atConnectionLengthIgnoreGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper('getTangentAtLength', {
    rotate: false
  })
};
const atConnectionRatioKeepGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper('getTangentAtRatio', {
    rotate: true
  })
};
const atConnectionRatioIgnoreGradient = {
  qualify: isEdgeView,
  set: atConnectionWrapper('getTangentAtRatio', {
    rotate: false
  })
}; // aliases
// -------

const atConnectionLength = atConnectionLengthKeepGradient;
const atConnectionRatio = atConnectionRatioKeepGradient; // utils
// -----

function atConnectionWrapper(method, options) {
  const zeroVector = {
    x: 1,
    y: 0
  };
  return (value, args) => {
    let p;
    let angle;
    const view = args.view;
    const tangent = view[method](Number(value));

    if (tangent) {
      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
      p = tangent.start;
    } else {
      p = view.path.start;
      angle = 0;
    }

    if (angle === 0) {
      return {
        transform: `translate(${p.x},${p.y}')`
      };
    }

    return {
      transform: `translate(${p.x},${p.y}') rotate(${angle})`
    };
  };
}

/***/ }),

/***/ 23906:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/fill.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fill": () => (/* binding */ fill)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const fill = {
  qualify: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,

  set(fill, {
    view
  }) {
    return `url(#${view.graph.defineGradient(fill)})`;
  }

};

/***/ }),

/***/ 33750:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/filter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "filter": () => (/* binding */ filter)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const filter = {
  qualify: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,

  set(filter, {
    view
  }) {
    return `url(#${view.graph.defineFilter(filter)})`;
  }

};

/***/ }),

/***/ 60923:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/html.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "html": () => (/* binding */ html)
/* harmony export */ });
const html = {
  set(html, {
    view,
    elem
  }) {
    view.$(elem).html(`${html}`);
  }

};

/***/ }),

/***/ 18945:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Attr": () => (/* binding */ Attr)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./raw */ 90870);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./main */ 72793);




var Attr;

(function (Attr) {
  function isValidDefinition(def, val, options) {
    if (def != null) {
      if (typeof def === 'string') {
        return true;
      }

      if (typeof def.qualify !== 'function' || _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.qualify, this, val, options)) {
        return true;
      }
    }

    return false;
  }

  Attr.isValidDefinition = isValidDefinition;
})(Attr || (Attr = {}));

(function (Attr) {
  Attr.presets = Object.assign(Object.assign({}, _raw__WEBPACK_IMPORTED_MODULE_2__.raw), _main__WEBPACK_IMPORTED_MODULE_3__);
  Attr.registry = _registry__WEBPACK_IMPORTED_MODULE_1__.Registry.create({
    type: 'attribute definition'
  });
  Attr.registry.register(Attr.presets, true);
})(Attr || (Attr = {}));

/***/ }),

/***/ 72793:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/main.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "annotations": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.annotations),
/* harmony export */   "atConnectionLength": () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionLength),
/* harmony export */   "atConnectionLengthIgnoreGradient": () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionLengthIgnoreGradient),
/* harmony export */   "atConnectionLengthKeepGradient": () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionLengthKeepGradient),
/* harmony export */   "atConnectionRatio": () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionRatio),
/* harmony export */   "atConnectionRatioIgnoreGradient": () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionRatioIgnoreGradient),
/* harmony export */   "atConnectionRatioKeepGradient": () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionRatioKeepGradient),
/* harmony export */   "connection": () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.connection),
/* harmony export */   "displayEmpty": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.displayEmpty),
/* harmony export */   "eol": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.eol),
/* harmony export */   "fill": () => (/* reexport safe */ _fill__WEBPACK_IMPORTED_MODULE_1__.fill),
/* harmony export */   "filter": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_8__.filter),
/* harmony export */   "html": () => (/* reexport safe */ _html__WEBPACK_IMPORTED_MODULE_7__.html),
/* harmony export */   "lineHeight": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.lineHeight),
/* harmony export */   "port": () => (/* reexport safe */ _port__WEBPACK_IMPORTED_MODULE_9__.port),
/* harmony export */   "ref": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "refCx": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refCx),
/* harmony export */   "refCy": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refCy),
/* harmony export */   "refD": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refD),
/* harmony export */   "refDKeepOffset": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refDKeepOffset),
/* harmony export */   "refDResetOffset": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refDResetOffset),
/* harmony export */   "refDx": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refDx),
/* harmony export */   "refDy": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refDy),
/* harmony export */   "refHeight": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refHeight),
/* harmony export */   "refHeight2": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refHeight2),
/* harmony export */   "refPoints": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refPoints),
/* harmony export */   "refPointsKeepOffset": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refPointsKeepOffset),
/* harmony export */   "refPointsResetOffset": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refPointsResetOffset),
/* harmony export */   "refR": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refR),
/* harmony export */   "refRCircumscribed": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refRCircumscribed),
/* harmony export */   "refRInscribed": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refRInscribed),
/* harmony export */   "refRx": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refRx),
/* harmony export */   "refRy": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refRy),
/* harmony export */   "refWidth": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refWidth),
/* harmony export */   "refWidth2": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refWidth2),
/* harmony export */   "refX": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refX),
/* harmony export */   "refX2": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refX2),
/* harmony export */   "refY": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refY),
/* harmony export */   "refY2": () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refY2),
/* harmony export */   "resetOffset": () => (/* reexport safe */ _align__WEBPACK_IMPORTED_MODULE_5__.resetOffset),
/* harmony export */   "sourceMarker": () => (/* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_10__.sourceMarker),
/* harmony export */   "stroke": () => (/* reexport safe */ _stroke__WEBPACK_IMPORTED_MODULE_2__.stroke),
/* harmony export */   "style": () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_6__.style),
/* harmony export */   "targetMarker": () => (/* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_10__.targetMarker),
/* harmony export */   "text": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.text),
/* harmony export */   "textPath": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.textPath),
/* harmony export */   "textVerticalAnchor": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.textVerticalAnchor),
/* harmony export */   "textWrap": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.textWrap),
/* harmony export */   "title": () => (/* reexport safe */ _title__WEBPACK_IMPORTED_MODULE_4__.title),
/* harmony export */   "vertexMarker": () => (/* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_10__.vertexMarker),
/* harmony export */   "xAlign": () => (/* reexport safe */ _align__WEBPACK_IMPORTED_MODULE_5__.xAlign),
/* harmony export */   "yAlign": () => (/* reexport safe */ _align__WEBPACK_IMPORTED_MODULE_5__.yAlign)
/* harmony export */ });
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ref */ 4141);
/* harmony import */ var _fill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fill */ 23906);
/* harmony import */ var _stroke__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stroke */ 49974);
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./text */ 41223);
/* harmony import */ var _title__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./title */ 14483);
/* harmony import */ var _align__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./align */ 26500);
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./style */ 13716);
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./html */ 60923);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./filter */ 33750);
/* harmony import */ var _port__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./port */ 73595);
/* harmony import */ var _marker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./marker */ 76589);
/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./connection */ 47921);













/***/ }),

/***/ 76589:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/marker.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sourceMarker": () => (/* binding */ sourceMarker),
/* harmony export */   "targetMarker": () => (/* binding */ targetMarker),
/* harmony export */   "vertexMarker": () => (/* binding */ vertexMarker)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _marker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../marker */ 24541);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




function qualify(value) {
  return typeof value === 'string' || _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(value);
}

const sourceMarker = {
  qualify,

  set(marker, {
    view,
    attrs
  }) {
    return createMarker('marker-start', marker, view, attrs);
  }

};
const targetMarker = {
  qualify,

  set(marker, {
    view,
    attrs
  }) {
    return createMarker('marker-end', marker, view, attrs, {
      transform: 'rotate(180)'
    });
  }

};
const vertexMarker = {
  qualify,

  set(marker, {
    view,
    attrs
  }) {
    return createMarker('marker-mid', marker, view, attrs);
  }

};

function createMarker(type, marker, view, attrs, manual = {}) {
  const def = typeof marker === 'string' ? {
    name: marker
  } : marker;

  const {
    name,
    args
  } = def,
        others = __rest(def, ["name", "args"]);

  let preset = others;

  if (name && typeof name === 'string') {
    const fn = _marker__WEBPACK_IMPORTED_MODULE_1__.Marker.registry.get(name);

    if (fn) {
      preset = fn(Object.assign(Object.assign({}, others), args));
    } else {
      return _marker__WEBPACK_IMPORTED_MODULE_1__.Marker.registry.onNotFound(name);
    }
  }

  const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);
  return {
    [type]: `url(#${view.graph.defineMarker(options)})`
  };
}

function normalizeAttr(attr, type) {
  const result = {}; // The context 'fill' is disregared here. The usual case is to use the
  // marker with a connection(for which 'fill' attribute is set to 'none').

  const stroke = attr.stroke;

  if (typeof stroke === 'string') {
    result.stroke = stroke;
    result.fill = stroke;
  } // Again the context 'fill-opacity' is ignored.


  let strokeOpacity = attr.strokeOpacity;

  if (strokeOpacity == null) {
    strokeOpacity = attr['stroke-opacity'];
  }

  if (strokeOpacity == null) {
    strokeOpacity = attr.opacity;
  }

  if (strokeOpacity != null) {
    result['stroke-opacity'] = strokeOpacity;
    result['fill-opacity'] = strokeOpacity;
  }

  if (type !== 'marker-mid') {
    const strokeWidth = parseFloat(attr.strokeWidth || attr['stroke-width']);

    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {
      const offset = Math.ceil(strokeWidth / 2);
      result.refX = type === 'marker-start' ? offset : -offset;
    }
  }

  return result;
}

/***/ }),

/***/ 73595:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/port.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "port": () => (/* binding */ port)
/* harmony export */ });
const port = {
  set(port) {
    if (port != null && typeof port === 'object' && port.id) {
      return port.id;
    }

    return port;
  }

};

/***/ }),

/***/ 90870:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/raw.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "raw": () => (/* binding */ raw)
/* harmony export */ });
const raw = {
  xlinkHref: 'xlink:href',
  xlinkShow: 'xlink:show',
  xlinkRole: 'xlink:role',
  xlinkType: 'xlink:type',
  xlinkArcrole: 'xlink:arcrole',
  xlinkTitle: 'xlink:title',
  xlinkActuate: 'xlink:actuate',
  xmlSpace: 'xml:space',
  xmlBase: 'xml:base',
  xmlLang: 'xml:lang',
  preserveAspectRatio: 'preserveAspectRatio',
  requiredExtension: 'requiredExtension',
  requiredFeatures: 'requiredFeatures',
  systemLanguage: 'systemLanguage',
  externalResourcesRequired: 'externalResourceRequired'
};

/***/ }),

/***/ 4141:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/ref.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "refCx": () => (/* binding */ refCx),
/* harmony export */   "refCy": () => (/* binding */ refCy),
/* harmony export */   "refD": () => (/* binding */ refD),
/* harmony export */   "refDKeepOffset": () => (/* binding */ refDKeepOffset),
/* harmony export */   "refDResetOffset": () => (/* binding */ refDResetOffset),
/* harmony export */   "refDx": () => (/* binding */ refDx),
/* harmony export */   "refDy": () => (/* binding */ refDy),
/* harmony export */   "refHeight": () => (/* binding */ refHeight),
/* harmony export */   "refHeight2": () => (/* binding */ refHeight2),
/* harmony export */   "refPoints": () => (/* binding */ refPoints),
/* harmony export */   "refPointsKeepOffset": () => (/* binding */ refPointsKeepOffset),
/* harmony export */   "refPointsResetOffset": () => (/* binding */ refPointsResetOffset),
/* harmony export */   "refR": () => (/* binding */ refR),
/* harmony export */   "refRCircumscribed": () => (/* binding */ refRCircumscribed),
/* harmony export */   "refRInscribed": () => (/* binding */ refRInscribed),
/* harmony export */   "refRx": () => (/* binding */ refRx),
/* harmony export */   "refRy": () => (/* binding */ refRy),
/* harmony export */   "refWidth": () => (/* binding */ refWidth),
/* harmony export */   "refWidth2": () => (/* binding */ refWidth2),
/* harmony export */   "refX": () => (/* binding */ refX),
/* harmony export */   "refX2": () => (/* binding */ refX2),
/* harmony export */   "refY": () => (/* binding */ refY),
/* harmony export */   "refY2": () => (/* binding */ refY2)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ 44650);


const ref = {// We do not set `ref` attribute directly on an element.
  // The attribute itself does not qualify for relative positioning.
}; // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
// otherwise, `refX` is the left coordinate of the bounding box

const refX = {
  position: positionWrapper('x', 'width', 'origin')
};
const refY = {
  position: positionWrapper('y', 'height', 'origin')
}; // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom
// coordinate of the reference element.

const refDx = {
  position: positionWrapper('x', 'width', 'corner')
};
const refDy = {
  position: positionWrapper('y', 'height', 'corner')
}; // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to
// the reference element size
// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20

const refWidth = {
  set: setWrapper('width', 'width')
};
const refHeight = {
  set: setWrapper('height', 'height')
};
const refRx = {
  set: setWrapper('rx', 'width')
};
const refRy = {
  set: setWrapper('ry', 'height')
};
const refRInscribed = {
  set: (attrName => {
    const widthFn = setWrapper(attrName, 'width');
    const heightFn = setWrapper(attrName, 'height');
    return function (value, options) {
      const refBBox = options.refBBox;
      const fn = refBBox.height > refBBox.width ? widthFn : heightFn;
      return _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, value, options);
    };
  })('r')
};
const refRCircumscribed = {
  set(val, {
    refBBox
  }) {
    let value = parseFloat(val);
    const percentage = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(val);

    if (percentage) {
      value /= 100;
    }

    const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
    let rValue;

    if (Number.isFinite(value)) {
      if (percentage || value >= 0 && value <= 1) {
        rValue = value * diagonalLength;
      } else {
        rValue = Math.max(value + diagonalLength, 0);
      }
    }

    return {
      r: rValue
    };
  }

};
const refCx = {
  set: setWrapper('cx', 'width')
};
const refCy = {
  set: setWrapper('cy', 'height')
};
const refDResetOffset = {
  set: dWrapper({
    resetOffset: true
  })
};
const refDKeepOffset = {
  set: dWrapper({
    resetOffset: false
  })
};
const refPointsResetOffset = {
  set: pointsWrapper({
    resetOffset: true
  })
};
const refPointsKeepOffset = {
  set: pointsWrapper({
    resetOffset: false
  })
}; // aliases
// -------

const refR = refRInscribed;
const refD = refDResetOffset;
const refPoints = refPointsResetOffset; // Allows to combine both absolute and relative positioning
// refX: 50%, refX2: 20

const refX2 = refX;
const refY2 = refY;
const refWidth2 = refWidth;
const refHeight2 = refHeight; // utils
// -----

function positionWrapper(axis, dimension, origin) {
  return (val, {
    refBBox
  }) => {
    if (val == null) {
      return null;
    }

    let value = parseFloat(val);
    const percentage = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(val);

    if (percentage) {
      value /= 100;
    }

    let delta;

    if (Number.isFinite(value)) {
      const refOrigin = refBBox[origin];

      if (percentage || value > 0 && value < 1) {
        delta = refOrigin[axis] + refBBox[dimension] * value;
      } else {
        delta = refOrigin[axis] + value;
      }
    }

    const point = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point();
    point[axis] = delta || 0;
    return point;
  };
}

function setWrapper(attrName, dimension) {
  return function (val, {
    refBBox
  }) {
    let value = parseFloat(val);
    const percentage = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(val);

    if (percentage) {
      value /= 100;
    }

    const attrs = {};

    if (Number.isFinite(value)) {
      const attrValue = percentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);
      attrs[attrName] = attrValue;
    }

    return attrs;
  };
}

function shapeWrapper(shapeConstructor, options) {
  const cacheName = 'x6-shape';
  const resetOffset = options && options.resetOffset;
  return function (value, {
    view,
    elem,
    refBBox
  }) {
    const $elem = view.$(elem);
    let cache = $elem.data(cacheName);

    if (!cache || cache.value !== value) {
      // only recalculate if value has changed
      const cachedShape = shapeConstructor(value);
      cache = {
        value,
        shape: cachedShape,
        shapeBBox: cachedShape.bbox()
      };
      $elem.data(cacheName, cache);
    }

    const shape = cache.shape.clone();
    const shapeBBox = cache.shapeBBox.clone();
    const shapeOrigin = shapeBBox.getOrigin();
    const refOrigin = refBBox.getOrigin();
    shapeBBox.x = refOrigin.x;
    shapeBBox.y = refOrigin.y;
    const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin); // `maxRectScaleToFit` can give Infinity if width or height is 0

    const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
    const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
    shape.scale(sx, sy, shapeOrigin);

    if (resetOffset) {
      shape.translate(-shapeOrigin.x, -shapeOrigin.y);
    }

    return shape;
  };
} // `d` attribute for SVGPaths


function dWrapper(options) {
  function pathConstructor(value) {
    return _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(value);
  }

  const shape = shapeWrapper(pathConstructor, options);
  return (value, args) => {
    const path = shape(value, args);
    return {
      d: path.serialize()
    };
  };
} // `points` attribute for SVGPolylines and SVGPolygons


function pointsWrapper(options) {
  const shape = shapeWrapper(points => new _geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points), options);
  return (value, args) => {
    const polyline = shape(value, args);
    return {
      points: polyline.serialize()
    };
  };
}

/***/ }),

/***/ 49974:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/stroke.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stroke": () => (/* binding */ stroke)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const stroke = {
  qualify: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,

  set(stroke, {
    view
  }) {
    const cell = view.cell;
    const options = Object.assign({}, stroke);

    if (cell.isEdge() && options.type === 'linearGradient') {
      const edgeView = view;
      const source = edgeView.sourcePoint;
      const target = edgeView.targetPoint;
      options.id = `gradient-${options.type}-${cell.id}`;
      options.attrs = Object.assign(Object.assign({}, options.attrs), {
        x1: source.x,
        y1: source.y,
        x2: target.x,
        y2: target.y,
        gradientUnits: 'userSpaceOnUse'
      });
      view.graph.defs.remove(options.id);
    }

    return `url(#${view.graph.defineGradient(options)})`;
  }

};

/***/ }),

/***/ 13716:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/style.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "style": () => (/* binding */ style)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const style = {
  qualify: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,

  set(styles, {
    view,
    elem
  }) {
    view.$(elem).css(styles);
  }

};

/***/ }),

/***/ 41223:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/text.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "annotations": () => (/* binding */ annotations),
/* harmony export */   "displayEmpty": () => (/* binding */ displayEmpty),
/* harmony export */   "eol": () => (/* binding */ eol),
/* harmony export */   "lineHeight": () => (/* binding */ lineHeight),
/* harmony export */   "text": () => (/* binding */ text),
/* harmony export */   "textPath": () => (/* binding */ textPath),
/* harmony export */   "textVerticalAnchor": () => (/* binding */ textVerticalAnchor),
/* harmony export */   "textWrap": () => (/* binding */ textWrap)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const text = {
  qualify(text, {
    attrs
  }) {
    return attrs.textWrap == null || !_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(attrs.textWrap);
  },

  set(text, {
    view,
    elem,
    attrs
  }) {
    const cacheName = 'x6-text';
    const $elem = view.$(elem);
    const cache = $elem.data(cacheName);

    const json = str => {
      try {
        return JSON.parse(str);
      } catch (error) {
        return str;
      }
    };

    const options = {
      x: attrs.x,
      eol: attrs.eol,
      annotations: json(attrs.annotations),
      textPath: json(attrs['text-path'] || attrs.textPath),
      textVerticalAnchor: attrs['text-vertical-anchor'] || attrs.textVerticalAnchor,
      displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',
      lineHeight: attrs['line-height'] || attrs.lineHeight
    };
    const fontSize = attrs['font-size'] || attrs.fontSize;
    const textHash = JSON.stringify([text, options]);

    if (fontSize) {
      elem.setAttribute('font-size', fontSize);
    } // Updates the text only if there was a change in the string
    // or any of its attributes.


    if (cache == null || cache !== textHash) {
      // Text Along Path Selector
      const textPath = options.textPath;

      if (textPath != null && typeof textPath === 'object') {
        const selector = textPath.selector;

        if (typeof selector === 'string') {
          const pathNode = view.find(selector)[0];

          if (pathNode instanceof SVGPathElement) {
            _util__WEBPACK_IMPORTED_MODULE_0__.Dom.ensureId(pathNode);
            options.textPath = Object.assign({
              'xlink:href': `#${pathNode.id}`
            }, textPath);
          }
        }
      }

      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.text(elem, `${text}`, options);
      $elem.data(cacheName, textHash);
    }
  }

};
const textWrap = {
  qualify: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,

  set(val, {
    view,
    elem,
    attrs,
    refBBox
  }) {
    const info = val; // option `width`

    const width = info.width || 0;

    if (_util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(width)) {
      refBBox.width *= parseFloat(width) / 100;
    } else if (width <= 0) {
      refBBox.width += width;
    } else {
      refBBox.width = width;
    } // option `height`


    const height = info.height || 0;

    if (_util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(height)) {
      refBBox.height *= parseFloat(height) / 100;
    } else if (height <= 0) {
      refBBox.height += height;
    } else {
      refBBox.height = height;
    } // option `text`


    let wrappedText;
    let txt = info.text;

    if (txt == null) {
      txt = attrs.text;
    }

    if (txt != null) {
      wrappedText = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.breakText(`${txt}`, refBBox, {
        'font-weight': attrs['font-weight'] || attrs.fontWeight,
        'font-size': attrs['font-size'] || attrs.fontSize,
        'font-family': attrs['font-family'] || attrs.fontFamily,
        lineHeight: attrs.lineHeight
      }, {
        svgDocument: view.graph.view.svg,
        ellipsis: info.ellipsis,
        hyphen: info.hyphen,
        breakWord: info.breakWord
      });
    } else {
      wrappedText = '';
    }

    _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(text.set, this, wrappedText, {
      view,
      elem,
      attrs,
      refBBox,
      cell: view.cell
    });
  }

};

const isTextInUse = (val, {
  attrs
}) => {
  return attrs.text !== undefined;
};

const lineHeight = {
  qualify: isTextInUse
};
const textVerticalAnchor = {
  qualify: isTextInUse
};
const textPath = {
  qualify: isTextInUse
};
const annotations = {
  qualify: isTextInUse
};
const eol = {
  qualify: isTextInUse
};
const displayEmpty = {
  qualify: isTextInUse
};

/***/ }),

/***/ 14483:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/title.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "title": () => (/* binding */ title)
/* harmony export */ });
const title = {
  qualify(title, {
    elem
  }) {
    // HTMLElement title is specified via an attribute (i.e. not an element)
    return elem instanceof SVGElement;
  },

  set(val, {
    view,
    elem
  }) {
    const cacheName = 'x6-title';
    const title = `${val}`;
    const $elem = view.$(elem);
    const cache = $elem.data(cacheName);

    if (cache == null || cache !== title) {
      $elem.data(cacheName, title); // Generally SVGTitleElement should be the first child
      // element of its parent.

      const firstChild = elem.firstChild;

      if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {
        // Update an existing title
        const titleElem = firstChild;
        titleElem.textContent = title;
      } else {
        // Create a new title
        const titleNode = document.createElementNS(elem.namespaceURI, 'title');
        titleNode.textContent = title;
        elem.insertBefore(titleNode, firstChild);
      }
    }
  }

};

/***/ }),

/***/ 14143:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/flip-x.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flipX": () => (/* binding */ flipX)
/* harmony export */ });
const flipX = function (img) {
  // d b
  // d b
  const canvas = document.createElement('canvas');
  const width = img.width;
  const height = img.height;
  canvas.width = width * 2;
  canvas.height = height;
  const ctx = canvas.getContext('2d'); // left image

  ctx.drawImage(img, 0, 0, width, height); // flipped right image

  ctx.translate(2 * width, 0);
  ctx.scale(-1, 1);
  ctx.drawImage(img, 0, 0, width, height);
  return canvas;
};

/***/ }),

/***/ 26391:
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/flip-xy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flipXY": () => (/* binding */ flipXY)
/* harmony export */ });
const flipXY = function (img) {
  // d b
  // q p
  const canvas = document.createElement('canvas');
  const width = img.width;
  const height = img.height;
  canvas.width = 2 * width;
  canvas.height = 2 * height;
  const ctx = canvas.getContext('2d'); // top-left image

  ctx.drawImage(img, 0, 0, width, height); // xy-flipped bottom-right image

  ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0, width, height); // x-flipped top-right image

  ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
  ctx.drawImage(img, 0, 0, width, height); // y-flipped bottom-left image

  ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
  ctx.drawImage(img, 0, 0, width, height);
  return canvas;
};

/***/ }),

/***/ 78558:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/flip-y.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flipY": () => (/* binding */ flipY)
/* harmony export */ });
const flipY = function (img) {
  // d d
  // q q
  const canvas = document.createElement('canvas');
  const width = img.width;
  const height = img.height;
  canvas.width = width;
  canvas.height = height * 2;
  const ctx = canvas.getContext('2d'); // top image

  ctx.drawImage(img, 0, 0, width, height); // flipped bottom image

  ctx.translate(0, 2 * height);
  ctx.scale(1, -1);
  ctx.drawImage(img, 0, 0, width, height);
  return canvas;
};

/***/ }),

/***/ 56257:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Background": () => (/* binding */ Background)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 4874);


var Background;

(function (Background) {
  Background.presets = Object.assign({}, _main__WEBPACK_IMPORTED_MODULE_1__);
  Background.presets['flip-x'] = _main__WEBPACK_IMPORTED_MODULE_1__.flipX;
  Background.presets['flip-y'] = _main__WEBPACK_IMPORTED_MODULE_1__.flipY;
  Background.presets['flip-xy'] = _main__WEBPACK_IMPORTED_MODULE_1__.flipXY;
  Background.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'background pattern'
  });
  Background.registry.register(Background.presets, true);
})(Background || (Background = {}));

/***/ }),

/***/ 4874:
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/main.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flipX": () => (/* reexport safe */ _flip_x__WEBPACK_IMPORTED_MODULE_0__.flipX),
/* harmony export */   "flipXY": () => (/* reexport safe */ _flip_xy__WEBPACK_IMPORTED_MODULE_2__.flipXY),
/* harmony export */   "flipY": () => (/* reexport safe */ _flip_y__WEBPACK_IMPORTED_MODULE_1__.flipY),
/* harmony export */   "watermark": () => (/* reexport safe */ _watermark__WEBPACK_IMPORTED_MODULE_3__.watermark)
/* harmony export */ });
/* harmony import */ var _flip_x__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flip-x */ 14143);
/* harmony import */ var _flip_y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flip-y */ 78558);
/* harmony import */ var _flip_xy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flip-xy */ 26391);
/* harmony import */ var _watermark__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./watermark */ 93200);





/***/ }),

/***/ 93200:
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/watermark.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "watermark": () => (/* binding */ watermark)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);

const watermark = function (img, options) {
  const width = img.width;
  const height = img.height;
  const canvas = document.createElement('canvas');
  canvas.width = width * 3;
  canvas.height = height * 3;
  const ctx = canvas.getContext('2d');
  const angle = options.angle != null ? -options.angle : -20;
  const radians = _geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle);
  const stepX = canvas.width / 4;
  const stepY = canvas.height / 4;

  for (let i = 0; i < 4; i += 1) {
    for (let j = 0; j < 4; j += 1) {
      if ((i + j) % 2 > 0) {
        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
        ctx.rotate(radians);
        ctx.drawImage(img, -width / 2, -height / 2, width, height);
      }
    }
  }

  return canvas;
};

/***/ }),

/***/ 35465:
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/anchor.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anchor": () => (/* binding */ anchor)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 20443);


function alignLine(line, type, offset = 0) {
  const {
    start,
    end
  } = line;
  let a;
  let b;
  let direction;
  let coordinate;

  switch (type) {
    case 'left':
      coordinate = 'x';
      a = end;
      b = start;
      direction = -1;
      break;

    case 'right':
      coordinate = 'x';
      a = start;
      b = end;
      direction = 1;
      break;

    case 'top':
      coordinate = 'y';
      a = end;
      b = start;
      direction = -1;
      break;

    case 'bottom':
      coordinate = 'y';
      a = start;
      b = end;
      direction = 1;
      break;

    default:
      return;
  }

  if (start[coordinate] < end[coordinate]) {
    a[coordinate] = b[coordinate];
  } else {
    b[coordinate] = a[coordinate];
  }

  if (Number.isFinite(offset)) {
    a[coordinate] += direction * offset;
    b[coordinate] += direction * offset;
  }
}
/**
 * Places the connection point at the edge's endpoint.
 */


const anchor = function (line, view, magnet, options) {
  const {
    alignOffset,
    align
  } = options;

  if (align) {
    alignLine(line, align, alignOffset);
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.offset)(line.end, line.start, options.offset);
};

/***/ }),

/***/ 6629:
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/bbox.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bbox": () => (/* binding */ bbox)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 20443);

/**
 * Places the connection point at the intersection between the edge
 * path end segment and the target node bbox.
 */

const bbox = function (line, view, magnet, options) {
  const bbox = view.getBBoxOfElement(magnet);

  if (options.stroked) {
    bbox.inflate((0,_util__WEBPACK_IMPORTED_MODULE_0__.getStrokeWidth)(magnet) / 2);
  }

  const intersections = line.intersect(bbox);
  const p = intersections && intersections.length ? line.start.closest(intersections) : line.end;
  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.offset)(p, line.start, options.offset);
};

/***/ }),

/***/ 40582:
/*!************************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/boundary.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "boundary": () => (/* binding */ boundary)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ 20443);



/**
 * Places the connection point at the intersection between the
 * edge path end segment and the actual shape of the target magnet.
 */

const boundary = function (line, view, magnet, options) {
  let node;
  let intersection;
  const anchor = line.end;
  const selector = options.selector;

  if (typeof selector === 'string') {
    node = view.findOne(selector);
  } else if (Array.isArray(selector)) {
    node = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.getByPath(magnet, selector);
  } else {
    node = (0,_util__WEBPACK_IMPORTED_MODULE_2__.findShapeNode)(magnet);
  }

  if (!_util__WEBPACK_IMPORTED_MODULE_0__.Dom.isSVGGraphicsElement(node)) {
    if (node === magnet || !_util__WEBPACK_IMPORTED_MODULE_0__.Dom.isSVGGraphicsElement(magnet)) {
      return anchor;
    }

    node = magnet;
  }

  const localShape = view.getShapeOfElement(node);
  const magnetMatrix = view.getMatrixOfElement(node);
  const translateMatrix = view.getRootTranslatedMatrix();
  const rotateMatrix = view.getRootRotatedMatrix();
  const targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);
  const localMatrix = targetMatrix.inverse();
  const localLine = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformLine(line, localMatrix);
  const localRef = localLine.start.clone();
  const data = view.getDataOfElement(node);

  if (options.insideout === false) {
    if (data.shapeBBox == null) {
      data.shapeBBox = localShape.bbox();
    }

    const localBBox = data.shapeBBox;

    if (localBBox != null && localBBox.containsPoint(localRef)) {
      return anchor;
    }
  }

  if (options.extrapolate === true) {
    localLine.setLength(1e6);
  } // Caching segment subdivisions for paths


  let pathOptions;

  if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Path.isPath(localShape)) {
    const precision = options.precision || 2;

    if (data.segmentSubdivisions == null) {
      data.segmentSubdivisions = localShape.getSegmentSubdivisions({
        precision
      });
    }

    pathOptions = {
      precision,
      segmentSubdivisions: data.segmentSubdivisions
    };
    intersection = localLine.intersect(localShape, pathOptions);
  } else {
    intersection = localLine.intersect(localShape);
  }

  if (intersection) {
    if (Array.isArray(intersection)) {
      intersection = localRef.closest(intersection);
    }
  } else if (options.sticky === true) {
    // No intersection, find the closest point instead
    if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(localShape)) {
      intersection = localShape.getNearestPointToPoint(localRef);
    } else if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Ellipse.isEllipse(localShape)) {
      intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);
    } else {
      intersection = localShape.closestPoint(localRef, pathOptions);
    }
  }

  const cp = intersection ? _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformPoint(intersection, targetMatrix) : anchor;
  let cpOffset = options.offset || 0;

  if (options.stroked !== false) {
    if (typeof cpOffset === 'object') {
      cpOffset = Object.assign({}, cpOffset);

      if (cpOffset.x == null) {
        cpOffset.x = 0;
      }

      cpOffset.x += (0,_util__WEBPACK_IMPORTED_MODULE_2__.getStrokeWidth)(node) / 2;
    } else {
      cpOffset += (0,_util__WEBPACK_IMPORTED_MODULE_2__.getStrokeWidth)(node) / 2;
    }
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_2__.offset)(cp, line.start, cpOffset);
};

/***/ }),

/***/ 45708:
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionPoint": () => (/* binding */ ConnectionPoint)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 37266);


var ConnectionPoint;

(function (ConnectionPoint) {
  ConnectionPoint.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  ConnectionPoint.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'connection point'
  });
  ConnectionPoint.registry.register(ConnectionPoint.presets, true);
})(ConnectionPoint || (ConnectionPoint = {}));

/***/ }),

/***/ 37266:
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/main.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anchor": () => (/* reexport safe */ _anchor__WEBPACK_IMPORTED_MODULE_3__.anchor),
/* harmony export */   "bbox": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.bbox),
/* harmony export */   "boundary": () => (/* reexport safe */ _boundary__WEBPACK_IMPORTED_MODULE_2__.boundary),
/* harmony export */   "rect": () => (/* reexport safe */ _rect__WEBPACK_IMPORTED_MODULE_1__.rect)
/* harmony export */ });
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox */ 6629);
/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect */ 19550);
/* harmony import */ var _boundary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./boundary */ 40582);
/* harmony import */ var _anchor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anchor */ 35465);





/***/ }),

/***/ 19550:
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/rect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rect": () => (/* binding */ rect)
/* harmony export */ });
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox */ 6629);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 20443);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ 44650);



/**
 * Places the connection point at the intersection between the
 * link path end segment and the element's unrotated bbox.
 */

const rect = function (line, view, magnet, options, type) {
  const cell = view.cell;
  const angle = cell.isNode() ? cell.getAngle() : 0;

  if (angle === 0) {
    return _util__WEBPACK_IMPORTED_MODULE_2__.FunctionExt.call(_bbox__WEBPACK_IMPORTED_MODULE_0__.bbox, this, line, view, magnet, options, type);
  }

  const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);

  if (options.stroked) {
    bboxRaw.inflate((0,_util__WEBPACK_IMPORTED_MODULE_1__.getStrokeWidth)(magnet) / 2);
  }

  const center = bboxRaw.getCenter();
  const lineRaw = line.clone().rotate(angle, center);
  const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);
  const p = intersections && intersections.length ? lineRaw.start.closest(intersections).rotate(-angle, center) : line.end;
  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.offset)(p, line.start, options.offset);
};

/***/ }),

/***/ 20443:
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "findShapeNode": () => (/* binding */ findShapeNode),
/* harmony export */   "getStrokeWidth": () => (/* binding */ getStrokeWidth),
/* harmony export */   "offset": () => (/* binding */ offset)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);

function offset(p1, p2, offset) {
  let tx;

  if (typeof offset === 'object') {
    if (Number.isFinite(offset.y)) {
      const line = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(p2, p1);
      const {
        start,
        end
      } = line.parallel(offset.y);
      p2 = start; // eslint-disable-line

      p1 = end; // eslint-disable-line
    }

    tx = offset.x;
  } else {
    tx = offset;
  }

  if (tx == null || !Number.isFinite(tx)) {
    return p1;
  }

  const length = p1.distance(p2);

  if (tx === 0 && length > 0) {
    return p1;
  }

  return p1.move(p2, -Math.min(tx, length - 1));
}
function getStrokeWidth(magnet) {
  const stroke = magnet.getAttribute('stroke-width');

  if (stroke === null) {
    return 0;
  }

  return parseFloat(stroke) || 0;
}
function findShapeNode(magnet) {
  if (magnet == null) {
    return null;
  }

  let node = magnet;

  do {
    let tagName = node.tagName;
    if (typeof tagName !== 'string') return null;
    tagName = tagName.toUpperCase();

    if (tagName === 'G') {
      node = node.firstElementChild;
    } else if (tagName === 'TITLE') {
      node = node.nextElementSibling;
    } else break;
  } while (node);

  return node;
}

/***/ }),

/***/ 74566:
/*!************************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-strategy/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectionStrategy": () => (/* binding */ ConnectionStrategy)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 53160);


var ConnectionStrategy;

(function (ConnectionStrategy) {
  ConnectionStrategy.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  ConnectionStrategy.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'connection strategy'
  });
  ConnectionStrategy.registry.register(ConnectionStrategy.presets, true);
})(ConnectionStrategy || (ConnectionStrategy = {}));

/***/ }),

/***/ 53160:
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-strategy/main.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "noop": () => (/* reexport safe */ _noop__WEBPACK_IMPORTED_MODULE_0__.noop),
/* harmony export */   "pinAbsolute": () => (/* reexport safe */ _pin__WEBPACK_IMPORTED_MODULE_1__.pinAbsolute),
/* harmony export */   "pinRelative": () => (/* reexport safe */ _pin__WEBPACK_IMPORTED_MODULE_1__.pinRelative)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop */ 26088);
/* harmony import */ var _pin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pin */ 29477);



/***/ }),

/***/ 26088:
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-strategy/noop.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "noop": () => (/* binding */ noop)
/* harmony export */ });
const noop = terminal => terminal;

/***/ }),

/***/ 29477:
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-strategy/pin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pinAbsolute": () => (/* binding */ pinAbsolute),
/* harmony export */   "pinRelative": () => (/* binding */ pinRelative)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);


function toPercentage(value, max) {
  if (max === 0) {
    return '0%';
  }

  return `${Math.round(value / max * 100)}%`;
}

function pin(relative) {
  const strategy = (terminal, view, magnet, coords) => {
    return view.isEdgeElement(magnet) ? pinEdgeTerminal(relative, terminal, view, magnet, coords) : pinNodeTerminal(relative, terminal, view, magnet, coords);
  };

  return strategy;
}

function pinNodeTerminal(relative, data, view, magnet, coords) {
  const node = view.cell;
  const angle = node.getAngle();
  const bbox = view.getUnrotatedBBoxOfElement(magnet);
  const center = node.getBBox().getCenter();
  const pos = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(coords).rotate(angle, center);
  let dx = pos.x - bbox.x;
  let dy = pos.y - bbox.y;

  if (relative) {
    dx = toPercentage(dx, bbox.width);
    dy = toPercentage(dy, bbox.height);
  }

  data.anchor = {
    name: 'topLeft',
    args: {
      dx,
      dy,
      rotate: true
    }
  };
  return data;
}

function pinEdgeTerminal(relative, end, view, magnet, coords) {
  const connection = view.getConnection();

  if (!connection) {
    return end;
  }

  const length = connection.closestPointLength(coords);

  if (relative) {
    const totalLength = connection.length();
    end.anchor = {
      name: 'ratio',
      args: {
        ratio: length / totalLength
      }
    };
  } else {
    end.anchor = {
      name: 'length',
      args: {
        length
      }
    };
  }

  return end;
}

const pinRelative = pin(true);
const pinAbsolute = pin(false);

/***/ }),

/***/ 32417:
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Connector": () => (/* binding */ Connector)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 58211);


var Connector;

(function (Connector) {
  Connector.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  Connector.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'connector'
  });
  Connector.registry.register(Connector.presets, true);
})(Connector || (Connector = {}));

/***/ }),

/***/ 82749:
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/jumpover.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jumpover": () => (/* binding */ jumpover)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* eslint-disable no-underscore-dangle */
 // takes care of math. error for case when jump is too close to end of line

const CLOSE_PROXIMITY_PADDING = 1;
const F13 = 1 / 3;
const F23 = 2 / 3;

function setupUpdating(view) {
  let updateList = view.graph._jumpOverUpdateList; // first time setup for this paper

  if (updateList == null) {
    updateList = view.graph._jumpOverUpdateList = [];
    /**
     * Handler for a batch:stop event to force
     * update of all registered links with jump over connector
     */

    view.graph.on('cell:mouseup', () => {
      const list = view.graph._jumpOverUpdateList;

      for (let i = 0; i < list.length; i += 1) {
        list[i].update();
      }
    });
    view.graph.on('model:reseted', () => {
      updateList = view.graph._jumpOverUpdateList = [];
    });
  } // add this link to a list so it can be updated when some other link is updated


  if (updateList.indexOf(view) < 0) {
    updateList.push(view); // watch for change of connector type or removal of link itself
    // to remove the link from a list of jump over connectors

    const clean = () => updateList.splice(updateList.indexOf(view), 1);

    view.cell.once('change:connector', clean);
    view.cell.once('removed', clean);
  }
}

function createLines(sourcePoint, targetPoint, route = []) {
  const points = [sourcePoint, ...route, targetPoint];
  const lines = [];
  points.forEach((point, idx) => {
    const next = points[idx + 1];

    if (next != null) {
      lines.push(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(point, next));
    }
  });
  return lines;
}

function findLineIntersections(line, crossCheckLines) {
  const intersections = [];
  crossCheckLines.forEach(crossCheckLine => {
    const intersection = line.intersectsWithLine(crossCheckLine);

    if (intersection) {
      intersections.push(intersection);
    }
  });
  return intersections;
}

function getDistence(p1, p2) {
  return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(p1, p2).squaredLength();
}
/**
 * Split input line into multiple based on intersection points.
 */


function createJumps(line, intersections, jumpSize) {
  return intersections.reduce((memo, point, idx) => {
    // skipping points that were merged with the previous line
    // to make bigger arc over multiple lines that are close to each other
    if (skippedPoints.includes(point)) {
      return memo;
    } // always grab the last line from buffer and modify it


    const lastLine = memo.pop() || line; // calculate start and end of jump by moving by a given size of jump

    const jumpStart = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(point).move(lastLine.start, -jumpSize);
    let jumpEnd = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(point).move(lastLine.start, +jumpSize); // now try to look at the next intersection point

    const nextPoint = intersections[idx + 1];

    if (nextPoint != null) {
      const distance = jumpEnd.distance(nextPoint);

      if (distance <= jumpSize) {
        // next point is close enough, move the jump end by this
        // difference and mark the next point to be skipped
        jumpEnd = nextPoint.move(lastLine.start, distance);
        skippedPoints.push(nextPoint);
      }
    } else {
      // this block is inside of `else` as an optimization so the distance is
      // not calculated when we know there are no other intersection points
      const endDistance = jumpStart.distance(lastLine.end); // if the end is too close to possible jump, draw remaining line instead of a jump

      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
        memo.push(lastLine);
        return memo;
      }
    }

    const startDistance = jumpEnd.distance(lastLine.start);

    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
      // if the start of line is too close to jump, draw that line instead of a jump
      memo.push(lastLine);
      return memo;
    } // finally create a jump line


    const jumpLine = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(jumpStart, jumpEnd); // it's just simple line but with a `isJump` property

    jumppedLines.push(jumpLine);
    memo.push(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(lastLine.start, jumpStart), jumpLine, new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(jumpEnd, lastLine.end));
    return memo;
  }, []);
}

function buildPath(lines, jumpSize, jumpType, radius) {
  const path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
  let segment; // first move to the start of a first line

  segment = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('M', lines[0].start);
  path.appendSegment(segment);
  lines.forEach((line, index) => {
    if (jumppedLines.includes(line)) {
      let angle;
      let diff;
      let control1;
      let control2;

      if (jumpType === 'arc') {
        // approximates semicircle with 2 curves
        angle = -90; // determine rotation of arc based on difference between points

        diff = line.start.diff(line.end); // make sure the arc always points up (or right)

        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;

        if (xAxisRotate) {
          angle += 180;
        }

        const center = line.getCenter();
        const centerLine = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(center, line.end).rotate(angle, center);
        let halfLine; // first half

        halfLine = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(line.start, center);
        control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);
        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);
        segment = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, centerLine.end);
        path.appendSegment(segment); // second half

        halfLine = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(center, line.end);
        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);
        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);
        segment = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, line.end);
        path.appendSegment(segment);
      } else if (jumpType === 'gap') {
        segment = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('M', line.end);
        path.appendSegment(segment);
      } else if (jumpType === 'cubic') {
        // approximates semicircle with 1 curve
        angle = line.start.theta(line.end);
        const xOffset = jumpSize * 0.6;
        let yOffset = jumpSize * 1.35; // determine rotation of arc based on difference between points

        diff = line.start.diff(line.end); // make sure the arc always points up (or right)

        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;

        if (xAxisRotate) {
          yOffset *= -1;
        }

        control1 = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);
        control2 = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);
        segment = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, line.end);
        path.appendSegment(segment);
      }
    } else {
      const nextLine = lines[index + 1];

      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {
        segment = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('L', line.end);
        path.appendSegment(segment);
      } else {
        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);
      }
    }
  });
  return path;
}

function buildRoundedSegment(offset, path, curr, prev, next) {
  const prevDistance = curr.distance(prev) / 2;
  const nextDistance = curr.distance(next) / 2;
  const startMove = -Math.min(offset, prevDistance);
  const endMove = -Math.min(offset, nextDistance);
  const roundedStart = curr.clone().move(prev, startMove).round();
  const roundedEnd = curr.clone().move(next, endMove).round();
  const control1 = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);
  const control2 = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);
  let segment;
  segment = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('L', roundedStart);
  path.appendSegment(segment);
  segment = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, roundedEnd);
  path.appendSegment(segment);
}

let jumppedLines;
let skippedPoints;
const jumpover = function (sourcePoint, targetPoint, routePoints, options = {}) {
  jumppedLines = [];
  skippedPoints = [];
  setupUpdating(this);
  const jumpSize = options.size || 5;
  const jumpType = options.type || 'arc';
  const radius = options.radius || 0; // list of connector types not to jump over.

  const ignoreConnectors = options.ignoreConnectors || ['smooth'];
  const graph = this.graph;
  const model = graph.model;
  const allLinks = model.getEdges(); // there is just one link, draw it directly

  if (allLinks.length === 1) {
    return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);
  }

  const edge = this.cell;
  const thisIndex = allLinks.indexOf(edge);
  const defaultConnector = graph.options.connecting.connector || {}; // not all links are meant to be jumped over.

  const edges = allLinks.filter((link, idx) => {
    const connector = link.getConnector() || defaultConnector; // avoid jumping over links with connector type listed in `ignored connectors`.

    if (ignoreConnectors.includes(connector.name)) {
      return false;
    } // filter out links that are above this one and  have the same connector type
    // otherwise there would double hoops for each intersection


    if (idx > thisIndex) {
      return connector.name !== 'jumpover';
    }

    return true;
  }); // find views for all links

  const linkViews = edges.map(edge => {
    return graph.renderer.findViewByCell(edge);
  }); // create lines for this link

  const thisLines = createLines(sourcePoint, targetPoint, routePoints); // create lines for all other links

  const linkLines = linkViews.map(linkView => {
    if (linkView == null) {
      return [];
    }

    if (linkView === this) {
      return thisLines;
    }

    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);
  }); // transform lines for this link by splitting with jump lines at
  // points of intersection with other links

  const jumpingLines = [];
  thisLines.forEach(line => {
    // iterate all links and grab the intersections with this line
    // these are then sorted by distance so the line can be split more easily
    const intersections = edges.reduce((memo, link, i) => {
      // don't intersection with itself
      if (link !== edge) {
        const lineIntersections = findLineIntersections(line, linkLines[i]);
        memo.push(...lineIntersections);
      }

      return memo;
    }, []).sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b));

    if (intersections.length > 0) {
      // split the line based on found intersection points
      jumpingLines.push(...createJumps(line, intersections, jumpSize));
    } else {
      // without any intersection the line goes uninterrupted
      jumpingLines.push(line);
    }
  });
  const path = buildPath(jumpingLines, jumpSize, jumpType, radius);
  jumppedLines = [];
  skippedPoints = [];
  return options.raw ? path : path.serialize();
};

/***/ }),

/***/ 50025:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/loop.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loop": () => (/* binding */ loop)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);

const loop = function (sourcePoint, targetPoint, routePoints, options = {}) {
  const fix = routePoints.length === 3 ? 0 : 1;
  const p1 = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(routePoints[0 + fix]);
  const p2 = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(routePoints[2 + fix]);
  const center = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(routePoints[1 + fix]);

  if (!_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.equals(sourcePoint, targetPoint)) {
    const middle = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);
    const angle = middle.angleBetween(_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(sourcePoint).rotate(90, middle), center);

    if (angle > 1) {
      p1.rotate(180 - angle, middle);
      p2.rotate(180 - angle, middle);
      center.rotate(180 - angle, middle);
    }
  }

  const pathData = `
     M ${sourcePoint.x} ${sourcePoint.y}
     Q ${p1.x} ${p1.y} ${center.x} ${center.y}
     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}
  `;
  return options.raw ? _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(pathData) : pathData;
};

/***/ }),

/***/ 58211:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/main.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jumpover": () => (/* reexport safe */ _jumpover__WEBPACK_IMPORTED_MODULE_4__.jumpover),
/* harmony export */   "loop": () => (/* reexport safe */ _loop__WEBPACK_IMPORTED_MODULE_1__.loop),
/* harmony export */   "normal": () => (/* reexport safe */ _normal__WEBPACK_IMPORTED_MODULE_0__.normal),
/* harmony export */   "rounded": () => (/* reexport safe */ _rounded__WEBPACK_IMPORTED_MODULE_2__.rounded),
/* harmony export */   "smooth": () => (/* reexport safe */ _smooth__WEBPACK_IMPORTED_MODULE_3__.smooth)
/* harmony export */ });
/* harmony import */ var _normal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normal */ 31329);
/* harmony import */ var _loop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loop */ 50025);
/* harmony import */ var _rounded__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rounded */ 2492);
/* harmony import */ var _smooth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./smooth */ 48064);
/* harmony import */ var _jumpover__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jumpover */ 82749);






/***/ }),

/***/ 31329:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/normal.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normal": () => (/* binding */ normal)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);

const normal = function (sourcePoint, targetPoint, routePoints, options = {}) {
  const points = [sourcePoint, ...routePoints, targetPoint];
  const polyline = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);
  const path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path(polyline);
  return options.raw ? path : path.serialize();
};

/***/ }),

/***/ 2492:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/rounded.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rounded": () => (/* binding */ rounded)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);

const rounded = function (sourcePoint, targetPoint, routePoints, options = {}) {
  const path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
  path.appendSegment(_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('M', sourcePoint));
  const f13 = 1 / 3;
  const f23 = 2 / 3;
  const radius = options.radius || 10;
  let prevDistance;
  let nextDistance;

  for (let i = 0, ii = routePoints.length; i < ii; i += 1) {
    const curr = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(routePoints[i]);
    const prev = routePoints[i - 1] || sourcePoint;
    const next = routePoints[i + 1] || targetPoint;
    prevDistance = nextDistance || curr.distance(prev) / 2;
    nextDistance = curr.distance(next) / 2;
    const startMove = -Math.min(radius, prevDistance);
    const endMove = -Math.min(radius, nextDistance);
    const roundedStart = curr.clone().move(prev, startMove).round();
    const roundedEnd = curr.clone().move(next, endMove).round();
    const control1 = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);
    const control2 = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);
    path.appendSegment(_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('L', roundedStart));
    path.appendSegment(_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, roundedEnd));
  }

  path.appendSegment(_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('L', targetPoint));
  return options.raw ? path : path.serialize();
};

/***/ }),

/***/ 48064:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/smooth.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "smooth": () => (/* binding */ smooth)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);

const smooth = function (sourcePoint, targetPoint, routePoints, options = {}) {
  let path;
  let direction = options.direction;

  if (routePoints && routePoints.length !== 0) {
    const points = [sourcePoint, ...routePoints, targetPoint];
    const curves = _geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.throughPoints(points);
    path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path(curves);
  } else {
    // If we have no route, use a default cubic bezier curve, cubic bezier
    // requires two control points, the control points have `x` midway
    // between source and target. This produces an S-like curve.
    path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
    path.appendSegment(_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('M', sourcePoint));

    if (!direction) {
      direction = Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y) ? 'H' : 'V';
    }

    if (direction === 'H') {
      const controlPointX = (sourcePoint.x + targetPoint.x) / 2;
      path.appendSegment(_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));
    } else {
      const controlPointY = (sourcePoint.y + targetPoint.y) / 2;
      path.appendSegment(_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));
    }
  }

  return options.raw ? path : path.serialize();
};

/***/ }),

/***/ 98580:
/*!******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/closest.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "closest": () => (/* binding */ closest),
/* harmony export */   "getClosestPoint": () => (/* binding */ getClosestPoint)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _node_anchor_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node-anchor/util */ 4832);


const getClosestPoint = function (view, magnet, refPoint, options) {
  const closestPoint = view.getClosestPoint(refPoint);
  return closestPoint != null ? closestPoint : new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point();
};
const closest = (0,_node_anchor_util__WEBPACK_IMPORTED_MODULE_1__.resolve)(getClosestPoint);

/***/ }),

/***/ 98548:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EdgeAnchor": () => (/* binding */ EdgeAnchor)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 82979);


var EdgeAnchor;

(function (EdgeAnchor) {
  EdgeAnchor.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  EdgeAnchor.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'edge endpoint'
  });
  EdgeAnchor.registry.register(EdgeAnchor.presets, true);
})(EdgeAnchor || (EdgeAnchor = {}));

/***/ }),

/***/ 88323:
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/length.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "length": () => (/* binding */ length)
/* harmony export */ });
const length = function (view, magnet, ref, options) {
  const length = options.length != null ? options.length : 20;
  return view.getPointAtLength(length);
};

/***/ }),

/***/ 82979:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "closest": () => (/* reexport safe */ _closest__WEBPACK_IMPORTED_MODULE_3__.closest),
/* harmony export */   "length": () => (/* reexport safe */ _length__WEBPACK_IMPORTED_MODULE_1__.length),
/* harmony export */   "orth": () => (/* reexport safe */ _orth__WEBPACK_IMPORTED_MODULE_2__.orth),
/* harmony export */   "ratio": () => (/* reexport safe */ _ratio__WEBPACK_IMPORTED_MODULE_0__.ratio)
/* harmony export */ });
/* harmony import */ var _ratio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ratio */ 31950);
/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length */ 88323);
/* harmony import */ var _orth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orth */ 66784);
/* harmony import */ var _closest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./closest */ 98580);





/***/ }),

/***/ 66784:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/orth.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "orth": () => (/* binding */ orth)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _node_anchor_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node-anchor/util */ 4832);
/* harmony import */ var _closest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./closest */ 98580);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util */ 44650);





const orthogonal = function (view, magnet, refPoint, options) {
  const OFFSET = 1e6;
  const path = view.getConnection();
  const segmentSubdivisions = view.getConnectionSubdivisions();
  const vLine = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));
  const hLine = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));
  const vIntersections = vLine.intersect(path, {
    segmentSubdivisions
  });
  const hIntersections = hLine.intersect(path, {
    segmentSubdivisions
  });
  const intersections = [];

  if (vIntersections) {
    intersections.push(...vIntersections);
  }

  if (hIntersections) {
    intersections.push(...hIntersections);
  }

  if (intersections.length > 0) {
    return refPoint.closest(intersections);
  }

  if (options.fallbackAt != null) {
    return (0,_node_anchor_util__WEBPACK_IMPORTED_MODULE_1__.getPointAtEdge)(view, options.fallbackAt);
  }

  return _util__WEBPACK_IMPORTED_MODULE_3__.FunctionExt.call(_closest__WEBPACK_IMPORTED_MODULE_2__.getClosestPoint, this, view, magnet, refPoint, options);
};

const orth = (0,_node_anchor_util__WEBPACK_IMPORTED_MODULE_1__.resolve)(orthogonal);

/***/ }),

/***/ 31950:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/ratio.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ratio": () => (/* binding */ ratio)
/* harmony export */ });
const ratio = function (view, magnet, ref, options) {
  let ratio = options.ratio != null ? options.ratio : 0.5;

  if (ratio > 1) {
    ratio /= 100;
  }

  return view.getPointAtRatio(ratio);
};

/***/ }),

/***/ 86096:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/blur.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "blur": () => (/* binding */ blur)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function blur(args = {}) {
  const x = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.x, 2);
  const stdDeviation = args.y != null && Number.isFinite(args.y) ? [x, args.y] : x;
  return `
    <filter>
      <feGaussianBlur stdDeviation="${stdDeviation}"/>
    </filter>
  `.trim();
}

/***/ }),

/***/ 67520:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/brightness.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "brightness": () => (/* binding */ brightness)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function brightness(args = {}) {
  const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
  return `
    <filter>
      <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}"/>
        <feFuncG type="linear" slope="${amount}"/>
        <feFuncB type="linear" slope="${amount}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

/***/ }),

/***/ 56564:
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/contrast.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "contrast": () => (/* binding */ contrast)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function contrast(args = {}) {
  const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
  const amount2 = 0.5 - amount / 2;
  return `
    <filter>
     <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncG type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncB type="linear" slope="${amount}" intercept="${amount2}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}

/***/ }),

/***/ 64489:
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/drop-shadow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dropShadow": () => (/* binding */ dropShadow)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function dropShadow(args = {}) {
  const dx = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.dx, 0);
  const dy = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.dy, 0);
  const color = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getString)(args.color, 'black');
  const blur = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.blur, 4);
  const opacity = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.opacity, 1);
  return 'SVGFEDropShadowElement' in window ? `<filter>
         <feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}" />
       </filter>`.trim() : `<filter>
         <feGaussianBlur in="SourceAlpha" stdDeviation="${blur}" />
         <feOffset dx="${dx}" dy="${dy}" result="offsetblur" />
         <feFlood flood-color="${color}" />
         <feComposite in2="offsetblur" operator="in" />
         <feComponentTransfer>
           <feFuncA type="linear" slope="${opacity}" />
         </feComponentTransfer>
         <feMerge>
           <feMergeNode/>
           <feMergeNode in="SourceGraphic"/>
         </feMerge>
       </filter>`.trim();
}

/***/ }),

/***/ 85292:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/gray-scale.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "grayScale": () => (/* binding */ grayScale)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function grayScale(args = {}) {
  const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
  const a = 0.2126 + 0.7874 * (1 - amount);
  const b = 0.7152 - 0.7152 * (1 - amount);
  const c = 0.0722 - 0.0722 * (1 - amount);
  const d = 0.2126 - 0.2126 * (1 - amount);
  const e = 0.7152 + 0.2848 * (1 - amount);
  const f = 0.0722 - 0.0722 * (1 - amount);
  const g = 0.2126 - 0.2126 * (1 - amount);
  const h = 0.0722 + 0.9278 * (1 - amount);
  return `
    <filter>
      <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/>
    </filter>
  `.trim();
}

/***/ }),

/***/ 11858:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/highlight.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "highlight": () => (/* binding */ highlight)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function highlight(args = {}) {
  const color = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getString)(args.color, 'red');
  const blur = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.blur, 0);
  const width = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.width, 1);
  const opacity = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.opacity, 1);
  return `
      <filter>
        <feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/>
        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/>
        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>
        <feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/>
        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>
      </filter>
    `.trim();
}

/***/ }),

/***/ 56715:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/hue-rotate.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hueRotate": () => (/* binding */ hueRotate)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function hueRotate(args = {}) {
  const angle = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.angle, 0);
  return `
      <filter>
        <feColorMatrix type="hueRotate" values="${angle}"/>
      </filter>
    `.trim();
}

/***/ }),

/***/ 2782:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Filter": () => (/* binding */ Filter)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 49531);


var Filter;

(function (Filter) {
  Filter.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  Filter.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'filter'
  });
  Filter.registry.register(Filter.presets, true);
})(Filter || (Filter = {}));

/***/ }),

/***/ 69596:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/invert.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "invert": () => (/* binding */ invert)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function invert(args = {}) {
  const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
  const amount2 = 1 - amount;
  return `
      <filter>
        <feComponentTransfer>
          <feFuncR type="table" tableValues="${amount} ${amount2}"/>
          <feFuncG type="table" tableValues="${amount} ${amount2}"/>
          <feFuncB type="table" tableValues="${amount} ${amount2}"/>
        </feComponentTransfer>
      </filter>
    `.trim();
}

/***/ }),

/***/ 49531:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/main.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "blur": () => (/* reexport safe */ _blur__WEBPACK_IMPORTED_MODULE_2__.blur),
/* harmony export */   "brightness": () => (/* reexport safe */ _brightness__WEBPACK_IMPORTED_MODULE_9__.brightness),
/* harmony export */   "contrast": () => (/* reexport safe */ _contrast__WEBPACK_IMPORTED_MODULE_10__.contrast),
/* harmony export */   "dropShadow": () => (/* reexport safe */ _drop_shadow__WEBPACK_IMPORTED_MODULE_3__.dropShadow),
/* harmony export */   "grayScale": () => (/* reexport safe */ _gray_scale__WEBPACK_IMPORTED_MODULE_4__.grayScale),
/* harmony export */   "highlight": () => (/* reexport safe */ _highlight__WEBPACK_IMPORTED_MODULE_1__.highlight),
/* harmony export */   "hueRotate": () => (/* reexport safe */ _hue_rotate__WEBPACK_IMPORTED_MODULE_7__.hueRotate),
/* harmony export */   "invert": () => (/* reexport safe */ _invert__WEBPACK_IMPORTED_MODULE_8__.invert),
/* harmony export */   "outline": () => (/* reexport safe */ _outline__WEBPACK_IMPORTED_MODULE_0__.outline),
/* harmony export */   "saturate": () => (/* reexport safe */ _saturate__WEBPACK_IMPORTED_MODULE_6__.saturate),
/* harmony export */   "sepia": () => (/* reexport safe */ _sepia__WEBPACK_IMPORTED_MODULE_5__.sepia)
/* harmony export */ });
/* harmony import */ var _outline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./outline */ 46825);
/* harmony import */ var _highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./highlight */ 11858);
/* harmony import */ var _blur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blur */ 86096);
/* harmony import */ var _drop_shadow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drop-shadow */ 64489);
/* harmony import */ var _gray_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gray-scale */ 85292);
/* harmony import */ var _sepia__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sepia */ 52444);
/* harmony import */ var _saturate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./saturate */ 32585);
/* harmony import */ var _hue_rotate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hue-rotate */ 56715);
/* harmony import */ var _invert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./invert */ 69596);
/* harmony import */ var _brightness__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./brightness */ 67520);
/* harmony import */ var _contrast__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./contrast */ 56564);












/***/ }),

/***/ 46825:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/outline.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "outline": () => (/* binding */ outline)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function outline(args = {}) {
  const color = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getString)(args.color, 'blue');
  const width = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.width, 1);
  const margin = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.margin, 2);
  const opacity = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.opacity, 1);
  const innerRadius = margin;
  const outerRadius = margin + width;
  return `
    <filter>
      <feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/>
      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" />
      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" />
      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>
      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>
      <feMerge>
        <feMergeNode in="outline"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `.trim();
}

/***/ }),

/***/ 32585:
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/saturate.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "saturate": () => (/* binding */ saturate)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function saturate(args = {}) {
  const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
  return `
      <filter>
        <feColorMatrix type="saturate" values="${1 - amount}"/>
      </filter>
    `.trim();
}

/***/ }),

/***/ 52444:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/sepia.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sepia": () => (/* binding */ sepia)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 25248);

function sepia(args = {}) {
  const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
  const a = 0.393 + 0.607 * (1 - amount);
  const b = 0.769 - 0.769 * (1 - amount);
  const c = 0.189 - 0.189 * (1 - amount);
  const d = 0.349 - 0.349 * (1 - amount);
  const e = 0.686 + 0.314 * (1 - amount);
  const f = 0.168 - 0.168 * (1 - amount);
  const g = 0.272 - 0.272 * (1 - amount);
  const h = 0.534 - 0.534 * (1 - amount);
  const i = 0.131 + 0.869 * (1 - amount);
  return `
      <filter>
        <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/>
      </filter>
    `.trim();
}

/***/ }),

/***/ 25248:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNumber": () => (/* binding */ getNumber),
/* harmony export */   "getString": () => (/* binding */ getString)
/* harmony export */ });
function getString(value, defaultValue) {
  return value != null ? value : defaultValue;
}
function getNumber(num, defaultValue) {
  return num != null && Number.isFinite(num) ? num : defaultValue;
}

/***/ }),

/***/ 9784:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/dot.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dot": () => (/* binding */ dot)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const dot = {
  color: '#aaaaaa',
  thickness: 1,
  markup: 'rect',

  update(elem, options) {
    const width = options.thickness * options.sx;
    const height = options.thickness * options.sy;
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
      width,
      height,
      rx: width,
      ry: height,
      fill: options.color
    });
  }

};

/***/ }),

/***/ 46810:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/double-mesh.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "doubleMesh": () => (/* binding */ doubleMesh)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const doubleMesh = [{
  color: 'rgba(224,224,224,1)',
  thickness: 1,
  markup: 'path',

  update(elem, options) {
    let d;
    const width = options.width;
    const height = options.height;
    const thickness = options.thickness;

    if (width - thickness >= 0 && height - thickness >= 0) {
      d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
    } else {
      d = 'M 0 0 0 0';
    }

    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
      d,
      stroke: options.color,
      'stroke-width': options.thickness
    });
  }

}, {
  color: 'rgba(224,224,224,0.2)',
  thickness: 3,
  factor: 4,
  markup: 'path',

  update(elem, options) {
    let d;
    const factor = options.factor || 1;
    const width = options.width * factor;
    const height = options.height * factor;
    const thickness = options.thickness;

    if (width - thickness >= 0 && height - thickness >= 0) {
      d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
    } else {
      d = 'M 0 0 0 0';
    } // update wrapper size


    options.width = width;
    options.height = height;
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
      d,
      stroke: options.color,
      'stroke-width': options.thickness
    });
  }

}];

/***/ }),

/***/ 24035:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/fixed-dot.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fixedDot": () => (/* binding */ fixedDot)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const fixedDot = {
  color: '#aaaaaa',
  thickness: 1,
  markup: 'rect',

  update(elem, options) {
    const size = options.sx <= 1 ? options.thickness * options.sx : options.thickness;
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
      width: size,
      height: size,
      rx: size,
      ry: size,
      fill: options.color
    });
  }

};

/***/ }),

/***/ 80892:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Grid": () => (/* binding */ Grid)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main */ 90979);



class Grid {
  constructor() {
    this.patterns = {};
    this.root = _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create(_util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSvgDocument(), {
      width: '100%',
      height: '100%'
    }, [_util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSvgElement('defs')]).node;
  }

  add(id, elem) {
    const firstChild = this.root.childNodes[0];

    if (firstChild) {
      firstChild.appendChild(elem);
    }

    this.patterns[id] = elem;
    _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create('rect', {
      width: '100%',
      height: '100%',
      fill: `url(#${id})`
    }).appendTo(this.root);
  }

  get(id) {
    return this.patterns[id];
  }

  has(id) {
    return this.patterns[id] != null;
  }

}

(function (Grid) {
  Grid.presets = _main__WEBPACK_IMPORTED_MODULE_2__;
  Grid.registry = _registry__WEBPACK_IMPORTED_MODULE_1__.Registry.create({
    type: 'grid'
  });
  Grid.registry.register(Grid.presets, true);
})(Grid || (Grid = {}));

/***/ }),

/***/ 90979:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/main.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dot": () => (/* reexport safe */ _dot__WEBPACK_IMPORTED_MODULE_0__.dot),
/* harmony export */   "doubleMesh": () => (/* reexport safe */ _double_mesh__WEBPACK_IMPORTED_MODULE_3__.doubleMesh),
/* harmony export */   "fixedDot": () => (/* reexport safe */ _fixed_dot__WEBPACK_IMPORTED_MODULE_1__.fixedDot),
/* harmony export */   "mesh": () => (/* reexport safe */ _mesh__WEBPACK_IMPORTED_MODULE_2__.mesh)
/* harmony export */ });
/* harmony import */ var _dot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dot */ 9784);
/* harmony import */ var _fixed_dot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fixed-dot */ 24035);
/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh */ 6490);
/* harmony import */ var _double_mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-mesh */ 46810);





/***/ }),

/***/ 6490:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/mesh.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mesh": () => (/* binding */ mesh)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const mesh = {
  color: 'rgba(224,224,224,1)',
  thickness: 1,
  markup: 'path',

  update(elem, options) {
    let d;
    const width = options.width;
    const height = options.height;
    const thickness = options.thickness;

    if (width - thickness >= 0 && height - thickness >= 0) {
      d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
    } else {
      d = 'M 0 0 0 0';
    }

    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
      d,
      stroke: options.color,
      'stroke-width': options.thickness
    });
  }

};

/***/ }),

/***/ 7204:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/class.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "className": () => (/* binding */ className)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global */ 9789);


const defaultClassName = _global__WEBPACK_IMPORTED_MODULE_1__.Util.prefix('highlighted');
const className = {
  highlight(cellView, magnet, options) {
    const cls = options && options.className || defaultClassName;
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(magnet, cls);
  },

  unhighlight(cellView, magnet, options) {
    const cls = options && options.className || defaultClassName;
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(magnet, cls);
  }

};

/***/ }),

/***/ 10793:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Highlighter": () => (/* binding */ Highlighter)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 84028);


var Highlighter;

(function (Highlighter) {
  function check(name, highlighter) {
    if (typeof highlighter.highlight !== 'function') {
      throw new Error(`Highlighter '${name}' is missing required \`highlight()\` method`);
    }

    if (typeof highlighter.unhighlight !== 'function') {
      throw new Error(`Highlighter '${name}' is missing required \`unhighlight()\` method`);
    }
  }

  Highlighter.check = check;
})(Highlighter || (Highlighter = {}));

(function (Highlighter) {
  Highlighter.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  Highlighter.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'highlighter'
  });
  Highlighter.registry.register(Highlighter.presets, true);
})(Highlighter || (Highlighter = {}));

/***/ }),

/***/ 84028:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "className": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_0__.className),
/* harmony export */   "opacity": () => (/* reexport safe */ _opacity__WEBPACK_IMPORTED_MODULE_1__.opacity),
/* harmony export */   "stroke": () => (/* reexport safe */ _stroke__WEBPACK_IMPORTED_MODULE_2__.stroke)
/* harmony export */ });
/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class */ 7204);
/* harmony import */ var _opacity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./opacity */ 54473);
/* harmony import */ var _stroke__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stroke */ 40137);




/***/ }),

/***/ 54473:
/*!******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/opacity.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "opacity": () => (/* binding */ opacity)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global */ 9789);


const className = _global__WEBPACK_IMPORTED_MODULE_1__.Util.prefix('highlight-opacity');
const opacity = {
  highlight(cellView, magnet) {
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(magnet, className);
  },

  unhighlight(cellView, magnetEl) {
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(magnetEl, className);
  }

};

/***/ }),

/***/ 40137:
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/stroke.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stroke": () => (/* binding */ stroke)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global */ 9789);


const defaultOptions = {
  padding: 3,
  rx: 0,
  ry: 0,
  attrs: {
    'stroke-width': 3,
    stroke: '#FEB663'
  }
};
const stroke = {
  highlight(cellView, magnet, options) {
    const id = Private.getHighlighterId(magnet, options);

    if (Private.hasCache(id)) {
      return;
    } // eslint-disable-next-line


    options = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.defaultsDeep({}, options, defaultOptions);
    const magnetVel = _util__WEBPACK_IMPORTED_MODULE_0__.Vector.create(magnet);
    let pathData;
    let magnetBBox;

    try {
      pathData = magnetVel.toPathData();
    } catch (error) {
      // Failed to get path data from magnet element.
      // Draw a rectangle around the entire cell view instead.
      magnetBBox = magnetVel.bbox(true
      /* without transforms */
      );
      pathData = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));
    }

    const path = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSvgElement('path');
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(path, Object.assign({
      d: pathData,
      'pointer-events': 'none',
      'vector-effect': 'non-scaling-stroke',
      fill: 'none'
    }, options.attrs ? _util__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(options.attrs) : null)); // const highlightVel = v.create('path').attr()

    if (cellView.isEdgeElement(magnet)) {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(path, 'd', cellView.getConnectionPathData());
    } else {
      let highlightMatrix = magnetVel.getTransformToElement(cellView.container); // Add padding to the highlight element.

      const padding = options.padding;

      if (padding) {
        if (magnetBBox == null) {
          magnetBBox = magnetVel.bbox(true);
        }

        const cx = magnetBBox.x + magnetBBox.width / 2;
        const cy = magnetBBox.y + magnetBBox.height / 2;
        magnetBBox = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformRectangle(magnetBBox, highlightMatrix);
        const width = Math.max(magnetBBox.width, 1);
        const height = Math.max(magnetBBox.height, 1);
        const sx = (width + padding) / width;
        const sy = (height + padding) / height;
        const paddingMatrix = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix({
          a: sx,
          b: 0,
          c: 0,
          d: sy,
          e: cx - sx * cx,
          f: cy - sy * cy
        });
        highlightMatrix = highlightMatrix.multiply(paddingMatrix);
      }

      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transform(path, highlightMatrix);
    }

    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(path, _global__WEBPACK_IMPORTED_MODULE_1__.Util.prefix('highlight-stroke'));
    const cell = cellView.cell;

    const removeHandler = () => Private.removeHighlighter(id);

    cell.on('removed', removeHandler);

    if (cell.model) {
      cell.model.on('reseted', removeHandler);
    }

    cellView.container.appendChild(path);
    Private.setCache(id, path);
  },

  unhighlight(cellView, magnet, opt) {
    Private.removeHighlighter(Private.getHighlighterId(magnet, opt));
  }

};
var Private;

(function (Private) {
  function getHighlighterId(magnet, options) {
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.ensureId(magnet);
    return magnet.id + JSON.stringify(options);
  }

  Private.getHighlighterId = getHighlighterId;
  const cache = {};

  function setCache(id, elem) {
    cache[id] = elem;
  }

  Private.setCache = setCache;

  function hasCache(id) {
    return cache[id] != null;
  }

  Private.hasCache = hasCache;

  function removeHighlighter(id) {
    const elem = cache[id];

    if (elem) {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(elem);
      delete cache[id];
    }
  }

  Private.removeHighlighter = removeHighlighter;
})(Private || (Private = {}));

/***/ }),

/***/ 73306:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Attr": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.Attr),
/* harmony export */   "Background": () => (/* reexport safe */ _background__WEBPACK_IMPORTED_MODULE_4__.Background),
/* harmony export */   "ConnectionPoint": () => (/* reexport safe */ _connection_point__WEBPACK_IMPORTED_MODULE_12__.ConnectionPoint),
/* harmony export */   "ConnectionStrategy": () => (/* reexport safe */ _connection_strategy__WEBPACK_IMPORTED_MODULE_15__.ConnectionStrategy),
/* harmony export */   "Connector": () => (/* reexport safe */ _connector__WEBPACK_IMPORTED_MODULE_14__.Connector),
/* harmony export */   "EdgeAnchor": () => (/* reexport safe */ _edge_anchor__WEBPACK_IMPORTED_MODULE_11__.EdgeAnchor),
/* harmony export */   "EdgeTool": () => (/* reexport safe */ _tool__WEBPACK_IMPORTED_MODULE_8__.EdgeTool),
/* harmony export */   "Filter": () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_3__.Filter),
/* harmony export */   "Grid": () => (/* reexport safe */ _grid__WEBPACK_IMPORTED_MODULE_2__.Grid),
/* harmony export */   "Highlighter": () => (/* reexport safe */ _highlighter__WEBPACK_IMPORTED_MODULE_5__.Highlighter),
/* harmony export */   "Marker": () => (/* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_9__.Marker),
/* harmony export */   "NodeAnchor": () => (/* reexport safe */ _node_anchor__WEBPACK_IMPORTED_MODULE_10__.NodeAnchor),
/* harmony export */   "NodeTool": () => (/* reexport safe */ _tool__WEBPACK_IMPORTED_MODULE_8__.NodeTool),
/* harmony export */   "PortLabelLayout": () => (/* reexport safe */ _port_label_layout__WEBPACK_IMPORTED_MODULE_7__.PortLabelLayout),
/* harmony export */   "PortLayout": () => (/* reexport safe */ _port_layout__WEBPACK_IMPORTED_MODULE_6__.PortLayout),
/* harmony export */   "Registry": () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_0__.Registry),
/* harmony export */   "Router": () => (/* reexport safe */ _router__WEBPACK_IMPORTED_MODULE_13__.Router),
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registry */ 80618);
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr */ 18945);
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./grid */ 80892);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter */ 2782);
/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./background */ 56257);
/* harmony import */ var _highlighter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./highlighter */ 10793);
/* harmony import */ var _port_layout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./port-layout */ 37425);
/* harmony import */ var _port_label_layout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./port-label-layout */ 49443);
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tool */ 59912);
/* harmony import */ var _marker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./marker */ 24541);
/* harmony import */ var _node_anchor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./node-anchor */ 41005);
/* harmony import */ var _edge_anchor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./edge-anchor */ 98548);
/* harmony import */ var _connection_point__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./connection-point */ 45708);
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./router */ 49255);
/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./connector */ 32417);
/* harmony import */ var _connection_strategy__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./connection-strategy */ 74566);








 // connection







 //


const create = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create;

/***/ }),

/***/ 90263:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/async.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "async": () => (/* binding */ async)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 7996);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const async = _a => {
  var {
    width,
    height,
    offset,
    open,
    flip
  } = _a,
      attrs = __rest(_a, ["width", "height", "offset", "open", "flip"]);

  let h = height || 6;
  const w = width || 10;
  const opened = open === true;
  const fliped = flip === true;
  const result = Object.assign(Object.assign({}, attrs), {
    tagName: 'path'
  });

  if (fliped) {
    h = -h;
  }

  const path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
  path.moveTo(0, h).lineTo(w, 0);

  if (!opened) {
    path.lineTo(w, h);
    path.close();
  } else {
    result.fill = 'none';
  }

  result.d = (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(path.serialize(), {
    x: offset || -w / 2,
    y: h / 2
  });
  return result;
};

/***/ }),

/***/ 67804:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/circle.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circle": () => (/* binding */ circle),
/* harmony export */   "circlePlus": () => (/* binding */ circlePlus)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 7996);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const circle = _a => {
  var {
    r
  } = _a,
      attrs = __rest(_a, ["r"]);

  const radius = r || 5;
  return Object.assign(Object.assign({
    cx: radius
  }, attrs), {
    tagName: 'circle',
    r: radius
  });
};
const circlePlus = _a => {
  var {
    r
  } = _a,
      attrs = __rest(_a, ["r"]);

  const radius = r || 5;
  const path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
  path.moveTo(radius, 0).lineTo(radius, radius * 2);
  path.moveTo(0, radius).lineTo(radius * 2, radius);
  return {
    children: [Object.assign(Object.assign({}, circle({
      r: radius
    })), {
      fill: 'none'
    }), Object.assign(Object.assign({}, attrs), {
      tagName: 'path',
      d: (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(path.serialize(), -radius)
    })]
  };
};

/***/ }),

/***/ 31879:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/classic.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "block": () => (/* binding */ block),
/* harmony export */   "classic": () => (/* binding */ classic)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ 7996);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




const block = _a => {
  var {
    size,
    width,
    height,
    offset,
    open
  } = _a,
      attrs = __rest(_a, ["size", "width", "height", "offset", "open"]);

  return createClassicMarker({
    size,
    width,
    height,
    offset
  }, open === true, true, undefined, attrs);
};
const classic = _a => {
  var {
    size,
    width,
    height,
    offset,
    factor
  } = _a,
      attrs = __rest(_a, ["size", "width", "height", "offset", "factor"]);

  return createClassicMarker({
    size,
    width,
    height,
    offset
  }, false, false, factor, attrs);
};

function createClassicMarker(options, open, full, factor = 3 / 4, attrs = {}) {
  const size = options.size || 10;
  const width = options.width || size;
  const height = options.height || size;
  const path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
  const localAttrs = {};

  if (open) {
    path.moveTo(width, 0).lineTo(0, height / 2).lineTo(width, height);
    localAttrs.fill = 'none';
  } else {
    path.moveTo(0, height / 2);
    path.lineTo(width, 0);

    if (!full) {
      const f = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.clamp(factor, 0, 1);
      path.lineTo(width * f, height / 2);
    }

    path.lineTo(width, height);
    path.close();
  }

  return Object.assign(Object.assign(Object.assign({}, localAttrs), attrs), {
    tagName: 'path',
    d: (0,_util__WEBPACK_IMPORTED_MODULE_2__.normalize)(path.serialize(), {
      x: options.offset != null ? options.offset : -width / 2
    })
  });
}

/***/ }),

/***/ 20066:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/cross.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cross": () => (/* binding */ cross)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 7996);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const cross = _a => {
  var {
    size,
    width,
    height,
    offset
  } = _a,
      attrs = __rest(_a, ["size", "width", "height", "offset"]);

  const s = size || 10;
  const w = width || s;
  const h = height || s;
  const path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
  path.moveTo(0, 0).lineTo(w, h).moveTo(0, h).lineTo(w, 0);
  return Object.assign(Object.assign({}, attrs), {
    tagName: 'path',
    fill: 'none',
    d: (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(path.serialize(), offset || -w / 2)
  });
};

/***/ }),

/***/ 10169:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/diamond.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "diamond": () => (/* binding */ diamond)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 7996);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const diamond = _a => {
  var {
    size,
    width,
    height,
    offset
  } = _a,
      attrs = __rest(_a, ["size", "width", "height", "offset"]);

  const s = size || 10;
  const w = width || s;
  const h = height || s;
  const path = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
  path.moveTo(0, h / 2).lineTo(w / 2, 0).lineTo(w, h / 2).lineTo(w / 2, h).close();
  return Object.assign(Object.assign({}, attrs), {
    tagName: 'path',
    d: (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(path.serialize(), offset == null ? -w / 2 : offset)
  });
};

/***/ }),

/***/ 87203:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/ellipse.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ellipse": () => (/* binding */ ellipse)
/* harmony export */ });
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

const ellipse = _a => {
  var {
    rx,
    ry
  } = _a,
      attrs = __rest(_a, ["rx", "ry"]);

  const radiusX = rx || 5;
  const radiusy = ry || 5;
  return Object.assign(Object.assign({
    cx: radiusX
  }, attrs), {
    tagName: 'ellipse',
    rx: radiusX,
    ry: radiusy
  });
};

/***/ }),

/***/ 24541:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Marker": () => (/* binding */ Marker)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 4386);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ 7996);



var Marker;

(function (Marker) {
  Marker.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  Marker.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'marker'
  });
  Marker.registry.register(Marker.presets, true);
})(Marker || (Marker = {}));

(function (Marker) {
  Marker.normalize = _util__WEBPACK_IMPORTED_MODULE_2__.normalize;
})(Marker || (Marker = {}));

/***/ }),

/***/ 4386:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/main.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "async": () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_4__.async),
/* harmony export */   "block": () => (/* reexport safe */ _classic__WEBPACK_IMPORTED_MODULE_0__.block),
/* harmony export */   "circle": () => (/* reexport safe */ _circle__WEBPACK_IMPORTED_MODULE_5__.circle),
/* harmony export */   "circlePlus": () => (/* reexport safe */ _circle__WEBPACK_IMPORTED_MODULE_5__.circlePlus),
/* harmony export */   "classic": () => (/* reexport safe */ _classic__WEBPACK_IMPORTED_MODULE_0__.classic),
/* harmony export */   "cross": () => (/* reexport safe */ _cross__WEBPACK_IMPORTED_MODULE_3__.cross),
/* harmony export */   "diamond": () => (/* reexport safe */ _diamond__WEBPACK_IMPORTED_MODULE_1__.diamond),
/* harmony export */   "ellipse": () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_6__.ellipse),
/* harmony export */   "path": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_2__.path)
/* harmony export */ });
/* harmony import */ var _classic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classic */ 31879);
/* harmony import */ var _diamond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diamond */ 10169);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ 40504);
/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross */ 20066);
/* harmony import */ var _async__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./async */ 90263);
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./circle */ 67804);
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ellipse */ 87203);








/***/ }),

/***/ 40504:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/path.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "path": () => (/* binding */ path)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 7996);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


const path = _a => {
  var {
    d,
    offsetX,
    offsetY
  } = _a,
      attrs = __rest(_a, ["d", "offsetX", "offsetY"]);

  return Object.assign(Object.assign({}, attrs), {
    tagName: 'path',
    d: (0,_util__WEBPACK_IMPORTED_MODULE_0__.normalize)(d, offsetX, offsetY)
  });
};

/***/ }),

/***/ 7996:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalize": () => (/* binding */ normalize)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);

function normalize(d, offset1, offset2) {
  let offsetX;
  let offsetY;

  if (typeof offset1 === 'object') {
    offsetX = offset1.x;
    offsetY = offset1.y;
  } else {
    offsetX = offset1;
    offsetY = offset2;
  }

  const path = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(d);
  const bbox = path.bbox();

  if (bbox) {
    let ty = -bbox.height / 2 - bbox.y;
    let tx = -bbox.width / 2 - bbox.x;

    if (typeof offsetX === 'number') {
      tx -= offsetX;
    }

    if (typeof offsetY === 'number') {
      ty -= offsetY;
    }

    path.translate(tx, ty);
  }

  return path.serialize();
}

/***/ }),

/***/ 78943:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/bbox.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bottom": () => (/* binding */ bottom),
/* harmony export */   "bottomLeft": () => (/* binding */ bottomLeft),
/* harmony export */   "bottomRight": () => (/* binding */ bottomRight),
/* harmony export */   "center": () => (/* binding */ center),
/* harmony export */   "left": () => (/* binding */ left),
/* harmony export */   "right": () => (/* binding */ right),
/* harmony export */   "top": () => (/* binding */ top),
/* harmony export */   "topLeft": () => (/* binding */ topLeft),
/* harmony export */   "topRight": () => (/* binding */ topRight)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const center = createBBoxAnchor('center');
const top = createBBoxAnchor('topCenter');
const bottom = createBBoxAnchor('bottomCenter');
const left = createBBoxAnchor('leftMiddle');
const right = createBBoxAnchor('rightMiddle');
const topLeft = createBBoxAnchor('topLeft');
const topRight = createBBoxAnchor('topRight');
const bottomLeft = createBBoxAnchor('bottomLeft');
const bottomRight = createBBoxAnchor('bottomRight');

function createBBoxAnchor(method) {
  return function (view, magnet, ref, options = {}) {
    const bbox = options.rotate ? view.getUnrotatedBBoxOfElement(magnet) : view.getBBoxOfElement(magnet);
    const result = bbox[method];
    result.x += _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(options.dx, bbox.width);
    result.y += _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(options.dy, bbox.height);
    const cell = view.cell;
    return options.rotate ? result.rotate(-cell.getAngle(), cell.getBBox().getCenter()) : result;
  };
}

/***/ }),

/***/ 41005:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeAnchor": () => (/* binding */ NodeAnchor)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 3702);


var NodeAnchor;

(function (NodeAnchor) {
  NodeAnchor.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  NodeAnchor.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'node endpoint'
  });
  NodeAnchor.registry.register(NodeAnchor.presets, true);
})(NodeAnchor || (NodeAnchor = {}));

/***/ }),

/***/ 3702:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bottom": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.bottom),
/* harmony export */   "bottomLeft": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.bottomLeft),
/* harmony export */   "bottomRight": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.bottomRight),
/* harmony export */   "center": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.center),
/* harmony export */   "left": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.left),
/* harmony export */   "midSide": () => (/* reexport safe */ _middle_side__WEBPACK_IMPORTED_MODULE_3__.midSide),
/* harmony export */   "nodeCenter": () => (/* reexport safe */ _node_center__WEBPACK_IMPORTED_MODULE_2__.nodeCenter),
/* harmony export */   "orth": () => (/* reexport safe */ _orth__WEBPACK_IMPORTED_MODULE_1__.orth),
/* harmony export */   "right": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.right),
/* harmony export */   "top": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.top),
/* harmony export */   "topLeft": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.topLeft),
/* harmony export */   "topRight": () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.topRight)
/* harmony export */ });
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox */ 78943);
/* harmony import */ var _orth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orth */ 95477);
/* harmony import */ var _node_center__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node-center */ 34990);
/* harmony import */ var _middle_side__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./middle-side */ 30984);





/***/ }),

/***/ 30984:
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/middle-side.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "midSide": () => (/* binding */ midSide)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 4832);


const middleSide = function (view, magnet, refPoint, options) {
  let bbox;
  let angle = 0;
  let center;
  const node = view.cell;

  if (options.rotate) {
    bbox = view.getUnrotatedBBoxOfElement(magnet);
    center = node.getBBox().getCenter();
    angle = node.getAngle();
  } else {
    bbox = view.getBBoxOfElement(magnet);
  }

  const padding = options.padding;

  if (padding != null && Number.isFinite(padding)) {
    bbox.inflate(padding);
  }

  if (options.rotate) {
    refPoint.rotate(angle, center);
  }

  const side = bbox.getNearestSideToPoint(refPoint);
  let result;

  switch (side) {
    case 'left':
      result = bbox.getLeftMiddle();
      break;

    case 'right':
      result = bbox.getRightMiddle();
      break;

    case 'top':
      result = bbox.getTopCenter();
      break;

    case 'bottom':
      result = bbox.getBottomCenter();
      break;

    default:
      break;
  }

  const direction = options.direction;

  if (direction === 'H') {
    if (side === 'top' || side === 'bottom') {
      if (refPoint.x <= bbox.x + bbox.width) {
        result = bbox.getLeftMiddle();
      } else {
        result = bbox.getRightMiddle();
      }
    }
  } else if (direction === 'V') {
    if (refPoint.y <= bbox.y + bbox.height) {
      result = bbox.getTopCenter();
    } else {
      result = bbox.getBottomCenter();
    }
  }

  return options.rotate ? result.rotate(-angle, center) : result;
};
/**
 * Places the anchor of the edge in the middle of the side of view bbox
 * closest to the other endpoint.
 */


const midSide = (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(middleSide);

/***/ }),

/***/ 34990:
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/node-center.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nodeCenter": () => (/* binding */ nodeCenter)
/* harmony export */ });
/**
 * Places the anchor of the edge at center of the node bbox.
 */
const nodeCenter = function (view, magnet, ref, options, endType) {
  const result = view.cell.getConnectionPoint(this.cell, endType);

  if (options.dx || options.dy) {
    result.translate(options.dx || 0, options.dy || 0);
  }

  return result;
};

/***/ }),

/***/ 95477:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/orth.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "orth": () => (/* binding */ orth)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 4832);



const orthogonal = function (view, magnet, refPoint, options) {
  const angle = view.cell.getAngle();
  const bbox = view.getBBoxOfElement(magnet);
  const result = bbox.getCenter();
  const topLeft = bbox.getTopLeft();
  const bottomRight = bbox.getBottomRight();
  let padding = options.padding;

  if (!Number.isFinite(padding)) {
    padding = 0;
  }

  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {
    const dy = refPoint.y - result.y;
    result.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle));
    result.y += dy;
  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {
    const dx = refPoint.x - result.x;
    result.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle));
    result.x += dx;
  }

  return result;
};
/**
 * Tries to place the anchor of the edge inside the view bbox so that the
 * edge is made orthogonal. The anchor is placed along two line segments
 * inside the view bbox (between the centers of the top and bottom side and
 * between the centers of the left and right sides). If it is not possible
 * to place the anchor so that the edge would be orthogonal, the anchor is
 * placed at the center of the view bbox instead.
 */


const orth = (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolve)(orthogonal);

/***/ }),

/***/ 4832:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPointAtEdge": () => (/* binding */ getPointAtEdge),
/* harmony export */   "resolve": () => (/* binding */ resolve)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);

 // eslint-disable-next-line

function resolve(fn) {
  return function (view, magnet, ref, options) {
    if (ref instanceof Element) {
      const refView = this.graph.renderer.findViewByElem(ref);
      let refPoint;

      if (refView) {
        if (refView.isEdgeElement(ref)) {
          const distance = options.fixedAt != null ? options.fixedAt : '50%';
          refPoint = getPointAtEdge(refView, distance);
        } else {
          refPoint = refView.getBBoxOfElement(ref).getCenter();
        }
      } else {
        refPoint = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
      }

      return fn.call(this, view, magnet, refPoint, options);
    }

    return fn.apply(this, arguments); // eslint-disable-line
  };
}
function getPointAtEdge(edgeView, value) {
  const isPercentage = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(value);
  const num = typeof value === 'string' ? parseFloat(value) : value;

  if (isPercentage) {
    return edgeView.getPointAtRatio(num / 100);
  }

  return edgeView.getPointAtLength(num);
}

/***/ }),

/***/ 49443:
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PortLabelLayout": () => (/* binding */ PortLabelLayout)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 15758);


var PortLabelLayout;

(function (PortLabelLayout) {
  PortLabelLayout.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  PortLabelLayout.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'port label layout'
  });
  PortLabelLayout.registry.register(PortLabelLayout.presets, true);
})(PortLabelLayout || (PortLabelLayout = {}));

/***/ }),

/***/ 2175:
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/inout.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "inside": () => (/* binding */ inside),
/* harmony export */   "insideOriented": () => (/* binding */ insideOriented),
/* harmony export */   "outside": () => (/* binding */ outside),
/* harmony export */   "outsideOriented": () => (/* binding */ outsideOriented)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 10708);

const outside = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, false, args);
const outsideOriented = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, true, args);
const inside = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, false, args);
const insideOriented = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, true, args);

function outsideLayout(portPosition, elemBBox, autoOrient, args) {
  const offset = args.offset != null ? args.offset : 15;
  const angle = elemBBox.getCenter().theta(portPosition);
  const bboxAngles = getBBoxAngles(elemBBox);
  let y;
  let tx;
  let ty;
  let textAnchor;
  let orientAngle = 0;

  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
    y = '.3em';
    tx = offset;
    ty = 0;
    textAnchor = 'start';
  } else if (angle < bboxAngles[0]) {
    y = '0';
    tx = 0;
    ty = -offset;

    if (autoOrient) {
      orientAngle = -90;
      textAnchor = 'start';
    } else {
      textAnchor = 'middle';
    }
  } else if (angle < bboxAngles[3]) {
    y = '.3em';
    tx = -offset;
    ty = 0;
    textAnchor = 'end';
  } else {
    y = '.6em';
    tx = 0;
    ty = offset;

    if (autoOrient) {
      orientAngle = 90;
      textAnchor = 'start';
    } else {
      textAnchor = 'middle';
    }
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
    position: {
      x: Math.round(tx),
      y: Math.round(ty)
    },
    angle: orientAngle,
    attrs: {
      '.': {
        y,
        'text-anchor': textAnchor
      }
    }
  }, args);
}

function insideLayout(portPosition, elemBBox, autoOrient, args) {
  const offset = args.offset != null ? args.offset : 15;
  const angle = elemBBox.getCenter().theta(portPosition);
  const bboxAngles = getBBoxAngles(elemBBox);
  let y;
  let tx;
  let ty;
  let textAnchor;
  let orientAngle = 0;

  if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
    y = '.3em';
    tx = -offset;
    ty = 0;
    textAnchor = 'end';
  } else if (angle < bboxAngles[0]) {
    y = '.6em';
    tx = 0;
    ty = offset;

    if (autoOrient) {
      orientAngle = 90;
      textAnchor = 'start';
    } else {
      textAnchor = 'middle';
    }
  } else if (angle < bboxAngles[3]) {
    y = '.3em';
    tx = offset;
    ty = 0;
    textAnchor = 'start';
  } else {
    y = '0em';
    tx = 0;
    ty = -offset;

    if (autoOrient) {
      orientAngle = -90;
      textAnchor = 'start';
    } else {
      textAnchor = 'middle';
    }
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
    position: {
      x: Math.round(tx),
      y: Math.round(ty)
    },
    angle: orientAngle,
    attrs: {
      '.': {
        y,
        'text-anchor': textAnchor
      }
    }
  }, args);
}

function getBBoxAngles(elemBBox) {
  const center = elemBBox.getCenter();
  const tl = center.theta(elemBBox.getTopLeft());
  const bl = center.theta(elemBBox.getBottomLeft());
  const br = center.theta(elemBBox.getBottomRight());
  const tr = center.theta(elemBBox.getTopRight());
  return [tl, tr, br, bl];
}

/***/ }),

/***/ 15758:
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/main.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bottom": () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.bottom),
/* harmony export */   "inside": () => (/* reexport safe */ _inout__WEBPACK_IMPORTED_MODULE_1__.inside),
/* harmony export */   "insideOriented": () => (/* reexport safe */ _inout__WEBPACK_IMPORTED_MODULE_1__.insideOriented),
/* harmony export */   "left": () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.left),
/* harmony export */   "manual": () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.manual),
/* harmony export */   "outside": () => (/* reexport safe */ _inout__WEBPACK_IMPORTED_MODULE_1__.outside),
/* harmony export */   "outsideOriented": () => (/* reexport safe */ _inout__WEBPACK_IMPORTED_MODULE_1__.outsideOriented),
/* harmony export */   "radial": () => (/* reexport safe */ _radial__WEBPACK_IMPORTED_MODULE_2__.radial),
/* harmony export */   "radialOriented": () => (/* reexport safe */ _radial__WEBPACK_IMPORTED_MODULE_2__.radialOriented),
/* harmony export */   "right": () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.right),
/* harmony export */   "top": () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.top)
/* harmony export */ });
/* harmony import */ var _side__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./side */ 69537);
/* harmony import */ var _inout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inout */ 2175);
/* harmony import */ var _radial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radial */ 75066);




/***/ }),

/***/ 75066:
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/radial.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "radial": () => (/* binding */ radial),
/* harmony export */   "radialOriented": () => (/* binding */ radialOriented)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 10708);


const radial = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), false, args);
const radialOriented = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), true, args);

function radialLayout(portCenterOffset, autoOrient, args) {
  const offset = args.offset != null ? args.offset : 20;
  const origin = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
  const angle = -portCenterOffset.theta(origin);
  const pos = portCenterOffset.clone().move(origin, offset).diff(portCenterOffset).round();
  let y = '.3em';
  let textAnchor;
  let orientAngle = angle;

  if ((angle + 90) % 180 === 0) {
    textAnchor = autoOrient ? 'end' : 'middle';

    if (!autoOrient && angle === -270) {
      y = '0em';
    }
  } else if (angle > -270 && angle < -90) {
    textAnchor = 'start';
    orientAngle = angle - 180;
  } else {
    textAnchor = 'end';
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_1__.toResult)({
    position: pos.round().toJSON(),
    angle: autoOrient ? orientAngle : 0,
    attrs: {
      '.': {
        y,
        'text-anchor': textAnchor
      }
    }
  }, args);
}

/***/ }),

/***/ 69537:
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/side.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bottom": () => (/* binding */ bottom),
/* harmony export */   "left": () => (/* binding */ left),
/* harmony export */   "manual": () => (/* binding */ manual),
/* harmony export */   "right": () => (/* binding */ right),
/* harmony export */   "top": () => (/* binding */ top)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 10708);

const manual = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
  position: elemBBox.getTopLeft()
}, args);
const left = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
  position: {
    x: -15,
    y: 0
  },
  attrs: {
    '.': {
      y: '.3em',
      'text-anchor': 'end'
    }
  }
}, args);
const right = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
  position: {
    x: 15,
    y: 0
  },
  attrs: {
    '.': {
      y: '.3em',
      'text-anchor': 'start'
    }
  }
}, args);
const top = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
  position: {
    x: 0,
    y: -15
  },
  attrs: {
    '.': {
      'text-anchor': 'middle'
    }
  }
}, args);
const bottom = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
  position: {
    x: 0,
    y: 15
  },
  attrs: {
    '.': {
      y: '.6em',
      'text-anchor': 'middle'
    }
  }
}, args);

/***/ }),

/***/ 10708:
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/util.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toResult": () => (/* binding */ toResult)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

const defaults = {
  position: {
    x: 0,
    y: 0
  },
  angle: 0,
  attrs: {
    '.': {
      y: '0',
      'text-anchor': 'start'
    }
  }
};
function toResult(preset, args) {
  const {
    x,
    y,
    angle,
    attrs
  } = args || {};
  return _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.defaultsDeep({}, {
    angle,
    attrs,
    position: {
      x,
      y
    }
  }, preset, defaults);
}

/***/ }),

/***/ 28624:
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/absolute.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "absolute": () => (/* binding */ absolute)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 78749);

const absolute = (portsPositionArgs, elemBBox) => {
  return portsPositionArgs.map(({
    x,
    y,
    angle
  }) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)((0,_util__WEBPACK_IMPORTED_MODULE_0__.normalizePoint)(elemBBox, {
    x,
    y
  }), angle || 0));
};

/***/ }),

/***/ 61051:
/*!******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/ellipse.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ellipse": () => (/* binding */ ellipse),
/* harmony export */   "ellipseSpread": () => (/* binding */ ellipseSpread)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 78749);


const ellipse = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const startAngle = groupPositionArgs.start || 0;
  const stepAngle = groupPositionArgs.step || 20;
  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index, count) => (index + 0.5 - count / 2) * stepAngle);
};
const ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const startAngle = groupPositionArgs.start || 0;
  const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;
  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, index => {
    return index * stepAngle;
  });
};

function ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {
  const center = elemBBox.getCenter();
  const start = elemBBox.getTopCenter();
  const ratio = elemBBox.width / elemBBox.height;
  const ellipse = _geometry__WEBPACK_IMPORTED_MODULE_0__.Ellipse.fromRect(elemBBox);
  const count = portsPositionArgs.length;
  return portsPositionArgs.map((item, index) => {
    const angle = startAngle + stepFn(index, count);
    const p = start.clone().rotate(-angle, center).scale(ratio, 1, center);
    const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;

    if (item.dx || item.dy) {
      p.translate(item.dx || 0, item.dy || 0);
    }

    if (item.dr) {
      p.move(center, item.dr);
    }

    return (0,_util__WEBPACK_IMPORTED_MODULE_1__.toResult)(p.round(), theta, item);
  });
}

/***/ }),

/***/ 37425:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PortLayout": () => (/* binding */ PortLayout)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 5868);


var PortLayout;

(function (PortLayout) {
  PortLayout.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  PortLayout.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'port layout'
  });
  PortLayout.registry.register(PortLayout.presets, true);
})(PortLayout || (PortLayout = {}));

/***/ }),

/***/ 77663:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/line.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bottom": () => (/* binding */ bottom),
/* harmony export */   "left": () => (/* binding */ left),
/* harmony export */   "line": () => (/* binding */ line),
/* harmony export */   "right": () => (/* binding */ right),
/* harmony export */   "top": () => (/* binding */ top)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 78749);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const line = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  const start = (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalizePoint)(elemBBox, groupPositionArgs.start || elemBBox.getOrigin());
  const end = (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalizePoint)(elemBBox, groupPositionArgs.end || elemBBox.getCorner());
  return lineLayout(portsPositionArgs, start, end, groupPositionArgs);
};
const left = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getBottomLeft(), groupPositionArgs);
};
const right = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopRight(), elemBBox.getBottomRight(), groupPositionArgs);
};
const top = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getTopRight(), groupPositionArgs);
};
const bottom = (portsPositionArgs, elemBBox, groupPositionArgs) => {
  return lineLayout(portsPositionArgs, elemBBox.getBottomLeft(), elemBBox.getBottomRight(), groupPositionArgs);
};

function lineLayout(portsPositionArgs, p1, p2, groupPositionArgs) {
  const line = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(p1, p2);
  const length = portsPositionArgs.length;
  return portsPositionArgs.map((_a, index) => {
    var {
      strict
    } = _a,
        offset = __rest(_a, ["strict"]);

    const ratio = strict || groupPositionArgs.strict ? (index + 1) / (length + 1) : (index + 0.5) / length;
    const p = line.pointAt(ratio);

    if (offset.dx || offset.dy) {
      p.translate(offset.dx || 0, offset.dy || 0);
    }

    return (0,_util__WEBPACK_IMPORTED_MODULE_1__.toResult)(p.round(), 0, offset);
  });
}

/***/ }),

/***/ 5868:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "absolute": () => (/* reexport safe */ _absolute__WEBPACK_IMPORTED_MODULE_0__.absolute),
/* harmony export */   "bottom": () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.bottom),
/* harmony export */   "ellipse": () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_1__.ellipse),
/* harmony export */   "ellipseSpread": () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_1__.ellipseSpread),
/* harmony export */   "left": () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.left),
/* harmony export */   "line": () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.line),
/* harmony export */   "right": () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.right),
/* harmony export */   "top": () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.top)
/* harmony export */ });
/* harmony import */ var _absolute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./absolute */ 28624);
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ellipse */ 61051);
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ 77663);




/***/ }),

/***/ 78749:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizePoint": () => (/* binding */ normalizePoint),
/* harmony export */   "toResult": () => (/* binding */ toResult)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);


function normalizePoint(bbox, args = {}) {
  return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(_util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(args.x, bbox.width), _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(args.y, bbox.height));
}
function toResult(point, angle, rawArgs) {
  return Object.assign({
    angle,
    position: point.toJSON()
  }, rawArgs);
}

/***/ }),

/***/ 80618:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/registry.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Registry": () => (/* binding */ Registry)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);

class Registry {
  constructor(options) {
    this.options = Object.assign({}, options);
    this.data = this.options.data || {};
    this.register = this.register.bind(this);
    this.unregister = this.unregister.bind(this);
  }

  get names() {
    return Object.keys(this.data);
  }

  register(name, options, force = false) {
    if (typeof name === 'object') {
      Object.keys(name).forEach(key => {
        this.register(key, name[key], options);
      });
      return;
    }

    if (this.exist(name) && !force && !_util__WEBPACK_IMPORTED_MODULE_0__.Platform.isApplyingHMR()) {
      this.onDuplicated(name);
    }

    const process = this.options.process;
    const entity = process ? _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(process, this, name, options) : options;
    this.data[name] = entity;
    return entity;
  }

  unregister(name) {
    const entity = name ? this.data[name] : null;
    delete this.data[name];
    return entity;
  }

  get(name) {
    return name ? this.data[name] : null;
  }

  exist(name) {
    return name ? this.data[name] != null : false;
  }

  onDuplicated(name) {
    // eslint-disable-next-line no-useless-catch
    try {
      // race
      if (this.options.onConflict) {
        _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(this.options.onConflict, this, name);
      }

      throw new Error(`${_util__WEBPACK_IMPORTED_MODULE_0__.StringExt.upperFirst(this.options.type)} with name '${name}' already registered.`);
    } catch (err) {
      throw err;
    }
  }

  onNotFound(name, prefix) {
    throw new Error(this.getSpellingSuggestion(name, prefix));
  }

  getSpellingSuggestion(name, prefix) {
    const suggestion = this.getSpellingSuggestionForName(name);
    const prefixed = prefix ? `${prefix} ${_util__WEBPACK_IMPORTED_MODULE_0__.StringExt.lowerFirst(this.options.type)}` : this.options.type;
    return (// eslint-disable-next-line
      `${_util__WEBPACK_IMPORTED_MODULE_0__.StringExt.upperFirst(prefixed)} with name '${name}' does not exist.${suggestion ? ` Did you mean '${suggestion}'?` : ''}`
    );
  }

  getSpellingSuggestionForName(name) {
    return _util__WEBPACK_IMPORTED_MODULE_0__.StringExt.getSpellingSuggestion(name, Object.keys(this.data), candidate => candidate);
  }

}

(function (Registry) {
  function create(options) {
    return new Registry(options);
  }

  Registry.create = create;
})(Registry || (Registry = {}));

/***/ }),

/***/ 64362:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/er.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "er": () => (/* binding */ er)
/* harmony export */ });
const er = function (vertices, options, edgeView) {
  const offsetRaw = options.offset || 32;
  const min = options.min == null ? 16 : options.min;
  let offset = 0;
  let direction = options.direction;
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;
  const sourcePoint = sourceBBox.getCenter();
  const targetPoint = targetBBox.getCenter();

  if (typeof offsetRaw === 'number') {
    offset = offsetRaw;
  }

  if (direction == null) {
    let dx = targetBBox.left - sourceBBox.right;
    let dy = targetBBox.top - sourceBBox.bottom;

    if (dx >= 0 && dy >= 0) {
      direction = dx >= dy ? 'L' : 'T';
    } else if (dx <= 0 && dy >= 0) {
      dx = sourceBBox.left - targetBBox.right;

      if (dx >= 0) {
        direction = dx >= dy ? 'R' : 'T';
      } else {
        direction = 'T';
      }
    } else if (dx >= 0 && dy <= 0) {
      dy = sourceBBox.top - targetBBox.bottom;

      if (dy >= 0) {
        direction = dx >= dy ? 'L' : 'B';
      } else {
        direction = 'L';
      }
    } else {
      dx = sourceBBox.left - targetBBox.right;
      dy = sourceBBox.top - targetBBox.bottom;

      if (dx >= 0 && dy >= 0) {
        direction = dx >= dy ? 'R' : 'B';
      } else if (dx <= 0 && dy >= 0) {
        direction = 'B';
      } else if (dx >= 0 && dy <= 0) {
        direction = 'R';
      } else {
        direction = Math.abs(dx) > Math.abs(dy) ? 'R' : 'B';
      }
    }
  }

  if (direction === 'H') {
    direction = targetPoint.x - sourcePoint.x >= 0 ? 'L' : 'R';
  } else if (direction === 'V') {
    direction = targetPoint.y - sourcePoint.y >= 0 ? 'T' : 'B';
  }

  if (offsetRaw === 'center') {
    if (direction === 'L') {
      offset = (targetBBox.left - sourceBBox.right) / 2;
    } else if (direction === 'R') {
      offset = (sourceBBox.left - targetBBox.right) / 2;
    } else if (direction === 'T') {
      offset = (targetBBox.top - sourceBBox.bottom) / 2;
    } else if (direction === 'B') {
      offset = (sourceBBox.top - targetBBox.bottom) / 2;
    }
  }

  let coord;
  let dim;
  let factor;
  const horizontal = direction === 'L' || direction === 'R';

  if (horizontal) {
    if (targetPoint.y === sourcePoint.y) {
      return [...vertices];
    }

    factor = direction === 'L' ? 1 : -1;
    coord = 'x';
    dim = 'width';
  } else {
    if (targetPoint.x === sourcePoint.x) {
      return [...vertices];
    }

    factor = direction === 'T' ? 1 : -1;
    coord = 'y';
    dim = 'height';
  }

  const source = sourcePoint.clone();
  const target = targetPoint.clone();
  source[coord] += factor * (sourceBBox[dim] / 2 + offset);
  target[coord] -= factor * (targetBBox[dim] / 2 + offset);

  if (horizontal) {
    const sourceX = source.x;
    const targetX = target.x;
    const sourceDelta = sourceBBox.width / 2 + min;
    const targetDelta = targetBBox.width / 2 + min;

    if (targetPoint.x > sourcePoint.x) {
      if (targetX <= sourceX) {
        source.x = Math.max(targetX, sourcePoint.x + sourceDelta);
        target.x = Math.min(sourceX, targetPoint.x - targetDelta);
      }
    } else if (targetX >= sourceX) {
      source.x = Math.min(targetX, sourcePoint.x - sourceDelta);
      target.x = Math.max(sourceX, targetPoint.x + targetDelta);
    }
  } else {
    const sourceY = source.y;
    const targetY = target.y;
    const sourceDelta = sourceBBox.height / 2 + min;
    const targetDelta = targetBBox.height / 2 + min;

    if (targetPoint.y > sourcePoint.y) {
      if (targetY <= sourceY) {
        source.y = Math.max(targetY, sourcePoint.y + sourceDelta);
        target.y = Math.min(sourceY, targetPoint.y - targetDelta);
      }
    } else if (targetY >= sourceY) {
      source.y = Math.min(targetY, sourcePoint.y - sourceDelta);
      target.y = Math.max(sourceY, targetPoint.y + targetDelta);
    }
  }

  return [source.toJSON(), ...vertices, target.toJSON()];
};

/***/ }),

/***/ 49255:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Router": () => (/* binding */ Router)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ 66217);


var Router;

(function (Router) {
  Router.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
  Router.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'router'
  });
  Router.registry.register(Router.presets, true);
})(Router || (Router = {}));

/***/ }),

/***/ 36938:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/loop.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loop": () => (/* binding */ loop)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);


function rollup(points, merge) {
  if (merge != null && merge !== false) {
    const amount = typeof merge === 'boolean' ? 0 : merge;

    if (amount > 0) {
      const center1 = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(points[1]).move(points[2], amount);
      const center2 = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(points[1]).move(points[0], amount);
      return [center1.toJSON(), ...points, center2.toJSON()];
    }

    {
      const center = points[1];
      return [Object.assign({}, center), ...points, Object.assign({}, center)];
    }
  }

  return points;
}

const loop = function (vertices, options, edgeView) {
  const width = options.width || 50;
  const height = options.height || 80;
  const halfHeight = height / 2;
  const angle = options.angle || 'auto';
  const sourceAnchor = edgeView.sourceAnchor;
  const targetAnchor = edgeView.targetAnchor;
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;

  if (sourceAnchor.equals(targetAnchor)) {
    const getVertices = angle => {
      const rad = _geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle);
      const sin = Math.sin(rad);
      const cos = Math.cos(rad);
      const center = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);
      const ref = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(center.x - cos * halfHeight, center.y - sin * halfHeight);
      const p1 = ref.clone().rotate(-90, center);
      const p2 = ref.clone().rotate(90, center);
      return [p1.toJSON(), center.toJSON(), p2.toJSON()];
    };

    const validate = end => {
      const start = sourceAnchor.clone().move(end, -1);
      const line = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(start, end);
      return !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line);
    };

    const angles = [0, 90, 180, 270, 45, 135, 225, 315];

    if (typeof angle === 'number') {
      return rollup(getVertices(angle), options.merge);
    }

    const center = sourceBBox.getCenter();

    if (center.equals(sourceAnchor)) {
      return rollup(getVertices(0), options.merge);
    }

    const deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));
    let ret = getVertices(deg);

    if (validate(ret[1])) {
      return rollup(ret, options.merge);
    } // return the best vertices


    for (let i = 1, l = angles.length; i < l; i += 1) {
      ret = getVertices(deg + angles[i]);

      if (validate(ret[1])) {
        return rollup(ret, options.merge);
      }
    }

    return rollup(ret, options.merge);
  }

  {
    const line = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(sourceAnchor, targetAnchor);
    let parallel = line.parallel(-width);
    let center = parallel.getCenter();
    let p1 = parallel.start.clone().move(parallel.end, halfHeight);
    let p2 = parallel.end.clone().move(parallel.start, halfHeight);
    const ref = line.parallel(-1);
    const line1 = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(ref.start, center);
    const line2 = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(ref.end, center);

    if (sourceBBox.containsPoint(center) || targetBBox.containsPoint(center) || sourceBBox.intersectsWithLine(line1) || sourceBBox.intersectsWithLine(line2) || targetBBox.intersectsWithLine(line1) || targetBBox.intersectsWithLine(line2)) {
      parallel = line.parallel(width);
      center = parallel.getCenter();
      p1 = parallel.start.clone().move(parallel.end, halfHeight);
      p2 = parallel.end.clone().move(parallel.start, halfHeight);
    }

    if (options.merge) {
      const line = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(sourceAnchor, targetAnchor);
      const normal = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(center, line.center).setLength(Number.MAX_SAFE_INTEGER);
      const intersects1 = sourceBBox.intersectsWithLine(normal);
      const intersects2 = targetBBox.intersectsWithLine(normal);
      const intersects = intersects1 ? Array.isArray(intersects1) ? intersects1 : [intersects1] : [];

      if (intersects2) {
        if (Array.isArray(intersects2)) {
          intersects.push(...intersects2);
        } else {
          intersects.push(intersects2);
        }
      }

      const anchor = line.center.closest(intersects);

      if (anchor) {
        edgeView.sourceAnchor = anchor.clone();
        edgeView.targetAnchor = anchor.clone();
      } else {
        edgeView.sourceAnchor = line.center.clone();
        edgeView.targetAnchor = line.center.clone();
      }
    }

    return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge);
  }
};

/***/ }),

/***/ 66217:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/main.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "er": () => (/* reexport safe */ _er__WEBPACK_IMPORTED_MODULE_5__.er),
/* harmony export */   "loop": () => (/* reexport safe */ _loop__WEBPACK_IMPORTED_MODULE_6__.loop),
/* harmony export */   "manhattan": () => (/* reexport safe */ _manhattan_index__WEBPACK_IMPORTED_MODULE_4__.manhattan),
/* harmony export */   "metro": () => (/* reexport safe */ _metro__WEBPACK_IMPORTED_MODULE_3__.metro),
/* harmony export */   "normal": () => (/* reexport safe */ _normal__WEBPACK_IMPORTED_MODULE_0__.normal),
/* harmony export */   "oneSide": () => (/* reexport safe */ _oneside__WEBPACK_IMPORTED_MODULE_1__.oneSide),
/* harmony export */   "orth": () => (/* reexport safe */ _orth__WEBPACK_IMPORTED_MODULE_2__.orth)
/* harmony export */ });
/* harmony import */ var _normal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normal */ 83978);
/* harmony import */ var _oneside__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./oneside */ 22418);
/* harmony import */ var _orth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orth */ 44240);
/* harmony import */ var _metro__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metro */ 65924);
/* harmony import */ var _manhattan_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./manhattan/index */ 18754);
/* harmony import */ var _er__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./er */ 64362);
/* harmony import */ var _loop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loop */ 36938);








/***/ }),

/***/ 18754:
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "manhattan": () => (/* binding */ manhattan)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ 44650);
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router */ 40597);
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options */ 23878);



const manhattan = function (vertices, options, edgeView) {
  return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_router__WEBPACK_IMPORTED_MODULE_1__.router, this, vertices, Object.assign(Object.assign({}, _options__WEBPACK_IMPORTED_MODULE_2__.defaults), options), edgeView);
};

/***/ }),

/***/ 64746:
/*!****************************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/obstacle-map.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObstacleMap": () => (/* binding */ ObstacleMap)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry */ 17653);


/**
 * Helper structure to identify whether a point lies inside an obstacle.
 */

class ObstacleMap {
  constructor(options) {
    this.options = options;
    this.mapGridSize = 100;
    this.map = {};
  }
  /**
   * Builds a map of all nodes for quicker obstacle queries i.e. is a point
   * contained in any obstacle?
   *
   * A simplified grid search.
   */


  build(model, edge) {
    const options = this.options; // source or target node could be excluded from set of obstacles

    const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {
      const terminal = edge[type];

      if (terminal) {
        const cell = model.getCell(terminal.cell);

        if (cell) {
          memo.push(cell);
        }
      }

      return memo;
    }, []);
    let excludedAncestors = [];
    const source = model.getCell(edge.getSourceCellId());

    if (source) {
      excludedAncestors = _util__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.union(excludedAncestors, source.getAncestors().map(cell => cell.id));
    }

    const target = model.getCell(edge.getTargetCellId());

    if (target) {
      excludedAncestors = _util__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.union(excludedAncestors, target.getAncestors().map(cell => cell.id));
    } // The graph is divided into smaller cells, where each holds information
    // about which node belong to it. When we query whether a point lies
    // inside an obstacle we don't need to go through all obstacles, we check
    // only those in a particular cell.


    const mapGridSize = this.mapGridSize;
    model.getNodes().reduce((map, node) => {
      const shape = node.shape;
      const excludeShapes = options.excludeShapes;
      const excType = shape ? excludeShapes.includes(shape) : false;
      const excTerminal = excludedTerminals.some(cell => cell.id === node.id);
      const excNode = options.excludeNodes.includes(node);
      const excAncestor = excludedAncestors.includes(node.id);
      const excHidden = options.excludeHiddenNodes && !node.isVisible();
      const excluded = excType || excTerminal || excNode || excAncestor || excHidden;

      if (!excluded) {
        const bbox = node.getBBox().moveAndExpand(options.paddingBox);
        const origin = bbox.getOrigin().snapToGrid(mapGridSize);
        const corner = bbox.getCorner().snapToGrid(mapGridSize);

        for (let x = origin.x; x <= corner.x; x += mapGridSize) {
          for (let y = origin.y; y <= corner.y; y += mapGridSize) {
            const key = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y).toString();

            if (map[key] == null) {
              map[key] = [];
            }

            map[key].push(bbox);
          }
        }
      }

      return map;
    }, this.map);
    return this;
  }

  isAccessible(point) {
    const key = point.clone().snapToGrid(this.mapGridSize).toString();
    const rects = this.map[key];
    return rects ? rects.every(rect => !rect.containsPoint(point)) : true;
  }

}

/***/ }),

/***/ 23878:
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/options.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaults": () => (/* binding */ defaults),
/* harmony export */   "resolve": () => (/* binding */ resolve),
/* harmony export */   "resolveOptions": () => (/* binding */ resolveOptions)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry */ 17653);
/* harmony import */ var _orth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../orth */ 44240);



const defaults = {
  step: 10,
  maxLoopCount: 2000,
  precision: 1,
  maxDirectionChange: 90,
  perpendicular: true,
  excludeTerminals: [],
  excludeShapes: [],
  excludeNodes: [],
  excludeHiddenNodes: false,
  startDirections: ['top', 'right', 'bottom', 'left'],
  endDirections: ['top', 'right', 'bottom', 'left'],
  directionMap: {
    top: {
      x: 0,
      y: -1
    },
    right: {
      x: 1,
      y: 0
    },
    bottom: {
      x: 0,
      y: 1
    },
    left: {
      x: -1,
      y: 0
    }
  },

  cost() {
    const step = resolve(this.step, this);
    return step;
  },

  directions() {
    const step = resolve(this.step, this);
    const cost = resolve(this.cost, this);
    return [{
      cost,
      offsetX: step,
      offsetY: 0
    }, {
      cost,
      offsetX: -step,
      offsetY: 0
    }, {
      cost,
      offsetX: 0,
      offsetY: step
    }, {
      cost,
      offsetX: 0,
      offsetY: -step
    }];
  },

  penalties() {
    const step = resolve(this.step, this);
    return {
      0: 0,
      45: step / 2,
      90: step / 2
    };
  },

  paddingBox() {
    const step = resolve(this.step, this);
    return {
      x: -step,
      y: -step,
      width: 2 * step,
      height: 2 * step
    };
  },

  fallbackRouter: _orth__WEBPACK_IMPORTED_MODULE_2__.orth,
  draggingRouter: null
};
function resolve(input, options) {
  if (typeof input === 'function') {
    return input.call(options);
  }

  return input;
}
function resolveOptions(options) {
  const result = Object.keys(options).reduce((memo, key) => {
    const ret = memo;

    if (key === 'fallbackRouter' || key === 'draggingRouter' || key === 'fallbackRoute') {
      ret[key] = options[key];
    } else {
      ret[key] = resolve(options[key], options);
    }

    return memo;
  }, {});

  if (result.padding) {
    const sides = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(result.padding);
    result.paddingBox = {
      x: -sides.left,
      y: -sides.top,
      width: sides.left + sides.right,
      height: sides.top + sides.bottom
    };
  }

  result.directions.forEach(direction => {
    const point1 = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0);
    const point2 = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(direction.offsetX, direction.offsetY);
    direction.angle = _geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(point1.theta(point2));
  });
  return result;
}

/***/ }),

/***/ 40597:
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/router.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "router": () => (/* binding */ router)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry */ 17653);
/* harmony import */ var _sorted_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sorted-set */ 53855);
/* harmony import */ var _obstacle_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./obstacle-map */ 64746);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ 69598);
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./options */ 23878);






/**
 * Finds the route between two points (`from`, `to`).
 */

function findRoute(edgeView, from, to, map, options) {
  const precision = options.precision;
  let sourceEndpoint;
  let targetEndpoint;

  if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(from)) {
    sourceEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.round(_util__WEBPACK_IMPORTED_MODULE_4__.getSourceEndpoint(edgeView, options).clone(), precision);
  } else {
    sourceEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.round(from.clone(), precision);
  }

  if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(to)) {
    targetEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.round(_util__WEBPACK_IMPORTED_MODULE_4__.getTargetEndpoint(edgeView, options).clone(), precision);
  } else {
    targetEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.round(to.clone(), precision);
  } // Get grid for this route.


  const grid = _util__WEBPACK_IMPORTED_MODULE_4__.getGrid(options.step, sourceEndpoint, targetEndpoint); // Get pathfinding points.
  // -----------------------

  const startPoint = sourceEndpoint;
  const endPoint = targetEndpoint;
  let startPoints;
  let endPoints;

  if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(from)) {
    startPoints = _util__WEBPACK_IMPORTED_MODULE_4__.getRectPoints(startPoint, from, options.startDirections, grid, options);
  } else {
    startPoints = [startPoint];
  }

  if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(to)) {
    endPoints = _util__WEBPACK_IMPORTED_MODULE_4__.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);
  } else {
    endPoints = [endPoint];
  } // take into account only accessible rect points (those not under obstacles)


  startPoints = startPoints.filter(p => map.isAccessible(p));
  endPoints = endPoints.filter(p => map.isAccessible(p)); // There is an accessible route point on both sides.

  if (startPoints.length > 0 && endPoints.length > 0) {
    const openSet = new _sorted_set__WEBPACK_IMPORTED_MODULE_2__.SortedSet(); // Keeps the actual points for given nodes of the open set.

    const points = {}; // Keeps the point that is immediate predecessor of given element.

    const parents = {}; // Cost from start to a point along best known path.

    const costs = {};

    for (let i = 0, n = startPoints.length; i < n; i += 1) {
      // startPoint is assumed to be aligned already
      const startPoint = startPoints[i];
      const key = _util__WEBPACK_IMPORTED_MODULE_4__.getKey(startPoint);
      openSet.add(key, _util__WEBPACK_IMPORTED_MODULE_4__.getCost(startPoint, endPoints));
      points[key] = startPoint;
      costs[key] = 0;
    }

    const previousRouteDirectionAngle = options.previousDirectionAngle; // undefined for first route

    const isPathBeginning = previousRouteDirectionAngle === undefined; // directions

    let direction;
    let directionChange;
    const directions = _util__WEBPACK_IMPORTED_MODULE_4__.getGridOffsets(grid, options);
    const numDirections = directions.length;
    const endPointsKeys = endPoints.reduce((res, endPoint) => {
      const key = _util__WEBPACK_IMPORTED_MODULE_4__.getKey(endPoint);
      res.push(key);
      return res;
    }, []); // main route finding loop

    const sameStartEndPoints = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.equalPoints(startPoints, endPoints);
    let loopsRemaining = options.maxLoopCount;

    while (!openSet.isEmpty() && loopsRemaining > 0) {
      // Get the closest item and mark it CLOSED
      const currentKey = openSet.pop();
      const currentPoint = points[currentKey];
      const currentParent = parents[currentKey];
      const currentCost = costs[currentKey];
      const isStartPoint = currentPoint.equals(startPoint);
      const isRouteBeginning = currentParent == null;
      let previousDirectionAngle;

      if (!isRouteBeginning) {
        previousDirectionAngle = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);
      } else if (!isPathBeginning) {
        // a vertex on the route
        previousDirectionAngle = previousRouteDirectionAngle;
      } else if (!isStartPoint) {
        // beginning of route on the path
        previousDirectionAngle = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);
      } else {
        previousDirectionAngle = null;
      } // Check if we reached any endpoint


      const skipEndCheck = isRouteBeginning && sameStartEndPoints;

      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
        options.previousDirectionAngle = previousDirectionAngle;
        return _util__WEBPACK_IMPORTED_MODULE_4__.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);
      } // Go over all possible directions and find neighbors


      for (let i = 0; i < numDirections; i += 1) {
        direction = directions[i];
        const directionAngle = direction.angle;
        directionChange = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionChange(previousDirectionAngle, directionAngle); // Don't use the point changed rapidly.

        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {
          continue;
        }

        const neighborPoint = _util__WEBPACK_IMPORTED_MODULE_4__.align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);
        const neighborKey = _util__WEBPACK_IMPORTED_MODULE_4__.getKey(neighborPoint); // Closed points were already evaluated.

        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {
          continue;
        } // Neighbor is an end point.


        if (endPointsKeys.indexOf(neighborKey) >= 0) {
          const isEndPoint = neighborPoint.equals(endPoint);

          if (!isEndPoint) {
            const endDirectionAngle = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);
            const endDirectionChange = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionChange(directionAngle, endDirectionAngle);

            if (endDirectionChange > options.maxDirectionChange) {
              continue;
            }
          }
        } // The current direction is ok.
        // ----------------------------


        const neighborCost = direction.cost;
        const neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];
        const costFromStart = currentCost + neighborCost + neighborPenalty; // Neighbor point has not been processed yet or the cost of
        // the path from start is lower than previously calculated.

        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
          points[neighborKey] = neighborPoint;
          parents[neighborKey] = currentPoint;
          costs[neighborKey] = costFromStart;
          openSet.add(neighborKey, costFromStart + _util__WEBPACK_IMPORTED_MODULE_4__.getCost(neighborPoint, endPoints));
        }
      }

      loopsRemaining -= 1;
    }
  }

  if (options.fallbackRoute) {
    return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);
  }

  return null;
}

const router = function (vertices, optionsRaw, edgeView) {
  const options = (0,_options__WEBPACK_IMPORTED_MODULE_5__.resolveOptions)(optionsRaw);
  const sourceBBox = _util__WEBPACK_IMPORTED_MODULE_4__.getSourceBBox(edgeView, options);
  const targetBBox = _util__WEBPACK_IMPORTED_MODULE_4__.getTargetBBox(edgeView, options);
  const sourceEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.getSourceEndpoint(edgeView, options); // pathfinding

  const map = new _obstacle_map__WEBPACK_IMPORTED_MODULE_3__.ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);
  const oldVertices = vertices.map(p => _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(p));
  const newVertices = []; // The origin of first route's grid, does not need snapping

  let tailPoint = sourceEndpoint;
  let from;
  let to;

  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {
    let partialRoute = null;
    from = to || sourceBBox;
    to = oldVertices[i]; // This is the last iteration

    if (to == null) {
      to = targetBBox; // If the target is a point, we should use dragging route
      // instead of main routing method if it has been provided.

      const edge = edgeView.cell;
      const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;

      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {
        const dragFrom = from === sourceBBox ? sourceEndpoint : from;
        const dragTo = to.getOrigin();
        partialRoute = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);
      }
    } // Find the partial route


    if (partialRoute == null) {
      partialRoute = findRoute(edgeView, from, to, map, options);
    } // Cannot found the partial route.


    if (partialRoute === null) {
      return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);
    } // Remove the first point if the previous partial route has
    // the same point as last.


    const leadPoint = partialRoute[0];

    if (leadPoint && leadPoint.equals(tailPoint)) {
      partialRoute.shift();
    } // Save tailPoint for next iteration


    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
    newVertices.push(...partialRoute);
  }

  return newVertices;
};

/***/ }),

/***/ 53855:
/*!**************************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/sorted-set.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SortedSet": () => (/* binding */ SortedSet)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ 44650);

const OPEN = 1;
const CLOSE = 2;
class SortedSet {
  constructor() {
    this.items = [];
    this.hash = {};
    this.values = {};
  }

  add(item, value) {
    if (this.hash[item]) {
      // item removal
      this.items.splice(this.items.indexOf(item), 1);
    } else {
      this.hash[item] = OPEN;
    }

    this.values[item] = value;
    const index = _util__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortedIndexBy(this.items, item, key => this.values[key]);
    this.items.splice(index, 0, item);
  }

  pop() {
    const item = this.items.shift();

    if (item) {
      this.hash[item] = CLOSE;
    }

    return item;
  }

  isOpen(item) {
    return this.hash[item] === OPEN;
  }

  isClose(item) {
    return this.hash[item] === CLOSE;
  }

  isEmpty() {
    return this.items.length === 0;
  }

}

/***/ }),

/***/ 69598:
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "align": () => (/* binding */ align),
/* harmony export */   "getCost": () => (/* binding */ getCost),
/* harmony export */   "getDirectionAngle": () => (/* binding */ getDirectionAngle),
/* harmony export */   "getDirectionChange": () => (/* binding */ getDirectionChange),
/* harmony export */   "getGrid": () => (/* binding */ getGrid),
/* harmony export */   "getGridOffsets": () => (/* binding */ getGridOffsets),
/* harmony export */   "getKey": () => (/* binding */ getKey),
/* harmony export */   "getRectPoints": () => (/* binding */ getRectPoints),
/* harmony export */   "getSourceBBox": () => (/* binding */ getSourceBBox),
/* harmony export */   "getSourceEndpoint": () => (/* binding */ getSourceEndpoint),
/* harmony export */   "getTargetBBox": () => (/* binding */ getTargetBBox),
/* harmony export */   "getTargetEndpoint": () => (/* binding */ getTargetEndpoint),
/* harmony export */   "normalizePoint": () => (/* binding */ normalizePoint),
/* harmony export */   "reconstructRoute": () => (/* binding */ reconstructRoute),
/* harmony export */   "round": () => (/* binding */ round)
/* harmony export */ });
/* harmony import */ var _global_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../global/util */ 40106);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../geometry */ 17653);


function getSourceBBox(view, options) {
  const bbox = view.sourceBBox.clone();

  if (options && options.paddingBox) {
    return bbox.moveAndExpand(options.paddingBox);
  }

  return bbox;
}
function getTargetBBox(view, options) {
  const bbox = view.targetBBox.clone();

  if (options && options.paddingBox) {
    return bbox.moveAndExpand(options.paddingBox);
  }

  return bbox;
}
function getSourceEndpoint(view, options) {
  if (view.sourceAnchor) {
    return view.sourceAnchor;
  }

  const sourceBBox = getSourceBBox(view, options);
  return sourceBBox.getCenter();
}
function getTargetEndpoint(view, options) {
  if (view.targetAnchor) {
    return view.targetAnchor;
  }

  const targetBBox = getTargetBBox(view, options);
  return targetBBox.getCenter();
} // returns a direction index from start point to end point
// corrects for grid deformation between start and end

function getDirectionAngle(start, end, directionCount, grid, options) {
  const quadrant = 360 / directionCount;
  const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));
  const normalizedAngle = _geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(angleTheta + quadrant / 2);
  return quadrant * Math.floor(normalizedAngle / quadrant);
}

function fixAngleEnd(start, end, grid, options) {
  const step = options.step;
  const diffX = end.x - start.x;
  const diffY = end.y - start.y;
  const gridStepsX = diffX / grid.x;
  const gridStepsY = diffY / grid.y;
  const distanceX = gridStepsX * step;
  const distanceY = gridStepsY * step;
  return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(start.x + distanceX, start.y + distanceY);
}
/**
 * Returns the change in direction between two direction angles.
 */


function getDirectionChange(angle1, angle2) {
  const change = Math.abs(angle1 - angle2);
  return change > 180 ? 360 - change : change;
} // fix direction offsets according to current grid

function getGridOffsets(grid, options) {
  const step = options.step;
  options.directions.forEach(direction => {
    direction.gridOffsetX = direction.offsetX / step * grid.x;
    direction.gridOffsetY = direction.offsetY / step * grid.y;
  });
  return options.directions;
} // get grid size in x and y dimensions, adapted to source and target positions

function getGrid(step, source, target) {
  return {
    source: source.clone(),
    x: getGridDimension(target.x - source.x, step),
    y: getGridDimension(target.y - source.y, step)
  };
}

function getGridDimension(diff, step) {
  // return step if diff = 0
  if (!diff) {
    return step;
  }

  const abs = Math.abs(diff);
  const count = Math.round(abs / step); // return `abs` if less than one step apart

  if (!count) {
    return abs;
  } // otherwise, return corrected step


  const roundedDiff = count * step;
  const remainder = abs - roundedDiff;
  const correction = remainder / count;
  return step + correction;
}

function snapGrid(point, grid) {
  const source = grid.source;
  const x = _global_util__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(point.x - source.x, grid.x) + source.x;
  const y = _global_util__WEBPACK_IMPORTED_MODULE_0__.Util.snapToGrid(point.y - source.y, grid.y) + source.y;
  return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y);
}

function round(point, precision) {
  return point.round(precision);
}
function align(point, grid, precision) {
  return round(snapGrid(point.clone(), grid), precision);
}
function getKey(point) {
  return point.toString();
}
function normalizePoint(point) {
  return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
function getCost(from, anchors) {
  let min = Infinity;

  for (let i = 0, len = anchors.length; i < len; i += 1) {
    const dist = from.manhattanDistance(anchors[i]);

    if (dist < min) {
      min = dist;
    }
  }

  return min;
} // Find points around the bbox taking given directions into account
// lines are drawn from anchor in given directions, intersections recorded
// if anchor is outside bbox, only those directions that intersect get a rect point
// the anchor itself is returned as rect point (representing some directions)
// (since those directions are unobstructed by the bbox)

function getRectPoints(anchor, bbox, directionList, grid, options) {
  const precision = options.precision;
  const directionMap = options.directionMap;
  const centerVector = anchor.diff(bbox.getCenter());
  const rectPoints = Object.keys(directionMap).reduce((res, key) => {
    if (directionList.includes(key)) {
      const direction = directionMap[key]; // Create a line that is guaranteed to intersect the bbox if bbox
      // is in the direction even if anchor lies outside of bbox.

      const ending = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));
      const intersectionLine = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Line(anchor, ending); // Get the farther intersection, in case there are two
      // (that happens if anchor lies next to bbox)

      const intersections = intersectionLine.intersect(bbox) || [];
      let farthestIntersectionDistance;
      let farthestIntersection = null;

      for (let i = 0; i < intersections.length; i += 1) {
        const intersection = intersections[i];
        const distance = anchor.squaredDistance(intersection);

        if (farthestIntersectionDistance == null || distance > farthestIntersectionDistance) {
          farthestIntersectionDistance = distance;
          farthestIntersection = intersection;
        }
      } // If an intersection was found in this direction, it is our rectPoint


      if (farthestIntersection) {
        let target = align(farthestIntersection, grid, precision); // If the rectPoint lies inside the bbox, offset it by one more step

        if (bbox.containsPoint(target)) {
          target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);
        }

        res.push(target);
      }
    }

    return res;
  }, []); // if anchor lies outside of bbox, add it to the array of points

  if (!bbox.containsPoint(anchor)) {
    rectPoints.push(align(anchor, grid, precision));
  }

  return rectPoints;
} // reconstructs a route by concatenating points with their parents

function reconstructRoute(parents, points, tailPoint, from, to) {
  const route = [];
  let prevDiff = normalizePoint(to.diff(tailPoint)); // tailPoint is assumed to be aligned already

  let currentKey = getKey(tailPoint);
  let parent = parents[currentKey];
  let point;

  while (parent) {
    // point is assumed to be aligned already
    point = points[currentKey];
    const diff = normalizePoint(point.diff(parent));

    if (!diff.equals(prevDiff)) {
      route.unshift(point);
      prevDiff = diff;
    } // parent is assumed to be aligned already


    currentKey = getKey(parent);
    parent = parents[currentKey];
  } // leadPoint is assumed to be aligned already


  const leadPoint = points[currentKey];
  const fromDiff = normalizePoint(leadPoint.diff(from));

  if (!fromDiff.equals(prevDiff)) {
    route.unshift(leadPoint);
  }

  return route;
}

/***/ }),

/***/ 65924:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/metro.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "metro": () => (/* binding */ metro)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _manhattan_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./manhattan/options */ 23878);
/* harmony import */ var _manhattan_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manhattan/index */ 18754);




const defaults = {
  maxDirectionChange: 45,

  // an array of directions to find next points on the route
  // different from start/end directions
  directions() {
    const step = (0,_manhattan_options__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.step, this);
    const cost = (0,_manhattan_options__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.cost, this);
    const diagonalCost = Math.ceil(Math.sqrt(step * step << 1)); // eslint-disable-line no-bitwise

    return [{
      cost,
      offsetX: step,
      offsetY: 0
    }, {
      cost: diagonalCost,
      offsetX: step,
      offsetY: step
    }, {
      cost,
      offsetX: 0,
      offsetY: step
    }, {
      cost: diagonalCost,
      offsetX: -step,
      offsetY: step
    }, {
      cost,
      offsetX: -step,
      offsetY: 0
    }, {
      cost: diagonalCost,
      offsetX: -step,
      offsetY: -step
    }, {
      cost,
      offsetX: 0,
      offsetY: -step
    }, {
      cost: diagonalCost,
      offsetX: step,
      offsetY: -step
    }];
  },

  // a simple route used in situations when main routing method fails
  // (exceed max number of loop iterations, inaccessible)
  fallbackRoute(from, to, options) {
    // Find a route which breaks by 45 degrees ignoring all obstacles.
    const theta = from.theta(to);
    const route = [];
    let a = {
      x: to.x,
      y: from.y
    };
    let b = {
      x: from.x,
      y: to.y
    };

    if (theta % 180 > 90) {
      const t = a;
      a = b;
      b = t;
    }

    const p1 = theta % 90 < 45 ? a : b;
    const l1 = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Line(from, p1);
    const alpha = 90 * Math.ceil(theta / 90);
    const p2 = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(l1.squaredLength(), _geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(alpha + 135), p1);
    const l2 = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Line(to, p2);
    const intersectionPoint = l1.intersectsWithLine(l2);
    const point = intersectionPoint || to;
    const directionFrom = intersectionPoint ? point : from;
    const quadrant = 360 / options.directions.length;
    const angleTheta = directionFrom.theta(to);
    const normalizedAngle = _geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(angleTheta + quadrant / 2);
    const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
    options.previousDirectionAngle = directionAngle;
    if (point) route.push(point.round());
    route.push(to);
    return route;
  }

};
const metro = function (vertices, options, linkView) {
  return _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_manhattan_index__WEBPACK_IMPORTED_MODULE_3__.manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);
};

/***/ }),

/***/ 83978:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/normal.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normal": () => (/* binding */ normal)
/* harmony export */ });
const normal = function (vertices) {
  return [...vertices];
};

/***/ }),

/***/ 22418:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/oneside.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "oneSide": () => (/* binding */ oneSide)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);

/**
 * Routes the edge always to/from a certain side
 */

const oneSide = function (vertices, options, edgeView) {
  const side = options.side || 'bottom';
  const padding = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(options.padding || 40);
  const sourceBBox = edgeView.sourceBBox;
  const targetBBox = edgeView.targetBBox;
  const sourcePoint = sourceBBox.getCenter();
  const targetPoint = targetBBox.getCenter();
  let coord;
  let dim;
  let factor;

  switch (side) {
    case 'top':
      factor = -1;
      coord = 'y';
      dim = 'height';
      break;

    case 'left':
      factor = -1;
      coord = 'x';
      dim = 'width';
      break;

    case 'right':
      factor = 1;
      coord = 'x';
      dim = 'width';
      break;

    case 'bottom':
    default:
      factor = 1;
      coord = 'y';
      dim = 'height';
      break;
  } // Move the points from the center of the element to outside of it.


  sourcePoint[coord] += factor * (sourceBBox[dim] / 2 + padding[side]);
  targetPoint[coord] += factor * (targetBBox[dim] / 2 + padding[side]); // Make edge orthogonal (at least the first and last vertex).

  if (factor * (sourcePoint[coord] - targetPoint[coord]) > 0) {
    targetPoint[coord] = sourcePoint[coord];
  } else {
    sourcePoint[coord] = targetPoint[coord];
  }

  return [sourcePoint.toJSON(), ...vertices, targetPoint.toJSON()];
};

/***/ }),

/***/ 44240:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/orth.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "orth": () => (/* binding */ orth)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ 88359);



/**
 * Returns a route with orthogonal line segments.
 */

const orth = function (vertices, options, edgeView) {
  let sourceBBox = _util__WEBPACK_IMPORTED_MODULE_2__.getSourceBBox(edgeView, options);
  let targetBBox = _util__WEBPACK_IMPORTED_MODULE_2__.getTargetBBox(edgeView, options);
  const sourceAnchor = _util__WEBPACK_IMPORTED_MODULE_2__.getSourceAnchor(edgeView, options);
  const targetAnchor = _util__WEBPACK_IMPORTED_MODULE_2__.getTargetAnchor(edgeView, options); // If anchor lies outside of bbox, the bbox expands to include it

  sourceBBox = sourceBBox.union(_util__WEBPACK_IMPORTED_MODULE_2__.getPointBBox(sourceAnchor));
  targetBBox = targetBBox.union(_util__WEBPACK_IMPORTED_MODULE_2__.getPointBBox(targetAnchor));
  const points = vertices.map(p => _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(p));
  points.unshift(sourceAnchor);
  points.push(targetAnchor); // bearing of previous route segment

  let bearing = null;
  const result = [];

  for (let i = 0, len = points.length - 1; i < len; i += 1) {
    let route = null;
    const from = points[i];
    const to = points[i + 1];
    const isOrthogonal = Private.getBearing(from, to) != null;

    if (i === 0) {
      // source
      if (i + 1 === len) {
        // source -> target
        // Expand one of the nodes by 1px to detect situations when the two
        // nodes are positioned next to each other with no gap in between.
        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {
          route = Private.insideNode(from, to, sourceBBox, targetBBox);
        } else if (!isOrthogonal) {
          route = Private.nodeToNode(from, to, sourceBBox, targetBBox);
        }
      } else {
        // source -> vertex
        if (sourceBBox.containsPoint(to)) {
          route = Private.insideNode(from, to, sourceBBox, _util__WEBPACK_IMPORTED_MODULE_2__.getPointBBox(to).moveAndExpand(_util__WEBPACK_IMPORTED_MODULE_2__.getPaddingBox(options)));
        } else if (!isOrthogonal) {
          route = Private.nodeToVertex(from, to, sourceBBox);
        }
      }
    } else if (i + 1 === len) {
      // vertex -> target
      // prevent overlaps with previous line segment
      const isOrthogonalLoop = isOrthogonal && Private.getBearing(to, from) === bearing;

      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
        route = Private.insideNode(from, to, _util__WEBPACK_IMPORTED_MODULE_2__.getPointBBox(from).moveAndExpand(_util__WEBPACK_IMPORTED_MODULE_2__.getPaddingBox(options)), targetBBox, bearing);
      } else if (!isOrthogonal) {
        route = Private.vertexToNode(from, to, targetBBox, bearing);
      }
    } else if (!isOrthogonal) {
      // vertex -> vertex
      route = Private.vertexToVertex(from, to, bearing);
    } // set bearing for next iteration


    if (route) {
      result.push(...route.points);
      bearing = route.direction;
    } else {
      // orthogonal route and not looped
      bearing = Private.getBearing(from, to);
    } // push `to` point to identified orthogonal vertices array


    if (i + 1 < len) {
      result.push(to);
    }
  }

  return result;
};
var Private;

(function (Private) {
  /**
   * Bearing to opposite bearing map
   */
  const opposites = {
    N: 'S',
    S: 'N',
    E: 'W',
    W: 'E'
  };
  /**
   * Bearing to radians map
   */

  const radians = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  /**
   * Returns a point `p` where lines p,p1 and p,p2 are perpendicular
   * and p is not contained in the given box
   */

  function freeJoin(p1, p2, bbox) {
    let p = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(p1.x, p2.y);

    if (bbox.containsPoint(p)) {
      p = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(p2.x, p1.y);
    } // kept for reference
    // if (bbox.containsPoint(p)) {
    //   return null
    // }


    return p;
  }
  /**
   * Returns either width or height of a bbox based on the given bearing.
   */


  function getBBoxSize(bbox, bearing) {
    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];
  }

  Private.getBBoxSize = getBBoxSize;

  function getBearing(from, to) {
    if (from.x === to.x) {
      return from.y > to.y ? 'N' : 'S';
    }

    if (from.y === to.y) {
      return from.x > to.x ? 'W' : 'E';
    }

    return null;
  }

  Private.getBearing = getBearing;

  function vertexToVertex(from, to, bearing) {
    const p1 = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(from.x, to.y);
    const p2 = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(to.x, from.y);
    const d1 = getBearing(from, p1);
    const d2 = getBearing(from, p2);
    const opposite = bearing ? opposites[bearing] : null;
    const p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;
    return {
      points: [p],
      direction: getBearing(p, to)
    };
  }

  Private.vertexToVertex = vertexToVertex;

  function nodeToVertex(from, to, fromBBox) {
    const p = freeJoin(from, to, fromBBox);
    return {
      points: [p],
      direction: getBearing(p, to)
    };
  }

  Private.nodeToVertex = nodeToVertex;

  function vertexToNode(from, to, toBBox, bearing) {
    const points = [new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(from.x, to.y), new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(to.x, from.y)];
    const freePoints = points.filter(p => !toBBox.containsPoint(p));
    const freeBearingPoints = freePoints.filter(p => getBearing(p, from) !== bearing);
    let p;

    if (freeBearingPoints.length > 0) {
      // Try to pick a point which bears the same direction as the previous segment.
      p = freeBearingPoints.filter(p => getBearing(from, p) === bearing).pop();
      p = p || freeBearingPoints[0];
      return {
        points: [p],
        direction: getBearing(p, to)
      };
    }

    {
      // Here we found only points which are either contained in the element or they would create
      // a link segment going in opposite direction from the previous one.
      // We take the point inside element and move it outside the element in the direction the
      // route is going. Now we can join this point with the current end (using freeJoin).
      p = _util__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.difference(points, freePoints)[0];
      const p2 = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
      const p1 = freeJoin(p2, from, toBBox);
      return {
        points: [p1, p2],
        direction: getBearing(p2, to)
      };
    }
  }

  Private.vertexToNode = vertexToNode;

  function nodeToNode(from, to, fromBBox, toBBox) {
    let route = nodeToVertex(to, from, toBBox);
    const p1 = route.points[0];

    if (fromBBox.containsPoint(p1)) {
      route = nodeToVertex(from, to, fromBBox);
      const p2 = route.points[0];

      if (toBBox.containsPoint(p2)) {
        const fromBorder = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
        const toBorder = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
        const mid = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Line(fromBorder, toBorder).getCenter();
        const startRoute = nodeToVertex(from, mid, fromBBox);
        const endRoute = vertexToVertex(mid, to, startRoute.direction);
        route.points = [startRoute.points[0], endRoute.points[0]];
        route.direction = endRoute.direction;
      }
    }

    return route;
  }

  Private.nodeToNode = nodeToNode; // Finds route for situations where one node is inside the other.
  // Typically the route is directed outside the outer node first and
  // then back towards the inner node.

  function insideNode(from, to, fromBBox, toBBox, bearing) {
    const boundary = fromBBox.union(toBBox).inflate(1); // start from the point which is closer to the boundary

    const center = boundary.getCenter();
    const reversed = center.distance(to) > center.distance(from);
    const start = reversed ? to : from;
    const end = reversed ? from : to;
    let p1;
    let p2;
    let p3;

    if (bearing) {
      // Points on circle with radius equals 'W + H` are always outside the rectangle
      // with width W and height H if the center of that circle is the center of that rectangle.
      p1 = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);
      p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);
    } else {
      p1 = boundary.getNearestPointToPoint(start).move(start, 1);
    }

    p2 = freeJoin(p1, end, boundary);
    let points;

    if (p1.round().equals(p2.round())) {
      p2 = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(boundary.width + boundary.height, _geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(p1.theta(start)) + Math.PI / 2, end);
      p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();
      p3 = freeJoin(p1, p2, boundary);
      points = reversed ? [p2, p3, p1] : [p1, p3, p2];
    } else {
      points = reversed ? [p2, p1] : [p1, p2];
    }

    const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
    return {
      points,
      direction
    };
  }

  Private.insideNode = insideNode;
})(Private || (Private = {}));

/***/ }),

/***/ 88359:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPaddingBox": () => (/* binding */ getPaddingBox),
/* harmony export */   "getPointBBox": () => (/* binding */ getPointBBox),
/* harmony export */   "getSourceAnchor": () => (/* binding */ getSourceAnchor),
/* harmony export */   "getSourceBBox": () => (/* binding */ getSourceBBox),
/* harmony export */   "getTargetAnchor": () => (/* binding */ getTargetAnchor),
/* harmony export */   "getTargetBBox": () => (/* binding */ getTargetBBox)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);


function getPointBBox(p) {
  return new _geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(p.x, p.y, 0, 0);
}
function getPaddingBox(options = {}) {
  const sides = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(options.padding || 20);
  return {
    x: -sides.left,
    y: -sides.top,
    width: sides.left + sides.right,
    height: sides.top + sides.bottom
  };
}
function getSourceBBox(view, options = {}) {
  return view.sourceBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getTargetBBox(view, options = {}) {
  return view.targetBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getSourceAnchor(view, options = {}) {
  if (view.sourceAnchor) {
    return view.sourceAnchor;
  }

  const bbox = getSourceBBox(view, options);
  return bbox.getCenter();
}
function getTargetAnchor(view, options = {}) {
  if (view.targetAnchor) {
    return view.targetAnchor;
  }

  const bbox = getTargetBBox(view, options);
  return bbox.getCenter();
}

/***/ }),

/***/ 48210:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/anchor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SourceAnchor": () => (/* binding */ SourceAnchor),
/* harmony export */   "TargetAnchor": () => (/* binding */ TargetAnchor)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/tool */ 92654);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ 6484);





class Anchor extends _view_tool__WEBPACK_IMPORTED_MODULE_2__.ToolsView.ToolItem {
  get type() {
    return this.options.type;
  }

  onRender() {
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));
    this.toggleArea(false);
    this.update();
  }

  update() {
    const type = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(type);

    if (terminalView) {
      this.updateAnchor();
      this.updateArea();
      this.container.style.display = '';
    } else {
      this.container.style.display = 'none';
    }

    return this;
  }

  updateAnchor() {
    const childNodes = this.childNodes;

    if (!childNodes) {
      return;
    }

    const anchorNode = childNodes.anchor;

    if (!anchorNode) {
      return;
    }

    const type = this.type;
    const edgeView = this.cellView;
    const options = this.options;
    const position = edgeView.getTerminalAnchor(type);
    const customAnchor = edgeView.cell.prop([type, 'anchor']);
    anchorNode.setAttribute('transform', `translate(${position.x}, ${position.y})`);
    const anchorAttrs = customAnchor ? options.customAnchorAttrs : options.defaultAnchorAttrs;

    if (anchorAttrs) {
      Object.keys(anchorAttrs).forEach(attrName => {
        anchorNode.setAttribute(attrName, anchorAttrs[attrName]);
      });
    }
  }

  updateArea() {
    const childNodes = this.childNodes;

    if (!childNodes) {
      return;
    }

    const areaNode = childNodes.area;

    if (!areaNode) {
      return;
    }

    const type = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(type);

    if (terminalView) {
      const terminalCell = terminalView.cell;
      const magnet = edgeView.getTerminalMagnet(type);
      let padding = this.options.areaPadding || 0;

      if (!Number.isFinite(padding)) {
        padding = 0;
      }

      let bbox;
      let angle;
      let center;

      if (terminalView.isEdgeElement(magnet)) {
        bbox = terminalView.getBBox();
        angle = 0;
        center = bbox.getCenter();
      } else {
        bbox = terminalView.getUnrotatedBBoxOfElement(magnet);
        angle = terminalCell.getAngle();
        center = bbox.getCenter();

        if (angle) {
          center.rotate(-angle, terminalCell.getBBox().getCenter());
        }
      }

      bbox.inflate(padding);
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(areaNode, {
        x: -bbox.width / 2,
        y: -bbox.height / 2,
        width: bbox.width,
        height: bbox.height,
        transform: `translate(${center.x}, ${center.y}) rotate(${angle})`
      });
    }
  }

  toggleArea(visible) {
    if (this.childNodes) {
      const elem = this.childNodes.area;

      if (elem) {
        elem.style.display = visible ? '' : 'none';
      }
    }
  }

  onMouseDown(evt) {
    if (this.guard(evt)) {
      return;
    }

    evt.stopPropagation();
    evt.preventDefault();
    this.graph.view.undelegateEvents();

    if (this.options.documentEvents) {
      this.delegateDocumentEvents(this.options.documentEvents);
    }

    this.focus();
    this.toggleArea(this.options.restrictArea);
    this.cell.startBatch('move-anchor', {
      ui: true,
      toolId: this.cid
    });
  }

  resetAnchor(anchor) {
    const type = this.type;
    const cell = this.cell;

    if (anchor) {
      cell.prop([type, 'anchor'], anchor, {
        rewrite: true,
        ui: true,
        toolId: this.cid
      });
    } else {
      cell.removeProp([type, 'anchor'], {
        ui: true,
        toolId: this.cid
      });
    }
  }

  onMouseMove(evt) {
    const terminalType = this.type;
    const edgeView = this.cellView;
    const terminalView = edgeView.getTerminalView(terminalType);

    if (terminalView == null) {
      return;
    }

    const e = this.normalizeEvent(evt);
    const terminalCell = terminalView.cell;
    const terminalMagnet = edgeView.getTerminalMagnet(terminalType);
    let coords = this.graph.clientToLocal(e.clientX, e.clientY);
    const snapFn = this.options.snap;

    if (typeof snapFn === 'function') {
      const tmp = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
      coords = _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(tmp);
    }

    if (this.options.restrictArea) {
      if (terminalView.isEdgeElement(terminalMagnet)) {
        const pointAtConnection = terminalView.getClosestPoint(coords);

        if (pointAtConnection) {
          coords = pointAtConnection;
        }
      } else {
        const bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);
        const angle = terminalCell.getAngle();
        const origin = terminalCell.getBBox().getCenter();
        const rotatedCoords = coords.clone().rotate(angle, origin);

        if (!bbox.containsPoint(rotatedCoords)) {
          coords = bbox.getNearestPointToPoint(rotatedCoords).rotate(-angle, origin);
        }
      }
    }

    let anchor;
    const anchorFn = this.options.anchor;

    if (typeof anchorFn === 'function') {
      anchor = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
    }

    this.resetAnchor(anchor);
    this.update();
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  onMouseUp(evt) {
    this.graph.view.delegateEvents();
    this.undelegateDocumentEvents();
    this.blur();
    this.toggleArea(false);
    const edgeView = this.cellView;

    if (this.options.removeRedundancies) {
      edgeView.removeRedundantLinearVertices({
        ui: true,
        toolId: this.cid
      });
    }

    this.cell.stopBatch('move-anchor', {
      ui: true,
      toolId: this.cid
    });
  }

  onDblClick() {
    const anchor = this.options.resetAnchor;

    if (anchor) {
      this.resetAnchor(anchor === true ? undefined : anchor);
    }

    this.update();
  }

}

(function (Anchor) {
  Anchor.config({
    tagName: 'g',
    markup: [{
      tagName: 'circle',
      selector: 'anchor',
      attrs: {
        cursor: 'pointer'
      }
    }, {
      tagName: 'rect',
      selector: 'area',
      attrs: {
        'pointer-events': 'none',
        fill: 'none',
        stroke: '#33334F',
        'stroke-dasharray': '2,4',
        rx: 5,
        ry: 5
      }
    }],
    events: {
      mousedown: 'onMouseDown',
      touchstart: 'onMouseDown',
      dblclick: 'onDblClick'
    },
    documentEvents: {
      mousemove: 'onMouseMove',
      touchmove: 'onMouseMove',
      mouseup: 'onMouseUp',
      touchend: 'onMouseUp',
      touchcancel: 'onMouseUp'
    },
    customAnchorAttrs: {
      'stroke-width': 4,
      stroke: '#33334F',
      fill: '#FFFFFF',
      r: 5
    },
    defaultAnchorAttrs: {
      'stroke-width': 2,
      stroke: '#FFFFFF',
      fill: '#33334F',
      r: 6
    },
    areaPadding: 6,
    snapRadius: 10,
    resetAnchor: true,
    restrictArea: true,
    removeRedundancies: true,
    anchor: _util__WEBPACK_IMPORTED_MODULE_3__.getAnchor,

    snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {
      const snapRadius = toolView.options.snapRadius || 0;
      const isSource = terminalType === 'source';
      const refIndex = isSource ? 0 : -1;
      const ref = this.cell.getVertexAt(refIndex) || this.getTerminalAnchor(isSource ? 'target' : 'source');

      if (ref) {
        if (Math.abs(ref.x - pos.x) < snapRadius) pos.x = ref.x;
        if (Math.abs(ref.y - pos.y) < snapRadius) pos.y = ref.y;
      }

      return pos;
    }

  });
})(Anchor || (Anchor = {}));

const SourceAnchor = Anchor.define({
  name: 'source-anchor',
  type: 'source'
});
const TargetAnchor = Anchor.define({
  name: 'target-anchor',
  type: 'target'
});

/***/ }),

/***/ 38550:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/arrowhead.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SourceArrowhead": () => (/* binding */ SourceArrowhead),
/* harmony export */   "TargetArrowhead": () => (/* binding */ TargetArrowhead)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/tool */ 92654);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





class Arrowhead extends _view_tool__WEBPACK_IMPORTED_MODULE_2__.ToolsView.ToolItem {
  get type() {
    return this.options.type;
  }

  get ratio() {
    return this.options.ratio;
  }

  init() {
    if (this.options.attrs) {
      const _a = this.options.attrs,
            {
        class: className
      } = _a,
            attrs = __rest(_a, ["class"]);

      this.setAttrs(attrs, this.container);

      if (className) {
        _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, className);
      }
    }
  }

  onRender() {
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`));
    this.update();
  }

  update() {
    const ratio = this.ratio;
    const edgeView = this.cellView;
    const tangent = edgeView.getTangentAtRatio(ratio);
    const position = tangent ? tangent.start : edgeView.getPointAtRatio(ratio);
    const angle = tangent && tangent.vector().vectorAngle(new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0)) || 0;

    if (!position) {
      return this;
    }

    const matrix = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix().translate(position.x, position.y).rotate(angle);
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transform(this.container, matrix, {
      absolute: true
    });
    return this;
  }

  onMouseDown(evt) {
    if (this.guard(evt)) {
      return;
    }

    evt.stopPropagation();
    evt.preventDefault();
    const edgeView = this.cellView;

    if (edgeView.can('arrowheadMovable')) {
      edgeView.cell.startBatch('move-arrowhead', {
        ui: true,
        toolId: this.cid
      });
      const coords = this.graph.snapToGrid(evt.clientX, evt.clientY);
      const data = edgeView.prepareArrowheadDragging(this.type, {
        x: coords.x,
        y: coords.y,
        options: {
          toolId: this.cid
        }
      });
      this.cellView.setEventData(evt, data);
      this.delegateDocumentEvents(this.options.documentEvents, evt.data);
      edgeView.graph.view.undelegateEvents();
      this.container.style.pointerEvents = 'none';
    }

    this.focus();
  }

  onMouseMove(evt) {
    const e = this.normalizeEvent(evt);
    const coords = this.graph.snapToGrid(e.clientX, e.clientY);
    this.cellView.onMouseMove(e, coords.x, coords.y);
    this.update();
  }

  onMouseUp(evt) {
    this.undelegateDocumentEvents();
    const e = this.normalizeEvent(evt);
    const edgeView = this.cellView;
    const coords = this.graph.snapToGrid(e.clientX, e.clientY);
    edgeView.onMouseUp(e, coords.x, coords.y);
    this.graph.view.delegateEvents();
    this.blur();
    this.container.style.pointerEvents = '';
    edgeView.cell.stopBatch('move-arrowhead', {
      ui: true,
      toolId: this.cid
    });
  }

}

(function (Arrowhead) {
  Arrowhead.config({
    tagName: 'path',
    isSVGElement: true,
    events: {
      mousedown: 'onMouseDown',
      touchstart: 'onMouseDown'
    },
    documentEvents: {
      mousemove: 'onMouseMove',
      touchmove: 'onMouseMove',
      mouseup: 'onMouseUp',
      touchend: 'onMouseUp',
      touchcancel: 'onMouseUp'
    }
  });
})(Arrowhead || (Arrowhead = {}));

const SourceArrowhead = Arrowhead.define({
  name: 'source-arrowhead',
  type: 'source',
  ratio: 0,
  attrs: {
    d: 'M 10 -8 -10 0 10 8 Z',
    fill: '#333',
    stroke: '#fff',
    'stroke-width': 2,
    cursor: 'move'
  }
});
const TargetArrowhead = Arrowhead.define({
  name: 'target-arrowhead',
  type: 'target',
  ratio: 1,
  attrs: {
    d: 'M -10 -8 10 0 -10 8 Z',
    fill: '#333',
    stroke: '#fff',
    'stroke-width': 2,
    cursor: 'move'
  }
});

/***/ }),

/***/ 66808:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/boundary.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Boundary": () => (/* binding */ Boundary)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/tool */ 92654);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ 6484);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




class Boundary extends _view_tool__WEBPACK_IMPORTED_MODULE_1__.ToolsView.ToolItem {
  onRender() {
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('cell-tool-boundary'));

    if (this.options.attrs) {
      const _a = this.options.attrs,
            {
        class: className
      } = _a,
            attrs = __rest(_a, ["class"]);

      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(this.container, _util__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(attrs));

      if (className) {
        _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, className);
      }
    }

    this.update();
  }

  update() {
    const view = this.cellView;
    const options = this.options;
    const {
      useCellGeometry,
      rotate
    } = options;
    const padding = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(options.padding);
    let bbox = _util__WEBPACK_IMPORTED_MODULE_2__.getViewBBox(view, useCellGeometry).moveAndExpand({
      x: -padding.left,
      y: -padding.top,
      width: padding.left + padding.right,
      height: padding.top + padding.bottom
    });
    const cell = view.cell;

    if (cell.isNode()) {
      const angle = cell.getAngle();

      if (angle) {
        if (rotate) {
          const origin = cell.getBBox().getCenter();
          _util__WEBPACK_IMPORTED_MODULE_0__.Dom.rotate(this.container, angle, origin.x, origin.y, {
            absolute: true
          });
        } else {
          bbox = bbox.bbox(angle);
        }
      }
    }

    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(this.container, bbox.toJSON());
    return this;
  }

}

(function (Boundary) {
  Boundary.config({
    name: 'boundary',
    tagName: 'rect',
    padding: 10,
    attrs: {
      fill: 'none',
      stroke: '#333',
      'stroke-width': 0.5,
      'stroke-dasharray': '5, 5',
      'pointer-events': 'none'
    }
  });
})(Boundary || (Boundary = {}));

/***/ }),

/***/ 4578:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/button.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Button": () => (/* binding */ Button)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/tool */ 92654);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ 6484);




class Button extends _view_tool__WEBPACK_IMPORTED_MODULE_2__.ToolsView.ToolItem {
  onRender() {
    _util__WEBPACK_IMPORTED_MODULE_1__.Dom.addClass(this.container, this.prefixClassName('cell-tool-button'));
    this.update();
  }

  update() {
    this.updatePosition();
    return this;
  }

  updatePosition() {
    const view = this.cellView;
    const matrix = view.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
    _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transform(this.container, matrix, {
      absolute: true
    });
  }

  getNodeMatrix() {
    const view = this.cellView;
    const options = this.options;
    let {
      x = 0,
      y = 0
    } = options;
    const {
      offset,
      useCellGeometry,
      rotate
    } = options;
    let bbox = _util__WEBPACK_IMPORTED_MODULE_3__.getViewBBox(view, useCellGeometry);
    const angle = view.cell.getAngle();

    if (!rotate) {
      bbox = bbox.bbox(angle);
    }

    let offsetX = 0;
    let offsetY = 0;

    if (typeof offset === 'number') {
      offsetX = offset;
      offsetY = offset;
    } else if (typeof offset === 'object') {
      offsetX = offset.x;
      offsetY = offset.y;
    }

    x = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizePercentage(x, bbox.width);
    y = _util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizePercentage(y, bbox.height);
    let matrix = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);

    if (rotate) {
      matrix = matrix.rotate(angle);
    }

    matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);
    return matrix;
  }

  getEdgeMatrix() {
    const view = this.cellView;
    const options = this.options;
    const {
      offset = 0,
      distance = 0,
      rotate
    } = options;
    let tangent;
    let position;
    let angle;

    if (_util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(distance)) {
      tangent = view.getTangentAtRatio(parseFloat(distance) / 100);
    } else {
      tangent = view.getTangentAtLength(distance);
    }

    if (tangent) {
      position = tangent.start;
      angle = tangent.vector().vectorAngle(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0)) || 0;
    } else {
      position = view.getConnection().start;
      angle = 0;
    }

    let matrix = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix().translate(position.x, position.y).rotate(angle);

    if (typeof offset === 'object') {
      matrix = matrix.translate(offset.x || 0, offset.y || 0);
    } else {
      matrix = matrix.translate(0, offset);
    }

    if (!rotate) {
      matrix = matrix.rotate(-angle);
    }

    return matrix;
  }

  onMouseDown(e) {
    if (this.guard(e)) {
      return;
    }

    e.stopPropagation();
    e.preventDefault();
    const onClick = this.options.onClick;

    if (typeof onClick === 'function') {
      _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(onClick, this.cellView, {
        e,
        view: this.cellView,
        cell: this.cellView.cell,
        btn: this
      });
    }
  }

}

(function (Button) {
  Button.config({
    name: 'button',
    events: {
      mousedown: 'onMouseDown',
      touchstart: 'onMouseDown'
    }
  });
})(Button || (Button = {}));

(function (Button) {
  Button.Remove = Button.define({
    name: 'button-remove',
    markup: [{
      tagName: 'circle',
      selector: 'button',
      attrs: {
        r: 7,
        fill: '#FF1D00',
        cursor: 'pointer'
      }
    }, {
      tagName: 'path',
      selector: 'icon',
      attrs: {
        d: 'M -3 -3 3 3 M -3 3 3 -3',
        fill: 'none',
        stroke: '#FFFFFF',
        'stroke-width': 2,
        'pointer-events': 'none'
      }
    }],
    distance: 60,
    offset: 0,

    onClick({
      view,
      btn
    }) {
      btn.parent.remove();
      view.cell.remove({
        ui: true,
        toolId: btn.cid
      });
    }

  });
})(Button || (Button = {}));

/***/ }),

/***/ 1337:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/editor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellEditor": () => (/* binding */ CellEditor)
/* harmony export */ });
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../view/tool */ 92654);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ 44650);



class CellEditor extends _view_tool__WEBPACK_IMPORTED_MODULE_0__.ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.labelIndex = -1;
    this.distance = 0.5;
  }

  render() {
    this.createElement();
    this.update();
    this.autoFocus();
    this.delegateDocumentEvents(this.options.documentEvents);
    return this;
  }

  createElement() {
    const {
      cell
    } = this;
    const classNames = [this.prefixClassName(`${cell.isEdge() ? 'edge' : 'node'}-tool-editor`), this.prefixClassName('cell-tool-editor')];
    this.editor = _view_tool__WEBPACK_IMPORTED_MODULE_0__.ToolsView.createElement('div', false);
    this.addClass(classNames, this.editor);
    this.editor.contentEditable = 'true';
    this.container.appendChild(this.editor);
  }

  update() {
    const {
      graph,
      cell,
      editor
    } = this;
    const style = editor.style; // set tool position

    let pos = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
    let minWidth = 20;

    if (cell.isNode()) {
      pos = cell.getBBox().center;
      minWidth = cell.size().width - 4;
    } else if (cell.isEdge()) {
      const e = this.options.event;
      const target = e.target;
      const parent = target.parentElement;
      const isEdgeLabel = parent && _util__WEBPACK_IMPORTED_MODULE_2__.Dom.hasClass(parent, this.prefixClassName('edge-label'));

      if (isEdgeLabel) {
        const index = parent.getAttribute('data-index') || '0';
        this.labelIndex = parseInt(index, 10);
        const matrix = parent.getAttribute('transform');
        const {
          translation
        } = _util__WEBPACK_IMPORTED_MODULE_2__.Dom.parseTransformString(matrix);
        pos = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(translation.tx, translation.ty);
        minWidth = _util__WEBPACK_IMPORTED_MODULE_2__.Dom.getBBox(target).width;
      } else {
        if (!this.options.labelAddable) {
          return this;
        }

        pos = graph.clientToLocal(_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(e.clientX, e.clientY));
        const view = this.cellView;
        const d = view.path.closestPointLength(pos);
        this.distance = d;
      }
    }

    pos = graph.localToGraph(pos);
    style.left = `${pos.x}px`;
    style.top = `${pos.y}px`;
    style.minWidth = `${minWidth}px`; // set tool transform

    const scale = graph.scale();
    style.transform = `scale(${scale.sx}, ${scale.sy}) translate(-50%, -50%)`; // set font style

    const attrs = this.options.attrs;
    style.fontSize = `${attrs.fontSize}px`;
    style.fontFamily = attrs.fontFamily;
    style.color = attrs.color;
    style.backgroundColor = attrs.backgroundColor; // set init value

    const getText = this.options.getText;
    let text;

    if (typeof getText === 'function') {
      text = _util__WEBPACK_IMPORTED_MODULE_2__.FunctionExt.call(getText, this.cellView, {
        cell: this.cell,
        index: this.labelIndex
      });
    }

    editor.innerText = text || '';
    return this;
  }

  onDocumentMouseDown(e) {
    if (e.target !== this.editor) {
      const cell = this.cell;
      const value = this.editor.innerText.replace(/\n$/, '') || ''; // set value

      const setText = this.options.setText;

      if (typeof setText === 'function') {
        _util__WEBPACK_IMPORTED_MODULE_2__.FunctionExt.call(setText, this.cellView, {
          cell: this.cell,
          value,
          index: this.labelIndex,
          distance: this.distance
        });
      } // remove tool


      cell.removeTool(cell.isEdge() ? 'edge-editor' : 'node-editor');
      this.undelegateDocumentEvents();
    }
  }

  onDblClick(e) {
    e.stopPropagation();
  }

  onMouseDown(e) {
    e.stopPropagation();
  }

  autoFocus() {
    setTimeout(() => {
      this.editor.focus();
      this.selectText();
    });
  }

  selectText() {
    if (window.getSelection) {
      const range = document.createRange();
      const selection = window.getSelection();
      range.selectNodeContents(this.editor);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }

}

(function (CellEditor) {
  CellEditor.config({
    tagName: 'div',
    isSVGElement: false,
    events: {
      dblclick: 'onDblClick',
      mousedown: 'onMouseDown'
    },
    documentEvents: {
      mousedown: 'onDocumentMouseDown'
    }
  });
})(CellEditor || (CellEditor = {}));

(function (CellEditor) {
  CellEditor.NodeEditor = CellEditor.define({
    attrs: {
      fontSize: 14,
      fontFamily: 'Arial, helvetica, sans-serif',
      color: '#000',
      backgroundColor: '#fff'
    },

    getText({
      cell
    }) {
      return cell.attr('text/text');
    },

    setText({
      cell,
      value
    }) {
      cell.attr('text/text', value);
    }

  });
  CellEditor.EdgeEditor = CellEditor.define({
    attrs: {
      fontSize: 14,
      fontFamily: 'Arial, helvetica, sans-serif',
      color: '#000',
      backgroundColor: '#fff'
    },
    labelAddable: true,

    getText({
      cell,
      index
    }) {
      if (index === -1) {
        return '';
      }

      return cell.prop(`labels/${index}/attrs/label/text`);
    },

    setText({
      cell,
      value,
      index,
      distance
    }) {
      const edge = cell;

      if (index === -1) {
        edge.appendLabel({
          position: {
            distance: distance
          },
          attrs: {
            label: {
              text: value
            }
          }
        });
      } else {
        if (value) {
          edge.prop(`labels/${index}/attrs/label/text`, value);
        } else if (typeof index === 'number') {
          edge.removeLabelAt(index);
        }
      }
    }

  });
})(CellEditor || (CellEditor = {}));

/***/ }),

/***/ 59912:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EdgeTool": () => (/* binding */ EdgeTool),
/* harmony export */   "NodeTool": () => (/* binding */ NodeTool)
/* harmony export */ });
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../view/tool */ 92654);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ 80618);
/* harmony import */ var _button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./button */ 4578);
/* harmony import */ var _boundary__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./boundary */ 66808);
/* harmony import */ var _vertices__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vertices */ 71191);
/* harmony import */ var _segments__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./segments */ 92710);
/* harmony import */ var _anchor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./anchor */ 48210);
/* harmony import */ var _arrowhead__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./arrowhead */ 38550);
/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor */ 1337);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










var NodeTool;

(function (NodeTool) {
  NodeTool.presets = {
    boundary: _boundary__WEBPACK_IMPORTED_MODULE_3__.Boundary,
    button: _button__WEBPACK_IMPORTED_MODULE_2__.Button,
    'button-remove': _button__WEBPACK_IMPORTED_MODULE_2__.Button.Remove,
    'node-editor': _editor__WEBPACK_IMPORTED_MODULE_8__.CellEditor.NodeEditor
  };
  NodeTool.registry = _registry__WEBPACK_IMPORTED_MODULE_1__.Registry.create({
    type: 'node tool',

    process(name, options) {
      if (typeof options === 'function') {
        return options;
      }

      let parent = _view_tool__WEBPACK_IMPORTED_MODULE_0__.ToolsView.ToolItem;

      const {
        inherit
      } = options,
            others = __rest(options, ["inherit"]);

      if (inherit) {
        const base = this.get(inherit);

        if (base == null) {
          this.onNotFound(inherit, 'inherited');
        } else {
          parent = base;
        }
      }

      if (others.name == null) {
        others.name = name;
      }

      return parent.define.call(parent, others);
    }

  });
  NodeTool.registry.register(NodeTool.presets, true);
})(NodeTool || (NodeTool = {}));

var EdgeTool;

(function (EdgeTool) {
  EdgeTool.presets = {
    boundary: _boundary__WEBPACK_IMPORTED_MODULE_3__.Boundary,
    vertices: _vertices__WEBPACK_IMPORTED_MODULE_4__.Vertices,
    segments: _segments__WEBPACK_IMPORTED_MODULE_5__.Segments,
    button: _button__WEBPACK_IMPORTED_MODULE_2__.Button,
    'button-remove': _button__WEBPACK_IMPORTED_MODULE_2__.Button.Remove,
    'source-anchor': _anchor__WEBPACK_IMPORTED_MODULE_6__.SourceAnchor,
    'target-anchor': _anchor__WEBPACK_IMPORTED_MODULE_6__.TargetAnchor,
    'source-arrowhead': _arrowhead__WEBPACK_IMPORTED_MODULE_7__.SourceArrowhead,
    'target-arrowhead': _arrowhead__WEBPACK_IMPORTED_MODULE_7__.TargetArrowhead,
    'edge-editor': _editor__WEBPACK_IMPORTED_MODULE_8__.CellEditor.EdgeEditor
  };
  EdgeTool.registry = _registry__WEBPACK_IMPORTED_MODULE_1__.Registry.create({
    type: 'edge tool',

    process(name, options) {
      if (typeof options === 'function') {
        return options;
      }

      let parent = _view_tool__WEBPACK_IMPORTED_MODULE_0__.ToolsView.ToolItem;

      const {
        inherit
      } = options,
            others = __rest(options, ["inherit"]);

      if (inherit) {
        const base = this.get(inherit);

        if (base == null) {
          this.onNotFound(inherit, 'inherited');
        } else {
          parent = base;
        }
      }

      if (others.name == null) {
        others.name = name;
      }

      return parent.define.call(parent, others);
    }

  });
  EdgeTool.registry.register(EdgeTool.presets, true);
})(EdgeTool || (EdgeTool = {}));

/***/ }),

/***/ 92710:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/segments.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Segments": () => (/* binding */ Segments)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/view */ 58458);
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/tool */ 92654);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ 6484);





class Segments extends _view_tool__WEBPACK_IMPORTED_MODULE_3__.ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.handles = [];
  }

  get vertices() {
    return this.cellView.cell.getVertices();
  }

  update() {
    this.render();
    return this;
  }

  onRender() {
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'));
    this.resetHandles();
    const edgeView = this.cellView;
    const vertices = [...this.vertices];
    vertices.unshift(edgeView.sourcePoint);
    vertices.push(edgeView.targetPoint);

    for (let i = 0, l = vertices.length; i < l - 1; i += 1) {
      const vertex = vertices[i];
      const nextVertex = vertices[i + 1];
      const handle = this.renderHandle(vertex, nextVertex, i);
      this.stamp(handle.container);
      this.handles.push(handle);
    }

    return this;
  }

  renderHandle(vertex, nextVertex, index) {
    const handle = this.options.createHandle({
      index,
      graph: this.graph,
      guard: evt => this.guard(evt),
      attrs: this.options.attrs || {}
    });

    if (this.options.processHandle) {
      this.options.processHandle(handle);
    }

    this.graph.hook.onToolItemCreated({
      name: 'segments',
      cell: this.cell,
      view: this.cellView,
      tool: handle
    });
    this.updateHandle(handle, vertex, nextVertex);
    this.container.appendChild(handle.container);
    this.startHandleListening(handle);
    return handle;
  }

  startHandleListening(handle) {
    handle.on('change', this.onHandleChange, this);
    handle.on('changing', this.onHandleChanging, this);
    handle.on('changed', this.onHandleChanged, this);
  }

  stopHandleListening(handle) {
    handle.off('change', this.onHandleChange, this);
    handle.off('changing', this.onHandleChanging, this);
    handle.off('changed', this.onHandleChanged, this);
  }

  resetHandles() {
    const handles = this.handles;
    this.handles = [];

    if (handles) {
      handles.forEach(handle => {
        this.stopHandleListening(handle);
        handle.remove();
      });
    }
  }

  shiftHandleIndexes(delta) {
    const handles = this.handles;

    for (let i = 0, n = handles.length; i < n; i += 1) {
      handles[i].options.index += delta;
    }
  }

  resetAnchor(type, anchor) {
    const edge = this.cellView.cell;
    const options = {
      ui: true,
      toolId: this.cid
    };

    if (anchor) {
      edge.prop([type, 'anchor'], anchor, options);
    } else {
      edge.removeProp([type, 'anchor'], options);
    }
  }

  snapHandle(handle, position, data) {
    const axis = handle.options.axis;
    const index = handle.options.index;
    const edgeView = this.cellView;
    const edge = edgeView.cell;
    const vertices = edge.getVertices();
    const prev = vertices[index - 2] || data.sourceAnchor;
    const next = vertices[index + 1] || data.targetAnchor;
    const snapRadius = this.options.snapRadius;

    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {
      position[axis] = prev[axis];
    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {
      position[axis] = next[axis];
    }

    return position;
  }

  onHandleChanging({
    handle,
    e
  }) {
    const graph = this.graph;
    const options = this.options;
    const edgeView = this.cellView;
    const anchorFn = options.anchor;
    const axis = handle.options.axis;
    const index = handle.options.index - 1;
    const data = this.getEventData(e);
    const evt = this.normalizeEvent(e);
    const coords = graph.snapToGrid(evt.clientX, evt.clientY);
    const position = this.snapHandle(handle, coords.clone(), data);
    const vertices = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.vertices);
    let vertex = vertices[index];
    let nextVertex = vertices[index + 1]; // First Segment

    const sourceView = edgeView.sourceView;
    const sourceBBox = edgeView.sourceBBox;
    let changeSourceAnchor = false;
    let deleteSourceAnchor = false;

    if (!vertex) {
      vertex = edgeView.sourceAnchor.toJSON();
      vertex[axis] = position[axis];

      if (sourceBBox.containsPoint(vertex)) {
        changeSourceAnchor = true;
      } else {
        vertices.unshift(vertex);
        this.shiftHandleIndexes(1);
        deleteSourceAnchor = true;
      }
    } else if (index === 0) {
      if (sourceBBox.containsPoint(vertex)) {
        vertices.shift();
        this.shiftHandleIndexes(-1);
        changeSourceAnchor = true;
      } else {
        vertex[axis] = position[axis];
        deleteSourceAnchor = true;
      }
    } else {
      vertex[axis] = position[axis];
    }

    if (typeof anchorFn === 'function' && sourceView) {
      if (changeSourceAnchor) {
        const sourceAnchorPosition = data.sourceAnchor.clone();
        sourceAnchorPosition[axis] = position[axis];
        const sourceAnchor = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);
        this.resetAnchor('source', sourceAnchor);
      }

      if (deleteSourceAnchor) {
        this.resetAnchor('source', data.sourceAnchorDef);
      }
    } // Last segment


    const targetView = edgeView.targetView;
    const targetBBox = edgeView.targetBBox;
    let changeTargetAnchor = false;
    let deleteTargetAnchor = false;

    if (!nextVertex) {
      nextVertex = edgeView.targetAnchor.toJSON();
      nextVertex[axis] = position[axis];

      if (targetBBox.containsPoint(nextVertex)) {
        changeTargetAnchor = true;
      } else {
        vertices.push(nextVertex);
        deleteTargetAnchor = true;
      }
    } else if (index === vertices.length - 2) {
      if (targetBBox.containsPoint(nextVertex)) {
        vertices.pop();
        changeTargetAnchor = true;
      } else {
        nextVertex[axis] = position[axis];
        deleteTargetAnchor = true;
      }
    } else {
      nextVertex[axis] = position[axis];
    }

    if (typeof anchorFn === 'function' && targetView) {
      if (changeTargetAnchor) {
        const targetAnchorPosition = data.targetAnchor.clone();
        targetAnchorPosition[axis] = position[axis];
        const targetAnchor = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);
        this.resetAnchor('target', targetAnchor);
      }

      if (deleteTargetAnchor) {
        this.resetAnchor('target', data.targetAnchorDef);
      }
    }

    if (!_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.equalPoints(vertices, this.vertices)) {
      this.cellView.cell.setVertices(vertices, {
        ui: true,
        toolId: this.cid
      });
    }

    this.updateHandle(handle, vertex, nextVertex, 0);

    if (!options.stopPropagation) {
      edgeView.notifyMouseMove(evt, coords.x, coords.y);
    }
  }

  onHandleChange({
    handle,
    e
  }) {
    const options = this.options;
    const handles = this.handles;
    const edgeView = this.cellView;
    const index = handle.options.index;

    if (!Array.isArray(handles)) {
      return;
    }

    for (let i = 0, n = handles.length; i < n; i += 1) {
      if (i !== index) {
        handles[i].hide();
      }
    }

    this.focus();
    this.setEventData(e, {
      sourceAnchor: edgeView.sourceAnchor.clone(),
      targetAnchor: edgeView.targetAnchor.clone(),
      sourceAnchorDef: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.cell.prop(['source', 'anchor'])),
      targetAnchorDef: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.cell.prop(['target', 'anchor']))
    });
    this.cell.startBatch('move-segment', {
      ui: true,
      toolId: this.cid
    });

    if (!options.stopPropagation) {
      const normalizedEvent = this.normalizeEvent(e);
      const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
      edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);
    }
  }

  onHandleChanged({
    e
  }) {
    const options = this.options;
    const edgeView = this.cellView;

    if (options.removeRedundancies) {
      edgeView.removeRedundantLinearVertices({
        ui: true,
        toolId: this.cid
      });
    }

    const normalizedEvent = this.normalizeEvent(e);
    const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
    this.render();
    this.blur();
    this.cell.stopBatch('move-segment', {
      ui: true,
      toolId: this.cid
    });

    if (!options.stopPropagation) {
      edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);
    }

    edgeView.checkMouseleave(normalizedEvent);
    options.onChanged && options.onChanged({
      edge: edgeView.cell,
      edgeView
    });
  }

  updateHandle(handle, vertex, nextVertex, offset = 0) {
    const precision = this.options.precision || 0;
    const vertical = Math.abs(vertex.x - nextVertex.x) < precision;
    const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;

    if (vertical || horizontal) {
      const segmentLine = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Line(vertex, nextVertex);
      const length = segmentLine.length();

      if (length < this.options.threshold) {
        handle.hide();
      } else {
        const position = segmentLine.getCenter();
        const axis = vertical ? 'x' : 'y';
        position[axis] += offset || 0;
        const angle = segmentLine.vector().vectorAngle(new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0));
        handle.updatePosition(position.x, position.y, angle, this.cellView);
        handle.show();
        handle.options.axis = axis;
      }
    } else {
      handle.hide();
    }
  }

  onRemove() {
    this.resetHandles();
  }

}

(function (Segments) {
  class Handle extends _view_view__WEBPACK_IMPORTED_MODULE_2__.View {
    constructor(options) {
      super();
      this.options = options;
      this.render();
      this.delegateEvents({
        mousedown: 'onMouseDown',
        touchstart: 'onMouseDown'
      });
    }

    render() {
      this.container = _view_view__WEBPACK_IMPORTED_MODULE_2__.View.createElement('rect', true);
      const attrs = this.options.attrs;

      if (typeof attrs === 'function') {
        const defaults = Segments.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));
      } else {
        this.setAttrs(attrs);
      }

      this.addClass(this.prefixClassName('edge-tool-segment'));
    }

    updatePosition(x, y, angle, view) {
      const p = view.getClosestPoint(new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y)) || new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y);
      let matrix = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix().translate(p.x, p.y);

      if (!p.equals({
        x,
        y
      })) {
        const line = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Line(x, y, p.x, p.y);
        let deg = line.vector().vectorAngle(new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0));

        if (deg !== 0) {
          deg += 90;
        }

        matrix = matrix.rotate(deg);
      } else {
        matrix = matrix.rotate(angle);
      }

      this.setAttrs({
        transform: _util__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToTransformString(matrix),
        cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize'
      });
    }

    onMouseDown(evt) {
      if (this.options.guard(evt)) {
        return;
      }

      this.trigger('change', {
        e: evt,
        handle: this
      });
      evt.stopPropagation();
      evt.preventDefault();
      this.options.graph.view.undelegateEvents();
      this.delegateDocumentEvents({
        mousemove: 'onMouseMove',
        touchmove: 'onMouseMove',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
        touchcancel: 'onMouseUp'
      }, evt.data);
    }

    onMouseMove(evt) {
      this.emit('changing', {
        e: evt,
        handle: this
      });
    }

    onMouseUp(evt) {
      this.emit('changed', {
        e: evt,
        handle: this
      });
      this.undelegateDocumentEvents();
      this.options.graph.view.delegateEvents();
    }

    show() {
      this.container.style.display = '';
    }

    hide() {
      this.container.style.display = 'none';
    }

  }

  Segments.Handle = Handle;
})(Segments || (Segments = {}));

(function (Segments) {
  Segments.config({
    name: 'segments',
    precision: 0.5,
    threshold: 40,
    snapRadius: 10,
    stopPropagation: true,
    removeRedundancies: true,
    attrs: {
      width: 20,
      height: 8,
      x: -10,
      y: -4,
      rx: 4,
      ry: 4,
      fill: '#333',
      stroke: '#fff',
      'stroke-width': 2
    },
    createHandle: options => new Segments.Handle(options),
    anchor: _util__WEBPACK_IMPORTED_MODULE_4__.getAnchor
  });
})(Segments || (Segments = {}));

/***/ }),

/***/ 6484:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/util.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAnchor": () => (/* binding */ getAnchor),
/* harmony export */   "getViewBBox": () => (/* binding */ getViewBBox)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _connection_strategy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../connection-strategy */ 74566);


function getAnchor(pos, terminalView, terminalMagnet, type) {
  const end = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_connection_strategy__WEBPACK_IMPORTED_MODULE_1__.ConnectionStrategy.presets.pinRelative, this.graph, {}, terminalView, terminalMagnet, pos, this.cell, type, {});
  return end.anchor;
}
function getViewBBox(view, quick) {
  if (quick) {
    return view.cell.getBBox();
  }

  return view.cell.isEdge() ? view.getConnection().bbox() : view.getUnrotatedBBoxOfElement(view.container);
}

/***/ }),

/***/ 71191:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/vertices.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vertices": () => (/* binding */ Vertices)
/* harmony export */ });
/* harmony import */ var _global_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global/util */ 40106);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/view */ 58458);
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/tool */ 92654);




class Vertices extends _view_tool__WEBPACK_IMPORTED_MODULE_3__.ToolsView.ToolItem {
  constructor() {
    super(...arguments);
    this.handles = [];
  }

  get vertices() {
    return this.cellView.cell.getVertices();
  }

  onRender() {
    this.addClass(this.prefixClassName('edge-tool-vertices'));

    if (this.options.addable) {
      this.updatePath();
    }

    this.resetHandles();
    this.renderHandles();
    return this;
  }

  update() {
    const vertices = this.vertices;

    if (vertices.length === this.handles.length) {
      this.updateHandles();
    } else {
      this.resetHandles();
      this.renderHandles();
    }

    if (this.options.addable) {
      this.updatePath();
    }

    return this;
  }

  resetHandles() {
    const handles = this.handles;
    this.handles = [];

    if (handles) {
      handles.forEach(handle => {
        this.stopHandleListening(handle);
        handle.remove();
      });
    }
  }

  renderHandles() {
    const vertices = this.vertices;

    for (let i = 0, l = vertices.length; i < l; i += 1) {
      const vertex = vertices[i];
      const createHandle = this.options.createHandle;
      const processHandle = this.options.processHandle;
      const handle = createHandle({
        index: i,
        graph: this.graph,
        guard: evt => this.guard(evt),
        attrs: this.options.attrs || {}
      });

      if (processHandle) {
        processHandle(handle);
      }

      this.graph.hook.onToolItemCreated({
        name: 'vertices',
        cell: this.cell,
        view: this.cellView,
        tool: handle
      });
      handle.updatePosition(vertex.x, vertex.y);
      this.stamp(handle.container);
      this.container.appendChild(handle.container);
      this.handles.push(handle);
      this.startHandleListening(handle);
    }
  }

  updateHandles() {
    const vertices = this.vertices;

    for (let i = 0, l = vertices.length; i < l; i += 1) {
      const vertex = vertices[i];
      const handle = this.handles[i];

      if (handle) {
        handle.updatePosition(vertex.x, vertex.y);
      }
    }
  }

  updatePath() {
    const connection = this.childNodes.connection;

    if (connection) {
      connection.setAttribute('d', this.cellView.getConnectionPathData());
    }
  }

  startHandleListening(handle) {
    const edgeView = this.cellView;

    if (edgeView.can('vertexMovable')) {
      handle.on('change', this.onHandleChange, this);
      handle.on('changing', this.onHandleChanging, this);
      handle.on('changed', this.onHandleChanged, this);
    }

    if (edgeView.can('vertexDeletable')) {
      handle.on('remove', this.onHandleRemove, this);
    }
  }

  stopHandleListening(handle) {
    const edgeView = this.cellView;

    if (edgeView.can('vertexMovable')) {
      handle.off('change', this.onHandleChange, this);
      handle.off('changing', this.onHandleChanging, this);
      handle.off('changed', this.onHandleChanged, this);
    }

    if (edgeView.can('vertexDeletable')) {
      handle.off('remove', this.onHandleRemove, this);
    }
  }

  getNeighborPoints(index) {
    const edgeView = this.cellView;
    const vertices = this.vertices;
    const prev = index > 0 ? vertices[index - 1] : edgeView.sourceAnchor;
    const next = index < vertices.length - 1 ? vertices[index + 1] : edgeView.targetAnchor;
    return {
      prev: _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(prev),
      next: _geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(next)
    };
  }

  getMouseEventArgs(evt) {
    const e = this.normalizeEvent(evt);
    const {
      x,
      y
    } = this.graph.snapToGrid(e.clientX, e.clientY);
    return {
      e,
      x,
      y
    };
  }

  onHandleChange({
    e
  }) {
    this.focus();
    const edgeView = this.cellView;
    edgeView.cell.startBatch('move-vertex', {
      ui: true,
      toolId: this.cid
    });

    if (!this.options.stopPropagation) {
      const {
        e: evt,
        x,
        y
      } = this.getMouseEventArgs(e);
      edgeView.notifyMouseDown(evt, x, y);
    }
  }

  onHandleChanging({
    handle,
    e
  }) {
    const edgeView = this.cellView;
    const index = handle.options.index;
    const {
      e: evt,
      x,
      y
    } = this.getMouseEventArgs(e);
    const vertex = {
      x,
      y
    };
    this.snapVertex(vertex, index);
    edgeView.cell.setVertexAt(index, vertex, {
      ui: true,
      toolId: this.cid
    });
    handle.updatePosition(vertex.x, vertex.y);

    if (!this.options.stopPropagation) {
      edgeView.notifyMouseMove(evt, x, y);
    }
  }

  onHandleChanged({
    e
  }) {
    const options = this.options;
    const edgeView = this.cellView;

    if (options.addable) {
      this.updatePath();
    }

    if (!options.removeRedundancies) {
      return;
    }

    const verticesRemoved = edgeView.removeRedundantLinearVertices({
      ui: true,
      toolId: this.cid
    });

    if (verticesRemoved) {
      this.render();
    }

    this.blur();
    edgeView.cell.stopBatch('move-vertex', {
      ui: true,
      toolId: this.cid
    });

    if (this.eventData(e).vertexAdded) {
      edgeView.cell.stopBatch('add-vertex', {
        ui: true,
        toolId: this.cid
      });
    }

    const {
      e: evt,
      x,
      y
    } = this.getMouseEventArgs(e);

    if (!this.options.stopPropagation) {
      edgeView.notifyMouseUp(evt, x, y);
    }

    edgeView.checkMouseleave(evt);
    options.onChanged && options.onChanged({
      edge: edgeView.cell,
      edgeView
    });
  }

  snapVertex(vertex, index) {
    const snapRadius = this.options.snapRadius || 0;

    if (snapRadius > 0) {
      const neighbors = this.getNeighborPoints(index);
      const prev = neighbors.prev;
      const next = neighbors.next;

      if (Math.abs(vertex.x - prev.x) < snapRadius) {
        vertex.x = prev.x;
      } else if (Math.abs(vertex.x - next.x) < snapRadius) {
        vertex.x = next.x;
      }

      if (Math.abs(vertex.y - prev.y) < snapRadius) {
        vertex.y = neighbors.prev.y;
      } else if (Math.abs(vertex.y - next.y) < snapRadius) {
        vertex.y = next.y;
      }
    }
  }

  onHandleRemove({
    handle,
    e
  }) {
    if (this.options.removable) {
      const index = handle.options.index;
      const edgeView = this.cellView;
      edgeView.cell.removeVertexAt(index, {
        ui: true
      });

      if (this.options.addable) {
        this.updatePath();
      }

      edgeView.checkMouseleave(this.normalizeEvent(e));
    }
  }

  onPathMouseDown(evt) {
    const edgeView = this.cellView;

    if (this.guard(evt) || !this.options.addable || !edgeView.can('vertexAddable')) {
      return;
    }

    evt.stopPropagation();
    evt.preventDefault();
    const e = this.normalizeEvent(evt);
    const vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();
    edgeView.cell.startBatch('add-vertex', {
      ui: true,
      toolId: this.cid
    });
    const index = edgeView.getVertexIndex(vertex.x, vertex.y);
    this.snapVertex(vertex, index);
    edgeView.cell.insertVertex(vertex, index, {
      ui: true,
      toolId: this.cid
    });
    this.render();
    const handle = this.handles[index];
    this.eventData(e, {
      vertexAdded: true
    });
    handle.onMouseDown(e);
  }

  onRemove() {
    this.resetHandles();
  }

}

(function (Vertices) {
  class Handle extends _view_view__WEBPACK_IMPORTED_MODULE_2__.View {
    constructor(options) {
      super();
      this.options = options;
      this.render();
      this.delegateEvents({
        mousedown: 'onMouseDown',
        touchstart: 'onMouseDown',
        dblclick: 'onDoubleClick'
      });
    }

    get graph() {
      return this.options.graph;
    }

    render() {
      this.container = _view_view__WEBPACK_IMPORTED_MODULE_2__.View.createElement('circle', true);
      const attrs = this.options.attrs;

      if (typeof attrs === 'function') {
        const defaults = Vertices.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));
      } else {
        this.setAttrs(attrs);
      }

      this.addClass(this.prefixClassName('edge-tool-vertex'));
    }

    updatePosition(x, y) {
      this.setAttrs({
        cx: x,
        cy: y
      });
    }

    onMouseDown(evt) {
      if (this.options.guard(evt)) {
        return;
      }

      evt.stopPropagation();
      evt.preventDefault();
      this.graph.view.undelegateEvents();
      this.delegateDocumentEvents({
        mousemove: 'onMouseMove',
        touchmove: 'onMouseMove',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
        touchcancel: 'onMouseUp'
      }, evt.data);
      this.emit('change', {
        e: evt,
        handle: this
      });
    }

    onMouseMove(evt) {
      this.emit('changing', {
        e: evt,
        handle: this
      });
    }

    onMouseUp(evt) {
      this.emit('changed', {
        e: evt,
        handle: this
      });
      this.undelegateDocumentEvents();
      this.graph.view.delegateEvents();
    }

    onDoubleClick(evt) {
      this.emit('remove', {
        e: evt,
        handle: this
      });
    }

  }

  Vertices.Handle = Handle;
})(Vertices || (Vertices = {}));

(function (Vertices) {
  const pathClassName = _global_util__WEBPACK_IMPORTED_MODULE_0__.Util.prefix('edge-tool-vertex-path');
  Vertices.config({
    name: 'vertices',
    snapRadius: 20,
    addable: true,
    removable: true,
    removeRedundancies: true,
    stopPropagation: true,
    attrs: {
      r: 6,
      fill: '#333',
      stroke: '#fff',
      cursor: 'move',
      'stroke-width': 2
    },
    createHandle: options => new Vertices.Handle(options),
    markup: [{
      tagName: 'path',
      selector: 'connection',
      className: pathClassName,
      attrs: {
        fill: 'none',
        stroke: 'transparent',
        'stroke-width': 10,
        cursor: 'pointer'
      }
    }],
    events: {
      [`mousedown .${pathClassName}`]: 'onPathMouseDown',
      [`touchstart .${pathClassName}`]: 'onPathMouseDown'
    }
  });
})(Vertices || (Vertices = {}));

/***/ }),

/***/ 20287:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/base.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Base": () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _model_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/node */ 21738);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



class Base extends _model_node__WEBPACK_IMPORTED_MODULE_0__.Node {
  get label() {
    return this.getLabel();
  }

  set label(val) {
    this.setLabel(val);
  }

  getLabel() {
    return this.getAttrByPath('text/text');
  }

  setLabel(label, options) {
    if (label == null) {
      this.removeLabel();
    } else {
      this.setAttrByPath('text/text', label, options);
    }

    return this;
  }

  removeLabel() {
    this.removeAttrByPath('text/text');
    return this;
  }

}

(function (Base) {
  Base.bodyAttr = {
    fill: '#ffffff',
    stroke: '#333333',
    strokeWidth: 2
  };
  Base.labelAttr = {
    fontSize: 14,
    fill: '#000000',
    refX: 0.5,
    refY: 0.5,
    textAnchor: 'middle',
    textVerticalAnchor: 'middle',
    fontFamily: 'Arial, helvetica, sans-serif'
  };
  Base.config({
    attrs: {
      text: Object.assign({}, Base.labelAttr)
    },

    propHooks(metadata) {
      const {
        label
      } = metadata,
            others = __rest(metadata, ["label"]);

      if (label) {
        _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.setByPath(others, 'attrs/text/text', label);
      }

      return others;
    },

    visible: true
  });
})(Base || (Base = {}));

/***/ }),

/***/ 5200:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/circle.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Circle": () => (/* binding */ Circle)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 72993);

const Circle = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('circle', {
  width: 60,
  height: 60,
  attrs: {
    circle: {
      r: 30,
      cx: 30,
      cy: 30
    }
  }
});

/***/ }),

/***/ 38588:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/cylinder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cylinder": () => (/* binding */ Cylinder)
/* harmony export */ });
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path */ 93065);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 72993);


const Cylinder = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('cylinder', {
  width: 40,
  height: 40,
  attrs: {
    path: {
      fill: '#FFFFFF',
      stroke: '#cbd2d7',
      strokeWidth: 3,
      d: ['M 0 10 C 10 5, 30 5, 40 10 C 30 15, 10 15, 0 10', 'L 0 20', 'C 10 25, 30 25, 40 20', 'L 40 10'].join(' ')
    },
    text: {
      refY: 0.7,
      refDy: null,
      fill: '#435460'
    }
  }
}, {
  parent: _path__WEBPACK_IMPORTED_MODULE_0__.Path,
  ignoreMarkup: true
});

/***/ }),

/***/ 40863:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/ellipse.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ellipse": () => (/* binding */ Ellipse)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 72993);

const Ellipse = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('ellipse', {
  width: 60,
  height: 40,
  attrs: {
    ellipse: {
      rx: 30,
      ry: 20,
      cx: 30,
      cy: 20
    }
  }
});

/***/ }),

/***/ 97303:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/image.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Image": () => (/* binding */ Image)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 72993);

const Image = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('image', {
  attrs: {
    text: {
      refY: null,
      refDy: 16
    }
  },
  propHooks: (0,_util__WEBPACK_IMPORTED_MODULE_0__.getImageUrlHook)()
});

/***/ }),

/***/ 61967:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Circle": () => (/* reexport safe */ _circle__WEBPACK_IMPORTED_MODULE_1__.Circle),
/* harmony export */   "Cylinder": () => (/* reexport safe */ _cylinder__WEBPACK_IMPORTED_MODULE_8__.Cylinder),
/* harmony export */   "Ellipse": () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_2__.Ellipse),
/* harmony export */   "Image": () => (/* reexport safe */ _image__WEBPACK_IMPORTED_MODULE_5__.Image),
/* harmony export */   "Path": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_6__.Path),
/* harmony export */   "Polygon": () => (/* reexport safe */ _polygon__WEBPACK_IMPORTED_MODULE_3__.Polygon),
/* harmony export */   "Polyline": () => (/* reexport safe */ _polyline__WEBPACK_IMPORTED_MODULE_4__.Polyline),
/* harmony export */   "Rect": () => (/* reexport safe */ _rect__WEBPACK_IMPORTED_MODULE_0__.Rect),
/* harmony export */   "Rhombus": () => (/* reexport safe */ _rhombus__WEBPACK_IMPORTED_MODULE_7__.Rhombus),
/* harmony export */   "Text": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_9__.Text),
/* harmony export */   "TextBlock": () => (/* reexport safe */ _text_block__WEBPACK_IMPORTED_MODULE_10__.TextBlock)
/* harmony export */ });
/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rect */ 97176);
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./circle */ 5200);
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ellipse */ 40863);
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polygon */ 71785);
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polyline */ 52890);
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./image */ 97303);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./path */ 93065);
/* harmony import */ var _rhombus__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rhombus */ 62429);
/* harmony import */ var _cylinder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cylinder */ 38588);
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./text */ 16562);
/* harmony import */ var _text_block__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./text-block */ 95492);












/***/ }),

/***/ 93065:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/path.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Path": () => (/* binding */ Path)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 72993);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const Path = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('path', {
  width: 60,
  height: 60,
  attrs: {
    text: {
      ref: 'path',
      refY: null,
      refDy: 16
    }
  },

  propHooks(metadata) {
    const {
      d
    } = metadata,
          others = __rest(metadata, ["d"]);

    if (d != null) {
      _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.setByPath(others, 'attrs/path/d', d);
    }

    return others;
  }

});

/***/ }),

/***/ 71785:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/polygon.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Polygon": () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 72993);

const Polygon = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('polygon', {
  width: 60,
  height: 40,
  attrs: {
    text: {
      refY: null,
      refDy: 16
    }
  }
});

/***/ }),

/***/ 52890:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/polyline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Polyline": () => (/* binding */ Polyline)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 72993);

const Polyline = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('polyline', {
  width: 60,
  height: 40,
  attrs: {
    text: {
      refY: null,
      refDy: 16
    }
  }
});

/***/ }),

/***/ 97176:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/rect.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rect": () => (/* binding */ Rect)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 72993);

const Rect = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('rect', {
  attrs: {
    rect: {
      width: 100,
      height: 60
    }
  }
});

/***/ }),

/***/ 62429:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/rhombus.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rhombus": () => (/* binding */ Rhombus)
/* harmony export */ });
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path */ 93065);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 72993);


const Rhombus = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('rhombus', {
  d: 'M 30 0 L 60 30 30 60 0 30 z',
  attrs: {
    text: {
      refY: 0.5,
      refDy: null
    }
  }
}, {
  parent: _path__WEBPACK_IMPORTED_MODULE_0__.Path,
  ignoreMarkup: true
});

/***/ }),

/***/ 95492:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/text-block.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextBlock": () => (/* binding */ TextBlock)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model */ 59502);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view */ 29818);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ 72993);




const contentSelector = '.text-block-content';
const registryName = (0,_util__WEBPACK_IMPORTED_MODULE_3__.getName)('text-block');
class TextBlock extends _model__WEBPACK_IMPORTED_MODULE_1__.Node {
  get content() {
    return this.getContent();
  }

  set content(val) {
    this.setContent(val);
  }

  getContent() {
    return this.store.get('content', '');
  }

  setContent(content, options = {}) {
    this.store.set('content', content, options);
  }

  setup() {
    super.setup();
    this.store.on('change:*', metadata => {
      const key = metadata.key;

      if (key === 'content') {
        this.updateContent(this.getContent());
      } else if (key === 'size') {
        this.updateSize(this.getSize());
      }
    });
    this.updateSize(this.getSize());
    this.updateContent(this.getContent());
  }

  updateSize(size) {
    if (_util__WEBPACK_IMPORTED_MODULE_0__.Platform.SUPPORT_FOREIGNOBJECT) {
      this.setAttrs({
        foreignObject: Object.assign({}, size),
        [contentSelector]: {
          style: Object.assign({}, size)
        }
      });
    }
  }

  updateContent(content) {
    if (_util__WEBPACK_IMPORTED_MODULE_0__.Platform.SUPPORT_FOREIGNOBJECT) {
      this.setAttrs({
        [contentSelector]: {
          html: content ? _util__WEBPACK_IMPORTED_MODULE_0__.StringExt.sanitizeHTML(content) : ''
        }
      });
    } else {
      this.setAttrs({
        [contentSelector]: {
          text: content
        }
      });
    }
  }

}

(function (TextBlock) {
  TextBlock.config({
    type: registryName,
    view: registryName,
    markup: ['<g class="rotatable">', '<g class="scalable"><rect/></g>', _util__WEBPACK_IMPORTED_MODULE_0__.Platform.SUPPORT_FOREIGNOBJECT ? [`<foreignObject>`, `<body xmlns="http://www.w3.org/1999/xhtml">`, `<div class="${contentSelector.substr(1)}" />`, `</body>`, `</foreignObject>`].join('') : `<text class="${contentSelector.substr(1)}"/>`, '</g>'].join(''),
    attrs: {
      '.': {
        fill: '#ffffff',
        stroke: 'none'
      },
      rect: {
        fill: '#ffffff',
        stroke: '#000000',
        width: 80,
        height: 100
      },
      text: {
        fill: '#000000',
        fontSize: 14,
        fontFamily: 'Arial, helvetica, sans-serif'
      },
      body: {
        style: {
          background: 'transparent',
          position: 'static',
          margin: 0,
          padding: 0
        }
      },
      foreignObject: {
        style: {
          overflow: 'hidden'
        }
      },
      [contentSelector]: {
        refX: 0.5,
        refY: 0.5,
        yAlign: 'middle',
        xAlign: 'middle',
        style: {
          textAlign: 'center',
          verticalAlign: 'middle',
          display: 'table-cell',
          padding: '0 5px',
          margin: 0
        }
      }
    }
  });
  _model__WEBPACK_IMPORTED_MODULE_1__.Node.registry.register(registryName, TextBlock);
})(TextBlock || (TextBlock = {}));

(function (TextBlock) {
  const contentAction = 'content';

  class View extends _view__WEBPACK_IMPORTED_MODULE_2__.NodeView {
    confirmUpdate(flag, options = {}) {
      let ret = super.confirmUpdate(flag, options);

      if (this.hasAction(ret, contentAction)) {
        this.updateContent();
        ret = this.removeAction(ret, contentAction);
      }

      return ret;
    }

    update(partialAttrs) {
      if (_util__WEBPACK_IMPORTED_MODULE_0__.Platform.SUPPORT_FOREIGNOBJECT) {
        super.update(partialAttrs);
      } else {
        const node = this.cell;
        const attrs = Object.assign({}, partialAttrs || node.getAttrs());
        delete attrs[contentSelector];
        super.update(attrs);

        if (!partialAttrs || _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.has(partialAttrs, contentSelector)) {
          this.updateContent(partialAttrs);
        }
      }
    }

    updateContent(partialAttrs) {
      if (_util__WEBPACK_IMPORTED_MODULE_0__.Platform.SUPPORT_FOREIGNOBJECT) {
        super.update(partialAttrs);
      } else {
        const node = this.cell;
        const textAttrs = (partialAttrs || node.getAttrs())[contentSelector]; // Break the text to fit the node size taking into
        // account the attributes set on the node.

        const text = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.breakText(node.getContent(), node.getSize(), textAttrs, {
          svgDocument: this.graph.view.svg
        });
        const attrs = {
          [contentSelector]: _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, textAttrs, {
            text
          })
        };
        super.update(attrs);
      }
    }

  }

  TextBlock.View = View;

  (function (View) {
    View.config({
      bootstrap: ['render', contentAction],
      actions: _util__WEBPACK_IMPORTED_MODULE_0__.Platform.SUPPORT_FOREIGNOBJECT ? {} : {
        size: contentAction,
        content: contentAction
      }
    });
    _view__WEBPACK_IMPORTED_MODULE_2__.NodeView.registry.register(registryName, View);
  })(View = TextBlock.View || (TextBlock.View = {}));
})(TextBlock || (TextBlock = {}));

/***/ }),

/***/ 16562:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/text.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Text": () => (/* binding */ Text)
/* harmony export */ });
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../view */ 29818);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 72993);


const viewName = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getName)('text');
class Text extends (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('text', {
  view: viewName,
  attrs: {
    text: {
      fontSize: 18,
      fill: '#000000',
      stroke: null,
      refX: 0.5,
      refY: 0.5
    }
  }
}, {
  noText: true
}) {}

(function (Text) {
  class View extends _view__WEBPACK_IMPORTED_MODULE_0__.NodeView {
    confirmUpdate(flag, options = {}) {
      let ret = super.confirmUpdate(flag, options);

      if (this.hasAction(ret, 'scale')) {
        this.resize();
        ret = this.removeAction(ret, 'scale');
      }

      return ret;
    }

  }

  Text.View = View;
  View.config({
    actions: {
      attrs: ['scale']
    }
  });
  _view__WEBPACK_IMPORTED_MODULE_0__.NodeView.registry.register(viewName, View);
})(Text || (Text = {}));

/***/ }),

/***/ 72993:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/basic/util.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createShape": () => (/* binding */ createShape),
/* harmony export */   "getImageUrlHook": () => (/* binding */ getImageUrlHook),
/* harmony export */   "getMarkup": () => (/* binding */ getMarkup),
/* harmony export */   "getName": () => (/* binding */ getName)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ 20287);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



function getMarkup(tagName, noText = false) {
  return `<g class="rotatable"><g class="scalable"><${tagName}/></g>${noText ? '' : '<text/>'}</g>`;
}
function getName(name) {
  return `basic.${name}`;
}
function getImageUrlHook(attrName = 'xlink:href') {
  const hook = metadata => {
    const {
      imageUrl,
      imageWidth,
      imageHeight
    } = metadata,
          others = __rest(metadata, ["imageUrl", "imageWidth", "imageHeight"]);

    if (imageUrl != null || imageWidth != null || imageHeight != null) {
      const apply = () => {
        if (others.attrs) {
          const image = others.attrs.image;

          if (imageUrl != null) {
            image[attrName] = imageUrl;
          }

          if (imageWidth != null) {
            image.width = imageWidth;
          }

          if (imageHeight != null) {
            image.height = imageHeight;
          }

          others.attrs.image = image;
        }
      };

      if (others.attrs) {
        if (others.attrs.image == null) {
          others.attrs.image = {};
        }

        apply();
      } else {
        others.attrs = {
          image: {}
        };
        apply();
      }
    }

    return others;
  };

  return hook;
}
function createShape(shape, config, options = {}) {
  const name = getName(shape);
  const defaults = {
    constructorName: name,
    attrs: {
      '.': {
        fill: '#ffffff',
        stroke: 'none'
      },
      [shape]: {
        fill: '#ffffff',
        stroke: '#000000'
      }
    }
  };

  if (!options.ignoreMarkup) {
    defaults.markup = getMarkup(shape, options.noText === true);
  }

  const base = options.parent || _base__WEBPACK_IMPORTED_MODULE_1__.Base;
  return base.define(_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(defaults, config, {
    shape: name
  }));
}

/***/ }),

/***/ 37623:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicShape": () => (/* reexport module object */ _basic__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "Shape": () => (/* reexport module object */ _standard__WEBPACK_IMPORTED_MODULE_1__)
/* harmony export */ });
/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic */ 61967);
/* harmony import */ var _standard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./standard */ 58424);




/***/ }),

/***/ 7484:
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/circle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Circle": () => (/* binding */ Circle)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 77069);

const Circle = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('circle', {
  attrs: {
    body: {
      refCx: '50%',
      refCy: '50%',
      refR: '50%'
    }
  }
});

/***/ }),

/***/ 75492:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/cylinder.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cylinder": () => (/* binding */ Cylinder)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ 20287);


const CYLINDER_TILT = 10;
const Cylinder = _base__WEBPACK_IMPORTED_MODULE_1__.Base.define({
  shape: 'cylinder',
  overwrite: true,
  markup: [{
    tagName: 'path',
    selector: 'body'
  }, {
    tagName: 'ellipse',
    selector: 'top'
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    body: Object.assign(Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_1__.Base.bodyAttr), {
      lateral: CYLINDER_TILT
    }),
    top: Object.assign(Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_1__.Base.bodyAttr), {
      refCx: '50%',
      refRx: '50%',
      cy: CYLINDER_TILT,
      ry: CYLINDER_TILT
    })
  },
  attrHooks: {
    lateral: {
      set(t, {
        refBBox
      }) {
        const isPercentage = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(t);

        if (isPercentage) {
          // eslint-disable-next-line
          t = parseFloat(t) / 100;
        }

        const x = refBBox.x;
        const y = refBBox.y;
        const w = refBBox.width;
        const h = refBBox.height; // curve control point variables

        const rx = w / 2;
        const ry = isPercentage ? h * t : t;
        const kappa = 0.551784;
        const cx = kappa * rx;
        const cy = kappa * ry; // shape variables

        const xLeft = x;
        const xCenter = x + w / 2;
        const xRight = x + w;
        const ySideTop = y + ry;
        const yCurveTop = ySideTop - ry;
        const ySideBottom = y + h - ry;
        const yCurveBottom = y + h; // return calculated shape

        const data = ['M', xLeft, ySideTop, 'L', xLeft, ySideBottom, 'C', x, ySideBottom + cy, xCenter - cx, yCurveBottom, xCenter, yCurveBottom, 'C', xCenter + cx, yCurveBottom, xRight, ySideBottom + cy, xRight, ySideBottom, 'L', xRight, ySideTop, 'C', xRight, ySideTop - cy, xCenter + cx, yCurveTop, xCenter, yCurveTop, 'C', xCenter - cx, yCurveTop, xLeft, ySideTop - cy, xLeft, ySideTop, 'Z'];
        return {
          d: data.join(' ')
        };
      }

    }
  },
  knob: {
    enabled: true,

    position({
      node
    }) {
      const lateral = node.attr('body/lateral');
      return {
        x: 0,
        y: lateral
      };
    },

    onMouseMove({
      node,
      data,
      deltaY
    }) {
      if (deltaY !== 0) {
        const bbox = node.getBBox();
        const previous = node.attr('body/lateral');

        if (data.round == null) {
          data.round = previous;
        }

        const min = 0;
        const max = bbox.height / 2;
        const current = _util__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(data.round + deltaY, min, max);

        if (current !== previous) {
          node.attr({
            body: {
              lateral: current
            },
            top: {
              cy: current,
              ry: current
            }
          });
        }
      }
    }

  }
});

/***/ }),

/***/ 42876:
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/edge-doubled.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DoubleEdge": () => (/* binding */ DoubleEdge)
/* harmony export */ });
/* harmony import */ var _model_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/edge */ 51257);

const DoubleEdge = _model_edge__WEBPACK_IMPORTED_MODULE_0__.Edge.define({
  shape: 'double-edge',
  markup: [{
    tagName: 'path',
    selector: 'outline',
    attrs: {
      fill: 'none'
    }
  }, {
    tagName: 'path',
    selector: 'line',
    attrs: {
      fill: 'none',
      cursor: 'pointer'
    }
  }],
  attrs: {
    line: {
      connection: true,
      stroke: '#dddddd',
      strokeWidth: 4,
      strokeLinejoin: 'round',
      targetMarker: {
        tagName: 'path',
        stroke: '#000000',
        d: 'M 10 -3 10 -10 -2 0 10 10 10 3'
      }
    },
    outline: {
      connection: true,
      stroke: '#000000',
      strokeWidth: 6,
      strokeLinejoin: 'round'
    }
  }
});

/***/ }),

/***/ 56614:
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/edge-shadow.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShadowEdge": () => (/* binding */ ShadowEdge)
/* harmony export */ });
/* harmony import */ var _model_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/edge */ 51257);

const ShadowEdge = _model_edge__WEBPACK_IMPORTED_MODULE_0__.Edge.define({
  shape: 'shadow-edge',
  markup: [{
    tagName: 'path',
    selector: 'shadow',
    attrs: {
      fill: 'none'
    }
  }, {
    tagName: 'path',
    selector: 'line',
    attrs: {
      fill: 'none',
      cursor: 'pointer'
    }
  }],
  attrs: {
    line: {
      connection: true,
      stroke: '#FF0000',
      strokeWidth: 20,
      strokeLinejoin: 'round',
      targetMarker: {
        name: 'path',
        stroke: 'none',
        d: 'M 0 -10 -10 0 0 10 z',
        offsetX: -5
      },
      sourceMarker: {
        name: 'path',
        stroke: 'none',
        d: 'M -10 -10 0 0 -10 10 0 10 0 -10 z',
        offsetX: -5
      }
    },
    shadow: {
      connection: true,
      refX: 3,
      refY: 6,
      stroke: '#000000',
      strokeOpacity: 0.2,
      strokeWidth: 20,
      strokeLinejoin: 'round',
      targetMarker: {
        name: 'path',
        d: 'M 0 -10 -10 0 0 10 z',
        stroke: 'none',
        offsetX: -5
      },
      sourceMarker: {
        name: 'path',
        stroke: 'none',
        d: 'M -10 -10 0 0 -10 10 0 10 0 -10 z',
        offsetX: -5
      }
    }
  }
});

/***/ }),

/***/ 34973:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/edge.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Edge": () => (/* binding */ Edge)
/* harmony export */ });
/* harmony import */ var _model_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/edge */ 51257);

const Edge = _model_edge__WEBPACK_IMPORTED_MODULE_0__.Edge.define({
  shape: 'edge',
  markup: [{
    tagName: 'path',
    selector: 'wrap',
    groupSelector: 'lines',
    attrs: {
      fill: 'none',
      cursor: 'pointer',
      stroke: 'transparent',
      strokeLinecap: 'round'
    }
  }, {
    tagName: 'path',
    selector: 'line',
    groupSelector: 'lines',
    attrs: {
      fill: 'none',
      pointerEvents: 'none'
    }
  }],
  attrs: {
    lines: {
      connection: true,
      strokeLinejoin: 'round'
    },
    wrap: {
      strokeWidth: 10
    },
    line: {
      stroke: '#333',
      strokeWidth: 2,
      targetMarker: 'classic'
    }
  }
});

/***/ }),

/***/ 37162:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/ellipse.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ellipse": () => (/* binding */ Ellipse)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 77069);

const Ellipse = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('ellipse', {
  attrs: {
    body: {
      refCx: '50%',
      refCy: '50%',
      refRx: '50%',
      refRy: '50%'
    }
  }
});

/***/ }),

/***/ 82403:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Empty": () => (/* binding */ Empty)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ 20287);

const Empty = _base__WEBPACK_IMPORTED_MODULE_0__.Base.define({
  shape: 'empty'
});

/***/ }),

/***/ 74057:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HTML": () => (/* binding */ HTML)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../registry */ 73306);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view */ 29818);
/* harmony import */ var _model_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/node */ 21738);
/* harmony import */ var _view_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/node */ 78415);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base */ 20287);





class HTML extends _base__WEBPACK_IMPORTED_MODULE_4__.Base {
  get html() {
    return this.getHTML();
  }

  set html(val) {
    this.setHTML(val);
  }

  getHTML() {
    return this.store.get('html');
  }

  setHTML(html, options = {}) {
    if (html == null) {
      this.removeHTML(options);
    } else {
      this.store.set('html', html, options);
    }

    return this;
  }

  removeHTML(options = {}) {
    return this.store.remove('html', options);
  }

}

(function (HTML) {
  class View extends _view_node__WEBPACK_IMPORTED_MODULE_3__.NodeView {
    init() {
      super.init();
      this.cell.on('change:*', () => {
        const shouldUpdate = this.graph.hook.shouldUpdateHTMLComponent(this.cell);

        if (shouldUpdate) {
          this.renderHTMLComponent();
        }
      });
    }

    confirmUpdate(flag) {
      const ret = super.confirmUpdate(flag);
      return this.handleAction(ret, View.action, () => this.renderHTMLComponent());
    }

    renderHTMLComponent() {
      const container = this.selectors.foContent;

      if (container) {
        const $wrap = this.$(container).empty();
        const component = this.graph.hook.getHTMLComponent(this.cell);

        if (component) {
          if (typeof component === 'string') {
            $wrap.html(component);
          } else {
            $wrap.append(component);
          }
        }
      }
    }

  }

  HTML.View = View;

  (function (View) {
    View.action = 'html';
    View.config({
      bootstrap: [View.action],
      actions: {
        html: View.action
      }
    });
    _view_node__WEBPACK_IMPORTED_MODULE_3__.NodeView.registry.register('html-view', View);
  })(View = HTML.View || (HTML.View = {}));
})(HTML || (HTML = {}));

(function (HTML) {
  HTML.config({
    view: 'html-view',
    markup: [{
      tagName: 'rect',
      selector: 'body'
    }, Object.assign({}, _view__WEBPACK_IMPORTED_MODULE_1__.Markup.getForeignObjectMarkup()), {
      tagName: 'text',
      selector: 'label'
    }],
    attrs: {
      body: {
        fill: 'none',
        stroke: 'none',
        refWidth: '100%',
        refHeight: '100%'
      },
      fo: {
        refWidth: '100%',
        refHeight: '100%'
      }
    }
  });
  _model_node__WEBPACK_IMPORTED_MODULE_2__.Node.registry.register('html', HTML);
})(HTML || (HTML = {}));

(function (HTML) {
  HTML.componentRegistry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
    type: 'html componnet'
  });
})(HTML || (HTML = {}));

/***/ }),

/***/ 72059:
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/image-bordered.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BorderedImage": () => (/* binding */ BorderedImage)
/* harmony export */ });
/* harmony import */ var _basic_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/util */ 72993);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 77069);


const BorderedImage = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('image-bordered', {
  markup: [{
    tagName: 'rect',
    selector: 'background',
    attrs: {
      stroke: 'none'
    }
  }, {
    tagName: 'image',
    selector: 'image'
  }, {
    tagName: 'rect',
    selector: 'border',
    attrs: {
      fill: 'none'
    }
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    background: {
      refWidth: -1,
      refHeight: -1,
      x: 0.5,
      y: 0.5,
      fill: '#ffffff'
    },
    border: {
      refWidth: '100%',
      refHeight: '100%',
      stroke: '#333333',
      strokeWidth: 2
    },
    image: {
      // xlinkHref: '[URL]'
      refWidth: -1,
      refHeight: -1,
      x: 0.5,
      y: 0.5
    }
  },
  propHooks: (0,_basic_util__WEBPACK_IMPORTED_MODULE_0__.getImageUrlHook)()
});

/***/ }),

/***/ 35663:
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/image-embedded.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EmbeddedImage": () => (/* binding */ EmbeddedImage)
/* harmony export */ });
/* harmony import */ var _basic_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/util */ 72993);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 77069);


const EmbeddedImage = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('image-embedded', {
  markup: [{
    tagName: 'rect',
    selector: 'body'
  }, {
    tagName: 'image',
    selector: 'image'
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    body: {
      refWidth: '100%',
      refHeight: '100%',
      stroke: '#333333',
      fill: '#FFFFFF',
      strokeWidth: 2
    },
    image: {
      // xlinkHref: '[URL]'
      refWidth: '30%',
      refHeight: -20,
      x: 10,
      y: 10,
      preserveAspectRatio: 'xMidYMin'
    }
  },
  propHooks: (0,_basic_util__WEBPACK_IMPORTED_MODULE_0__.getImageUrlHook)()
});

/***/ }),

/***/ 51989:
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/image-inscribed.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InscribedImage": () => (/* binding */ InscribedImage)
/* harmony export */ });
/* harmony import */ var _basic_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/util */ 72993);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 77069);


const InscribedImage = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('image-inscribed', {
  propHooks: (0,_basic_util__WEBPACK_IMPORTED_MODULE_0__.getImageUrlHook)(),
  markup: [{
    tagName: 'ellipse',
    selector: 'background'
  }, {
    tagName: 'image',
    selector: 'image'
  }, {
    tagName: 'ellipse',
    selector: 'border',
    attrs: {
      fill: 'none'
    }
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    border: {
      refRx: '50%',
      refRy: '50%',
      refCx: '50%',
      refCy: '50%',
      stroke: '#333333',
      strokeWidth: 2
    },
    background: {
      refRx: '50%',
      refRy: '50%',
      refCx: '50%',
      refCy: '50%',
      fill: '#ffffff'
    },
    image: {
      // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%
      refWidth: '68%',
      refHeight: '68%',
      // The image offset is calculated as (100% - 68%) / 2
      refX: '16%',
      refY: '16%',
      preserveAspectRatio: 'xMidYMid' // xlinkHref: '[URL]'

    } // label: {
    //   refX: '50%',
    //   refY: '100%',
    //   refY2: 10,
    //   textAnchor: 'middle',
    //   textVerticalAnchor: 'top',
    // },

  }
});

/***/ }),

/***/ 89186:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/image.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Image": () => (/* binding */ Image)
/* harmony export */ });
/* harmony import */ var _basic_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basic/util */ 72993);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 77069);


const Image = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('image', {
  attrs: {
    image: {
      refWidth: '100%',
      refHeight: '100%'
    }
  },
  propHooks: (0,_basic_util__WEBPACK_IMPORTED_MODULE_0__.getImageUrlHook)()
}, {
  selector: 'image'
});

/***/ }),

/***/ 58424:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BorderedImage": () => (/* reexport safe */ _image_bordered__WEBPACK_IMPORTED_MODULE_11__.BorderedImage),
/* harmony export */   "Circle": () => (/* reexport safe */ _circle__WEBPACK_IMPORTED_MODULE_3__.Circle),
/* harmony export */   "Cylinder": () => (/* reexport safe */ _cylinder__WEBPACK_IMPORTED_MODULE_4__.Cylinder),
/* harmony export */   "DoubleEdge": () => (/* reexport safe */ _edge_doubled__WEBPACK_IMPORTED_MODULE_16__.DoubleEdge),
/* harmony export */   "Edge": () => (/* reexport safe */ _edge__WEBPACK_IMPORTED_MODULE_14__.Edge),
/* harmony export */   "Ellipse": () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_5__.Ellipse),
/* harmony export */   "EmbeddedImage": () => (/* reexport safe */ _image_embedded__WEBPACK_IMPORTED_MODULE_12__.EmbeddedImage),
/* harmony export */   "Empty": () => (/* reexport safe */ _empty__WEBPACK_IMPORTED_MODULE_0__.Empty),
/* harmony export */   "HTML": () => (/* reexport safe */ _html__WEBPACK_IMPORTED_MODULE_17__.HTML),
/* harmony export */   "HeaderedRect": () => (/* reexport safe */ _rect_headered__WEBPACK_IMPORTED_MODULE_2__.HeaderedRect),
/* harmony export */   "Image": () => (/* reexport safe */ _image__WEBPACK_IMPORTED_MODULE_10__.Image),
/* harmony export */   "InscribedImage": () => (/* reexport safe */ _image_inscribed__WEBPACK_IMPORTED_MODULE_13__.InscribedImage),
/* harmony export */   "Path": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.Path),
/* harmony export */   "Polygon": () => (/* reexport safe */ _polygon__WEBPACK_IMPORTED_MODULE_6__.Polygon),
/* harmony export */   "Polyline": () => (/* reexport safe */ _polyline__WEBPACK_IMPORTED_MODULE_7__.Polyline),
/* harmony export */   "Rect": () => (/* reexport safe */ _rect__WEBPACK_IMPORTED_MODULE_1__.Rect),
/* harmony export */   "ShadowEdge": () => (/* reexport safe */ _edge_shadow__WEBPACK_IMPORTED_MODULE_15__.ShadowEdge),
/* harmony export */   "TextBlock": () => (/* reexport safe */ _text_block__WEBPACK_IMPORTED_MODULE_9__.TextBlock)
/* harmony export */ });
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./empty */ 82403);
/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect */ 98114);
/* harmony import */ var _rect_headered__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rect-headered */ 23940);
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./circle */ 7484);
/* harmony import */ var _cylinder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cylinder */ 75492);
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ellipse */ 37162);
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./polygon */ 9546);
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polyline */ 99075);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./path */ 80708);
/* harmony import */ var _text_block__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./text-block */ 35039);
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./image */ 89186);
/* harmony import */ var _image_bordered__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./image-bordered */ 72059);
/* harmony import */ var _image_embedded__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./image-embedded */ 35663);
/* harmony import */ var _image_inscribed__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./image-inscribed */ 51989);
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./edge */ 34973);
/* harmony import */ var _edge_shadow__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./edge-shadow */ 56614);
/* harmony import */ var _edge_doubled__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./edge-doubled */ 42876);
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./html */ 74057);



















/***/ }),

/***/ 80708:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/path.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Path": () => (/* binding */ Path)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ 20287);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const Path = _base__WEBPACK_IMPORTED_MODULE_1__.Base.define({
  shape: 'path',
  markup: [{
    tagName: 'rect',
    selector: 'bg'
  }, {
    tagName: 'path',
    selector: 'body'
  }, {
    tagName: 'text',
    selector: 'label'
  }],
  attrs: {
    bg: {
      refWidth: '100%',
      refHeight: '100%',
      fill: 'none',
      stroke: 'none',
      pointerEvents: 'all'
    },
    body: {
      fill: 'none',
      stroke: '#000',
      strokeWidth: 2
    }
  },

  propHooks(metadata) {
    const {
      path
    } = metadata,
          others = __rest(metadata, ["path"]);

    if (path) {
      _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.setByPath(others, 'attrs/body/refD', path);
    }

    return others;
  }

});

/***/ }),

/***/ 66050:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/poly.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Poly": () => (/* binding */ Poly)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ 20287);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ 44650);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




class Poly extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
  get points() {
    return this.getPoints();
  }

  set points(pts) {
    this.setPoints(pts);
  }

  getPoints() {
    return this.getAttrByPath('body/refPoints');
  }

  setPoints(points, options) {
    if (points == null) {
      this.removePoints();
    } else {
      this.setAttrByPath('body/refPoints', Poly.pointsToString(points), options);
    }

    return this;
  }

  removePoints() {
    this.removeAttrByPath('body/refPoints');
    return this;
  }

}

(function (Poly) {
  function pointsToString(points) {
    return typeof points === 'string' ? points : points.map(p => {
      if (Array.isArray(p)) {
        return p.join(',');
      }

      if (_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(p)) {
        return `${p.x}, ${p.y}`;
      }

      return '';
    }).join(' ');
  }

  Poly.pointsToString = pointsToString;
  Poly.config({
    propHooks(metadata) {
      const {
        points
      } = metadata,
            others = __rest(metadata, ["points"]);

      if (points) {
        const data = pointsToString(points);

        if (data) {
          _util__WEBPACK_IMPORTED_MODULE_2__.ObjectExt.setByPath(others, 'attrs/body/refPoints', data);
        }
      }

      return others;
    }

  });
})(Poly || (Poly = {}));

/***/ }),

/***/ 9546:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/polygon.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Polygon": () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var _poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./poly */ 66050);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 77069);


const Polygon = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('polygon', {}, {
  parent: _poly__WEBPACK_IMPORTED_MODULE_0__.Poly
});

/***/ }),

/***/ 99075:
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/polyline.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Polyline": () => (/* binding */ Polyline)
/* harmony export */ });
/* harmony import */ var _poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./poly */ 66050);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ 77069);


const Polyline = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('polyline', {}, {
  parent: _poly__WEBPACK_IMPORTED_MODULE_0__.Poly
});

/***/ }),

/***/ 23940:
/*!******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/rect-headered.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HeaderedRect": () => (/* binding */ HeaderedRect)
/* harmony export */ });
/* harmony import */ var _model_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/node */ 21738);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ 20287);


const HeaderedRect = _model_node__WEBPACK_IMPORTED_MODULE_0__.Node.define({
  shape: 'rect-headered',
  markup: [{
    tagName: 'rect',
    selector: 'body'
  }, {
    tagName: 'rect',
    selector: 'header'
  }, {
    tagName: 'text',
    selector: 'headerText'
  }, {
    tagName: 'text',
    selector: 'bodyText'
  }],
  attrs: {
    body: Object.assign(Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_1__.Base.bodyAttr), {
      refWidth: '100%',
      refHeight: '100%'
    }),
    header: Object.assign(Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_1__.Base.bodyAttr), {
      refWidth: '100%',
      height: 30,
      stroke: '#000000'
    }),
    headerText: Object.assign(Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_1__.Base.labelAttr), {
      refX: '50%',
      refY: 15,
      fontSize: 16
    }),
    bodyText: Object.assign(Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_1__.Base.labelAttr), {
      refY2: 15
    })
  }
});

/***/ }),

/***/ 98114:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/rect.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rect": () => (/* binding */ Rect)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 77069);

const Rect = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('rect', {
  attrs: {
    body: {
      refWidth: '100%',
      refHeight: '100%'
    }
  }
});

/***/ }),

/***/ 35039:
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/text-block.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextBlock": () => (/* binding */ TextBlock)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../registry */ 73306);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base */ 20287);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




const TextBlock = _base__WEBPACK_IMPORTED_MODULE_2__.Base.define({
  shape: 'text-block',
  markup: [{
    tagName: 'rect',
    selector: 'body'
  }, _util__WEBPACK_IMPORTED_MODULE_0__.Platform.SUPPORT_FOREIGNOBJECT ? {
    tagName: 'foreignObject',
    selector: 'foreignObject',
    children: [{
      tagName: 'div',
      ns: _util__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.xhtml,
      selector: 'label',
      style: {
        width: '100%',
        height: '100%',
        position: 'static',
        backgroundColor: 'transparent',
        textAlign: 'center',
        margin: 0,
        padding: '0px 5px',
        boxSizing: 'border-box',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }
    }]
  } : {
    tagName: 'text',
    selector: 'label',
    attrs: {
      textAnchor: 'middle'
    }
  }],
  attrs: {
    body: Object.assign(Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_2__.Base.bodyAttr), {
      refWidth: '100%',
      refHeight: '100%'
    }),
    foreignObject: {
      refWidth: '100%',
      refHeight: '100%'
    },
    label: {
      style: {
        fontSize: 14
      }
    }
  },

  propHooks(metadata) {
    const {
      text
    } = metadata,
          others = __rest(metadata, ["text"]);

    if (text) {
      _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.setByPath(others, 'attrs/label/text', text);
    }

    return others;
  },

  attrHooks: {
    text: {
      set(text, {
        cell,
        view,
        refBBox,
        elem,
        attrs
      }) {
        if (elem instanceof HTMLElement) {
          elem.textContent = text;
        } else {
          // No foreign object
          const style = attrs.style || {};
          const wrapValue = {
            text,
            width: -5,
            height: '100%'
          };
          const wrapAttrs = Object.assign({
            textVerticalAnchor: 'middle'
          }, style);
          const textWrap = _registry__WEBPACK_IMPORTED_MODULE_1__.Attr.presets.textWrap;
          _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(textWrap.set, this, wrapValue, {
            cell,
            view,
            elem,
            refBBox,
            attrs: wrapAttrs
          });
          return {
            fill: style.color || null
          };
        }
      },

      position(text, {
        refBBox,
        elem
      }) {
        if (elem instanceof SVGElement) {
          return refBBox.getCenter();
        }
      }

    }
  }
});

/***/ }),

/***/ 77069:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/standard/util.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createShape": () => (/* binding */ createShape),
/* harmony export */   "getMarkup": () => (/* binding */ getMarkup)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ 44650);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ 20287);


function getMarkup(tagName, selector = 'body') {
  return [{
    tagName,
    selector
  }, {
    tagName: 'text',
    selector: 'label'
  }];
}
function createShape(shape, config, options = {}) {
  const defaults = {
    constructorName: shape,
    markup: getMarkup(shape, options.selector),
    attrs: {
      [shape]: Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_1__.Base.bodyAttr)
    }
  };
  const base = options.parent || _base__WEBPACK_IMPORTED_MODULE_1__.Base;
  return base.define(_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(defaults, config, {
    shape
  }));
}

/***/ }),

/***/ 23919:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/style/raw.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "content": () => (/* binding */ content)
/* harmony export */ });
/* eslint-disable */

/**
 * Auto generated file, do not modify it!
 */
const content = `.x6-graph {
  position: relative;
  outline: none;
}
.x6-graph-background,
.x6-graph-grid,
.x6-graph-svg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-background-stage,
.x6-graph-grid-stage,
.x6-graph-svg-stage {
  user-select: none;
}
.x6-graph.x6-graph-pannable {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph.x6-graph-panning {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-node {
  cursor: move;
  /* stylelint-disable-next-line */
}
.x6-node.x6-node-immovable {
  cursor: default;
}
.x6-node * {
  -webkit-user-drag: none;
}
.x6-node .scalable * {
  vector-effect: non-scaling-stroke;
}
.x6-node [magnet='true'] {
  cursor: crosshair;
  transition: opacity 0.3s;
}
.x6-node [magnet='true']:hover {
  opacity: 0.7;
}
.x6-node foreignObject {
  display: block;
  overflow: visible;
  background-color: transparent;
}
.x6-node foreignObject > body {
  position: static;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: visible;
  background-color: transparent;
}
.x6-edge .source-marker,
.x6-edge .target-marker {
  vector-effect: non-scaling-stroke;
}
.x6-edge .connection {
  stroke-linejoin: round;
  fill: none;
}
.x6-edge .connection-wrap {
  cursor: move;
  opacity: 0;
  fill: none;
  stroke: #000;
  stroke-width: 15;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.x6-edge .connection-wrap:hover {
  opacity: 0.4;
  stroke-opacity: 0.4;
}
.x6-edge .vertices {
  cursor: move;
  opacity: 0;
}
.x6-edge .vertices .vertex {
  fill: #1abc9c;
}
.x6-edge .vertices .vertex :hover {
  fill: #34495e;
  stroke: none;
}
.x6-edge .vertices .vertex-remove {
  cursor: pointer;
  fill: #fff;
}
.x6-edge .vertices .vertex-remove-area {
  cursor: pointer;
  opacity: 0.1;
}
.x6-edge .vertices .vertex-group:hover .vertex-remove-area {
  opacity: 1;
}
.x6-edge .arrowheads {
  cursor: move;
  opacity: 0;
}
.x6-edge .arrowheads .arrowhead {
  fill: #1abc9c;
}
.x6-edge .arrowheads .arrowhead :hover {
  fill: #f39c12;
  stroke: none;
}
.x6-edge .tools {
  cursor: pointer;
  opacity: 0;
}
.x6-edge .tools .tool-options {
  display: none;
}
.x6-edge .tools .tool-remove circle {
  fill: #f00;
}
.x6-edge .tools .tool-remove path {
  fill: #fff;
}
.x6-edge:hover .vertices,
.x6-edge:hover .arrowheads,
.x6-edge:hover .tools {
  opacity: 1;
}
.x6-highlight-opacity {
  opacity: 0.3;
}
@keyframes halo-pie-visibility {
  0% {
    visibility: hidden;
  }
  100% {
    visibility: visible;
  }
}
@keyframes halo-pie-opening {
  0% {
    transform: scale(0.4) rotate(-20deg);
  }
  100% {
    transform: scale(1) rotate(0);
  }
}
.x6-widget-handle {
  position: absolute;
  width: 20px;
  height: 20px;
  background-color: transparent;
  background-repeat: no-repeat;
  background-position: 0 0;
  background-size: 20px 20px;
  cursor: pointer;
  user-select: none;
  pointer-events: auto;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-handle.hidden {
  display: none;
}
.x6-widget-handle-selected {
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
}
.x6-widget-handle-remove {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15.386%2C3.365c-3.315-3.314-8.707-3.313-12.021%2C0c-3.314%2C3.315-3.314%2C8.706%2C0%2C12.02%20c3.314%2C3.314%2C8.707%2C3.314%2C12.021%2C0S18.699%2C6.68%2C15.386%2C3.365L15.386%2C3.365z%20M4.152%2C14.598C1.273%2C11.719%2C1.273%2C7.035%2C4.153%2C4.154%20c2.88-2.88%2C7.563-2.88%2C10.443%2C0c2.881%2C2.88%2C2.881%2C7.562%2C0%2C10.443C11.716%2C17.477%2C7.032%2C17.477%2C4.152%2C14.598L4.152%2C14.598z%22%2F%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.157%2C11.371L7.38%2C6.593C7.162%2C6.375%2C6.809%2C6.375%2C6.592%2C6.592c-0.218%2C0.219-0.218%2C0.572%2C0%2C0.79%20l4.776%2C4.776c0.218%2C0.219%2C0.571%2C0.219%2C0.79%2C0C12.375%2C11.941%2C12.375%2C11.588%2C12.157%2C11.371L12.157%2C11.371z%22%2F%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M11.369%2C6.593l-4.777%2C4.778c-0.217%2C0.217-0.217%2C0.568%2C0%2C0.787c0.219%2C0.219%2C0.571%2C0.217%2C0.788%2C0l4.777-4.777%20c0.218-0.218%2C0.218-0.571%2C0.001-0.789C11.939%2C6.375%2C11.587%2C6.375%2C11.369%2C6.593L11.369%2C6.593z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
  cursor: pointer;
}
.x6-widget-handle-remove:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15.386%2C3.365c-3.315-3.314-8.707-3.313-12.021%2C0c-3.314%2C3.315-3.314%2C8.706%2C0%2C12.02%20c3.314%2C3.314%2C8.707%2C3.314%2C12.021%2C0S18.699%2C6.68%2C15.386%2C3.365L15.386%2C3.365z%22%2F%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M12.157%2C11.371L7.38%2C6.593C7.162%2C6.375%2C6.809%2C6.375%2C6.592%2C6.592c-0.218%2C0.219-0.218%2C0.572%2C0%2C0.79%20l4.776%2C4.776c0.218%2C0.219%2C0.571%2C0.219%2C0.79%2C0C12.375%2C11.941%2C12.375%2C11.588%2C12.157%2C11.371L12.157%2C11.371z%22%2F%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M11.369%2C6.593l-4.777%2C4.778c-0.217%2C0.217-0.217%2C0.568%2C0%2C0.787c0.219%2C0.219%2C0.571%2C0.217%2C0.788%2C0l4.777-4.777%20c0.218-0.218%2C0.218-0.571%2C0.001-0.789C11.939%2C6.375%2C11.587%2C6.375%2C11.369%2C6.593L11.369%2C6.593z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-rotate {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M9.374%2C17.592c-4.176%2C0-7.57-3.401-7.57-7.575c0-4.175%2C3.395-7.574%2C7.57-7.574c0.28%2C0%2C0.56%2C0.018%2C0.837%2C0.05%20V1.268c0-0.158%2C0.099-0.3%2C0.239-0.36c0.151-0.058%2C0.315-0.026%2C0.428%2C0.086l2.683%2C2.688c0.152%2C0.154%2C0.152%2C0.399%2C0%2C0.553l-2.68%2C2.693%20c-0.115%2C0.112-0.279%2C0.147-0.431%2C0.087c-0.141-0.063-0.239-0.205-0.239-0.361V5.296C9.934%2C5.243%2C9.654%2C5.22%2C9.374%2C5.22%20c-2.646%2C0-4.796%2C2.152-4.796%2C4.797s2.154%2C4.798%2C4.796%2C4.798c2.645%2C0%2C4.798-2.153%2C4.798-4.798c0-0.214%2C0.174-0.391%2C0.391-0.391h1.991%20c0.217%2C0%2C0.394%2C0.177%2C0.394%2C0.391C16.947%2C14.19%2C13.549%2C17.592%2C9.374%2C17.592L9.374%2C17.592z%20M9.374%2C17.592%22%2F%3E%3C%2Fsvg%3E%20');
  cursor: move;
}
.x6-widget-handle-rotate:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M9.374%2C17.592c-4.176%2C0-7.57-3.401-7.57-7.575c0-4.175%2C3.395-7.574%2C7.57-7.574c0.28%2C0%2C0.56%2C0.018%2C0.837%2C0.05%20V1.268c0-0.158%2C0.099-0.3%2C0.239-0.36c0.151-0.058%2C0.315-0.026%2C0.428%2C0.086l2.683%2C2.688c0.152%2C0.154%2C0.152%2C0.399%2C0%2C0.553l-2.68%2C2.693%20c-0.115%2C0.112-0.279%2C0.147-0.431%2C0.087c-0.141-0.063-0.239-0.205-0.239-0.361V5.296C9.934%2C5.243%2C9.654%2C5.22%2C9.374%2C5.22%20c-2.646%2C0-4.796%2C2.152-4.796%2C4.797s2.154%2C4.798%2C4.796%2C4.798c2.645%2C0%2C4.798-2.153%2C4.798-4.798c0-0.214%2C0.174-0.391%2C0.391-0.391h1.991%20c0.217%2C0%2C0.394%2C0.177%2C0.394%2C0.391C16.947%2C14.19%2C13.549%2C17.592%2C9.374%2C17.592L9.374%2C17.592z%20M9.374%2C17.592%22%2F%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-resize {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20height%3D%2224px%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20width%3D%2224px%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Asketch%3D%22http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch%2Fns%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Ctitle%2F%3E%3Cdesc%2F%3E%3Cdefs%2F%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%20id%3D%22miu%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%3E%3Cg%20id%3D%22Artboard-1%22%20transform%3D%22translate(-251.000000%2C%20-443.000000)%22%3E%3Cg%20id%3D%22slice%22%20transform%3D%22translate(215.000000%2C%20119.000000)%22%2F%3E%3Cpath%20d%3D%22M252%2C448%20L256%2C448%20L256%2C444%20L252%2C444%20L252%2C448%20Z%20M257%2C448%20L269%2C448%20L269%2C446%20L257%2C446%20L257%2C448%20Z%20M257%2C464%20L269%2C464%20L269%2C462%20L257%2C462%20L257%2C464%20Z%20M270%2C444%20L270%2C448%20L274%2C448%20L274%2C444%20L270%2C444%20Z%20M252%2C462%20L252%2C466%20L256%2C466%20L256%2C462%20L252%2C462%20Z%20M270%2C462%20L270%2C466%20L274%2C466%20L274%2C462%20L270%2C462%20Z%20M254%2C461%20L256%2C461%20L256%2C449%20L254%2C449%20L254%2C461%20Z%20M270%2C461%20L272%2C461%20L272%2C449%20L270%2C449%20L270%2C461%20Z%22%20fill%3D%22%236A6C8A%22%20id%3D%22editor-crop-glyph%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E');
  cursor: se-resize;
}
.x6-widget-handle-resize:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3Csvg%20height%3D%2224px%22%20version%3D%221.1%22%20viewBox%3D%220%200%2024%2024%22%20width%3D%2224px%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Asketch%3D%22http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch%2Fns%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Ctitle%2F%3E%3Cdesc%2F%3E%3Cdefs%2F%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%20id%3D%22miu%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%3E%3Cg%20id%3D%22Artboard-1%22%20transform%3D%22translate(-251.000000%2C%20-443.000000)%22%3E%3Cg%20id%3D%22slice%22%20transform%3D%22translate(215.000000%2C%20119.000000)%22%2F%3E%3Cpath%20d%3D%22M252%2C448%20L256%2C448%20L256%2C444%20L252%2C444%20L252%2C448%20Z%20M257%2C448%20L269%2C448%20L269%2C446%20L257%2C446%20L257%2C448%20Z%20M257%2C464%20L269%2C464%20L269%2C462%20L257%2C462%20L257%2C464%20Z%20M270%2C444%20L270%2C448%20L274%2C448%20L274%2C444%20L270%2C444%20Z%20M252%2C462%20L252%2C466%20L256%2C466%20L256%2C462%20L252%2C462%20Z%20M270%2C462%20L270%2C466%20L274%2C466%20L274%2C462%20L270%2C462%20Z%20M254%2C461%20L256%2C461%20L256%2C449%20L254%2C449%20L254%2C461%20Z%20M270%2C461%20L272%2C461%20L272%2C449%20L270%2C449%20L270%2C461%20Z%22%20fill%3D%22%23FD6EB6%22%20id%3D%22editor-crop-glyph%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E');
}
.x6-widget-handle-clone {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.852%2C0.875h-9.27c-0.853%2C0-1.547%2C0.694-1.547%2C1.547v10.816h1.547V2.422h9.27V0.875z%20M15.172%2C3.965h-8.5%20c-0.849%2C0-1.547%2C0.698-1.547%2C1.547v10.816c0%2C0.849%2C0.698%2C1.547%2C1.547%2C1.547h8.5c0.85%2C0%2C1.543-0.698%2C1.543-1.547V5.512%20C16.715%2C4.663%2C16.021%2C3.965%2C15.172%2C3.965L15.172%2C3.965z%20M15.172%2C16.328h-8.5V5.512h8.5V16.328z%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
  cursor: move;
}
.x6-widget-handle-clone:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M12.852%2C0.875h-9.27c-0.853%2C0-1.547%2C0.694-1.547%2C1.547v10.816h1.547V2.422h9.27V0.875z%20M15.172%2C3.965h-8.5%20c-0.849%2C0-1.547%2C0.698-1.547%2C1.547v10.816c0%2C0.849%2C0.698%2C1.547%2C1.547%2C1.547h8.5c0.849%2C0%2C1.543-0.698%2C1.543-1.547V5.512%20C16.715%2C4.663%2C16.021%2C3.965%2C15.172%2C3.965L15.172%2C3.965z%20M15.172%2C16.328h-8.5V5.512h8.5V16.328z%20M15.172%2C16.328%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-link {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M9.884%2C9.838c0.54-0.551%2C1.005-0.955%2C1.384-1.201c0.463-0.308%2C0.749-0.352%2C0.887-0.352h1.34v1.367%20c0%2C0.104%2C0.061%2C0.2%2C0.154%2C0.242s0.204%2C0.027%2C0.284-0.038l3.168-2.669c0.06-0.051%2C0.096-0.125%2C0.096-0.203S17.16%2C6.83%2C17.101%2C6.781%20l-3.168-2.677c-0.08-0.067-0.19-0.081-0.284-0.038c-0.094%2C0.045-0.154%2C0.139-0.154%2C0.242v1.414h-1.343%20c-1.24%2C0.014-2.215%2C0.67-2.927%2C1.242c-0.797%2C0.65-1.533%2C1.447-2.245%2C2.217c-0.361%2C0.391-0.7%2C0.759-1.044%2C1.1%20c-0.541%2C0.549-1.011%2C0.951-1.395%2C1.199c-0.354%2C0.231-0.678%2C0.357-0.921%2C0.357h-1.8c-0.146%2C0-0.266%2C0.12-0.266%2C0.265v2.029%20c0%2C0.148%2C0.12%2C0.268%2C0.266%2C0.268h1.8l0%2C0c1.255-0.014%2C2.239-0.667%2C2.958-1.24c0.82-0.661%2C1.572-1.475%2C2.297-2.256%20C9.225%2C10.524%2C9.555%2C10.169%2C9.884%2C9.838z%22%2F%3E%3C%2Fsvg%3E%20');
  cursor: move;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
}
.x6-widget-handle-link:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M9.884%2C9.838c0.54-0.551%2C1.005-0.955%2C1.384-1.201c0.463-0.308%2C0.749-0.352%2C0.887-0.352h1.34v1.367%20c0%2C0.104%2C0.061%2C0.2%2C0.154%2C0.242s0.204%2C0.027%2C0.284-0.038l3.168-2.669c0.06-0.051%2C0.096-0.125%2C0.096-0.203S17.16%2C6.83%2C17.101%2C6.781%20l-3.168-2.677c-0.08-0.067-0.19-0.081-0.284-0.038c-0.094%2C0.045-0.154%2C0.139-0.154%2C0.242v1.414h-1.343%20c-1.24%2C0.014-2.215%2C0.67-2.927%2C1.242c-0.797%2C0.65-1.533%2C1.447-2.245%2C2.217c-0.361%2C0.391-0.7%2C0.759-1.044%2C1.1%20c-0.541%2C0.549-1.011%2C0.951-1.395%2C1.199c-0.354%2C0.231-0.678%2C0.357-0.921%2C0.357h-1.8c-0.146%2C0-0.266%2C0.12-0.266%2C0.265v2.029%20c0%2C0.148%2C0.12%2C0.268%2C0.266%2C0.268h1.8l0%2C0c1.255-0.014%2C2.239-0.667%2C2.958-1.24c0.82-0.661%2C1.572-1.475%2C2.297-2.256%20C9.225%2C10.524%2C9.555%2C10.169%2C9.884%2C9.838z%22%2F%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-fork {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%236A6C8A%22%20d%3D%22M13.307%2C11.593c-0.69%2C0-1.299%2C0.33-1.693%2C0.835l-4.136-2.387%20C7.552%2C9.82%2C7.602%2C9.589%2C7.602%2C9.344c0-0.25-0.051-0.487-0.129-0.71l4.097-2.364c0.393%2C0.536%2C1.022%2C0.888%2C1.737%2C0.888%20c1.193%2C0%2C2.16-0.967%2C2.16-2.159s-0.967-2.159-2.16-2.159c-1.191%2C0-2.158%2C0.967-2.158%2C2.159c0%2C0.076%2C0.014%2C0.149%2C0.021%2C0.223%20L6.848%2C7.716C6.469%2C7.39%2C5.982%2C7.185%2C5.442%2C7.185c-1.191%2C0-2.158%2C0.967-2.158%2C2.159s0.967%2C2.159%2C2.158%2C2.159%20c0.545%2C0%2C1.037-0.208%2C1.417-0.541l4.319%2C2.493c-0.014%2C0.098-0.029%2C0.194-0.029%2C0.296c0%2C1.193%2C0.967%2C2.159%2C2.158%2C2.159%20c1.193%2C0%2C2.16-0.966%2C2.16-2.159C15.467%2C12.559%2C14.5%2C11.593%2C13.307%2C11.593z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
  cursor: move;
}
.x6-widget-handle-fork:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20fill%3D%22%23FD6EB6%22%20d%3D%22M13.307%2C11.593c-0.69%2C0-1.299%2C0.33-1.693%2C0.835l-4.136-2.387%20c0.075-0.22%2C0.125-0.452%2C0.125-0.697c0-0.25-0.051-0.487-0.129-0.71l4.097-2.365c0.394%2C0.536%2C1.022%2C0.888%2C1.737%2C0.888%20c1.193%2C0%2C2.16-0.967%2C2.16-2.159s-0.967-2.159-2.16-2.159c-1.191%2C0-2.158%2C0.967-2.158%2C2.159c0%2C0.076%2C0.015%2C0.148%2C0.022%2C0.223%20L6.848%2C7.716C6.469%2C7.39%2C5.981%2C7.185%2C5.442%2C7.185c-1.191%2C0-2.158%2C0.967-2.158%2C2.159s0.967%2C2.159%2C2.158%2C2.159%20c0.545%2C0%2C1.037-0.208%2C1.417-0.541l4.319%2C2.493c-0.013%2C0.098-0.029%2C0.194-0.029%2C0.296c0%2C1.193%2C0.967%2C2.159%2C2.158%2C2.159%20c1.193%2C0%2C2.16-0.966%2C2.16-2.159C15.467%2C12.559%2C14.5%2C11.593%2C13.307%2C11.593z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-unlink {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M12.285%2C9.711l-2.104-0.302L9.243%2C8.568L6.669%2C7.095C6.948%2C6.6%2C6.995%2C6.026%2C6.845%2C5.474%20c-0.191-0.698-0.695-1.36-1.438-1.786C4.068%2C2.922%2C2.464%2C3.214%2C1.82%2C4.338C1.536%2C4.836%2C1.489%2C5.414%2C1.64%2C5.97%20c0.189%2C0.698%2C0.694%2C1.36%2C1.438%2C1.787c0.328%2C0.187%2C0.67%2C0.31%2C1.01%2C0.372c0.002%2C0%2C0.006%2C0.002%2C0.008%2C0.004%20c0.027%2C0.004%2C0.057%2C0.009%2C0.088%2C0.011c2.12%2C0.316%2C3.203%2C0.915%2C3.73%2C1.337c-0.527%2C0.424-1.61%2C1.021-3.731%2C1.339%20c-0.029%2C0.003-0.058%2C0.007-0.087%2C0.012c-0.002%2C0.002-0.004%2C0.002-0.007%2C0.003c-0.341%2C0.062-0.684%2C0.187-1.013%2C0.374%20c-0.74%2C0.425-1.246%2C1.089-1.437%2C1.787c-0.149%2C0.555-0.105%2C1.133%2C0.181%2C1.632c0.011%2C0.018%2C0.021%2C0.033%2C0.033%2C0.049l0.883%2C0.783%20c0.765%2C0.366%2C1.775%2C0.328%2C2.67-0.184c0.744-0.425%2C1.248-1.088%2C1.439-1.786c0.148-0.552%2C0.104-1.126-0.176-1.62l2.573-1.473%20c0.573%2C0.287%2C2.299%2C1.292%2C2.299%2C1.292s3.602%2C1.445%2C4.241%2C1.812c0.773%2C0.191%2C0.566-0.151%2C0.566-0.151L12.285%2C9.711z%20M5.571%2C6.482%20C5.279%2C6.993%2C4.425%2C7.076%2C3.705%2C6.664C3.282%2C6.424%2C2.966%2C6.039%2C2.856%2C5.64C2.81%2C5.464%2C2.778%2C5.203%2C2.917%2C4.963%20c0.291-0.51%2C1.146-0.593%2C1.866-0.182C5.21%2C5.027%2C5.521%2C5.4%2C5.632%2C5.807C5.679%2C5.98%2C5.708%2C6.242%2C5.571%2C6.482z%20M5.632%2C13.159%20c-0.111%2C0.406-0.422%2C0.778-0.848%2C1.025c-0.719%2C0.409-1.576%2C0.327-1.867-0.184c-0.137-0.239-0.106-0.499-0.06-0.676%20c0.108-0.398%2C0.426-0.781%2C0.847-1.022c0.72-0.412%2C1.574-0.329%2C1.866%2C0.181C5.708%2C12.723%2C5.679%2C12.983%2C5.632%2C13.159z%20M16.181%2C5.139%20c-0.448%2C0.258-4.435%2C1.9-4.435%2C1.9s-1.556%2C0.855-2.104%2C1.13l0.937%2C0.843l2.057-0.229l4.11-3.638%20C16.745%2C5.146%2C17.013%2C4.664%2C16.181%2C5.139z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-unlink:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%20width%3D%2218.75px%22%20height%3D%2218.75px%22%20viewBox%3D%220%200%2018.75%2018.75%22%20enable-background%3D%22new%200%200%2018.75%2018.75%22%20xml%3Aspace%3D%22preserve%22%3E%3Cg%3E%3Cg%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M12.285%2C9.711l-2.104-0.302L9.243%2C8.568L6.669%2C7.095C6.948%2C6.6%2C6.995%2C6.026%2C6.845%2C5.474%20c-0.191-0.698-0.695-1.36-1.438-1.786C4.068%2C2.922%2C2.464%2C3.214%2C1.82%2C4.338C1.536%2C4.836%2C1.489%2C5.414%2C1.64%2C5.97%20c0.189%2C0.698%2C0.694%2C1.36%2C1.438%2C1.787c0.328%2C0.187%2C0.67%2C0.31%2C1.01%2C0.372c0.002%2C0%2C0.006%2C0.002%2C0.008%2C0.004%20c0.027%2C0.004%2C0.057%2C0.009%2C0.088%2C0.011c2.12%2C0.316%2C3.203%2C0.915%2C3.73%2C1.337c-0.527%2C0.424-1.61%2C1.021-3.731%2C1.339%20c-0.029%2C0.003-0.058%2C0.007-0.087%2C0.012c-0.002%2C0.002-0.004%2C0.002-0.007%2C0.003c-0.341%2C0.062-0.684%2C0.187-1.013%2C0.374%20c-0.74%2C0.425-1.246%2C1.089-1.437%2C1.787c-0.149%2C0.555-0.105%2C1.133%2C0.181%2C1.632c0.011%2C0.018%2C0.021%2C0.033%2C0.033%2C0.049l0.883%2C0.783%20c0.765%2C0.366%2C1.775%2C0.328%2C2.67-0.184c0.744-0.425%2C1.248-1.088%2C1.439-1.786c0.148-0.552%2C0.104-1.126-0.176-1.62l2.573-1.473%20c0.573%2C0.287%2C2.299%2C1.292%2C2.299%2C1.292s3.602%2C1.445%2C4.241%2C1.812c0.773%2C0.191%2C0.566-0.151%2C0.566-0.151L12.285%2C9.711z%20M5.571%2C6.482%20C5.279%2C6.993%2C4.425%2C7.076%2C3.705%2C6.664C3.282%2C6.424%2C2.966%2C6.039%2C2.856%2C5.64C2.81%2C5.464%2C2.778%2C5.203%2C2.917%2C4.963%20c0.291-0.51%2C1.146-0.593%2C1.866-0.182C5.21%2C5.027%2C5.521%2C5.4%2C5.632%2C5.807C5.679%2C5.98%2C5.708%2C6.242%2C5.571%2C6.482z%20M5.632%2C13.159%20c-0.111%2C0.406-0.422%2C0.778-0.848%2C1.025c-0.719%2C0.409-1.576%2C0.327-1.867-0.184c-0.137-0.239-0.106-0.499-0.06-0.676%20c0.108-0.398%2C0.426-0.781%2C0.847-1.022c0.72-0.412%2C1.574-0.329%2C1.866%2C0.181C5.708%2C12.723%2C5.679%2C12.983%2C5.632%2C13.159z%20M16.181%2C5.139%20c-0.448%2C0.258-4.435%2C1.9-4.435%2C1.9s-1.556%2C0.855-2.104%2C1.13l0.937%2C0.843l2.057-0.229l4.11-3.638%20C16.745%2C5.146%2C17.013%2C4.664%2C16.181%2C5.139z%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E%20');
}
.x6-widget-handle-direction {
  background-image: url("data:image/svg+xml;charset=UTF-8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20%20PUBLIC%20'-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN'%20%20'http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd'%3E%3Csvg%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%20512%20512%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%0A%09.st0%7Bfill%3A%236A6C8A%3Bstroke%3A%236A6C8A%3Bstroke-width%3A30%7D%0A%09.dot%7Bfill%3A%236A6C8A%3B%7D%0A%3C%2Fstyle%3E%3Cg%3E%3Cg%20id%3D%22XMLID_475_%22%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M133.1%2C277.1c1.8%2C0%2C3.7-0.6%2C5.4-1.7c4.1-3%2C5-8.7%2C2-12.8c-3-4.1-8.7-5-12.8-2c0%2C0%2C0%2C0%2C0%2C0%20%20%20%20%20c-4.1%2C3-5%2C8.7-2%2C12.8C127.5%2C275.8%2C130.3%2C277.1%2C133.1%2C277.1z%22%20id%3D%22XMLID_489_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M138.5%2C359.6c-4.1-3-9.8-2.1-12.8%2C2c-3%2C4.1-2.1%2C9.8%2C2%2C12.8c1.6%2C1.2%2C3.5%2C1.7%2C5.4%2C1.7%20%20%20%20%20c2.8%2C0%2C5.6-1.3%2C7.4-3.7C143.5%2C368.3%2C142.6%2C362.6%2C138.5%2C359.6z%22%20id%3D%22XMLID_726_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C327.7c-4.8%2C1.6-7.4%2C6.7-5.9%2C11.5c1.3%2C3.9%2C4.8%2C6.3%2C8.7%2C6.3c0.9%2C0%2C1.9-0.1%2C2.8-0.4%20%20%20%20%20c4.8-1.6%2C7.4-6.7%2C5.9-11.5C118%2C328.8%2C112.9%2C326.2%2C108.1%2C327.7z%22%20id%3D%22XMLID_776_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C307.3c0.9%2C0.3%2C1.9%2C0.4%2C2.8%2C0.4c3.8%2C0%2C7.4-2.4%2C8.7-6.3c1.6-4.8-1.1-9.9-5.9-11.5%20%20%20%20%20c-4.8-1.6-9.9%2C1.1-11.5%2C5.9C100.7%2C300.6%2C103.3%2C305.7%2C108.1%2C307.3z%22%20id%3D%22XMLID_777_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M169.2%2C265.4c2.4%2C0%2C4.7-1%2C6.5-2.6c1.7-1.7%2C2.7-4.1%2C2.7-6.5c0-2.4-1-4.8-2.7-6.5%20%20%20%20%20c-1.7-1.7-4.1-2.7-6.5-2.7s-4.7%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.5C164.4%2C264.4%2C166.8%2C265.4%2C169.2%2C265.4z%22%20id%3D%22XMLID_797_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M247.7%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C243.7%2C265.4%2C247.7%2C261.3%2C247.7%2C256.3z%22%20id%3D%22XMLID_798_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M213%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C208.9%2C265.4%2C213%2C261.3%2C213%2C256.3z%22%20id%3D%22XMLID_799_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M317.2%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C313.1%2C265.4%2C317.2%2C261.3%2C317.2%2C256.3z%22%20id%3D%22XMLID_800_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M282.5%2C256.3c0-5-4.1-9.1-9.1-9.1s-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20S282.5%2C261.3%2C282.5%2C256.3z%22%20id%3D%22XMLID_801_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M401.1%2C185.2c0.9%2C0%2C1.9-0.1%2C2.8-0.5c4.8-1.6%2C7.4-6.7%2C5.9-11.5c-1.6-4.8-6.7-7.4-11.5-5.8%20%20%20%20%20c-4.8%2C1.6-7.4%2C6.7-5.8%2C11.5C393.6%2C182.8%2C397.2%2C185.2%2C401.1%2C185.2z%22%20id%3D%22XMLID_802_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M403.9%2C205.2c-4.8-1.6-9.9%2C1-11.5%2C5.9l0%2C0c-1.6%2C4.8%2C1.1%2C9.9%2C5.9%2C11.5%20%20%20%20%20c0.9%2C0.3%2C1.9%2C0.5%2C2.8%2C0.5c3.9%2C0%2C7.4-2.5%2C8.7-6.3c0%2C0%2C0%2C0%2C0%2C0C411.3%2C211.9%2C408.7%2C206.8%2C403.9%2C205.2z%22%20id%3D%22XMLID_803_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C237.2L373.5%2C237.2c-4.1%2C3-5%2C8.7-2%2C12.8c1.8%2C2.4%2C4.6%2C3.7%2C7.4%2C3.7%20%20%20%20%20c1.8%2C0%2C3.7-0.6%2C5.4-1.8c4.1-3%2C4.9-8.7%2C2-12.8C383.3%2C235.1%2C377.6%2C234.2%2C373.5%2C237.2z%22%20id%3D%22XMLID_804_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C152.9c1.6%2C1.2%2C3.5%2C1.8%2C5.4%2C1.8c2.8%2C0%2C5.6-1.3%2C7.4-3.8c3-4.1%2C2.1-9.8-2-12.7%20%20%20%20%20c-4.1-3-9.8-2.1-12.7%2C2C368.5%2C144.2%2C369.4%2C149.9%2C373.5%2C152.9z%22%20id%3D%22XMLID_805_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M342.8%2C247.1c-2.4%2C0-4.8%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.4%20%20%20%20%20c1.7%2C1.7%2C4%2C2.7%2C6.5%2C2.7c2.4%2C0%2C4.7-1%2C6.5-2.7c1.7-1.7%2C2.7-4%2C2.7-6.4c0-2.4-1-4.8-2.7-6.5C347.6%2C248.1%2C345.2%2C247.1%2C342.8%2C247.1z%22%20id%3D%22XMLID_806_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M342.8%2C124.7H206.6l36.4-36.4c3.6-3.6%2C3.6-9.3%2C0-12.9c-3.6-3.6-9.3-3.6-12.9%2C0l-51.5%2C51.5%20%20%20%20%20c-1.9%2C1.9-2.8%2C4.4-2.7%2C6.9c-0.1%2C2.5%2C0.7%2C5%2C2.7%2C6.9l51.5%2C51.5c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7%20%20%20%20%20c3.6-3.6%2C3.6-9.3%2C0-12.9l-36.4-36.4h136.1c0%2C0%2C0.1%2C0%2C0.1%2C0c0.6%2C0%2C1.2-0.1%2C1.8-0.2c0.2%2C0%2C0.4-0.1%2C0.6-0.1c0.1%2C0%2C0.2%2C0%2C0.3-0.1%20%20%20%20%20c3.2-1%2C5.6-3.6%2C6.3-6.9c0.1-0.6%2C0.2-1.2%2C0.2-1.8c0-0.6-0.1-1.2-0.2-1.8C351%2C127.8%2C347.3%2C124.7%2C342.8%2C124.7z%22%20id%3D%22XMLID_807_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M322.1%2C371.3l-51.5-51.5c-3.6-3.6-9.3-3.6-12.9%2C0c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9l36.9%2C36.9H169.2%20%20%20%20%20c-2.8%2C0-5.4%2C1.3-7%2C3.3c-0.1%2C0.1-0.2%2C0.2-0.3%2C0.4c-0.1%2C0.1-0.2%2C0.2-0.2%2C0.3c-0.1%2C0.1-0.1%2C0.2-0.2%2C0.4c-0.1%2C0.1-0.2%2C0.3-0.2%2C0.4%20%20%20%20%20c0%2C0.1-0.1%2C0.2-0.1%2C0.2c-0.1%2C0.2-0.2%2C0.4-0.3%2C0.6c0%2C0%2C0%2C0%2C0%2C0.1c-0.4%2C1.1-0.7%2C2.2-0.7%2C3.4c0%2C1.5%2C0.4%2C2.9%2C1%2C4.2c0%2C0%2C0%2C0.1%2C0.1%2C0.1%20%20%20%20%20c0.1%2C0.1%2C0.1%2C0.2%2C0.2%2C0.3c0.4%2C0.7%2C0.9%2C1.3%2C1.4%2C1.8c0.4%2C0.4%2C0.7%2C0.7%2C1.2%2C1c0.1%2C0.1%2C0.1%2C0.1%2C0.2%2C0.2c0%2C0%2C0.1%2C0%2C0.1%2C0.1%20%20%20%20%20c1.4%2C0.9%2C3.1%2C1.5%2C5%2C1.5h124.4l-36%2C36c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7l51.5-51.5%20%20%20%20%20c1.9-1.9%2C2.8-4.4%2C2.7-6.9C324.8%2C375.7%2C324%2C373.2%2C322.1%2C371.3z%22%20id%3D%22XMLID_808_%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E");
}
.x6-widget-handle-direction:hover {
  background-image: url("data:image/svg+xml;charset=UTF-8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20%20PUBLIC%20'-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN'%20%20'http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd'%3E%3Csvg%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%20512%20512%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cstyle%20type%3D%22text%2Fcss%22%3E%0A%09.st0%7Bfill%3A%23FD6EB6%3Bstroke%3A%23FD6EB6%3Bstroke-width%3A30%7D%0A%09.dot%7Bfill%3A%23FD6EB6%3B%7D%0A%3C%2Fstyle%3E%3Cg%3E%3Cg%20id%3D%22XMLID_475_%22%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M133.1%2C277.1c1.8%2C0%2C3.7-0.6%2C5.4-1.7c4.1-3%2C5-8.7%2C2-12.8c-3-4.1-8.7-5-12.8-2c0%2C0%2C0%2C0%2C0%2C0%20%20%20%20%20c-4.1%2C3-5%2C8.7-2%2C12.8C127.5%2C275.8%2C130.3%2C277.1%2C133.1%2C277.1z%22%20id%3D%22XMLID_489_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M138.5%2C359.6c-4.1-3-9.8-2.1-12.8%2C2c-3%2C4.1-2.1%2C9.8%2C2%2C12.8c1.6%2C1.2%2C3.5%2C1.7%2C5.4%2C1.7%20%20%20%20%20c2.8%2C0%2C5.6-1.3%2C7.4-3.7C143.5%2C368.3%2C142.6%2C362.6%2C138.5%2C359.6z%22%20id%3D%22XMLID_726_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C327.7c-4.8%2C1.6-7.4%2C6.7-5.9%2C11.5c1.3%2C3.9%2C4.8%2C6.3%2C8.7%2C6.3c0.9%2C0%2C1.9-0.1%2C2.8-0.4%20%20%20%20%20c4.8-1.6%2C7.4-6.7%2C5.9-11.5C118%2C328.8%2C112.9%2C326.2%2C108.1%2C327.7z%22%20id%3D%22XMLID_776_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M108.1%2C307.3c0.9%2C0.3%2C1.9%2C0.4%2C2.8%2C0.4c3.8%2C0%2C7.4-2.4%2C8.7-6.3c1.6-4.8-1.1-9.9-5.9-11.5%20%20%20%20%20c-4.8-1.6-9.9%2C1.1-11.5%2C5.9C100.7%2C300.6%2C103.3%2C305.7%2C108.1%2C307.3z%22%20id%3D%22XMLID_777_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M169.2%2C265.4c2.4%2C0%2C4.7-1%2C6.5-2.6c1.7-1.7%2C2.7-4.1%2C2.7-6.5c0-2.4-1-4.8-2.7-6.5%20%20%20%20%20c-1.7-1.7-4.1-2.7-6.5-2.7s-4.7%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.5C164.4%2C264.4%2C166.8%2C265.4%2C169.2%2C265.4z%22%20id%3D%22XMLID_797_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M247.7%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C243.7%2C265.4%2C247.7%2C261.3%2C247.7%2C256.3z%22%20id%3D%22XMLID_798_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M213%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C208.9%2C265.4%2C213%2C261.3%2C213%2C256.3z%22%20id%3D%22XMLID_799_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M317.2%2C256.3c0-5-4.1-9.1-9.1-9.1c-5%2C0-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20C313.1%2C265.4%2C317.2%2C261.3%2C317.2%2C256.3z%22%20id%3D%22XMLID_800_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M282.5%2C256.3c0-5-4.1-9.1-9.1-9.1s-9.1%2C4.1-9.1%2C9.1c0%2C5%2C4.1%2C9.1%2C9.1%2C9.1%20%20%20%20%20S282.5%2C261.3%2C282.5%2C256.3z%22%20id%3D%22XMLID_801_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M401.1%2C185.2c0.9%2C0%2C1.9-0.1%2C2.8-0.5c4.8-1.6%2C7.4-6.7%2C5.9-11.5c-1.6-4.8-6.7-7.4-11.5-5.8%20%20%20%20%20c-4.8%2C1.6-7.4%2C6.7-5.8%2C11.5C393.6%2C182.8%2C397.2%2C185.2%2C401.1%2C185.2z%22%20id%3D%22XMLID_802_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M403.9%2C205.2c-4.8-1.6-9.9%2C1-11.5%2C5.9l0%2C0c-1.6%2C4.8%2C1.1%2C9.9%2C5.9%2C11.5%20%20%20%20%20c0.9%2C0.3%2C1.9%2C0.5%2C2.8%2C0.5c3.9%2C0%2C7.4-2.5%2C8.7-6.3c0%2C0%2C0%2C0%2C0%2C0C411.3%2C211.9%2C408.7%2C206.8%2C403.9%2C205.2z%22%20id%3D%22XMLID_803_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C237.2L373.5%2C237.2c-4.1%2C3-5%2C8.7-2%2C12.8c1.8%2C2.4%2C4.6%2C3.7%2C7.4%2C3.7%20%20%20%20%20c1.8%2C0%2C3.7-0.6%2C5.4-1.8c4.1-3%2C4.9-8.7%2C2-12.8C383.3%2C235.1%2C377.6%2C234.2%2C373.5%2C237.2z%22%20id%3D%22XMLID_804_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M373.5%2C152.9c1.6%2C1.2%2C3.5%2C1.8%2C5.4%2C1.8c2.8%2C0%2C5.6-1.3%2C7.4-3.8c3-4.1%2C2.1-9.8-2-12.7%20%20%20%20%20c-4.1-3-9.8-2.1-12.7%2C2C368.5%2C144.2%2C369.4%2C149.9%2C373.5%2C152.9z%22%20id%3D%22XMLID_805_%22%2F%3E%0A%3Cpath%20class%3D%22dot%22%20d%3D%22M342.8%2C247.1c-2.4%2C0-4.8%2C1-6.5%2C2.7c-1.7%2C1.7-2.7%2C4-2.7%2C6.5c0%2C2.4%2C1%2C4.7%2C2.7%2C6.4%20%20%20%20%20c1.7%2C1.7%2C4%2C2.7%2C6.5%2C2.7c2.4%2C0%2C4.7-1%2C6.5-2.7c1.7-1.7%2C2.7-4%2C2.7-6.4c0-2.4-1-4.8-2.7-6.5C347.6%2C248.1%2C345.2%2C247.1%2C342.8%2C247.1z%22%20id%3D%22XMLID_806_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M342.8%2C124.7H206.6l36.4-36.4c3.6-3.6%2C3.6-9.3%2C0-12.9c-3.6-3.6-9.3-3.6-12.9%2C0l-51.5%2C51.5%20%20%20%20%20c-1.9%2C1.9-2.8%2C4.4-2.7%2C6.9c-0.1%2C2.5%2C0.7%2C5%2C2.7%2C6.9l51.5%2C51.5c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7%20%20%20%20%20c3.6-3.6%2C3.6-9.3%2C0-12.9l-36.4-36.4h136.1c0%2C0%2C0.1%2C0%2C0.1%2C0c0.6%2C0%2C1.2-0.1%2C1.8-0.2c0.2%2C0%2C0.4-0.1%2C0.6-0.1c0.1%2C0%2C0.2%2C0%2C0.3-0.1%20%20%20%20%20c3.2-1%2C5.6-3.6%2C6.3-6.9c0.1-0.6%2C0.2-1.2%2C0.2-1.8c0-0.6-0.1-1.2-0.2-1.8C351%2C127.8%2C347.3%2C124.7%2C342.8%2C124.7z%22%20id%3D%22XMLID_807_%22%2F%3E%0A%3Cpath%20class%3D%22st0%22%20d%3D%22M322.1%2C371.3l-51.5-51.5c-3.6-3.6-9.3-3.6-12.9%2C0c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9l36.9%2C36.9H169.2%20%20%20%20%20c-2.8%2C0-5.4%2C1.3-7%2C3.3c-0.1%2C0.1-0.2%2C0.2-0.3%2C0.4c-0.1%2C0.1-0.2%2C0.2-0.2%2C0.3c-0.1%2C0.1-0.1%2C0.2-0.2%2C0.4c-0.1%2C0.1-0.2%2C0.3-0.2%2C0.4%20%20%20%20%20c0%2C0.1-0.1%2C0.2-0.1%2C0.2c-0.1%2C0.2-0.2%2C0.4-0.3%2C0.6c0%2C0%2C0%2C0%2C0%2C0.1c-0.4%2C1.1-0.7%2C2.2-0.7%2C3.4c0%2C1.5%2C0.4%2C2.9%2C1%2C4.2c0%2C0%2C0%2C0.1%2C0.1%2C0.1%20%20%20%20%20c0.1%2C0.1%2C0.1%2C0.2%2C0.2%2C0.3c0.4%2C0.7%2C0.9%2C1.3%2C1.4%2C1.8c0.4%2C0.4%2C0.7%2C0.7%2C1.2%2C1c0.1%2C0.1%2C0.1%2C0.1%2C0.2%2C0.2c0%2C0%2C0.1%2C0%2C0.1%2C0.1%20%20%20%20%20c1.4%2C0.9%2C3.1%2C1.5%2C5%2C1.5h124.4l-36%2C36c-3.6%2C3.6-3.6%2C9.3%2C0%2C12.9c1.8%2C1.8%2C4.1%2C2.7%2C6.5%2C2.7c2.3%2C0%2C4.7-0.9%2C6.5-2.7l51.5-51.5%20%20%20%20%20c1.9-1.9%2C2.8-4.4%2C2.7-6.9C324.8%2C375.7%2C324%2C373.2%2C322.1%2C371.3z%22%20id%3D%22XMLID_808_%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E");
}
.x6-widget-handle-surround .x6-widget-handle-animate .x6-widget-handle {
  transition: background-size 80ms, width 80ms, height 80ms, top 150ms, left 150ms, bottom 150ms, right 150ms;
}
.x6-widget-handle-surround .x6-widget-handle-pos-se {
  right: -25px;
  bottom: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-nw {
  top: -21px;
  left: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-n {
  top: -22px;
  left: 50%;
  margin-left: -10px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-e {
  top: -webkit-calc(40%);
  top: calc(50% - 10px);
  right: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-ne {
  top: -21px;
  right: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-w {
  top: 50%;
  left: -25px;
  margin-top: -10px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-sw {
  bottom: -25px;
  left: -25px;
}
.x6-widget-handle-surround .x6-widget-handle-pos-s {
  bottom: -24px;
  left: 50%;
  margin-left: -10px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle {
  width: 15px;
  height: 15px;
  font-size: 15px;
  background-size: 15px 15px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-se {
  right: -19px;
  bottom: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-nw {
  top: -19px;
  left: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-n {
  top: -19px;
  margin-left: -7.5px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-e {
  top: -webkit-calc(42%);
  top: calc(50% - 8px);
  right: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-ne {
  top: -19px;
  right: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-w {
  left: -19px;
  margin-top: -8px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-sw {
  bottom: -19px;
  left: -19px;
}
.x6-widget-handle-surround .x6-widget-handle-small .x6-widget-handle-pos-s {
  bottom: -19px;
  margin-left: -7.5px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle {
  width: 10px;
  height: 10px;
  font-size: 10px;
  background-size: 10px 10px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-se {
  right: -15px;
  bottom: -13px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-nw {
  top: -13px;
  left: -15px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-n {
  top: -13px;
  margin-left: -5px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-e {
  top: -webkit-calc(45%);
  top: calc(50% - 5px);
  right: -15px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-ne {
  top: -13px;
  right: -15px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-w {
  left: -15px;
  margin-top: -5px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-sw {
  bottom: -13px;
  left: -15px;
}
.x6-widget-handle-surround .x6-widget-handle-tiny .x6-widget-handle-pos-s {
  bottom: -13px;
  margin-left: -5px;
}
.x6-widget-handle-toolbar {
  position: absolute;
  top: -50px;
  display: table-row;
  padding: 7px 5px;
}
.x6-widget-handle-toolbar::after {
  position: absolute;
  top: 100%;
  left: 10px;
  width: 0;
  height: 0;
  margin-top: 4px;
  border-right: 10px solid transparent;
  border-left: 10px solid transparent;
  content: '';
}
.x6-widget-handle-toolbar .x6-widget-handle {
  position: relative;
  display: table-cell;
  min-width: 20px;
  margin: 0 2px;
  background-position: 3px 3px;
  background-size: 16px 16px;
}
.x6-widget-handle-toolbar .x6-widget-handle::after {
  position: absolute;
  bottom: -11px;
  width: 100%;
  content: '';
}
.x6-widget-handle-pie {
  position: absolute;
  top: -webkit-calc(0%);
  top: calc(50% - 50px);
  right: -50px;
  z-index: 1;
  display: none;
  width: 100px;
  height: 100px;
  margin: -2px -2px 0 0;
  border-radius: 50%;
  cursor: default;
  pointer-events: visiblePainted;
}
.x6-widget-handle-pie .x6-widget-handle {
  width: 1px;
  height: auto;
  pointer-events: visiblePainted;
}
.x6-widget-handle-pie-slice-svg {
  width: 100%;
  height: 100%;
  overflow: visible !important;
}
.x6-widget-handle-pie-slice-img,
.x6-widget-handle-pie-slice-txt {
  display: none;
  pointer-events: none;
}
.x6-widget-handle-pie[data-pie-toggle-position='e'] {
  top: calc(50% - 50px);
  right: -50px;
  left: auto;
}
.x6-widget-handle-pie[data-pie-toggle-position='w'] {
  top: calc(50% - 50px);
  right: auto;
  left: -52px;
}
.x6-widget-handle-pie[data-pie-toggle-position='n'] {
  top: -50px;
  right: auto;
  bottom: auto;
  left: calc(50% - 52px);
}
.x6-widget-handle-pie[data-pie-toggle-position='s'] {
  top: auto;
  right: auto;
  bottom: -52px;
  left: calc(50% - 52px);
}
.x6-widget-handle-pie-opened {
  display: block;
  animation: halo-pie-visibility 0.1s, halo-pie-opening 0.1s;
  animation-timing-function: step-end, ease;
  animation-delay: 0s, 0.1s;
}
.x6-widget-handle-pie-toggle {
  position: absolute;
  top: -webkit-calc(35%);
  top: calc(50% - 15px);
  right: -15px;
  z-index: 2;
  display: block;
  box-sizing: border-box;
  width: 30px;
  height: 30px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 20px 20px;
  border-radius: 50%;
  cursor: pointer;
  user-select: none;
  pointer-events: visiblePainted;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-handle-pie-toggle-pos-e {
  top: -webkit-calc(35%);
  top: calc(50% - 15px);
  right: -15px;
  bottom: auto;
  left: auto;
}
.x6-widget-handle-pie-toggle-pos-w {
  top: -webkit-calc(35%);
  top: calc(50% - 15px);
  right: auto;
  bottom: auto;
  left: -15px;
}
.x6-widget-handle-pie-toggle-pos-n {
  top: -15px;
  right: auto;
  bottom: auto;
  left: -webkit-calc(35%);
  left: calc(50% - 15px);
}
.x6-widget-handle-pie-toggle-pos-s {
  top: auto;
  right: auto;
  bottom: -15px;
  left: -webkit-calc(35%);
  left: calc(50% - 15px);
}
.x6-widget-handle-pie-toggle-opened {
  transition: 0.1s background-image;
}
.x6-widget-handle-toolbar {
  position: static;
  display: inline-block;
  margin-top: -50px;
  margin-left: 45px;
  white-space: nowrap;
  vertical-align: top;
  background-color: #f5f5f5;
  border-bottom: 3px solid #333;
  border-radius: 5px;
  box-shadow: 0 1px 2px #222;
}
.x6-widget-handle-toolbar::after {
  top: -12px;
  left: 55px;
  margin-top: 0;
  border-top: 6px solid #333;
  border-right: 10px solid transparent;
  border-left: 10px solid transparent;
}
.x6-widget-handle-toolbar .x6-widget-handle {
  display: inline-block;
  vertical-align: top;
}
.x6-widget-handle-toolbar .x6-widget-handle:hover::after {
  border-bottom: 4px solid #fc6cb8;
}
.x6-widget-handle-toolbar .x6-widget-handle-rotate {
  position: absolute;
  top: 100%;
  right: 100%;
  margin-top: 3px;
  margin-right: 6px;
}
.x6-widget-handle-toolbar .x6-widget-handle-remove:hover::after,
.x6-widget-handle-toolbar .x6-widget-handle-rotate:hover::after {
  border-bottom: none;
}
.x6-widget-handle-toolbar .x6-widget-handle + .x6-widget-handle {
  margin-left: 4px;
}
.x6-widget-handle-pie {
  box-sizing: content-box;
  background-color: #f5f5f5;
  border: 2px solid #404040;
}
.x6-widget-handle-pie-slice {
  fill: transparent;
  stroke: #e9e9e9;
  stroke-width: 1;
}
.x6-widget-handle-pie-slice:hover {
  fill: #fff;
}
.x6-widget-handle-pie-slice-img {
  display: block;
}
.x6-widget-handle-selected .x6-widget-handle-pie-slice {
  fill: #fff;
}
.x6-widget-handle-pie-toggle {
  background-color: #f6f6f6;
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20height%3D%2216px%22%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%2016%2016%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%20width%3D%2216px%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cpath%20fill%3D%22%236A6C8A%22%20d%3D%22M15%2C6h-5V1c0-0.55-0.45-1-1-1H7C6.45%2C0%2C6%2C0.45%2C6%2C1v5H1C0.45%2C6%2C0%2C6.45%2C0%2C7v2c0%2C0.55%2C0.45%2C1%2C1%2C1h5v5c0%2C0.55%2C0.45%2C1%2C1%2C1h2%20c0.55%2C0%2C1-0.45%2C1-1v-5h5c0.55%2C0%2C1-0.45%2C1-1V7C16%2C6.45%2C15.55%2C6%2C15%2C6z%22%2F%3E%3C%2Fsvg%3E');
  background-size: 16px 16px;
  border: 2px solid #3b425f;
}
.x6-widget-handle-pie-toggle:hover {
  background-color: #fff;
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20height%3D%2216px%22%20id%3D%22Layer_1%22%20style%3D%22enable-background%3Anew%200%200%2016%2016%3B%22%20version%3D%221.1%22%20viewBox%3D%220%200%2016%2016%22%20width%3D%2216px%22%20xml%3Aspace%3D%22preserve%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cpath%20fill%3D%22%23FD6EB6%22%20d%3D%22M15%2C6h-5V1c0-0.55-0.45-1-1-1H7C6.45%2C0%2C6%2C0.45%2C6%2C1v5H1C0.45%2C6%2C0%2C6.45%2C0%2C7v2c0%2C0.55%2C0.45%2C1%2C1%2C1h5v5c0%2C0.55%2C0.45%2C1%2C1%2C1h2%20c0.55%2C0%2C1-0.45%2C1-1v-5h5c0.55%2C0%2C1-0.45%2C1-1V7C16%2C6.45%2C15.55%2C6%2C15%2C6z%22%2F%3E%3C%2Fsvg%3E');
  border-color: #fd6eb6;
}
.x6-widget-handle-pie-toggle-opened {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20id%3D%22Layer_1%22%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%20id%3D%22defs7%22%20%2F%3E%3Cpath%20d%3D%22M%2015%2C6%2010%2C6%20C%201.0301983%2C6.00505%2015.002631%2C6.011353%206%2C6%20L%201%2C6%20C%200.45%2C6%200%2C6.45%200%2C7%20l%200%2C2%20c%200%2C0.55%200.45%2C1%201%2C1%20l%205%2C0%20c%208.988585%2C-0.019732%20-5.02893401%2C-0.018728%204%2C0%20l%205%2C0%20c%200.55%2C0%201%2C-0.45%201%2C-1%20L%2016%2C7%20C%2016%2C6.45%2015.55%2C6%2015%2C6%20z%22%20id%3D%22path3%22%20style%3D%22fill%3A%236a6c8a%22%20%2F%3E%3C%2Fsvg%3E');
}
.x6-widget-handle-pie-toggle-opened:hover {
  background-image: url('data:image/svg+xml;charset=utf8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%20standalone%3D%22no%22%3F%3E%3Csvg%20xmlns%3Adc%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Felements%2F1.1%2F%22%20xmlns%3Acc%3D%22http%3A%2F%2Fcreativecommons.org%2Fns%23%22%20xmlns%3Ardf%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2F02%2F22-rdf-syntax-ns%23%22%20xmlns%3Asvg%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20version%3D%221.1%22%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20id%3D%22Layer_1%22%20xml%3Aspace%3D%22preserve%22%3E%3Cmetadata%20id%3D%22metadata9%22%3E%3Crdf%3ARDF%3E%3Ccc%3AWork%20rdf%3Aabout%3D%22%22%3E%3Cdc%3Aformat%3Eimage%2Fsvg%2Bxml%3C%2Fdc%3Aformat%3E%3Cdc%3Atype%20rdf%3Aresource%3D%22http%3A%2F%2Fpurl.org%2Fdc%2Fdcmitype%2FStillImage%22%20%2F%3E%3Cdc%3Atitle%3E%3C%2Fdc%3Atitle%3E%3C%2Fcc%3AWork%3E%3C%2Frdf%3ARDF%3E%3C%2Fmetadata%3E%3Cdefs%20id%3D%22defs7%22%20%2F%3E%3Cpath%20d%3D%22M%2015%2C6%2010%2C6%20C%201.0301983%2C6.00505%2015.002631%2C6.011353%206%2C6%20L%201%2C6%20C%200.45%2C6%200%2C6.45%200%2C7%20l%200%2C2%20c%200%2C0.55%200.45%2C1%201%2C1%20l%205%2C0%20c%208.988585%2C-0.019732%20-5.02893401%2C-0.018728%204%2C0%20l%205%2C0%20c%200.55%2C0%201%2C-0.45%201%2C-1%20L%2016%2C7%20C%2016%2C6.45%2015.55%2C6%2015%2C6%20z%22%20id%3D%22path3%22%20style%3D%22fill%3A%23FD6EB6%22%20%2F%3E%3C%2Fsvg%3E');
}
.x6-widget-dnd {
  position: absolute;
  top: -10000px;
  left: -10000px;
  z-index: 999999;
  display: none;
  cursor: move;
  opacity: 0.7;
  pointer-events: 'cursor';
}
.x6-widget-dnd.dragging {
  display: inline-block;
}
.x6-widget-dnd.dragging * {
  pointer-events: none !important;
}
.x6-widget-dnd .x6-graph {
  background: transparent;
  box-shadow: none;
}
.x6-widget-halo {
  position: absolute;
  pointer-events: none;
}
.x6-widget-halo-content {
  position: absolute;
  top: 100%;
  padding: 6px;
  font-size: 10px;
  line-height: 14px;
  text-align: center;
  border-radius: 6px;
}
.x6-widget-halo-handles + .x6-widget-halo-content {
  right: -20px;
  left: -20px;
  margin-top: 30px;
}
.x6-widget-halo-handles.x6-widget-handle-small + .x6-widget-halo-content {
  margin-top: 25px;
}
.x6-widget-halo-handles.x6-widget-handle-small + .x6-widget-halo-content {
  margin-top: 20px;
}
.x6-widget-halo-handles.x6-widget-handle-pie + .x6-widget-halo-content {
  right: 0;
  left: 0;
  margin-top: 10px;
}
.x6-widget-halo-content {
  color: #fff;
  background-color: #6a6b8a;
}
.x6-widget-halo.type-node .x6-widget-handle-toolbar .x6-widget-handle-remove {
  position: absolute;
  right: 100%;
  bottom: 100%;
  margin-right: 6px;
  margin-bottom: 3px;
}
.x6-widget-halo.type-edge .x6-widget-handle-surround .x6-widget-handle-remove {
  background-color: #fff;
  border-radius: 50%;
}
.x6-widget-halo.type-edge .x6-widget-handle-toolbar {
  margin-top: -60px;
  margin-left: -18px;
}
.x6-widget-halo.type-edge .x6-widget-handle-toolbar::after {
  top: -22px;
  left: -9px;
}
.x6-widget-minimap {
  position: relative;
  display: table-cell;
  box-sizing: border-box;
  overflow: hidden;
  text-align: center;
  vertical-align: middle;
  background-color: #fff;
  user-select: none;
}
.x6-widget-minimap .x6-graph {
  display: inline-block;
  box-shadow: 0 0 4px 0 #eee;
  cursor: pointer;
}
.x6-widget-minimap .x6-graph > svg {
  pointer-events: none;
  shape-rendering: optimizeSpeed;
}
.x6-widget-minimap .x6-graph .x6-node * {
  /* stylelint-disable-next-line */
  vector-effect: initial;
}
.x6-widget-minimap-viewport {
  position: absolute;
  box-sizing: content-box !important;
  margin: -2px 0 0 -2px;
  border: 2px solid #31d0c6;
  cursor: move;
}
.x6-widget-minimap-viewport-zoom {
  position: absolute;
  right: 0;
  bottom: 0;
  box-sizing: border-box;
  width: 12px;
  height: 12px;
  margin: 0 -6px -6px 0;
  background-color: #fff;
  border: 2px solid #31d0c6;
  border-radius: 50%;
  cursor: nwse-resize;
}
.x6-graph-scroller {
  position: relative;
  box-sizing: border-box;
  overflow: scroll;
  outline: none;
}
.x6-graph-scroller-content {
  position: relative;
}
.x6-graph-scroller-background {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-scroller .x6-graph {
  position: absolute;
  display: inline-block;
  margin: 0;
  box-shadow: none;
}
.x6-graph-scroller .x6-graph > svg {
  display: block;
}
.x6-graph-scroller.x6-graph-scroller-paged .x6-graph {
  box-shadow: 0 0 4px 0 #eee;
}
.x6-graph-scroller.x6-graph-scroller-pannable[data-panning='false'] {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph-scroller.x6-graph-scroller-pannable[data-panning='true'] {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-graph-pagebreak {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-pagebreak-vertical {
  position: absolute;
  top: 0;
  bottom: 0;
  box-sizing: border-box;
  width: 1px;
  border-left: 1px dashed #bdbdbd;
}
.x6-graph-pagebreak-horizontal {
  position: absolute;
  right: 0;
  left: 0;
  box-sizing: border-box;
  height: 1px;
  border-top: 1px dashed #bdbdbd;
}
.x6-widget-selection {
  position: absolute;
  display: none;
  width: 0;
  height: 0;
  touch-action: none;
}
.x6-widget-selection-rubberband {
  display: block;
  overflow: visible;
  opacity: 0.3;
}
.x6-widget-selection-selected {
  display: block;
}
.x6-widget-selection-box {
  cursor: move;
}
.x6-widget-selection-inner[data-selection-length='0'],
.x6-widget-selection-inner[data-selection-length='1'] {
  display: none;
}
.x6-widget-selection-content {
  position: absolute;
  top: 100%;
  right: -20px;
  left: -20px;
  margin-top: 30px;
  padding: 6px;
  line-height: 14px;
  text-align: center;
  border-radius: 6px;
}
.x6-widget-selection-content:empty {
  display: none;
}
.x6-widget-selection-rubberband {
  background-color: #3498db;
  border: 2px solid #2980b9;
}
.x6-widget-selection-box {
  box-sizing: content-box !important;
  margin-top: -4px;
  margin-left: -4px;
  padding-right: 4px;
  padding-bottom: 4px;
  border: 2px dashed #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-inner {
  box-sizing: content-box !important;
  margin-top: -8px;
  margin-left: -8px;
  padding-right: 12px;
  padding-bottom: 12px;
  border: 2px solid #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-content {
  color: #fff;
  font-size: 10px;
  background-color: #6a6b8a;
}
.x6-widget-snapline {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  pointer-events: none;
}
.x6-widget-snapline-vertical,
.x6-widget-snapline-horizontal {
  stroke: #2ecc71;
  stroke-width: 1px;
}
.x6-widget-stencil {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-widget-stencil::after {
  position: absolute;
  top: 0;
  display: block;
  width: 100%;
  height: 20px;
  padding: 8px 0;
  line-height: 20px;
  text-align: center;
  opacity: 0;
  transition: top 0.1s linear, opacity 0.1s linear;
  content: ' ';
  pointer-events: none;
}
.x6-widget-stencil-content {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  height: auto;
  overflow-x: hidden;
  overflow-y: auto;
}
.x6-widget-stencil .x6-node [magnet]:not([magnet='passive']) {
  pointer-events: none;
}
.x6-widget-stencil-group {
  padding: 0;
  padding-bottom: 8px;
  overflow: hidden;
  user-select: none;
}
.x6-widget-stencil-group.collapsed {
  height: auto;
  padding-bottom: 0;
}
.x6-widget-stencil-group-title {
  position: relative;
  margin-top: 0;
  margin-bottom: 0;
  padding: 4px;
  cursor: pointer;
}
.x6-widget-stencil-title,
.x6-widget-stencil-group > .x6-widget-stencil-group-title {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  user-select: none;
}
.x6-widget-stencil .unmatched {
  opacity: 0.3;
}
.x6-widget-stencil .x6-node.unmatched {
  display: none;
}
.x6-widget-stencil-group.unmatched {
  display: none;
}
.x6-widget-stencil-search-text {
  position: relative;
  z-index: 1;
  box-sizing: border-box;
  width: 100%;
  height: 30px;
  max-height: 30px;
  line-height: 30px;
  outline: 0;
}
.x6-widget-stencil.not-found::after {
  opacity: 1;
  content: attr(data-not-found-text);
}
.x6-widget-stencil.not-found.searchable::after {
  top: 30px;
}
.x6-widget-stencil.not-found.searchable.collapsable::after {
  top: 50px;
}
.x6-widget-stencil {
  color: #333;
  background: #f5f5f5;
}
.x6-widget-stencil-content {
  position: absolute;
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-content {
  top: 32px;
}
.x6-widget-stencil.searchable > .x6-widget-stencil-content {
  top: 80px;
}
.x6-widget-stencil.not-found::after {
  position: absolute;
}
.x6-widget-stencil.not-found.searchable.collapsable::after {
  top: 80px;
}
.x6-widget-stencil.not-found.searchable::after {
  top: 60px;
}
.x6-widget-stencil-group {
  height: auto;
  margin-bottom: 1px;
  padding: 0;
  transition: none;
}
.x6-widget-stencil-group .x6-graph {
  background: transparent;
  box-shadow: none;
}
.x6-widget-stencil-group.collapsed {
  height: auto;
  max-height: 31px;
}
.x6-widget-stencil-title,
.x6-widget-stencil-group > .x6-widget-stencil-group-title {
  position: relative;
  left: 0;
  box-sizing: border-box;
  width: 100%;
  height: 32px;
  padding: 0 5px 0 8px;
  color: #666;
  font-weight: 700;
  font-size: 12px;
  line-height: 32px;
  cursor: default;
  transition: all 0.3;
}
.x6-widget-stencil-title:hover,
.x6-widget-stencil-group > .x6-widget-stencil-group-title:hover {
  color: #444;
}
.x6-widget-stencil-title {
  background: #e9e9e9;
}
.x6-widget-stencil-group > .x6-widget-stencil-group-title {
  background: #ededed;
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-title,
.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title {
  padding-left: 32px;
  cursor: pointer;
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-title::before,
.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title::before {
  position: absolute;
  top: 6px;
  left: 8px;
  display: block;
  width: 18px;
  height: 18px;
  margin: 0;
  padding: 0;
  background-color: transparent;
  background-repeat: no-repeat;
  background-position: 0 0;
  border: none;
  content: ' ';
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-title::before,
.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title::before {
  background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNOS4zNzUuNUM0LjY4Ny41Ljg3NSA0LjMxMy44NzUgOWMwIDQuNjg4IDMuODEyIDguNSA4LjUgOC41IDQuNjg3IDAgOC41LTMuODEyIDguNS04LjUgMC00LjY4Ny0zLjgxMy04LjUtOC41LTguNXptMCAxNS44ODZDNS4zMDMgMTYuMzg2IDEuOTkgMTMuMDcyIDEuOTkgOXMzLjMxMi03LjM4NSA3LjM4NS03LjM4NVMxNi43NiA0LjkyOCAxNi43NiA5YzAgNC4wNzItMy4zMTMgNy4zODYtNy4zODUgNy4zODZ6Ii8+PHBhdGggZD0iTTEyLjc1MyA4LjQ0M0g1Ljk5N2EuNTU4LjU1OCAwIDAwMCAxLjExNmg2Ljc1NmEuNTU4LjU1OCAwIDAwMC0xLjExNnoiLz48L2c+PC9zdmc+');
  opacity: 0.4;
  transition: all 0.3s;
}
.x6-widget-stencil.collapsable > .x6-widget-stencil-title:hover::before,
.x6-widget-stencil-group.collapsable > .x6-widget-stencil-group-title:hover::before {
  opacity: 0.6;
}
.x6-widget-stencil.collapsable.collapsed > .x6-widget-stencil-title::before,
.x6-widget-stencil-group.collapsable.collapsed > .x6-widget-stencil-group-title::before {
  background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNOS4zNzUuNUM0LjY4Ny41Ljg3NSA0LjMxMy44NzUgOWMwIDQuNjg4IDMuODEyIDguNSA4LjUgOC41IDQuNjg3IDAgOC41LTMuODEyIDguNS04LjUgMC00LjY4Ny0zLjgxMy04LjUtOC41LTguNXptMCAxNS44ODZDNS4zMDMgMTYuMzg2IDEuOTkgMTMuMDcyIDEuOTkgOXMzLjMxMi03LjM4NSA3LjM4NS03LjM4NVMxNi43NiA0LjkyOCAxNi43NiA5YzAgNC4wNzItMy4zMTMgNy4zODYtNy4zODUgNy4zODZ6Ii8+PHBhdGggZD0iTTEyLjc1MyA4LjQ0M0g1Ljk5N2EuNTU4LjU1OCAwIDAwMCAxLjExNmg2Ljc1NmEuNTU4LjU1OCAwIDAwMC0xLjExNnoiLz48cGF0aCBkPSJNOC44MTcgNS42MjN2Ni43NTZhLjU1OC41NTggMCAwMDEuMTE2IDBWNS42MjNhLjU1OC41NTggMCAxMC0xLjExNiAweiIvPjwvZz48L3N2Zz4=');
  opacity: 0.4;
}
.x6-widget-stencil.collapsable.collapsed > .x6-widget-stencil-title:hover::before,
.x6-widget-stencil-group.collapsable.collapsed > .x6-widget-stencil-group-title:hover::before {
  opacity: 0.6;
}
.x6-widget-stencil input[type='search'] {
  -webkit-appearance: textfield;
}
.x6-widget-stencil input[type='search']::-webkit-search-cancel-button,
.x6-widget-stencil input[type='search']::-webkit-search-decoration {
  -webkit-appearance: none;
}
.x6-widget-stencil-search-text {
  display: block;
  width: 90%;
  margin: 8px 5%;
  padding-left: 8px;
  color: #333;
  background: #fff;
  border: 1px solid #e9e9e9;
  border-radius: 12px;
  outline: 0;
}
.x6-widget-stencil-search-text:focus {
  outline: 0;
}
.x6-widget-stencil::after {
  color: #808080;
  font-weight: 600;
  font-size: 12px;
  background: 0 0;
}
.x6-widget-transform {
  position: absolute;
  box-sizing: content-box !important;
  margin: -5px 0 0 -5px;
  padding: 4px;
  border: 1px dashed #000;
  border-radius: 5px;
  user-select: none;
  pointer-events: none;
}
.x6-widget-transform > div {
  position: absolute;
  box-sizing: border-box;
  background-color: #fff;
  border: 1px solid #000;
  transition: background-color 0.2s;
  pointer-events: auto;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-transform > div:hover {
  background-color: #d3d3d3;
}
.x6-widget-transform-cursor-n {
  cursor: n-resize;
}
.x6-widget-transform-cursor-s {
  cursor: s-resize;
}
.x6-widget-transform-cursor-e {
  cursor: e-resize;
}
.x6-widget-transform-cursor-w {
  cursor: w-resize;
}
.x6-widget-transform-cursor-ne {
  cursor: ne-resize;
}
.x6-widget-transform-cursor-nw {
  cursor: nw-resize;
}
.x6-widget-transform-cursor-se {
  cursor: se-resize;
}
.x6-widget-transform-cursor-sw {
  cursor: sw-resize;
}
.x6-widget-transform-resize {
  width: 10px;
  height: 10px;
  border-radius: 6px;
}
.x6-widget-transform-resize[data-position='top-left'] {
  top: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='top-right'] {
  top: -5px;
  right: -5px;
}
.x6-widget-transform-resize[data-position='bottom-left'] {
  bottom: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='bottom-right'] {
  right: -5px;
  bottom: -5px;
}
.x6-widget-transform-resize[data-position='top'] {
  top: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='bottom'] {
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='left'] {
  top: 50%;
  left: -5px;
  margin-top: -5px;
}
.x6-widget-transform-resize[data-position='right'] {
  top: 50%;
  right: -5px;
  margin-top: -5px;
}
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='top'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='right'] {
  display: none;
}
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='right'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='top'] {
  display: none;
}
.x6-widget-transform.no-resize .x6-widget-transform-resize {
  display: none;
}
.x6-widget-transform-rotate {
  top: -20px;
  left: -20px;
  width: 12px;
  height: 12px;
  border-radius: 6px;
  cursor: crosshair;
}
.x6-widget-transform.no-rotate .x6-widget-transform-rotate {
  display: none;
}
.x6-widget-transform-active {
  border-color: transparent;
  pointer-events: all;
}
.x6-widget-transform-active > div {
  display: none;
}
.x6-widget-transform-active > .x6-widget-transform-active-handle {
  display: block;
  background-color: #808080;
}
.x6-widget-knob {
  position: absolute;
  box-sizing: border-box;
  width: 16px;
  height: 16px;
  margin-top: -8px;
  margin-left: -8px;
  cursor: pointer;
  user-select: none;
}
.x6-widget-knob::before,
.x6-widget-knob::after {
  position: absolute;
  transform: rotate(45deg);
  content: '';
}
.x6-widget-knob::before {
  top: 4px;
  left: 4px;
  box-sizing: border-box;
  width: 8px;
  height: 8px;
  background-color: #fff;
}
.x6-widget-knob::after {
  top: 5px;
  left: 5px;
  box-sizing: border-box;
  width: 6px;
  height: 6px;
  background-color: #fca000;
}
.x6-graph-print {
  position: relative;
}
.x6-graph-print .x6-graph-print-ready {
  display: none;
}
.x6-graph-print .x6-graph-print-preview {
  overflow: hidden !important;
  background: #fff !important;
}
@media print {
  html,
  html > body.x6-graph-printing {
    position: relative !important;
    width: 100% !important;
    height: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
  html > body.x6-graph-printing > * {
    display: none !important;
  }
  html > body.x6-graph-printing > .x6-graph-print {
    display: block !important;
  }
  .x6-graph-print {
    top: 0 !important;
    left: 0 !important;
    margin: 0 !important;
    padding: 0 !important;
    overflow: hidden !important;
    page-break-after: always;
    background: #fff !important;
  }
  .x6-graph-print .x6-graph-print-ready {
    display: none;
  }
}
.x6-cell-tool-editor {
  position: relative;
  display: inline-block;
  min-height: 1em;
  margin: 0;
  padding: 0;
  line-height: 1;
  white-space: normal;
  text-align: center;
  vertical-align: top;
  overflow-wrap: normal;
  outline: none;
  transform-origin: 0 0;
  -webkit-user-drag: none;
}
.x6-edge-tool-editor {
  border: 1px solid #275fc5;
  border-radius: 2px;
}
`;

/***/ }),

/***/ 49927:
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/types/common.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ 64060:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/types/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ModifierKey": () => (/* reexport safe */ _modifier__WEBPACK_IMPORTED_MODULE_1__.ModifierKey)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ 49927);
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifier */ 38857);



/***/ }),

/***/ 38857:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/types/modifier.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ModifierKey": () => (/* binding */ ModifierKey)
/* harmony export */ });
// eslint-disable-next-line
var ModifierKey;

(function (ModifierKey) {
  function parse(modifiers) {
    const or = [];
    const and = [];

    if (Array.isArray(modifiers)) {
      or.push(...modifiers);
    } else {
      modifiers.split('|').forEach(item => {
        if (item.indexOf('&') === -1) {
          or.push(item);
        } else {
          and.push(...item.split('&'));
        }
      });
    }

    return {
      or,
      and
    };
  }

  ModifierKey.parse = parse;

  function equals(modifiers1, modifiers2) {
    if (modifiers1 != null && modifiers2 != null) {
      const m1 = parse(modifiers1);
      const m2 = parse(modifiers2);
      const or1 = m1.or.sort();
      const or2 = m2.or.sort();
      const and1 = m1.and.sort();
      const and2 = m2.and.sort();

      const equal = (a1, a2) => {
        return a1.length === a2.length && (a1.length === 0 || a1.every((a, i) => a === a2[i]));
      };

      return equal(or1, or2) && equal(and1, and2);
    }

    if (modifiers1 == null && modifiers2 == null) {
      return true;
    }

    return false;
  }

  ModifierKey.equals = equals;

  function isMatch(e, modifiers, strict) {
    if (modifiers == null || Array.isArray(modifiers) && modifiers.length === 0) {
      return strict ? e.altKey !== true && e.ctrlKey !== true && e.metaKey !== true && e.shiftKey !== true : true;
    }

    const {
      or,
      and
    } = parse(modifiers);

    const match = key => {
      const name = `${key.toLowerCase()}Key`;
      return e[name] === true;
    };

    return or.some(key => match(key)) && and.every(key => match(key));
  }

  ModifierKey.isMatch = isMatch;
})(ModifierKey || (ModifierKey = {}));

/***/ }),

/***/ 53707:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/array/array.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "diff": () => (/* reexport safe */ _diff__WEBPACK_IMPORTED_MODULE_10__.diff),
/* harmony export */   "difference": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "groupBy": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "isArray": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "isArrayLike": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "max": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "sortBy": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "sortedIndex": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "sortedIndexBy": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "union": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "uniq": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ 17191);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ 83917);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ 65097);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ 96569);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ 86589);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ 26617);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ 75020);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ 69466);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ 84251);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ 41050);
/* harmony import */ var _diff__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./diff */ 30267);



/***/ }),

/***/ 30267:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/array/diff.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "diff": () => (/* binding */ diff)
/* harmony export */ });
function diff(oldList, newList, key) {
  const oldMap = makeKeyIndexAndFree(oldList, key);
  const newMap = makeKeyIndexAndFree(newList, key);
  const newFree = newMap.free;
  const oldKeyIndex = oldMap.keyIndex;
  const newKeyIndex = newMap.keyIndex;
  const moves = [];
  const children = [];
  let i = 0;
  let item;
  let itemKey;
  let freeIndex = 0;

  while (i < oldList.length) {
    item = oldList[i];
    itemKey = item[key];

    if (itemKey) {
      // eslint-disable-next-line
      if (!newKeyIndex.hasOwnProperty(itemKey)) {
        children.push(null);
      } else {
        const newItemIndex = newKeyIndex[itemKey];
        children.push(newList[newItemIndex]);
      }
    } else {
      freeIndex += 1;
      const freeItem = newFree[freeIndex];
      children.push(freeItem || null);
    }

    i += 1;
  }

  const simulateList = children.slice(0);
  i = 0;

  while (i < simulateList.length) {
    if (simulateList[i] === null) {
      remove(i);
      removeSimulate(i);
    } else {
      i += 1;
    }
  }

  let j = i = 0;

  while (i < newList.length) {
    item = newList[i];
    itemKey = item[key];
    const simulateItem = simulateList[j];

    if (simulateItem) {
      const simulateItemKey = simulateItem[key];

      if (itemKey === simulateItemKey) {
        j += 1;
      } else {
        // eslint-disable-next-line
        if (!oldKeyIndex.hasOwnProperty(itemKey)) {
          insert(i, item);
        } else {
          const nextSimulateItem = simulateList[j + 1];

          if (nextSimulateItem) {
            const nextItemKey = nextSimulateItem[key];

            if (nextItemKey === itemKey) {
              remove(i);
              removeSimulate(j);
              j += 1;
            } else {
              insert(i, item);
            }
          }
        }
      }
    } else {
      insert(i, item);
    }

    i += 1;
  }

  let k = simulateList.length - j;

  while ((j += 1) < simulateList.length) {
    k -= 1;
    remove(k + i);
  }

  function remove(index) {
    const move = {
      index,
      type: 0,
      item: null
    };
    moves.push(move);
  }

  function insert(index, item) {
    const move = {
      index,
      item,
      type: 1
    };
    moves.push(move);
  }

  function removeSimulate(index) {
    simulateList.splice(index, 1);
  }

  return {
    moves
  };
}

function makeKeyIndexAndFree(list, key) {
  const keyIndex = {};
  const free = [];

  for (let i = 0, len = list.length; i < len; i += 1) {
    const item = list[i];
    const itemKey = item[key];

    if (itemKey) {
      keyIndex[itemKey] = i;
    } else {
      free.push(item);
    }
  }

  return {
    keyIndex,
    free
  };
}

/***/ }),

/***/ 17573:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/array/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArrayExt": () => (/* reexport module object */ _array__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ 53707);



/***/ }),

/***/ 79568:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/datauri/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataUri": () => (/* binding */ DataUri)
/* harmony export */ });
var DataUri;

(function (DataUri) {
  function isDataUrl(url) {
    const prefix = 'data:';
    return url.substr(0, prefix.length) === prefix;
  }

  DataUri.isDataUrl = isDataUrl;
  /**
   * Converts an image at `url` to base64-encoded data uri.
   * The mime type of the image is inferred from the `url` file extension.
   */

  function imageToDataUri(url, callback) {
    // No need to convert to data uri if it is already in data uri.
    if (!url || isDataUrl(url)) {
      // Keep the async nature of the function.
      setTimeout(() => callback(null, url));
      return;
    }

    const onError = () => {
      callback(new Error(`Failed to load image: ${url}`));
    };

    const onLoad = window.FileReader ? // chrome, IE10+
    xhr => {
      if (xhr.status === 200) {
        const reader = new FileReader();

        reader.onload = evt => {
          const dataUri = evt.target.result;
          callback(null, dataUri);
        };

        reader.onerror = onError;
        reader.readAsDataURL(xhr.response);
      } else {
        onError();
      }
    } : xhr => {
      const toString = u8a => {
        const CHUNK_SZ = 0x8000;
        const c = [];

        for (let i = 0; i < u8a.length; i += CHUNK_SZ) {
          c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
        }

        return c.join('');
      };

      if (xhr.status === 200) {
        let suffix = url.split('.').pop() || 'png';

        if (suffix === 'svg') {
          suffix = 'svg+xml';
        }

        const meta = `data:image/${suffix};base64,`;
        const bytes = new Uint8Array(xhr.response);
        const base64 = meta + btoa(toString(bytes));
        callback(null, base64);
      } else {
        onError();
      }
    };
    const xhr = new XMLHttpRequest();
    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';
    xhr.open('GET', url, true);
    xhr.addEventListener('error', onError);
    xhr.addEventListener('load', () => onLoad(xhr));
    xhr.send();
  }

  DataUri.imageToDataUri = imageToDataUri;

  function dataUriToBlob(dataUrl) {
    let uri = dataUrl.replace(/\s/g, '');
    uri = decodeURIComponent(uri);
    const index = uri.indexOf(',');
    const dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'

    const mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'

    const data = uri.slice(index + 1);
    let decodedString;

    if (dataType.indexOf('base64') >= 0) {
      // data may be encoded in base64
      decodedString = atob(data);
    } else {
      // convert the decoded string to UTF-8
      decodedString = unescape(encodeURIComponent(data));
    } // write the bytes of the string to a typed array


    const ia = new Uint8Array(decodedString.length);

    for (let i = 0; i < decodedString.length; i += 1) {
      ia[i] = decodedString.charCodeAt(i);
    }

    return new Blob([ia], {
      type: mime
    });
  }

  DataUri.dataUriToBlob = dataUriToBlob;

  function downloadBlob(blob, fileName) {
    const msSaveBlob = window.navigator.msSaveBlob;

    if (msSaveBlob) {
      // requires IE 10+
      // pulls up a save dialog
      msSaveBlob(blob, fileName);
    } else {
      // other browsers
      // downloads directly in Chrome and Safari
      // presents a save/open dialog in Firefox
      // Firefox bug: `from` field in save dialog always shows `from:blob:`
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link); // mark the url for garbage collection

      window.URL.revokeObjectURL(url);
    }
  }

  DataUri.downloadBlob = downloadBlob;

  function downloadDataUri(dataUrl, fileName) {
    const blob = dataUriToBlob(dataUrl);
    downloadBlob(blob, fileName);
  }

  DataUri.downloadDataUri = downloadDataUri;

  function parseViewBox(svg) {
    const matches = svg.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);

    if (matches && matches[2]) {
      return matches[2].replace(/\s+/, ' ').split(' ');
    }

    return null;
  }

  function getNumber(str) {
    const ret = parseFloat(str);
    return Number.isNaN(ret) ? null : ret;
  }

  function svgToDataUrl(svg, options = {}) {
    let viewBox = null;

    const getNumberFromViewBox = index => {
      if (viewBox == null) {
        viewBox = parseViewBox(svg);
      }

      if (viewBox != null) {
        return getNumber(viewBox[index]);
      }

      return null;
    };

    const getNumberFromMatches = reg => {
      const matches = svg.match(reg);

      if (matches && matches[2]) {
        return getNumber(matches[2]);
      }

      return null;
    };

    let w = options.width;

    if (w == null) {
      w = getNumberFromMatches(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    }

    if (w == null) {
      w = getNumberFromViewBox(2);
    }

    if (w == null) {
      throw new Error('Can not parse width from svg string');
    }

    let h = options.height;

    if (h == null) {
      h = getNumberFromMatches(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    }

    if (h == null) {
      h = getNumberFromViewBox(3);
    }

    if (h == null) {
      throw new Error('Can not parse height from svg string');
    }

    const decoded = encodeURIComponent(svg).replace(/'/g, '%27').replace(/"/g, '%22');
    const header = 'data:image/svg+xml';
    const dataUrl = `${header},${decoded}`;
    return dataUrl;
  }

  DataUri.svgToDataUrl = svgToDataUrl;
})(DataUri || (DataUri = {}));

/***/ }),

/***/ 10693:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/af.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cancelAnimationFrame": () => (/* binding */ cancelAnimationFrame),
/* harmony export */   "requestAnimationFrame": () => (/* binding */ requestAnimationFrame)
/* harmony export */ });
const requestAnimationFrame = function () {
  let raf;
  const win = window;

  if (win != null) {
    raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame;

    if (raf != null) {
      raf = raf.bind(win);
    }
  }

  if (raf == null) {
    let lastTime = 0;

    raf = callback => {
      const currTime = new Date().getTime();
      const timeToCall = Math.max(0, 16 - (currTime - lastTime));
      const id = setTimeout(() => {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  return raf;
}();
const cancelAnimationFrame = function () {
  let caf;
  const win = window;

  if (win != null) {
    caf = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.webkitCancelRequestAnimationFrame || win.msCancelAnimationFrame || win.msCancelRequestAnimationFrame || win.oCancelAnimationFrame || win.oCancelRequestAnimationFrame || win.mozCancelAnimationFrame || win.mozCancelRequestAnimationFrame;

    if (caf) {
      caf = caf.bind(win);
    }
  }

  if (caf == null) {
    caf = clearTimeout;
  }

  return caf;
}();

/***/ }),

/***/ 11844:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/attr.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "getAttribute": () => (/* binding */ getAttribute),
/* harmony export */   "kebablizeAttrs": () => (/* binding */ kebablizeAttrs),
/* harmony export */   "mergeAttrs": () => (/* binding */ mergeAttrs),
/* harmony export */   "qualifyAttr": () => (/* binding */ qualifyAttr),
/* harmony export */   "removeAttribute": () => (/* binding */ removeAttribute),
/* harmony export */   "setAttribute": () => (/* binding */ setAttribute),
/* harmony export */   "setAttributes": () => (/* binding */ setAttributes),
/* harmony export */   "styleToObject": () => (/* binding */ styleToObject)
/* harmony export */ });
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elem */ 32076);
/* harmony import */ var _string_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../string/format */ 67763);


const CASE_SENSITIVE_ATTR = ['viewBox', 'attributeName', 'attributeType', 'repeatCount'];
function getAttribute(elem, name) {
  return elem.getAttribute(name);
}
function removeAttribute(elem, name) {
  const qualified = qualifyAttr(name);

  if (qualified.ns) {
    if (elem.hasAttributeNS(qualified.ns, qualified.local)) {
      elem.removeAttributeNS(qualified.ns, qualified.local);
    }
  } else if (elem.hasAttribute(name)) {
    elem.removeAttribute(name);
  }
}
function setAttribute(elem, name, value) {
  if (value == null) {
    return removeAttribute(elem, name);
  }

  const qualified = qualifyAttr(name);

  if (qualified.ns && typeof value === 'string') {
    elem.setAttributeNS(qualified.ns, name, value);
  } else if (name === 'id') {
    elem.id = `${value}`;
  } else {
    elem.setAttribute(name, `${value}`);
  }
}
function setAttributes(elem, attrs) {
  Object.keys(attrs).forEach(name => {
    setAttribute(elem, name, attrs[name]);
  });
}
function attr(elem, name, value) {
  if (name == null) {
    const attrs = elem.attributes;
    const ret = {};

    for (let i = 0; i < attrs.length; i += 1) {
      ret[attrs[i].name] = attrs[i].value;
    }

    return ret;
  }

  if (typeof name === 'string' && value === undefined) {
    return elem.getAttribute(name);
  }

  if (typeof name === 'object') {
    setAttributes(elem, name);
  } else {
    setAttribute(elem, name, value);
  }
}
function qualifyAttr(name) {
  if (name.indexOf(':') !== -1) {
    const combinedKey = name.split(':');
    return {
      ns: _elem__WEBPACK_IMPORTED_MODULE_0__.ns[combinedKey[0]],
      local: combinedKey[1]
    };
  }

  return {
    ns: null,
    local: name
  };
}
function kebablizeAttrs(attrs) {
  const result = {};
  Object.keys(attrs).forEach(key => {
    const name = CASE_SENSITIVE_ATTR.includes(key) ? key : (0,_string_format__WEBPACK_IMPORTED_MODULE_1__.kebabCase)(key);
    result[name] = attrs[key];
  });
  return result;
}
function styleToObject(styleString) {
  const ret = {};
  const styles = styleString.split(';');
  styles.forEach(item => {
    const section = item.trim();

    if (section) {
      const pair = section.split('=');

      if (pair.length) {
        ret[pair[0].trim()] = pair[1] ? pair[1].trim() : '';
      }
    }
  });
  return ret;
}
function mergeAttrs(target, source) {
  Object.keys(source).forEach(attr => {
    if (attr === 'class') {
      target[attr] = target[attr] ? `${target[attr]} ${source[attr]}` : source[attr];
    } else if (attr === 'style') {
      const to = typeof target[attr] === 'object';
      const so = typeof source[attr] === 'object';
      let tt;
      let ss;

      if (to && so) {
        tt = target[attr];
        ss = source[attr];
      } else if (to) {
        tt = target[attr];
        ss = styleToObject(source[attr]);
      } else if (so) {
        tt = styleToObject(target[attr]);
        ss = source[attr];
      } else {
        tt = styleToObject(target[attr]);
        ss = styleToObject(source[attr]);
      }

      target[attr] = mergeAttrs(tt, ss);
    } else {
      target[attr] = source[attr];
    }
  });
  return target;
}

/***/ }),

/***/ 96306:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/class.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "getClass": () => (/* binding */ getClass),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "toggleClass": () => (/* binding */ toggleClass)
/* harmony export */ });
const rclass = /[\t\r\n\f]/g;
const rnotwhite = /\S+/g;

const fillSpaces = str => ` ${str} `;

function getClass(elem) {
  return elem && elem.getAttribute && elem.getAttribute('class') || '';
}
function hasClass(elem, selector) {
  if (elem == null || selector == null) {
    return false;
  }

  const classNames = fillSpaces(getClass(elem));
  const className = fillSpaces(selector);
  return elem.nodeType === 1 ? classNames.replace(rclass, ' ').includes(className) : false;
}
function addClass(elem, selector) {
  if (elem == null || selector == null) {
    return;
  }

  if (typeof selector === 'function') {
    return addClass(elem, selector(getClass(elem)));
  }

  if (typeof selector === 'string' && elem.nodeType === 1) {
    const classes = selector.match(rnotwhite) || [];
    const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
    let newValue = classes.reduce((memo, cls) => {
      if (memo.indexOf(fillSpaces(cls)) < 0) {
        return `${memo}${cls} `;
      }

      return memo;
    }, oldValue);
    newValue = newValue.trim();

    if (oldValue !== newValue) {
      elem.setAttribute('class', newValue);
    }
  }
}
function removeClass(elem, selector) {
  if (elem == null) {
    return;
  }

  if (typeof selector === 'function') {
    return removeClass(elem, selector(getClass(elem)));
  }

  if ((!selector || typeof selector === 'string') && elem.nodeType === 1) {
    const classes = (selector || '').match(rnotwhite) || [];
    const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
    let newValue = classes.reduce((memo, cls) => {
      const className = fillSpaces(cls);

      if (memo.indexOf(className) > -1) {
        return memo.replace(className, ' ');
      }

      return memo;
    }, oldValue);
    newValue = selector ? newValue.trim() : '';

    if (oldValue !== newValue) {
      elem.setAttribute('class', newValue);
    }
  }
}
function toggleClass(elem, selector, stateVal) {
  if (elem == null || selector == null) {
    return;
  }

  if (stateVal != null && typeof selector === 'string') {
    stateVal ? addClass(elem, selector) : removeClass(elem, selector);
    return;
  }

  if (typeof selector === 'function') {
    return toggleClass(elem, selector(getClass(elem), stateVal), stateVal);
  }

  if (typeof selector === 'string') {
    const metches = selector.match(rnotwhite) || [];
    metches.forEach(cls => {
      hasClass(elem, cls) ? removeClass(elem, cls) : addClass(elem, cls);
    });
  }
}

/***/ }),

/***/ 64879:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/core.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KAPPA": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.KAPPA),
/* harmony export */   "MouseWheelHandle": () => (/* reexport safe */ _mousewheel__WEBPACK_IMPORTED_MODULE_12__.MouseWheelHandle),
/* harmony export */   "addClass": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.addClass),
/* harmony export */   "animate": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.animate),
/* harmony export */   "animateAlongPath": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.animateAlongPath),
/* harmony export */   "animateTransform": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.animateTransform),
/* harmony export */   "append": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.append),
/* harmony export */   "appendTo": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.appendTo),
/* harmony export */   "attr": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.attr),
/* harmony export */   "bbox": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.bbox),
/* harmony export */   "before": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.before),
/* harmony export */   "breakText": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_7__.breakText),
/* harmony export */   "cancelAnimationFrame": () => (/* reexport safe */ _af__WEBPACK_IMPORTED_MODULE_0__.cancelAnimationFrame),
/* harmony export */   "circleToPathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.circleToPathData),
/* harmony export */   "clearSelection": () => (/* reexport safe */ _selection__WEBPACK_IMPORTED_MODULE_6__.clearSelection),
/* harmony export */   "contains": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.contains),
/* harmony export */   "createElement": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.createElement),
/* harmony export */   "createElementNS": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.createElementNS),
/* harmony export */   "createSVGMatrix": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.createSVGMatrix),
/* harmony export */   "createSVGPoint": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.createSVGPoint),
/* harmony export */   "createSVGTransform": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.createSVGTransform),
/* harmony export */   "createSlicePathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.createSlicePathData),
/* harmony export */   "createSvgDocument": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.createSvgDocument),
/* harmony export */   "createSvgElement": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.createSvgElement),
/* harmony export */   "decomposeMatrix": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.decomposeMatrix),
/* harmony export */   "ellipseToPathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.ellipseToPathData),
/* harmony export */   "empty": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.empty),
/* harmony export */   "ensureId": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.ensureId),
/* harmony export */   "find": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.find),
/* harmony export */   "findOne": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.findOne),
/* harmony export */   "findParentByClass": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.findParentByClass),
/* harmony export */   "getAttribute": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.getAttribute),
/* harmony export */   "getBBox": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.getBBox),
/* harmony export */   "getBBoxByElementAttr": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.getBBoxByElementAttr),
/* harmony export */   "getBoundingOffsetRect": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.getBoundingOffsetRect),
/* harmony export */   "getClass": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.getClass),
/* harmony export */   "getComputedStyle": () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle),
/* harmony export */   "getIntersection": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.getIntersection),
/* harmony export */   "getMatrixByElementAttr": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.getMatrixByElementAttr),
/* harmony export */   "getPointsFromSvgElement": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.getPointsFromSvgElement),
/* harmony export */   "getTransformToElement": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.getTransformToElement),
/* harmony export */   "getVendorPrefixedName": () => (/* reexport safe */ _prefix__WEBPACK_IMPORTED_MODULE_5__.getVendorPrefixedName),
/* harmony export */   "hasClass": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.hasClass),
/* harmony export */   "hasScrollbars": () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_4__.hasScrollbars),
/* harmony export */   "index": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.index),
/* harmony export */   "isHTMLElement": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement),
/* harmony export */   "isSVGGraphicsElement": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.isSVGGraphicsElement),
/* harmony export */   "kebablizeAttrs": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.kebablizeAttrs),
/* harmony export */   "lineToPathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.lineToPathData),
/* harmony export */   "matrixToRotation": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.matrixToRotation),
/* harmony export */   "matrixToScale": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.matrixToScale),
/* harmony export */   "matrixToTransformString": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.matrixToTransformString),
/* harmony export */   "matrixToTranslation": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.matrixToTranslation),
/* harmony export */   "mergeAttrs": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.mergeAttrs),
/* harmony export */   "ns": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.ns),
/* harmony export */   "parseTransformString": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.parseTransformString),
/* harmony export */   "parseXML": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.parseXML),
/* harmony export */   "polygonToPathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.polygonToPathData),
/* harmony export */   "polylineToPathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.polylineToPathData),
/* harmony export */   "prepend": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.prepend),
/* harmony export */   "qualifyAttr": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.qualifyAttr),
/* harmony export */   "rectToPathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.rectToPathData),
/* harmony export */   "rectangleToPathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.rectangleToPathData),
/* harmony export */   "remove": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.remove),
/* harmony export */   "removeAttribute": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.removeAttribute),
/* harmony export */   "removeClass": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.removeClass),
/* harmony export */   "requestAnimationFrame": () => (/* reexport safe */ _af__WEBPACK_IMPORTED_MODULE_0__.requestAnimationFrame),
/* harmony export */   "rotate": () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_11__.rotate),
/* harmony export */   "sample": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.sample),
/* harmony export */   "scale": () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_11__.scale),
/* harmony export */   "setAttribute": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.setAttribute),
/* harmony export */   "setAttributes": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.setAttributes),
/* harmony export */   "setPrefixedStyle": () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_4__.setPrefixedStyle),
/* harmony export */   "styleToObject": () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_1__.styleToObject),
/* harmony export */   "svgVersion": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.svgVersion),
/* harmony export */   "tagName": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.tagName),
/* harmony export */   "text": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_7__.text),
/* harmony export */   "toGeometryShape": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.toGeometryShape),
/* harmony export */   "toLocalPoint": () => (/* reexport safe */ _geom__WEBPACK_IMPORTED_MODULE_9__.toLocalPoint),
/* harmony export */   "toPath": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.toPath),
/* harmony export */   "toPathData": () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_8__.toPathData),
/* harmony export */   "toggleClass": () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_3__.toggleClass),
/* harmony export */   "transform": () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_11__.transform),
/* harmony export */   "transformLine": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.transformLine),
/* harmony export */   "transformPoint": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.transformPoint),
/* harmony export */   "transformPolyline": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.transformPolyline),
/* harmony export */   "transformRectangle": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.transformRectangle),
/* harmony export */   "transformStringToMatrix": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_10__.transformStringToMatrix),
/* harmony export */   "translate": () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_11__.translate),
/* harmony export */   "translateAndAutoOrient": () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_11__.translateAndAutoOrient),
/* harmony export */   "uniqueId": () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_2__.uniqueId)
/* harmony export */ });
/* harmony import */ var _af__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./af */ 10693);
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr */ 11844);
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elem */ 32076);
/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./class */ 96306);
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style */ 14106);
/* harmony import */ var _prefix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./prefix */ 54166);
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./selection */ 73898);
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./text */ 18848);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./path */ 54261);
/* harmony import */ var _geom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./geom */ 60240);
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./matrix */ 68067);
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transform */ 30766);
/* harmony import */ var _mousewheel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mousewheel */ 60775);






 // svg
// ---








/***/ }),

/***/ 32076:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/elem.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "appendTo": () => (/* binding */ appendTo),
/* harmony export */   "before": () => (/* binding */ before),
/* harmony export */   "contains": () => (/* binding */ contains),
/* harmony export */   "createElement": () => (/* binding */ createElement),
/* harmony export */   "createElementNS": () => (/* binding */ createElementNS),
/* harmony export */   "createSvgDocument": () => (/* binding */ createSvgDocument),
/* harmony export */   "createSvgElement": () => (/* binding */ createSvgElement),
/* harmony export */   "empty": () => (/* binding */ empty),
/* harmony export */   "ensureId": () => (/* binding */ ensureId),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "findOne": () => (/* binding */ findOne),
/* harmony export */   "findParentByClass": () => (/* binding */ findParentByClass),
/* harmony export */   "index": () => (/* binding */ index),
/* harmony export */   "isHTMLElement": () => (/* binding */ isHTMLElement),
/* harmony export */   "isSVGGraphicsElement": () => (/* binding */ isSVGGraphicsElement),
/* harmony export */   "ns": () => (/* binding */ ns),
/* harmony export */   "parseXML": () => (/* binding */ parseXML),
/* harmony export */   "prepend": () => (/* binding */ prepend),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "svgVersion": () => (/* binding */ svgVersion),
/* harmony export */   "tagName": () => (/* binding */ tagName),
/* harmony export */   "uniqueId": () => (/* binding */ uniqueId)
/* harmony export */ });
/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class */ 96306);

let idCounter = 0;
function uniqueId() {
  idCounter += 1;
  return `v${idCounter}`;
}
function ensureId(elem) {
  if (elem.id == null || elem.id === '') {
    elem.id = uniqueId();
  }

  return elem.id;
}
/**
 * Returns true if object is an instance of SVGGraphicsElement.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
 */

function isSVGGraphicsElement(elem) {
  if (elem == null) {
    return false;
  }

  return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;
}
const ns = {
  svg: 'http://www.w3.org/2000/svg',
  xmlns: 'http://www.w3.org/2000/xmlns/',
  xml: 'http://www.w3.org/XML/1998/namespace',
  xlink: 'http://www.w3.org/1999/xlink',
  xhtml: 'http://www.w3.org/1999/xhtml'
};
const svgVersion = '1.1';
function createElement(tagName, doc = document) {
  return doc.createElement(tagName);
}
function createElementNS(tagName, namespaceURI = ns.xhtml, doc = document) {
  return doc.createElementNS(namespaceURI, tagName);
}
function createSvgElement(tagName, doc = document) {
  return createElementNS(tagName, ns.svg, doc);
}
function createSvgDocument(content) {
  if (content) {
    const xml = `<svg xmlns="${ns.svg}" xmlns:xlink="${ns.xlink}" version="${svgVersion}">${content}</svg>`; // lgtm[js/html-constructed-from-input]

    const {
      documentElement
    } = parseXML(xml, {
      async: false
    });
    return documentElement;
  }

  const svg = document.createElementNS(ns.svg, 'svg');
  svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);
  svg.setAttribute('version', svgVersion);
  return svg;
}
function parseXML(data, options = {}) {
  let xml;

  try {
    const parser = new DOMParser();

    if (options.async != null) {
      const instance = parser;
      instance.async = options.async;
    }

    xml = parser.parseFromString(data, options.mimeType || 'text/xml');
  } catch (error) {
    xml = undefined;
  }

  if (!xml || xml.getElementsByTagName('parsererror').length) {
    throw new Error(`Invalid XML: ${data}`);
  }

  return xml;
}
function tagName(node, lowercase = true) {
  const nodeName = node.nodeName;
  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();
}
function index(elem) {
  let index = 0;
  let node = elem.previousSibling;

  while (node) {
    if (node.nodeType === 1) {
      index += 1;
    }

    node = node.previousSibling;
  }

  return index;
}
function find(elem, selector) {
  return elem.querySelectorAll(selector);
}
function findOne(elem, selector) {
  return elem.querySelector(selector);
}
function findParentByClass(elem, className, terminator) {
  const ownerSVGElement = elem.ownerSVGElement;
  let node = elem.parentNode;

  while (node && node !== terminator && node !== ownerSVGElement) {
    if ((0,_class__WEBPACK_IMPORTED_MODULE_0__.hasClass)(node, className)) {
      return node;
    }

    node = node.parentNode;
  }

  return null;
}
function contains(parent, child) {
  const bup = child && child.parentNode;
  return parent === bup || !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise
  ;
}
function remove(elem) {
  if (elem.parentNode) {
    elem.parentNode.removeChild(elem);
  }
}
function empty(elem) {
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
}
function append(elem, elems) {
  const arr = Array.isArray(elems) ? elems : [elems];
  arr.forEach(child => {
    if (child != null) {
      elem.appendChild(child);
    }
  });
}
function prepend(elem, elems) {
  const child = elem.firstChild;
  return child ? before(child, elems) : append(elem, elems);
}
function before(elem, elems) {
  const parent = elem.parentNode;

  if (parent) {
    const arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach(child => {
      if (child != null) {
        parent.insertBefore(child, elem);
      }
    });
  }
}
function appendTo(elem, target) {
  if (target != null) {
    target.appendChild(elem);
  }
} // Determines whether a node is an HTML node

function isHTMLElement(elem) {
  try {
    // Using W3 DOM2 (works for FF, Opera and Chrome)
    return elem instanceof HTMLElement;
  } catch (e) {
    // Browsers not supporting W3 DOM2 don't have HTMLElement and
    // an exception is thrown and we end up here. Testing some
    // properties that all elements have (works on IE7)
    return typeof elem === 'object' && elem.nodeType === 1 && typeof elem.style === 'object' && typeof elem.ownerDocument === 'object';
  }
}

/***/ }),

/***/ 60240:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/geom.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animate": () => (/* binding */ animate),
/* harmony export */   "animateAlongPath": () => (/* binding */ animateAlongPath),
/* harmony export */   "animateTransform": () => (/* binding */ animateTransform),
/* harmony export */   "bbox": () => (/* binding */ bbox),
/* harmony export */   "getBBox": () => (/* binding */ getBBox),
/* harmony export */   "getBBoxByElementAttr": () => (/* binding */ getBBoxByElementAttr),
/* harmony export */   "getBoundingOffsetRect": () => (/* binding */ getBoundingOffsetRect),
/* harmony export */   "getIntersection": () => (/* binding */ getIntersection),
/* harmony export */   "getMatrixByElementAttr": () => (/* binding */ getMatrixByElementAttr),
/* harmony export */   "getTransformToElement": () => (/* binding */ getTransformToElement),
/* harmony export */   "toGeometryShape": () => (/* binding */ toGeometryShape),
/* harmony export */   "toLocalPoint": () => (/* binding */ toLocalPoint)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr */ 11844);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ 54261);
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./elem */ 32076);
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./style */ 14106);
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./matrix */ 68067);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







/**
 * Returns the bounding box of the element after transformations are
 * applied. If `withoutTransformations` is `true`, transformations of
 * the element will not be considered when computing the bounding box.
 * If `target` is specified, bounding box will be computed relatively
 * to the `target` element.
 */

function bbox(elem, withoutTransformations, target) {
  let box;
  const ownerSVGElement = elem.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding
  // box defined and so fall back to 'zero' dimension element.

  if (!ownerSVGElement) {
    return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 0, 0);
  }

  try {
    box = elem.getBBox();
  } catch (e) {
    // Fallback for IE.
    box = {
      x: elem.clientLeft,
      y: elem.clientTop,
      width: elem.clientWidth,
      height: elem.clientHeight
    };
  }

  if (withoutTransformations) {
    return _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.create(box);
  }

  const matrix = getTransformToElement(elem, target || ownerSVGElement);
  return (0,_matrix__WEBPACK_IMPORTED_MODULE_5__.transformRectangle)(box, matrix);
}
/**
 * Returns the bounding box of the element after transformations are
 * applied. Unlike `bbox()`, this function fixes a browser implementation
 * bug to return the correct bounding box if this elemenent is a group of
 * svg elements (if `options.recursive` is specified).
 */

function getBBox(elem, options = {}) {
  let outputBBox;
  const ownerSVGElement = elem.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding box
  // defined and so fall back to 'zero' dimension element.
  // If the element is not an SVGGraphicsElement, we could not measure the
  // bounding box either

  if (!ownerSVGElement || !(0,_elem__WEBPACK_IMPORTED_MODULE_3__.isSVGGraphicsElement)(elem)) {
    if ((0,_elem__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(elem)) {
      // If the element is a HTMLElement, return the position relative to the body
      const {
        left,
        top,
        width,
        height
      } = getBoundingOffsetRect(elem);
      return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(left, top, width, height);
    }

    return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 0, 0);
  }

  let target = options.target;
  const recursive = options.recursive;

  if (!recursive) {
    try {
      outputBBox = elem.getBBox();
    } catch (e) {
      outputBBox = {
        x: elem.clientLeft,
        y: elem.clientTop,
        width: elem.clientWidth,
        height: elem.clientHeight
      };
    }

    if (!target) {
      return _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.create(outputBBox);
    } // transform like target


    const matrix = getTransformToElement(elem, target);
    return (0,_matrix__WEBPACK_IMPORTED_MODULE_5__.transformRectangle)(outputBBox, matrix);
  } // recursive


  {
    const children = elem.childNodes;
    const n = children.length;

    if (n === 0) {
      return getBBox(elem, {
        target
      });
    }

    if (!target) {
      target = elem; // eslint-disable-line
    }

    for (let i = 0; i < n; i += 1) {
      const child = children[i];
      let childBBox;

      if (child.childNodes.length === 0) {
        childBBox = getBBox(child, {
          target
        });
      } else {
        // if child is a group element, enter it with a recursive call
        childBBox = getBBox(child, {
          target,
          recursive: true
        });
      }

      if (!outputBBox) {
        outputBBox = childBBox;
      } else {
        outputBBox = outputBBox.union(childBBox);
      }
    }

    return outputBBox;
  }
} // BBox is calculated by the attribute on the node

function getBBoxByElementAttr(elem) {
  let node = elem;
  let tagName = node ? node.tagName.toLowerCase() : ''; // find shape node

  while (tagName === 'g') {
    node = node.firstElementChild;
    tagName = node ? node.tagName.toLowerCase() : '';
  }

  const attr = name => {
    const s = node.getAttribute(name);
    const v = s ? parseFloat(s) : 0;
    return Number.isNaN(v) ? 0 : v;
  };

  let r;
  let bbox;

  switch (tagName) {
    case 'rect':
      bbox = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));
      break;

    case 'circle':
      r = attr('r');
      bbox = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(attr('cx') - r, attr('cy') - r, 2 * r, 2 * r);
      break;

    default:
      break;
  }

  return bbox;
} // Matrix is calculated by the transform attribute on the node

function getMatrixByElementAttr(elem, target) {
  let matrix = (0,_matrix__WEBPACK_IMPORTED_MODULE_5__.createSVGMatrix)();

  if ((0,_elem__WEBPACK_IMPORTED_MODULE_3__.isSVGGraphicsElement)(target) && (0,_elem__WEBPACK_IMPORTED_MODULE_3__.isSVGGraphicsElement)(elem)) {
    let node = elem;
    const matrixList = [];

    while (node && node !== target) {
      const transform = node.getAttribute('transform') || null;
      const nodeMatrix = (0,_matrix__WEBPACK_IMPORTED_MODULE_5__.transformStringToMatrix)(transform);
      matrixList.push(nodeMatrix);
      node = node.parentNode;
    }

    matrixList.reverse().forEach(m => {
      matrix = matrix.multiply(m);
    });
  }

  return matrix;
}
/**
 * Returns an DOMMatrix that specifies the transformation necessary
 * to convert `elem` coordinate system into `target` coordinate system.
 */

function getTransformToElement(elem, target) {
  if ((0,_elem__WEBPACK_IMPORTED_MODULE_3__.isSVGGraphicsElement)(target) && (0,_elem__WEBPACK_IMPORTED_MODULE_3__.isSVGGraphicsElement)(elem)) {
    const targetCTM = target.getScreenCTM();
    const nodeCTM = elem.getScreenCTM();

    if (targetCTM && nodeCTM) {
      return targetCTM.inverse().multiply(nodeCTM);
    }
  } // Could not get actual transformation matrix


  return (0,_matrix__WEBPACK_IMPORTED_MODULE_5__.createSVGMatrix)();
}
/**
 * Converts a global point with coordinates `x` and `y` into the
 * coordinate space of the element.
 */

function toLocalPoint(elem, x, y) {
  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
  const p = svg.createSVGPoint();
  p.x = x;
  p.y = y;

  try {
    const ctm = svg.getScreenCTM();
    const globalPoint = p.matrixTransform(ctm.inverse());
    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();
    return globalPoint.matrixTransform(globalToLocalMatrix);
  } catch (e) {
    return p;
  }
}
/**
 * Convert the SVGElement to an equivalent geometric shape. The element's
 * transformations are not taken into account.
 *
 * SVGRectElement      => Rectangle
 *
 * SVGLineElement      => Line
 *
 * SVGCircleElement    => Ellipse
 *
 * SVGEllipseElement   => Ellipse
 *
 * SVGPolygonElement   => Polyline
 *
 * SVGPolylineElement  => Polyline
 *
 * SVGPathElement      => Path
 *
 * others              => Rectangle
 */

function toGeometryShape(elem) {
  const attr = name => {
    const s = elem.getAttribute(name);
    const v = s ? parseFloat(s) : 0;
    return Number.isNaN(v) ? 0 : v;
  };

  switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {
    case 'rect':
      return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));

    case 'circle':
      return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));

    case 'ellipse':
      return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));

    case 'polyline':
      {
        const points = (0,_path__WEBPACK_IMPORTED_MODULE_2__.getPointsFromSvgElement)(elem);
        return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);
      }

    case 'polygon':
      {
        const points = (0,_path__WEBPACK_IMPORTED_MODULE_2__.getPointsFromSvgElement)(elem);

        if (points.length > 1) {
          points.push(points[0]);
        }

        return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);
      }

    case 'path':
      {
        let d = elem.getAttribute('d');

        if (!_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.isValid(d)) {
          d = _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.normalize(d);
        }

        return _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(d);
      }

    case 'line':
      {
        return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));
      }

    default:
      break;
  } // Anything else is a rectangle


  return getBBox(elem);
}
function getIntersection(elem, ref, target) {
  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
  target = target || svg; // eslint-disable-line

  const bbox = getBBox(target);
  const center = bbox.getCenter();

  if (!bbox.intersectsWithLineFromCenterToPoint(ref)) {
    return null;
  }

  let spot = null;
  const tagName = elem.tagName.toLowerCase(); // Little speed up optimization for `<rect>` element. We do not do convert
  // to path element and sampling but directly calculate the intersection
  // through a transformed geometrical rectangle.

  if (tagName === 'rect') {
    const gRect = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(parseFloat(elem.getAttribute('x') || '0'), parseFloat(elem.getAttribute('y') || '0'), parseFloat(elem.getAttribute('width') || '0'), parseFloat(elem.getAttribute('height') || '0')); // Get the rect transformation matrix with regards to the SVG document.

    const rectMatrix = getTransformToElement(elem, target);
    const rectMatrixComponents = (0,_matrix__WEBPACK_IMPORTED_MODULE_5__.decomposeMatrix)(rectMatrix); // Rotate the rectangle back so that we can use
    // `intersectsWithLineFromCenterToPoint()`.

    const reseted = svg.createSVGTransform();
    reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y);
    const rect = (0,_matrix__WEBPACK_IMPORTED_MODULE_5__.transformRectangle)(gRect, reseted.matrix.multiply(rectMatrix));
    spot = _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.create(rect).intersectsWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);
  } else if (tagName === 'path' || tagName === 'polygon' || tagName === 'polyline' || tagName === 'circle' || tagName === 'ellipse') {
    const pathNode = tagName === 'path' ? elem : (0,_path__WEBPACK_IMPORTED_MODULE_2__.toPath)(elem);
    const samples = (0,_path__WEBPACK_IMPORTED_MODULE_2__.sample)(pathNode);
    let minDistance = Infinity;
    let closestSamples = [];

    for (let i = 0, ii = samples.length; i < ii; i += 1) {
      const sample = samples[i]; // Convert the sample point in the local coordinate system
      // to the global coordinate system.

      let gp = (0,_matrix__WEBPACK_IMPORTED_MODULE_5__.createSVGPoint)(sample.x, sample.y);
      gp = gp.matrixTransform(getTransformToElement(elem, target));
      const ggp = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(gp);
      const centerDistance = ggp.distance(center); // Penalize a higher distance to the reference point by 10%.
      // This gives better results. This is due to
      // inaccuracies introduced by rounding errors and getPointAtLength() returns.

      const refDistance = ggp.distance(ref) * 1.1;
      const distance = centerDistance + refDistance;

      if (distance < minDistance) {
        minDistance = distance;
        closestSamples = [{
          sample,
          refDistance
        }];
      } else if (distance < minDistance + 1) {
        closestSamples.push({
          sample,
          refDistance
        });
      }
    }

    closestSamples.sort((a, b) => a.refDistance - b.refDistance);

    if (closestSamples[0]) {
      spot = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(closestSamples[0].sample);
    }
  }

  return spot;
}
function animate(elem, options) {
  return createAnimation(elem, options, 'animate');
}
function animateTransform(elem, options) {
  return createAnimation(elem, options, 'animateTransform');
}

function createAnimation(elem, options, type) {
  // @see
  // https://www.w3.org/TR/SVG11/animate.html#AnimateElement
  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateElement
  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateTransformElement
  const animate = (0,_elem__WEBPACK_IMPORTED_MODULE_3__.createSvgElement)(type);
  elem.appendChild(animate);

  try {
    return setupAnimation(animate, options);
  } catch (error) {// pass
  }

  return () => {};
}

function setupAnimation(animate, options) {
  const {
    start,
    complete,
    repeat
  } = options,
        attrs = __rest(options, ["start", "complete", "repeat"]);

  (0,_attr__WEBPACK_IMPORTED_MODULE_1__.attr)(animate, attrs);
  start && animate.addEventListener('beginEvent', start);
  complete && animate.addEventListener('endEvent', complete);
  repeat && animate.addEventListener('repeatEvent', repeat);
  const ani = animate;
  ani.beginElement();
  return () => ani.endElement();
}
/**
 * Animate the element along the path SVG element (or Vector object).
 * `attrs` contain Animation Timing attributes describing the animation.
 */


function animateAlongPath(elem, options, path) {
  const id = (0,_elem__WEBPACK_IMPORTED_MODULE_3__.ensureId)(path); // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimationElement

  const animate = (0,_elem__WEBPACK_IMPORTED_MODULE_3__.createSvgElement)('animateMotion');
  const mpath = (0,_elem__WEBPACK_IMPORTED_MODULE_3__.createSvgElement)('mpath');
  (0,_attr__WEBPACK_IMPORTED_MODULE_1__.attr)(mpath, {
    'xlink:href': `#${id}`
  });
  animate.appendChild(mpath);
  elem.appendChild(animate);

  try {
    return setupAnimation(animate, options);
  } catch (e) {
    // Fallback for IE 9.
    if (document.documentElement.getAttribute('smiling') === 'fake') {
      // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)
      const ani = animate;
      ani.animators = [];
      const win = window;
      const animationID = ani.getAttribute('id');

      if (animationID) {
        win.id2anim[animationID] = ani;
      }

      const targets = win.getTargets(ani);

      for (let i = 0, ii = targets.length; i < ii; i += 1) {
        const target = targets[i];
        const animator = new win.Animator(ani, target, i);
        win.animators.push(animator);
        ani.animators[i] = animator;
        animator.register();
      }
    }
  }

  return () => {};
}
function getBoundingOffsetRect(elem) {
  let left = 0;
  let top = 0;
  let width = 0;
  let height = 0;

  if (elem) {
    let current = elem;

    while (current) {
      left += current.offsetLeft;
      top += current.offsetTop;
      current = current.offsetParent;

      if (current) {
        left += parseInt((0,_style__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(current, 'borderLeft'), 10);
        top += parseInt((0,_style__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(current, 'borderTop'), 10);
      }
    }

    width = elem.offsetWidth;
    height = elem.offsetHeight;
  }

  return {
    left,
    top,
    width,
    height
  };
}

/***/ }),

/***/ 29138:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dom": () => (/* reexport module object */ _main__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ 29822);



/***/ }),

/***/ 29822:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/main.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KAPPA": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.KAPPA),
/* harmony export */   "MouseWheelHandle": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.MouseWheelHandle),
/* harmony export */   "addClass": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.addClass),
/* harmony export */   "animate": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.animate),
/* harmony export */   "animateAlongPath": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.animateAlongPath),
/* harmony export */   "animateTransform": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.animateTransform),
/* harmony export */   "append": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.append),
/* harmony export */   "appendTo": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.appendTo),
/* harmony export */   "attr": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.attr),
/* harmony export */   "bbox": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.bbox),
/* harmony export */   "before": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.before),
/* harmony export */   "breakText": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.breakText),
/* harmony export */   "cancelAnimationFrame": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.cancelAnimationFrame),
/* harmony export */   "circleToPathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.circleToPathData),
/* harmony export */   "clearSelection": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.clearSelection),
/* harmony export */   "contains": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.contains),
/* harmony export */   "createElement": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.createElement),
/* harmony export */   "createElementNS": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.createElementNS),
/* harmony export */   "createSVGMatrix": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.createSVGMatrix),
/* harmony export */   "createSVGPoint": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.createSVGPoint),
/* harmony export */   "createSVGTransform": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.createSVGTransform),
/* harmony export */   "createSlicePathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.createSlicePathData),
/* harmony export */   "createSvgDocument": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.createSvgDocument),
/* harmony export */   "createSvgElement": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.createSvgElement),
/* harmony export */   "createVector": () => (/* reexport safe */ _vector__WEBPACK_IMPORTED_MODULE_1__.createVector),
/* harmony export */   "createVectors": () => (/* reexport safe */ _vector__WEBPACK_IMPORTED_MODULE_1__.createVectors),
/* harmony export */   "decomposeMatrix": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.decomposeMatrix),
/* harmony export */   "ellipseToPathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.ellipseToPathData),
/* harmony export */   "empty": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.empty),
/* harmony export */   "ensureId": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.ensureId),
/* harmony export */   "find": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.find),
/* harmony export */   "findOne": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.findOne),
/* harmony export */   "findParentByClass": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.findParentByClass),
/* harmony export */   "getAttribute": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getAttribute),
/* harmony export */   "getBBox": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getBBox),
/* harmony export */   "getBBoxByElementAttr": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getBBoxByElementAttr),
/* harmony export */   "getBoundingOffsetRect": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getBoundingOffsetRect),
/* harmony export */   "getClass": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getClass),
/* harmony export */   "getComputedStyle": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle),
/* harmony export */   "getIntersection": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getIntersection),
/* harmony export */   "getMatrixByElementAttr": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getMatrixByElementAttr),
/* harmony export */   "getPointsFromSvgElement": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getPointsFromSvgElement),
/* harmony export */   "getTransformToElement": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getTransformToElement),
/* harmony export */   "getVendorPrefixedName": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.getVendorPrefixedName),
/* harmony export */   "hasClass": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.hasClass),
/* harmony export */   "hasScrollbars": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.hasScrollbars),
/* harmony export */   "index": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.index),
/* harmony export */   "isHTMLElement": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),
/* harmony export */   "isSVGGraphicsElement": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.isSVGGraphicsElement),
/* harmony export */   "isVector": () => (/* reexport safe */ _vector__WEBPACK_IMPORTED_MODULE_1__.isVector),
/* harmony export */   "kebablizeAttrs": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.kebablizeAttrs),
/* harmony export */   "lineToPathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.lineToPathData),
/* harmony export */   "matrixToRotation": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.matrixToRotation),
/* harmony export */   "matrixToScale": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.matrixToScale),
/* harmony export */   "matrixToTransformString": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.matrixToTransformString),
/* harmony export */   "matrixToTranslation": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.matrixToTranslation),
/* harmony export */   "mergeAttrs": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.mergeAttrs),
/* harmony export */   "ns": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.ns),
/* harmony export */   "parseTransformString": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.parseTransformString),
/* harmony export */   "parseXML": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.parseXML),
/* harmony export */   "polygonToPathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.polygonToPathData),
/* harmony export */   "polylineToPathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.polylineToPathData),
/* harmony export */   "prepend": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.prepend),
/* harmony export */   "qualifyAttr": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.qualifyAttr),
/* harmony export */   "rectToPathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.rectToPathData),
/* harmony export */   "rectangleToPathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.rectangleToPathData),
/* harmony export */   "remove": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.remove),
/* harmony export */   "removeAttribute": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.removeAttribute),
/* harmony export */   "removeClass": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.removeClass),
/* harmony export */   "requestAnimationFrame": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.requestAnimationFrame),
/* harmony export */   "rotate": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.rotate),
/* harmony export */   "sample": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.sample),
/* harmony export */   "scale": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.scale),
/* harmony export */   "setAttribute": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.setAttribute),
/* harmony export */   "setAttributes": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.setAttributes),
/* harmony export */   "setPrefixedStyle": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.setPrefixedStyle),
/* harmony export */   "styleToObject": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.styleToObject),
/* harmony export */   "svgVersion": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.svgVersion),
/* harmony export */   "tagName": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.tagName),
/* harmony export */   "text": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.text),
/* harmony export */   "toGeometryShape": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.toGeometryShape),
/* harmony export */   "toLocalPoint": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.toLocalPoint),
/* harmony export */   "toPath": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.toPath),
/* harmony export */   "toPathData": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.toPathData),
/* harmony export */   "toggleClass": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.toggleClass),
/* harmony export */   "transform": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   "transformLine": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.transformLine),
/* harmony export */   "transformPoint": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.transformPoint),
/* harmony export */   "transformPolyline": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.transformPolyline),
/* harmony export */   "transformRectangle": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.transformRectangle),
/* harmony export */   "transformStringToMatrix": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.transformStringToMatrix),
/* harmony export */   "translate": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.translate),
/* harmony export */   "translateAndAutoOrient": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.translateAndAutoOrient),
/* harmony export */   "uniqueId": () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_0__.uniqueId)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ 64879);
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vector */ 9246);



/***/ }),

/***/ 68067:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/matrix.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSVGMatrix": () => (/* binding */ createSVGMatrix),
/* harmony export */   "createSVGPoint": () => (/* binding */ createSVGPoint),
/* harmony export */   "createSVGTransform": () => (/* binding */ createSVGTransform),
/* harmony export */   "decomposeMatrix": () => (/* binding */ decomposeMatrix),
/* harmony export */   "matrixToRotation": () => (/* binding */ matrixToRotation),
/* harmony export */   "matrixToScale": () => (/* binding */ matrixToScale),
/* harmony export */   "matrixToTransformString": () => (/* binding */ matrixToTransformString),
/* harmony export */   "matrixToTranslation": () => (/* binding */ matrixToTranslation),
/* harmony export */   "parseTransformString": () => (/* binding */ parseTransformString),
/* harmony export */   "transformLine": () => (/* binding */ transformLine),
/* harmony export */   "transformPoint": () => (/* binding */ transformPoint),
/* harmony export */   "transformPolyline": () => (/* binding */ transformPolyline),
/* harmony export */   "transformRectangle": () => (/* binding */ transformRectangle),
/* harmony export */   "transformStringToMatrix": () => (/* binding */ transformStringToMatrix)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elem */ 32076);


const svgDocument = (0,_elem__WEBPACK_IMPORTED_MODULE_1__.createSvgElement)('svg');
const transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi;
const transformSeparatorRegex = /[ ,]+/;
const transformationListRegex = /^(\w+)\((.*)\)/;
/**
 * Returns a SVG point object initialized with the `x` and `y` coordinates.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint
 */

function createSVGPoint(x, y) {
  const p = svgDocument.createSVGPoint();
  p.x = x;
  p.y = y;
  return p;
}
/**
 * Returns the SVG transformation matrix initialized with the given matrix.
 *
 * The given matrix is an object of the form:
 * {
 *   a: number
 *   b: number
 *   c: number
 *   d: number
 *   e: number
 *   f: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */

function createSVGMatrix(matrix) {
  const mat = svgDocument.createSVGMatrix();

  if (matrix != null) {
    const source = matrix;
    const target = mat; // eslint-disable-next-line

    for (const key in source) {
      target[key] = source[key];
    }
  }

  return mat;
}
/**
 * Returns a SVG transform object.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform
 */

function createSVGTransform(matrix) {
  if (matrix != null) {
    if (!(matrix instanceof DOMMatrix)) {
      matrix = createSVGMatrix(matrix); // eslint-disable-line
    }

    return svgDocument.createSVGTransformFromMatrix(matrix);
  }

  return svgDocument.createSVGTransform();
}
/**
 * Returns the SVG transformation matrix built from the `transformString`.
 *
 * E.g. 'translate(10,10) scale(2,2)' will result in matrix:
 * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`
 */

function transformStringToMatrix(transform) {
  let mat = createSVGMatrix();
  const matches = transform != null && transform.match(transformRegex);

  if (!matches) {
    return mat;
  }

  for (let i = 0, n = matches.length; i < n; i += 1) {
    const transformationString = matches[i];
    const transformationMatch = transformationString.match(transformationListRegex);

    if (transformationMatch) {
      let sx;
      let sy;
      let tx;
      let ty;
      let angle;
      let ctm = createSVGMatrix();
      const args = transformationMatch[2].split(transformSeparatorRegex);

      switch (transformationMatch[1].toLowerCase()) {
        case 'scale':
          sx = parseFloat(args[0]);
          sy = args[1] === undefined ? sx : parseFloat(args[1]);
          ctm = ctm.scaleNonUniform(sx, sy);
          break;

        case 'translate':
          tx = parseFloat(args[0]);
          ty = parseFloat(args[1]);
          ctm = ctm.translate(tx, ty);
          break;

        case 'rotate':
          angle = parseFloat(args[0]);
          tx = parseFloat(args[1]) || 0;
          ty = parseFloat(args[2]) || 0;

          if (tx !== 0 || ty !== 0) {
            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
          } else {
            ctm = ctm.rotate(angle);
          }

          break;

        case 'skewx':
          angle = parseFloat(args[0]);
          ctm = ctm.skewX(angle);
          break;

        case 'skewy':
          angle = parseFloat(args[0]);
          ctm = ctm.skewY(angle);
          break;

        case 'matrix':
          ctm.a = parseFloat(args[0]);
          ctm.b = parseFloat(args[1]);
          ctm.c = parseFloat(args[2]);
          ctm.d = parseFloat(args[3]);
          ctm.e = parseFloat(args[4]);
          ctm.f = parseFloat(args[5]);
          break;

        default:
          continue;
      }

      mat = mat.multiply(ctm);
    }
  }

  return mat;
}
function matrixToTransformString(matrix) {
  const m = matrix || {};
  const a = m.a != null ? m.a : 1;
  const b = m.b != null ? m.b : 0;
  const c = m.c != null ? m.c : 0;
  const d = m.d != null ? m.d : 1;
  const e = m.e != null ? m.e : 0;
  const f = m.f != null ? m.f : 0;
  return `matrix(${a},${b},${c},${d},${e},${f})`;
}
function parseTransformString(transform) {
  let translation;
  let rotation;
  let scale;

  if (transform) {
    const separator = transformSeparatorRegex; // Allow reading transform string with a single matrix

    if (transform.trim().indexOf('matrix') >= 0) {
      const matrix = transformStringToMatrix(transform);
      const decomposedMatrix = decomposeMatrix(matrix);
      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];
      rotation = [decomposedMatrix.rotation];
      scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
      const transformations = [];

      if (translation[0] !== 0 || translation[1] !== 0) {
        transformations.push(`translate(${translation.join(',')})`);
      }

      if (scale[0] !== 1 || scale[1] !== 1) {
        transformations.push(`scale(${scale.join(',')})`);
      }

      if (rotation[0] !== 0) {
        transformations.push(`rotate(${rotation[0]})`);
      }

      transform = transformations.join(' '); // eslint-disable-line
    } else {
      const translateMatch = transform.match(/translate\((.*?)\)/);

      if (translateMatch) {
        translation = translateMatch[1].split(separator);
      }

      const rotateMatch = transform.match(/rotate\((.*?)\)/);

      if (rotateMatch) {
        rotation = rotateMatch[1].split(separator);
      }

      const scaleMatch = transform.match(/scale\((.*?)\)/);

      if (scaleMatch) {
        scale = scaleMatch[1].split(separator);
      }
    }
  }

  const sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
  return {
    raw: transform || '',
    translation: {
      tx: translation && translation[0] ? parseInt(translation[0], 10) : 0,
      ty: translation && translation[1] ? parseInt(translation[1], 10) : 0
    },
    rotation: {
      angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,
      cx: rotation && rotation[1] ? parseInt(rotation[1], 10) : undefined,
      cy: rotation && rotation[2] ? parseInt(rotation[2], 10) : undefined
    },
    scale: {
      sx,
      sy: scale && scale[1] ? parseFloat(scale[1]) : sx
    }
  };
}

function deltaTransformPoint(matrix, point) {
  const dx = point.x * matrix.a + point.y * matrix.c + 0;
  const dy = point.x * matrix.b + point.y * matrix.d + 0;
  return {
    x: dx,
    y: dy
  };
}
/**
 * Decomposes the SVG transformation matrix into separate transformations.
 *
 * Returns an object of the form:
 * {
 *   translateX: number
 *   translateY: number
 *   scaleX: number
 *   scaleY: number
 *   skewX: number
 *   skewY: number
 *   rotation: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */


function decomposeMatrix(matrix) {
  // @see https://gist.github.com/2052247
  const px = deltaTransformPoint(matrix, {
    x: 0,
    y: 1
  });
  const py = deltaTransformPoint(matrix, {
    x: 1,
    y: 0
  });
  const skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;
  const skewY = 180 / Math.PI * Math.atan2(py.y, py.x);
  return {
    skewX,
    skewY,
    translateX: matrix.e,
    translateY: matrix.f,
    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
    rotation: skewX
  };
}
function matrixToScale(matrix) {
  let a;
  let b;
  let c;
  let d;

  if (matrix) {
    a = matrix.a == null ? 1 : matrix.a;
    d = matrix.d == null ? 1 : matrix.d;
    b = matrix.b;
    c = matrix.c;
  } else {
    a = d = 1;
  }

  return {
    sx: b ? Math.sqrt(a * a + b * b) : a,
    sy: c ? Math.sqrt(c * c + d * d) : d
  };
}
function matrixToRotation(matrix) {
  let p = {
    x: 0,
    y: 1
  };

  if (matrix) {
    p = deltaTransformPoint(matrix, p);
  }

  return {
    angle: _geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toDeg(Math.atan2(p.y, p.x)) - 90)
  };
}
function matrixToTranslation(matrix) {
  return {
    tx: matrix && matrix.e || 0,
    ty: matrix && matrix.f || 0
  };
}
/**
 * Transforms point by an SVG transformation represented by `matrix`.
 */

function transformPoint(point, matrix) {
  const ret = createSVGPoint(point.x, point.y).matrixTransform(matrix);
  return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(ret.x, ret.y);
}
/**
 * Transforms line by an SVG transformation represented by `matrix`.
 */

function transformLine(line, matrix) {
  return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));
}
/**
 * Transforms polyline by an SVG transformation represented by `matrix`.
 */

function transformPolyline(polyline, matrix) {
  let points = polyline instanceof _geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline ? polyline.points : polyline;

  if (!Array.isArray(points)) {
    points = [];
  }

  return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points.map(p => transformPoint(p, matrix)));
}
function transformRectangle(rect, matrix) {
  const p = svgDocument.createSVGPoint();
  p.x = rect.x;
  p.y = rect.y;
  const corner1 = p.matrixTransform(matrix);
  p.x = rect.x + rect.width;
  p.y = rect.y;
  const corner2 = p.matrixTransform(matrix);
  p.x = rect.x + rect.width;
  p.y = rect.y + rect.height;
  const corner3 = p.matrixTransform(matrix);
  p.x = rect.x;
  p.y = rect.y + rect.height;
  const corner4 = p.matrixTransform(matrix);
  const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
  const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
  const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
  const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
  return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(minX, minY, maxX - minX, maxY - minY);
}

/***/ }),

/***/ 60775:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/mousewheel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MouseWheelHandle": () => (/* binding */ MouseWheelHandle)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform */ 81115);


class MouseWheelHandle {
  constructor(target, onWheelCallback, onWheelGuard) {
    this.animationFrameId = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.eventName = _platform__WEBPACK_IMPORTED_MODULE_1__.Platform.isEventSupported('wheel') ? 'wheel' : 'mousewheel';
    this.target = target;
    this.onWheelCallback = onWheelCallback;
    this.onWheelGuard = onWheelGuard;
    this.onWheel = this.onWheel.bind(this);
    this.didWheel = this.didWheel.bind(this);
  }

  enable() {
    if (_platform__WEBPACK_IMPORTED_MODULE_1__.Platform.SUPPORT_PASSIVE) {
      this.target.addEventListener(this.eventName, this.onWheel, {
        passive: false
      });
    } else {
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.target).on('mousewheel', this.onWheel);
    }
  }

  disable() {
    if (_platform__WEBPACK_IMPORTED_MODULE_1__.Platform.SUPPORT_PASSIVE) {
      this.target.removeEventListener(this.eventName, this.onWheel);
    } else {
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.target).off('mousewheel');
    }
  }

  onWheel(e) {
    if (this.onWheelGuard != null && !this.onWheelGuard(e)) {
      return;
    }

    this.deltaX += e.deltaX;
    this.deltaY += e.deltaY;
    e.preventDefault();
    let changed;

    if (this.deltaX !== 0 || this.deltaY !== 0) {
      e.stopPropagation();
      changed = true;
    }

    if (changed === true && this.animationFrameId === 0) {
      this.animationFrameId = requestAnimationFrame(() => {
        this.didWheel(e);
      });
    }
  }

  didWheel(e) {
    this.animationFrameId = 0;
    this.onWheelCallback(e, this.deltaX, this.deltaY);
    this.deltaX = 0;
    this.deltaY = 0;
  }

}

/***/ }),

/***/ 54261:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/path.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KAPPA": () => (/* binding */ KAPPA),
/* harmony export */   "circleToPathData": () => (/* binding */ circleToPathData),
/* harmony export */   "createSlicePathData": () => (/* binding */ createSlicePathData),
/* harmony export */   "ellipseToPathData": () => (/* binding */ ellipseToPathData),
/* harmony export */   "getPointsFromSvgElement": () => (/* binding */ getPointsFromSvgElement),
/* harmony export */   "lineToPathData": () => (/* binding */ lineToPathData),
/* harmony export */   "polygonToPathData": () => (/* binding */ polygonToPathData),
/* harmony export */   "polylineToPathData": () => (/* binding */ polylineToPathData),
/* harmony export */   "rectToPathData": () => (/* binding */ rectToPathData),
/* harmony export */   "rectangleToPathData": () => (/* binding */ rectangleToPathData),
/* harmony export */   "sample": () => (/* binding */ sample),
/* harmony export */   "toPath": () => (/* binding */ toPath),
/* harmony export */   "toPathData": () => (/* binding */ toPathData)
/* harmony export */ });
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attr */ 11844);
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elem */ 32076);


const KAPPA = 0.551784;

function getNumbericAttribute(elem, attr, defaultValue = NaN) {
  const v = elem.getAttribute(attr);

  if (v == null) {
    return defaultValue;
  }

  const n = parseFloat(v);
  return Number.isNaN(n) ? defaultValue : n;
}

function sample(elem, interval = 1) {
  const length = elem.getTotalLength();
  const samples = [];
  let distance = 0;
  let sample;

  while (distance < length) {
    sample = elem.getPointAtLength(distance);
    samples.push({
      distance,
      x: sample.x,
      y: sample.y
    });
    distance += interval;
  }

  return samples;
}
function lineToPathData(line) {
  return ['M', getNumbericAttribute(line, 'x1'), getNumbericAttribute(line, 'y1'), 'L', getNumbericAttribute(line, 'x2'), getNumbericAttribute(line, 'y2')].join(' ');
}
function polygonToPathData(polygon) {
  const points = getPointsFromSvgElement(polygon);

  if (points.length === 0) {
    return null;
  }

  return `${svgPointsToPath(points)} Z`;
}
function polylineToPathData(polyline) {
  const points = getPointsFromSvgElement(polyline);

  if (points.length === 0) {
    return null;
  }

  return svgPointsToPath(points);
}

function svgPointsToPath(points) {
  const arr = points.map(p => `${p.x} ${p.y}`);
  return `M ${arr.join(' L')}`;
}

function getPointsFromSvgElement(elem) {
  const points = [];
  const nodePoints = elem.points;

  if (nodePoints) {
    for (let i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {
      points.push(nodePoints.getItem(i));
    }
  }

  return points;
}
function circleToPathData(circle) {
  const cx = getNumbericAttribute(circle, 'cx', 0);
  const cy = getNumbericAttribute(circle, 'cy', 0);
  const r = getNumbericAttribute(circle, 'r');
  const cd = r * KAPPA; // Control distance.

  return ['M', cx, cy - r, 'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, 'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, 'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, 'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, 'Z'].join(' ');
}
function ellipseToPathData(ellipse) {
  const cx = getNumbericAttribute(ellipse, 'cx', 0);
  const cy = getNumbericAttribute(ellipse, 'cy', 0);
  const rx = getNumbericAttribute(ellipse, 'rx');
  const ry = getNumbericAttribute(ellipse, 'ry') || rx;
  const cdx = rx * KAPPA; // Control distance x.

  const cdy = ry * KAPPA; // Control distance y.

  const d = ['M', cx, cy - ry, 'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, 'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, 'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, 'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, 'Z'].join(' ');
  return d;
}
function rectangleToPathData(rect) {
  return rectToPathData({
    x: getNumbericAttribute(rect, 'x', 0),
    y: getNumbericAttribute(rect, 'y', 0),
    width: getNumbericAttribute(rect, 'width', 0),
    height: getNumbericAttribute(rect, 'height', 0),
    rx: getNumbericAttribute(rect, 'rx', 0),
    ry: getNumbericAttribute(rect, 'ry', 0)
  });
}
function rectToPathData(r) {
  let d;
  const x = r.x;
  const y = r.y;
  const width = r.width;
  const height = r.height;
  const topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);
  const bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);
  const topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);
  const bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);

  if (topRx || bottomRx || topRy || bottomRy) {
    d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];
  } else {
    d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];
  }

  return d.join(' ');
}
function toPath(elem) {
  const path = (0,_elem__WEBPACK_IMPORTED_MODULE_1__.createSvgElement)('path');
  (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(path, (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(elem));
  const d = toPathData(elem);

  if (d) {
    path.setAttribute('d', d);
  }

  return path;
}
function toPathData(elem) {
  const tagName = elem.tagName.toLowerCase();

  switch (tagName) {
    case 'path':
      return elem.getAttribute('d');

    case 'line':
      return lineToPathData(elem);

    case 'polygon':
      return polygonToPathData(elem);

    case 'polyline':
      return polylineToPathData(elem);

    case 'ellipse':
      return ellipseToPathData(elem);

    case 'circle':
      return circleToPathData(elem);

    case 'rect':
      return rectangleToPathData(elem);

    default:
      break;
  }

  throw new Error(`"${tagName}" cannot be converted to svg path element.`);
} // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js

function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {
  const svgArcMax = 2 * Math.PI - 1e-6;
  const r0 = innerRadius;
  const r1 = outerRadius;
  let a0 = startAngle;
  let a1 = endAngle;

  if (a1 < a0) {
    const tmp = a0;
    a0 = a1;
    a1 = tmp;
  }

  const da = a1 - a0;
  const df = da < Math.PI ? '0' : '1';
  const c0 = Math.cos(a0);
  const s0 = Math.sin(a0);
  const c1 = Math.cos(a1);
  const s1 = Math.sin(a1);
  return da >= svgArcMax ? r0 ? // eslint-disable-next-line
  `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}M0,${r0}A${r0},${r0} 0 1,0 0,${-r0}A${r0},${r0} 0 1,0 0,${r0}Z` : // eslint-disable-next-line
  `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}Z` : r0 ? // eslint-disable-next-line
  `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L${r0 * c1},${r0 * s1}A${r0},${r0} 0 ${df},0 ${r0 * c0},${r0 * s0}Z` : // eslint-disable-next-line
  `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L0,0` + `Z`;
}

/***/ }),

/***/ 54166:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/prefix.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getVendorPrefixedName": () => (/* binding */ getVendorPrefixedName)
/* harmony export */ });
const hyphenPattern = /-(.)/g;

function camelize(str) {
  return str.replace(hyphenPattern, (_, char) => char.toUpperCase());
}

const memoized = {};
const prefixes = ['Webkit', 'ms', 'Moz', 'O'];
const testStyle = document ? document.createElement('div').style : {};

function getWithPrefix(name) {
  for (let i = 0; i < prefixes.length; i += 1) {
    const prefixedName = prefixes[i] + name;

    if (prefixedName in testStyle) {
      return prefixedName;
    }
  }

  return null;
}

function getVendorPrefixedName(property) {
  const name = camelize(property);

  if (memoized[name] == null) {
    const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
    memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
  }

  return memoized[name];
}

/***/ }),

/***/ 73898:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/selection.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearSelection": () => (/* binding */ clearSelection)
/* harmony export */ });
const clearSelection = function () {
  const doc = document;

  if (doc.selection) {
    return function () {
      doc.selection.empty();
    };
  }

  if (window.getSelection) {
    return function () {
      const selection = window.getSelection();

      if (selection) {
        if (selection.empty) {
          selection.empty();
        } else if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
      }
    };
  }

  return function () {};
}();

/***/ }),

/***/ 14106:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/style.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getComputedStyle": () => (/* binding */ getComputedStyle),
/* harmony export */   "hasScrollbars": () => (/* binding */ hasScrollbars),
/* harmony export */   "setPrefixedStyle": () => (/* binding */ setPrefixedStyle)
/* harmony export */ });
/* harmony import */ var _prefix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prefix */ 54166);

function setPrefixedStyle(style, name, value) {
  const vendor = (0,_prefix__WEBPACK_IMPORTED_MODULE_0__.getVendorPrefixedName)(name);

  if (vendor != null) {
    style[vendor] = value;
  }

  style[name] = value;
}
function getComputedStyle(elem, name) {
  // IE9+
  const computed = elem.ownerDocument && elem.ownerDocument.defaultView && elem.ownerDocument.defaultView.opener ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : window.getComputedStyle(elem, null);

  if (computed && name) {
    return computed.getPropertyValue(name) || computed[name];
  }

  return computed;
}
function hasScrollbars(container) {
  const style = getComputedStyle(container);
  return style != null && (style.overflow === 'scroll' || style.overflow === 'auto');
}

/***/ }),

/***/ 18848:
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/text.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "breakText": () => (/* binding */ breakText),
/* harmony export */   "text": () => (/* binding */ text)
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number */ 65090);
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../text */ 24489);
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attr */ 11844);
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vector */ 9502);
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./elem */ 32076);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform */ 81115);
/* eslint-disable no-control-regex */







function createTextPathNode(attrs, elem) {
  const vel = _vector__WEBPACK_IMPORTED_MODULE_3__.Vector.create(elem);
  const textPath = _vector__WEBPACK_IMPORTED_MODULE_3__.Vector.create('textPath');
  const d = attrs.d;

  if (d && attrs['xlink:href'] === undefined) {
    const path = _vector__WEBPACK_IMPORTED_MODULE_3__.Vector.create('path').attr('d', d).appendTo(vel.defs());
    textPath.attr('xlink:href', `#${path.id}`);
  }

  if (typeof attrs === 'object') {
    textPath.attr(attrs);
  }

  return textPath.node;
}

function annotateTextLine(lineNode, lineAnnotations, options) {
  const eol = options.eol;
  const baseSize = options.baseSize;
  const lineHeight = options.lineHeight;
  let maxFontSize = 0;
  let tspanNode;
  const fontMetrics = {};
  const lastJ = lineAnnotations.length - 1;

  for (let j = 0; j <= lastJ; j += 1) {
    let annotation = lineAnnotations[j];
    let fontSize = null;

    if (typeof annotation === 'object') {
      const annotationAttrs = annotation.attrs;
      const vTSpan = _vector__WEBPACK_IMPORTED_MODULE_3__.Vector.create('tspan', annotationAttrs);
      tspanNode = vTSpan.node;
      let t = annotation.t;

      if (eol && j === lastJ) {
        t += eol;
      }

      tspanNode.textContent = t; // Per annotation className

      const annotationClass = annotationAttrs.class;

      if (annotationClass) {
        vTSpan.addClass(annotationClass);
      } // set the list of indices of all the applied annotations
      // in the `annotations` attribute. This list is a comma
      // separated list of indices.


      if (options.includeAnnotationIndices) {
        vTSpan.attr('annotations', annotation.annotations.join(','));
      } // Check for max font size


      fontSize = parseFloat(annotationAttrs['font-size']);
      if (fontSize === undefined) fontSize = baseSize;
      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;
    } else {
      if (eol && j === lastJ) {
        annotation += eol;
      }

      tspanNode = document.createTextNode(annotation || ' ');

      if (baseSize && baseSize > maxFontSize) {
        maxFontSize = baseSize;
      }
    }

    lineNode.appendChild(tspanNode);
  }

  if (maxFontSize) {
    fontMetrics.maxFontSize = maxFontSize;
  }

  if (lineHeight) {
    fontMetrics.lineHeight = lineHeight;
  } else if (maxFontSize) {
    fontMetrics.lineHeight = maxFontSize * 1.2;
  }

  return fontMetrics;
}

const emRegex = /em$/;

function emToPx(em, fontSize) {
  const numerical = parseFloat(em);

  if (emRegex.test(em)) {
    return numerical * fontSize;
  }

  return numerical;
}

function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
  if (!Array.isArray(linesMetrics)) {
    return 0;
  }

  const n = linesMetrics.length;
  if (!n) return 0;
  let lineMetrics = linesMetrics[0];
  const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
  let rLineHeights = 0;
  const lineHeightPx = emToPx(lineHeight, baseSizePx);

  for (let i = 1; i < n; i += 1) {
    lineMetrics = linesMetrics[i];
    const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
    rLineHeights += iLineHeight;
  }

  const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
  let dy;

  switch (alignment) {
    case 'middle':
      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
      break;

    case 'bottom':
      dy = -(0.25 * llMaxFont) - rLineHeights;
      break;

    default:
    case 'top':
      dy = 0.8 * flMaxFont;
      break;
  }

  return dy;
}

function text(elem, content, options = {}) {
  content = _text__WEBPACK_IMPORTED_MODULE_1__.Text.sanitize(content); // eslint-disable-line

  const eol = options.eol;
  let textPath = options.textPath;
  const verticalAnchor = options.textVerticalAnchor;
  const namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top'; // Horizontal shift applied to all the lines but the first.

  let x = options.x;

  if (x === undefined) {
    x = elem.getAttribute('x') || 0;
  } // Annotations


  const iai = options.includeAnnotationIndices;
  let annotations = options.annotations;

  if (annotations && !Array.isArray(annotations)) {
    annotations = [annotations];
  } // Shift all the <tspan> but first by one line (`1em`)


  const defaultLineHeight = options.lineHeight;
  const autoLineHeight = defaultLineHeight === 'auto';
  const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';
  (0,_elem__WEBPACK_IMPORTED_MODULE_4__.empty)(elem);
  (0,_attr__WEBPACK_IMPORTED_MODULE_2__.attr)(elem, {
    // Preserve spaces, do not consecutive spaces to get collapsed to one.
    'xml:space': 'preserve',
    // An empty text gets rendered into the DOM in webkit-based browsers.
    // In order to unify this behaviour across all browsers
    // we rather hide the text element when it's empty.
    display: content || options.displayEmpty ? null : 'none'
  }); // Set default font-size if none

  const strFontSize = (0,_attr__WEBPACK_IMPORTED_MODULE_2__.attr)(elem, 'font-size');
  let fontSize = parseFloat(strFontSize);

  if (!fontSize) {
    fontSize = 16;

    if ((namedVerticalAnchor || annotations) && !strFontSize) {
      (0,_attr__WEBPACK_IMPORTED_MODULE_2__.attr)(elem, 'font-size', `${fontSize}`);
    }
  }

  let containerNode;

  if (textPath) {
    // Now all the `<tspan>`s will be inside the `<textPath>`.
    if (typeof textPath === 'string') {
      textPath = {
        d: textPath
      };
    }

    containerNode = createTextPathNode(textPath, elem);
  } else {
    containerNode = document.createDocumentFragment();
  }

  let dy;
  let offset = 0;
  let annotatedY;
  const lines = content.split('\n');
  const linesMetrics = [];
  const lastI = lines.length - 1;

  for (let i = 0; i <= lastI; i += 1) {
    dy = lineHeight;
    let lineClassName = 'v-line';
    const lineNode = (0,_elem__WEBPACK_IMPORTED_MODULE_4__.createSvgElement)('tspan');
    let lineMetrics;
    let line = lines[i];

    if (line) {
      if (annotations) {
        // Find the *compacted* annotations for this line.
        const lineAnnotations = _text__WEBPACK_IMPORTED_MODULE_1__.Text.annotate(line, annotations, {
          offset: -offset,
          includeAnnotationIndices: iai
        });
        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
          eol: i !== lastI && eol,
          baseSize: fontSize,
          lineHeight: autoLineHeight ? null : lineHeight,
          includeAnnotationIndices: iai
        }); // Get the line height based on the biggest font size
        // in the annotations for this line.

        const iLineHeight = lineMetrics.lineHeight;

        if (iLineHeight && autoLineHeight && i !== 0) {
          dy = iLineHeight;
        }

        if (i === 0) {
          annotatedY = lineMetrics.maxFontSize * 0.8;
        }
      } else {
        if (eol && i !== lastI) {
          line += eol;
        }

        lineNode.textContent = line;
      }
    } else {
      // Make sure the textContent is never empty. If it is, add a dummy
      // character and make it invisible, making the following lines correctly
      // relatively positioned. `dy=1em` won't work with empty lines otherwise.
      lineNode.textContent = '-';
      lineClassName += ' v-empty-line';
      const lineNodeStyle = lineNode.style;
      lineNodeStyle.fillOpacity = 0;
      lineNodeStyle.strokeOpacity = 0;

      if (annotations) {
        lineMetrics = {};
      }
    }

    if (lineMetrics) {
      linesMetrics.push(lineMetrics);
    }

    if (i > 0) {
      lineNode.setAttribute('dy', dy);
    } // Firefox requires 'x' to be set on the first line


    if (i > 0 || textPath) {
      lineNode.setAttribute('x', x);
    }

    lineNode.className.baseVal = lineClassName;
    containerNode.appendChild(lineNode);
    offset += line.length + 1; // + 1 = newline character.
  } // Y Alignment calculation


  if (namedVerticalAnchor) {
    if (annotations) {
      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
    } else if (verticalAnchor === 'top') {
      // A shortcut for top alignment. It does not depend on font-size nor line-height
      dy = '0.8em';
    } else {
      let rh; // remaining height

      if (lastI > 0) {
        rh = parseFloat(lineHeight) || 1;
        rh *= lastI;
        if (!emRegex.test(lineHeight)) rh /= fontSize;
      } else {
        // Single-line text
        rh = 0;
      }

      switch (verticalAnchor) {
        case 'middle':
          dy = `${0.3 - rh / 2}em`;
          break;

        case 'bottom':
          dy = `${-rh - 0.3}em`;
          break;

        default:
          break;
      }
    }
  } else if (verticalAnchor === 0) {
    dy = '0em';
  } else if (verticalAnchor) {
    dy = verticalAnchor;
  } else {
    // No vertical anchor is defined
    dy = 0; // Backwards compatibility - we change the `y` attribute instead of `dy`.

    if (elem.getAttribute('y') == null) {
      elem.setAttribute('y', `${annotatedY || '0.8em'}`);
    }
  }

  const firstLine = containerNode.firstChild;
  firstLine.setAttribute('dy', dy);
  elem.appendChild(containerNode);
}

function splitText(text, separator, eol, hyphen) {
  const words = [];
  const separators = [];

  if (separator != null) {
    const parts = text.split(separator);
    words.push(...parts);

    if (typeof separator === 'string') {
      for (let i = 0, l = parts.length - 1; i < l; i += 1) {
        separators.push(separator);
      }
    } else {
      const seps = text.match(new RegExp(separator, 'g'));

      for (let i = 0, l = parts.length - 1; i < l; i += 1) {
        separators.push(seps ? seps[i] : '');
      }
    }
  } else {
    let word = '';

    for (let i = 0, l = text.length; i < l; i += 1) {
      const char = text[i];

      if (char === ' ') {
        words.push(word);
        separators.push(' ');
        word = '';
      } else if (char.match(/[^\x00-\xff]/)) {
        // split double byte character
        if (word.length) {
          words.push(word);
          separators.push('');
        }

        words.push(char);
        separators.push('');
        word = '';
      } else {
        word += char;
      }
    }

    if (word.length) {
      words.push(word);
    }
  } // end-of-line


  for (let i = 0; i < words.length; i += 1) {
    const word = words[i];

    if (word.indexOf(eol) >= 0 && word.length > 1) {
      const parts = word.split(eol);

      for (let j = 0, k = parts.length - 1; j < k; j += 1) {
        parts.splice(2 * j + 1, 0, eol);
      }

      const valids = parts.filter(part => part !== '');
      words.splice(i, 1, ...valids);
      const seps = valids.map(() => '');
      seps.pop();
      separators.splice(i, 0, ...seps);
    }
  } // hyphen


  for (let i = 0; i < words.length; i += 1) {
    const word = words[i];
    const index = word.search(hyphen);

    if (index > 0 && index < word.length - 1) {
      words.splice(i, 1, word.substring(0, index + 1), word.substring(index + 1));
      separators.splice(i, 0, '');
    }
  }

  return {
    words,
    separators
  };
}

function breakText(text, size, styles = {}, options = {}) {
  const width = size.width;
  const height = size.height;
  const svgDocument = options.svgDocument || (0,_elem__WEBPACK_IMPORTED_MODULE_4__.createSvgElement)('svg');
  const telem = (0,_elem__WEBPACK_IMPORTED_MODULE_4__.createSvgElement)('text');
  const tspan = (0,_elem__WEBPACK_IMPORTED_MODULE_4__.createSvgElement)('tspan');
  const tnode = document.createTextNode('');
  (0,_attr__WEBPACK_IMPORTED_MODULE_2__.attr)(telem, styles);
  telem.appendChild(tspan); // Prevent flickering

  telem.style.opacity = '0'; // Prevent FF from throwing an uncaught exception when `getBBox()`
  // called on element that is not in the render tree (is not measurable).
  // <tspan>.getComputedTextLength() returns always 0 in this case.
  // Note that the `textElement` resp. `textSpan` can become hidden
  // when it's appended to the DOM and a `display: none` CSS stylesheet
  // rule gets applied.

  telem.style.display = 'block';
  tspan.style.display = 'block';
  tspan.appendChild(tnode);
  svgDocument.appendChild(telem);
  const shouldAppend = svgDocument.parentNode == null;

  if (shouldAppend) {
    document.body.appendChild(svgDocument);
  }

  const eol = options.eol || '\n';
  const separator = options.separator || ' ';
  const hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\w\d]/;
  const breakWord = options.breakWord !== false;
  const full = [];
  const lineSeprators = {};
  let lines = [];
  let partIndex; // let hyphenIndex

  let lineHeight;
  let currentSeparator;
  const {
    words,
    separators
  } = splitText(text, options.separator, eol, hyphen);

  for (let wordIndex = 0, lineIndex = 0, wordCount = words.length; wordIndex < wordCount; wordIndex += 1) {
    const word = words[wordIndex]; // empty word

    if (!word) {
      continue;
    } // end of line


    if (word === eol) {
      full[lineIndex] = true; // start a new line

      lineIndex += 1;
      lines[lineIndex] = '';
      continue;
    }

    if (lines[lineIndex] != null) {
      currentSeparator = separators[wordIndex - 1] || '';
      tnode.data = `${lines[lineIndex]}${currentSeparator}${word}`;
    } else {
      tnode.data = word;
    }

    if (tspan.getComputedTextLength() <= width) {
      // update line
      lines[lineIndex] = tnode.data;
      lineSeprators[lineIndex] = separators[wordIndex]; // when is partitioning, put rest of the word onto next line

      if (partIndex) {
        full[lineIndex] = true;
        lineIndex += 1;
        partIndex = 0;
      }
    } else {
      if (breakWord) {
        // word is too long to put in one line or is partitioning
        if (!lines[lineIndex] || partIndex) {
          const isPartition = !!partIndex;
          const isCharacter = word.length === 1;
          partIndex = word.length - 1;

          if (isPartition || isCharacter) {
            // word has only one character.
            if (isCharacter) {
              if (!lines[lineIndex]) {
                // can't fit this text within our rect
                lines = [];
                break;
              } // partitioning didn't help on the non-empty line
              // try again, but this time start with a new line
              // cancel partitions created


              words.splice(wordIndex, 2, word + words[wordIndex + 1]);
              separators.splice(wordIndex + 1, 1);
              full[lineIndex] = true;
              lineIndex += 1;
              wordCount -= 1;
              wordIndex -= 1;
              continue;
            } // update the partitioning words


            words[wordIndex] = word.substring(0, partIndex);
            words[wordIndex + 1] = word.substring(partIndex) + words[wordIndex + 1];
          } else {
            // partitioning the long word into two words
            words.splice(wordIndex, 1, word.substring(0, partIndex), word.substring(partIndex));
            separators.splice(wordIndex, 0, '');
            wordCount += 1; // if the previous line is not full

            if (lineIndex && !full[lineIndex - 1]) {
              lineIndex -= 1;
            }
          }

          wordIndex -= 1;
          continue;
        }
      } else if (!lines[lineIndex]) {
        lines[lineIndex] = word;
        full[lineIndex] = true;
        lineIndex += 1;
        continue;
      }

      lineIndex += 1;
      wordIndex -= 1;
    } // check whether the height of the entire text exceeds the rect height


    if (height != null) {
      // ensure line height
      if (lineHeight == null) {
        let heightValue; // use the same defaults as in V.prototype.text

        if (styles.lineHeight === 'auto') {
          heightValue = {
            value: 1.5,
            unit: 'em'
          };
        } else {
          heightValue = _number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.parseCssNumeric(styles.lineHeight, ['em']) || {
            value: 1,
            unit: 'em'
          };
        }

        lineHeight = heightValue.value;

        if (heightValue.unit === 'em') {
          if (_platform__WEBPACK_IMPORTED_MODULE_5__.Platform.IS_FIREFOX) {
            lineHeight *= tspan.getBBox().height;
          } else {
            lineHeight *= telem.getBBox().height;
          }
        }
      }

      if (lineHeight * lines.length > height) {
        // remove overflowing lines
        const lastLineIndex = Math.floor(height / lineHeight) - 1;
        const lastLine = lines[lastLineIndex];
        const overflowLine = lines[lastLineIndex + 1];
        lines.splice(lastLineIndex + 1);

        if (lastLine == null) {
          break;
        } // add ellipsis


        let ellipsis = options.ellipsis;

        if (!ellipsis) {
          break;
        }

        if (typeof ellipsis !== 'string') {
          ellipsis = '\u2026';
        }

        let fullLastLine = lastLine;

        if (overflowLine && breakWord) {
          fullLastLine += currentSeparator + overflowLine;
        }

        let lastCharIndex = fullLastLine.length;
        let fixedLastLine;
        let lastChar;

        do {
          lastChar = fullLastLine[lastCharIndex];
          fixedLastLine = fullLastLine.substring(0, lastCharIndex);

          if (!lastChar) {
            fixedLastLine += lineSeprators[lastLineIndex];
          } else if (lastChar.match(separator)) {
            fixedLastLine += lastChar;
          }

          fixedLastLine += ellipsis;
          tnode.data = fixedLastLine;

          if (tspan.getComputedTextLength() <= width) {
            lines[lastLineIndex] = fixedLastLine;
            break;
          }

          lastCharIndex -= 1;
        } while (lastCharIndex >= 0);

        break;
      }
    }
  }

  if (shouldAppend) {
    (0,_elem__WEBPACK_IMPORTED_MODULE_4__.remove)(svgDocument);
  } else {
    (0,_elem__WEBPACK_IMPORTED_MODULE_4__.remove)(telem);
  }

  return lines.join(eol);
}

/***/ }),

/***/ 30766:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/transform.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rotate": () => (/* binding */ rotate),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "translate": () => (/* binding */ translate),
/* harmony export */   "translateAndAutoOrient": () => (/* binding */ translateAndAutoOrient)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr */ 11844);
/* harmony import */ var _geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geom */ 60240);
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matrix */ 68067);




function transform(elem, matrix, options = {}) {
  if (matrix == null) {
    return (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.transformStringToMatrix)((0,_attr__WEBPACK_IMPORTED_MODULE_1__.attr)(elem, 'transform'));
  }

  if (options.absolute) {
    elem.setAttribute('transform', (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.matrixToTransformString)(matrix));
    return;
  }

  const transformList = elem.transform;
  const svgTransform = (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.createSVGTransform)(matrix);
  transformList.baseVal.appendItem(svgTransform);
}
function translate(elem, tx, ty = 0, options = {}) {
  let transformAttr = (0,_attr__WEBPACK_IMPORTED_MODULE_1__.attr)(elem, 'transform');
  const transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.parseTransformString)(transformAttr);

  if (tx == null) {
    return transform.translation;
  }

  transformAttr = transform.raw;
  transformAttr = transformAttr.replace(/translate\([^)]*\)/g, '').trim();
  const newTx = options.absolute ? tx : transform.translation.tx + tx;
  const newTy = options.absolute ? ty : transform.translation.ty + ty;
  const newTranslate = `translate(${newTx},${newTy})`; // Note that `translate()` is always the first transformation. This is
  // usually the desired case.

  elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim());
}
function rotate(elem, angle, cx, cy, options = {}) {
  let transformAttr = (0,_attr__WEBPACK_IMPORTED_MODULE_1__.attr)(elem, 'transform');
  const transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.parseTransformString)(transformAttr);

  if (angle == null) {
    return transform.rotation;
  }

  transformAttr = transform.raw;
  transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, '').trim();
  angle %= 360; // eslint-disable-line

  const newAngle = options.absolute ? angle : transform.rotation.angle + angle;
  const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : '';
  const newRotate = `rotate(${newAngle}${newOrigin})`;
  elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim());
}
function scale(elem, sx, sy) {
  let transformAttr = (0,_attr__WEBPACK_IMPORTED_MODULE_1__.attr)(elem, 'transform');
  const transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.parseTransformString)(transformAttr);

  if (sx == null) {
    return transform.scale;
  }

  sy = sy == null ? sx : sy; // eslint-disable-line

  transformAttr = transform.raw;
  transformAttr = transformAttr.replace(/scale\([^)]*\)/g, '').trim();
  const newScale = `scale(${sx},${sy})`;
  elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim());
}
function translateAndAutoOrient(elem, position, reference, target) {
  const pos = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(position);
  const ref = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(reference);

  if (!target) {
    const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
    target = svg; // eslint-disable-line
  } // Clean-up previously set transformations except the scale.
  // If we didn't clean up the previous transformations then they'd
  // add up with the old ones. Scale is an exception as it doesn't
  // add up, consider: `this.scale(2).scale(2).scale(2)`. The result
  // is that the element is scaled by the factor 2, not 8.


  const s = scale(elem);
  elem.setAttribute('transform', '');
  const bbox = (0,_geom__WEBPACK_IMPORTED_MODULE_2__.getBBox)(elem, {
    target
  }).scale(s.sx, s.sy); // 1. Translate to origin.

  const translateToOrigin = (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.createSVGTransform)();
  translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2); // 2. Rotate around origin.

  const rotateAroundOrigin = (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.createSVGTransform)();
  const angle = pos.angleBetween(ref, pos.clone().translate(1, 0));
  if (angle) rotateAroundOrigin.setRotate(angle, 0, 0); // 3. Translate to the `position` + the offset (half my width)
  //    towards the `reference` point.

  const translateFromOrigin = (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.createSVGTransform)();
  const finalPosition = pos.clone().move(ref, bbox.width / 2);
  translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y); // 4. Get the current transformation matrix of this node

  const ctm = (0,_geom__WEBPACK_IMPORTED_MODULE_2__.getTransformToElement)(elem, target); // 5. Apply transformations and the scale

  const transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.createSVGTransform)();
  transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));
  elem.setAttribute('transform', (0,_matrix__WEBPACK_IMPORTED_MODULE_3__.matrixToTransformString)(transform.matrix));
}

/***/ }),

/***/ 9246:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/dom/vector.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createVector": () => (/* binding */ createVector),
/* harmony export */   "createVectors": () => (/* binding */ createVectors),
/* harmony export */   "isVector": () => (/* binding */ isVector)
/* harmony export */ });
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vector */ 9502);

/**
 * **Deprecation Notice:** `Dom.isVector` is deprecated and will be moved in next
 * major release. Use `Vector.isVector()` instead.
 *
 * @deprecated
 */

const isVector = _vector__WEBPACK_IMPORTED_MODULE_0__.Vector.isVector;
/**
 * **Deprecation Notice:** `Dom.createVector` is deprecated and will be moved
 * in next major release. Use `Vector.create()` instead.
 *
 * @deprecated
 */

const createVector = _vector__WEBPACK_IMPORTED_MODULE_0__.Vector.create;
/**
 * **Deprecation Notice:** `Dom.createVectors` is deprecated and will be moved
 * in next major release. Use `Vector.createVectors()` instead.
 *
 * @deprecated
 */

const createVectors = _vector__WEBPACK_IMPORTED_MODULE_0__.Vector.createVectors;

/***/ }),

/***/ 4783:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/function/async.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isAsync": () => (/* binding */ isAsync),
/* harmony export */   "isAsyncLike": () => (/* binding */ isAsyncLike),
/* harmony export */   "toAsyncBoolean": () => (/* binding */ toAsyncBoolean),
/* harmony export */   "toDeferredBoolean": () => (/* binding */ toDeferredBoolean)
/* harmony export */ });
function isAsyncLike(obj) {
  return typeof obj === 'object' && obj.then && typeof obj.then === 'function';
}
function isAsync(obj) {
  return obj != null && (obj instanceof Promise || isAsyncLike(obj));
}
function toAsyncBoolean(...inputs) {
  const results = [];
  inputs.forEach(arg => {
    if (Array.isArray(arg)) {
      results.push(...arg);
    } else {
      results.push(arg);
    }
  });
  const hasAsync = results.some(res => isAsync(res));

  if (hasAsync) {
    const deferres = results.map(res => isAsync(res) ? res : Promise.resolve(res !== false));
    return Promise.all(deferres).then(arr => arr.reduce((memo, item) => item !== false && memo, true));
  }

  return results.every(res => res !== false);
}
function toDeferredBoolean(...inputs) {
  const ret = toAsyncBoolean(inputs);
  return typeof ret === 'boolean' ? Promise.resolve(ret) : ret;
}

/***/ }),

/***/ 42498:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/function/function.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "apply": () => (/* binding */ apply),
/* harmony export */   "cacher": () => (/* binding */ cacher),
/* harmony export */   "call": () => (/* binding */ call),
/* harmony export */   "debounce": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "defer": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "isFunction": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "noop": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "once": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ 15849);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ 95625);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ 14403);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ 88673);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ 33068);

function apply(fn, ctx, args) {
  if (args) {
    switch (args.length) {
      case 0:
        return fn.call(ctx);

      case 1:
        return fn.call(ctx, args[0]);

      case 2:
        return fn.call(ctx, args[0], args[1]);

      case 3:
        return fn.call(ctx, args[0], args[1], args[2]);

      case 4:
        return fn.call(ctx, args[0], args[1], args[2], args[3]);

      case 5:
        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);

      case 6:
        return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);

      default:
        return fn.apply(ctx, args);
    }
  }

  return fn.call(ctx);
}
function call(fn, ctx, ...args) {
  return apply(fn, ctx, args);
}

function repush(array, item) {
  for (let i = 0, ii = array.length; i < ii; i += 1) {
    if (array[i] === item) {
      return array.push(array.splice(i, 1)[0]);
    }
  }
}

function cacher(fn, ctx, postProcessor) {
  const keys = [];
  const cache = {};

  const f = (...args) => {
    let hasCache = false;
    const key = args.join('\u2400');

    if (key in cache) {
      hasCache = true;
      repush(keys, key);
    } else {
      if (keys.length >= 1000) {
        delete cache[keys.shift()];
      }

      keys.push(key);
      cache[key] = apply(fn, ctx || null, args);
    }

    return postProcessor ? postProcessor(cache[key], hasCache) : cache[key];
  };

  return f;
}

/***/ }),

/***/ 5144:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/function/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FunctionExt": () => (/* reexport module object */ _main__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ 57059);



/***/ }),

/***/ 57059:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/function/main.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "apply": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.apply),
/* harmony export */   "cacher": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.cacher),
/* harmony export */   "call": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.call),
/* harmony export */   "debounce": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.debounce),
/* harmony export */   "defer": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.defer),
/* harmony export */   "isAsync": () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_1__.isAsync),
/* harmony export */   "isAsyncLike": () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_1__.isAsyncLike),
/* harmony export */   "isFunction": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.isFunction),
/* harmony export */   "noop": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.noop),
/* harmony export */   "once": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.once),
/* harmony export */   "toAsyncBoolean": () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_1__.toAsyncBoolean),
/* harmony export */   "toDeferredBoolean": () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_1__.toDeferredBoolean)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ 42498);
/* harmony import */ var _async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async */ 4783);



/***/ }),

/***/ 44650:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArrayExt": () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_3__.ArrayExt),
/* harmony export */   "DataUri": () => (/* reexport safe */ _datauri__WEBPACK_IMPORTED_MODULE_11__.DataUri),
/* harmony export */   "Dom": () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_13__.Dom),
/* harmony export */   "FunctionExt": () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_7__.FunctionExt),
/* harmony export */   "JQuery": () => (/* reexport default from dynamic */ jquery__WEBPACK_IMPORTED_MODULE_0___default.a),
/* harmony export */   "JSONExt": () => (/* reexport safe */ _json__WEBPACK_IMPORTED_MODULE_10__.JSONExt),
/* harmony export */   "Lang": () => (/* reexport safe */ _lang__WEBPACK_IMPORTED_MODULE_2__.Lang),
/* harmony export */   "NumberExt": () => (/* reexport safe */ _number__WEBPACK_IMPORTED_MODULE_6__.NumberExt),
/* harmony export */   "ObjectExt": () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_4__.ObjectExt),
/* harmony export */   "Platform": () => (/* reexport safe */ _platform__WEBPACK_IMPORTED_MODULE_8__.Platform),
/* harmony export */   "Scheduler": () => (/* reexport safe */ _scheduler__WEBPACK_IMPORTED_MODULE_16__.Scheduler),
/* harmony export */   "SizeSensor": () => (/* reexport safe */ _size_sensor__WEBPACK_IMPORTED_MODULE_15__.SizeSensor),
/* harmony export */   "StringExt": () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_5__.StringExt),
/* harmony export */   "Text": () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_9__.Text),
/* harmony export */   "Unit": () => (/* reexport safe */ _unit__WEBPACK_IMPORTED_MODULE_12__.Unit),
/* harmony export */   "Vector": () => (/* reexport safe */ _vector__WEBPACK_IMPORTED_MODULE_14__.Vector)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polyfill */ 8300);
/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lang */ 48234);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array */ 17573);
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./object */ 79747);
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./string */ 6402);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./number */ 65090);
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./function */ 5144);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./platform */ 81115);
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./text */ 24489);
/* harmony import */ var _json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./json */ 73943);
/* harmony import */ var _datauri__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./datauri */ 79568);
/* harmony import */ var _unit__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./unit */ 69526);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dom */ 29138);
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./vector */ 9502);
/* harmony import */ var _size_sensor__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size-sensor */ 93109);
/* harmony import */ var _scheduler__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./scheduler */ 32220);



















/***/ }),

/***/ 73943:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/json/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JSONExt": () => (/* binding */ JSONExt)
/* harmony export */ });
/**
 * The namespace for JSON-specific functions.
 */
var JSONExt;

(function (JSONExt) {
  /**
   * A shared frozen empty JSONObject
   */
  JSONExt.emptyObject = Object.freeze({});
  /**
   * A shared frozen empty JSONArray
   */

  JSONExt.emptyArray = Object.freeze([]);
  /**
   * Test whether a JSON value is a primitive.
   *
   * @param value - The JSON value of interest.
   *
   * @returns `true` if the value is a primitive,`false` otherwise.
   */

  function isPrimitive(value) {
    return value === null || value === undefined || typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string';
  }

  JSONExt.isPrimitive = isPrimitive;

  function isArray(value) {
    return Array.isArray(value);
  }

  JSONExt.isArray = isArray;

  function isObject(value) {
    return !isPrimitive(value) && !isArray(value);
  }

  JSONExt.isObject = isObject;
  /**
   * Compare two JSON values for deep equality.
   *
   * @param first - The first JSON value of interest.
   *
   * @param second - The second JSON value of interest.
   *
   * @returns `true` if the values are equivalent, `false` otherwise.
   */

  function deepEqual(first, second) {
    // Check referential and primitive equality first.
    if (first === second) {
      return true;
    } // If one is a primitive, the `===` check ruled out the other.


    if (isPrimitive(first) || isPrimitive(second)) {
      return false;
    } // Test whether they are arrays.


    const a1 = isArray(first);
    const a2 = isArray(second); // Bail if the types are different.

    if (a1 !== a2) {
      return false;
    } // If they are both arrays, compare them.


    if (a1 && a2) {
      return deepArrayEqual(first, second);
    } // At this point, they must both be objects.


    return deepObjectEqual(first, second);
  }

  JSONExt.deepEqual = deepEqual;
  /**
   * Create a deep copy of a JSON value.
   *
   * @param value - The JSON value to copy.
   *
   * @returns A deep copy of the given JSON value.
   */

  function deepCopy(value) {
    // Do nothing for primitive values.
    if (isPrimitive(value)) {
      return value;
    } // Deep copy an array.


    if (isArray(value)) {
      return deepArrayCopy(value);
    } // Deep copy an object.


    return deepObjectCopy(value);
  }

  JSONExt.deepCopy = deepCopy;
  /**
   * Compare two JSON arrays for deep equality.
   */

  function deepArrayEqual(first, second) {
    // Check referential equality first.
    if (first === second) {
      return true;
    } // Test the arrays for equal length.


    if (first.length !== second.length) {
      return false;
    } // Compare the values for equality.


    for (let i = 0, n = first.length; i < n; i += 1) {
      if (!deepEqual(first[i], second[i])) {
        return false;
      }
    } // At this point, the arrays are equal.


    return true;
  }
  /**
   * Compare two JSON objects for deep equality.
   */


  function deepObjectEqual(first, second) {
    // Check referential equality first.
    if (first === second) {
      return true;
    } // Check for the first object's keys in the second object.
    // eslint-disable-next-line


    for (const key in first) {
      if (!(key in second)) {
        return false;
      }
    } // Check for the second object's keys in the first object.
    // eslint-disable-next-line


    for (const key in second) {
      if (!(key in first)) {
        return false;
      }
    } // Compare the values for equality.
    // eslint-disable-next-line


    for (const key in first) {
      if (!deepEqual(first[key], second[key])) {
        return false;
      }
    } // At this point, the objects are equal.


    return true;
  }
  /**
   * Create a deep copy of a JSON array.
   */


  function deepArrayCopy(value) {
    const result = new Array(value.length); // eslint-disable-line

    for (let i = 0, n = value.length; i < n; i += 1) {
      result[i] = deepCopy(value[i]);
    }

    return result;
  }
  /**
   * Create a deep copy of a JSON object.
   */


  function deepObjectCopy(value) {
    const result = {};
    Object.keys(value).forEach(key => {
      result[key] = deepCopy(value[key]);
    });
    return result;
  }
})(JSONExt || (JSONExt = {}));

/***/ }),

/***/ 48234:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/lang/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Lang": () => (/* reexport module object */ _lang__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ 57393);



/***/ }),

/***/ 57393:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/lang/lang.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isArray": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "isArrayLike": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "isBoolean": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "isFunction": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "isNil": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "isNull": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "isNumber": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "isNumeric": () => (/* binding */ isNumeric),
/* harmony export */   "isObject": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "isString": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "isUndefined": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "isWindow": () => (/* binding */ isWindow)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ 48172);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ 55421);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ 5279);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ 7190);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ 65735);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ 96195);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ 19089);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ 17191);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ 83917);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ 15849);

const isWindow = value => value && value === value.window;
const isNumeric = value => !Array.isArray(value) && value - parseFloat(value) + 1 >= 0;

/***/ }),

/***/ 65090:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/number/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NumberExt": () => (/* reexport module object */ _number__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ 72109);



/***/ }),

/***/ 72109:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/number/number.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clamp": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "inRange": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "isFinite": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "isInteger": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "isNaN": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "isNumber": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "isNumeric": () => (/* reexport safe */ _lang_lang__WEBPACK_IMPORTED_MODULE_12__.isNumeric),
/* harmony export */   "isPercentage": () => (/* binding */ isPercentage),
/* harmony export */   "isSafeInteger": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "mod": () => (/* binding */ mod),
/* harmony export */   "normalizePercentage": () => (/* binding */ normalizePercentage),
/* harmony export */   "normalizeSides": () => (/* binding */ normalizeSides),
/* harmony export */   "parseCssNumeric": () => (/* binding */ parseCssNumeric),
/* harmony export */   "parseInt": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "toFinite": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "toInteger": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "toNumber": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "toSafeInteger": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ 60560);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ 65735);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ 48961);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ 81663);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ 38804);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ 16450);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ 10601);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ 46503);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ 79034);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ 26011);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ 23374);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ 46061);
/* harmony import */ var _lang_lang__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../lang/lang */ 57393);


/**
 * Returns the remainder of division of `n` by `m`. You should use this
 * instead of the built-in operation as the built-in operation does not
 * properly handle negative numbers.
 */

function mod(n, m) {
  return (n % m + m) % m;
}
function random(lower, upper) {
  if (upper == null) {
    upper = lower == null ? 1 : lower; // eslint-disable-line

    lower = 0; // eslint-disable-line
  } else if (upper < lower) {
    const tmp = lower;
    lower = upper; // eslint-disable-line

    upper = tmp; // eslint-disable-line
  }

  return Math.floor(Math.random() * (upper - lower + 1) + lower);
}
function isPercentage(val) {
  return typeof val === 'string' && val.slice(-1) === '%';
}
function normalizePercentage(num, ref) {
  if (num == null) {
    return 0;
  }

  let raw;

  if (typeof num === 'string') {
    raw = parseFloat(num);

    if (isPercentage(num)) {
      raw /= 100;

      if (Number.isFinite(raw)) {
        return raw * ref;
      }
    }
  } else {
    raw = num;
  }

  if (!Number.isFinite(raw)) {
    return 0;
  }

  if (raw > 0 && raw < 1) {
    return raw * ref;
  }

  return raw;
}
function parseCssNumeric(val, units) {
  function getUnit(regexp) {
    const matches = new RegExp(`(?:\\d+(?:\\.\\d+)*)(${regexp})$`).exec(val);

    if (!matches) {
      return null;
    }

    return matches[1];
  }

  const number = parseFloat(val);

  if (Number.isNaN(number)) {
    return null;
  } // determine the unit


  let regexp;

  if (units == null) {
    // accept any unit, as well as no unit
    regexp = '[A-Za-z]*';
  } else if (Array.isArray(units)) {
    if (units.length === 0) {
      return null;
    }

    regexp = units.join('|');
  } else if (typeof units === 'string') {
    regexp = units;
  }

  const unit = getUnit(regexp);

  if (unit === null) {
    return null;
  }

  return {
    unit,
    value: number
  };
}
function normalizeSides(box) {
  if (typeof box === 'object') {
    let left = 0;
    let top = 0;
    let right = 0;
    let bottom = 0;

    if (box.vertical != null && Number.isFinite(box.vertical)) {
      top = bottom = box.vertical;
    }

    if (box.horizontal != null && Number.isFinite(box.horizontal)) {
      right = left = box.horizontal;
    }

    if (box.left != null && Number.isFinite(box.left)) left = box.left;
    if (box.top != null && Number.isFinite(box.top)) top = box.top;
    if (box.right != null && Number.isFinite(box.right)) right = box.right;
    if (box.bottom != null && Number.isFinite(box.bottom)) bottom = box.bottom;
    return {
      top,
      right,
      bottom,
      left
    };
  }

  let val = 0;

  if (box != null && Number.isFinite(box)) {
    val = box;
  }

  return {
    top: val,
    right: val,
    bottom: val,
    left: val
  };
}

/***/ }),

/***/ 79747:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/object/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectExt": () => (/* reexport module object */ _object__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object */ 31392);



/***/ }),

/***/ 64795:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/object/inherit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createClass": () => (/* binding */ createClass),
/* harmony export */   "inherit": () => (/* binding */ inherit)
/* harmony export */ });
const extendStatics = Object.setPrototypeOf || {
  __proto__: []
} instanceof Array && function (d, b) {
  d.__proto__ = b; // eslint-disable-line no-proto
} || function (d, b) {
  // eslint-disable-next-line no-restricted-syntax
  for (const p in b) {
    if (Object.prototype.hasOwnProperty.call(b, p)) {
      d[p] = b[p];
    }
  }
};
/**
 * @see https://github.com/microsoft/TypeScript/blob/5c85febb0ce9d6088cbe9b09cb42f73f9ee8ea05/src/compiler/transformers/es2015.ts#L4309
 */
// eslint-disable-next-line


function inherit(cls, base) {
  extendStatics(cls, base);

  function tmp() {
    this.constructor = cls;
  }

  cls.prototype = base === null ? Object.create(base) : (tmp.prototype = base.prototype, new tmp());
}

class A {}

const isNativeClass = /^\s*class\s+/.test(`${A}`) || /^\s*class\s*\{/.test(`${class {}}`);
/**
 * Extends class with specified class name.
 */

function createClass(className, base) {
  let cls;

  if (isNativeClass) {
    cls = class extends base {};
  } else {
    cls = function () {
      return base.apply(this, arguments); // eslint-disable-line
    };

    inherit(cls, base);
  }

  Object.defineProperty(cls, 'name', {
    value: className
  });
  return cls;
}

/***/ }),

/***/ 67083:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/object/mixins.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyMixins": () => (/* binding */ applyMixins)
/* harmony export */ });
/**
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 */
function applyMixins(derivedCtor, ...baseCtors) {
  baseCtors.forEach(baseCtor => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
      if (name !== 'constructor') {
        Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
      }
    });
  });
}

/***/ }),

/***/ 31392:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/object/object.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyMixins": () => (/* reexport safe */ _mixins__WEBPACK_IMPORTED_MODULE_13__.applyMixins),
/* harmony export */   "clone": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "cloneDeep": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "createClass": () => (/* reexport safe */ _inherit__WEBPACK_IMPORTED_MODULE_14__.createClass),
/* harmony export */   "defaults": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "defaultsDeep": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "ensure": () => (/* binding */ ensure),
/* harmony export */   "extend": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "flatten": () => (/* binding */ flatten),
/* harmony export */   "forIn": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "getBoolean": () => (/* binding */ getBoolean),
/* harmony export */   "getByPath": () => (/* binding */ getByPath),
/* harmony export */   "getNumber": () => (/* binding */ getNumber),
/* harmony export */   "getValue": () => (/* binding */ getValue),
/* harmony export */   "has": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "inherit": () => (/* reexport safe */ _inherit__WEBPACK_IMPORTED_MODULE_14__.inherit),
/* harmony export */   "isEmpty": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "isEqual": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "isMaliciousProp": () => (/* binding */ isMaliciousProp),
/* harmony export */   "isObject": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "isPlainObject": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "merge": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "pick": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "setByPath": () => (/* binding */ setByPath),
/* harmony export */   "unsetByPath": () => (/* binding */ unsetByPath)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ 92941);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ 96928);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ 19167);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ 45269);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ 57607);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ 63247);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ 34607);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ 19089);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ 8978);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ 27746);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ 38163);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ 50280);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash-es */ 92078);
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./mixins */ 67083);
/* harmony import */ var _inherit__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./inherit */ 64795);



function ensure(value, defaultValue) {
  return value != null ? value : defaultValue;
}
function getValue(obj, key, defaultValue) {
  const value = obj != null ? obj[key] : null;
  return defaultValue !== undefined ? ensure(value, defaultValue) : value;
}
function getNumber(obj, key, defaultValue) {
  let value = obj != null ? obj[key] : null;

  if (value == null) {
    return defaultValue;
  }

  value = +value;

  if (Number.isNaN(value) || !Number.isFinite(value)) {
    return defaultValue;
  }

  return value;
}
function getBoolean(obj, key, defaultValue) {
  const value = obj != null ? obj[key] : null;

  if (value == null) {
    return defaultValue;
  }

  return !!value;
}
function isMaliciousProp(prop) {
  return prop === '__proto__';
}
function getByPath(obj, path, delimiter = '/') {
  let ret;
  const keys = Array.isArray(path) ? path : path.split(delimiter);

  if (keys.length) {
    ret = obj;

    while (keys.length) {
      const key = keys.shift();

      if (Object(ret) === ret && key && key in ret) {
        ret = ret[key];
      } else {
        return undefined;
      }
    }
  }

  return ret;
}
function setByPath(obj, path, value, delimiter = '/') {
  const keys = Array.isArray(path) ? path : path.split(delimiter);
  const lastKey = keys.pop();

  if (lastKey && !isMaliciousProp(lastKey)) {
    let diver = obj;
    keys.forEach(key => {
      if (!isMaliciousProp(key)) {
        if (diver[key] == null) {
          diver[key] = {};
        }

        diver = diver[key];
      }
    });
    diver[lastKey] = value;
  }

  return obj;
}
function unsetByPath(obj, path, delimiter = '/') {
  const keys = Array.isArray(path) ? path.slice() : path.split(delimiter);
  const propertyToRemove = keys.pop();

  if (propertyToRemove) {
    if (keys.length > 0) {
      const parent = getByPath(obj, keys);

      if (parent) {
        delete parent[propertyToRemove];
      }
    } else {
      delete obj[propertyToRemove];
    }
  }

  return obj;
}
function flatten(obj, delim = '/', stop) {
  const ret = {};
  Object.keys(obj).forEach(key => {
    const val = obj[key];
    let deep = typeof val === 'object' || Array.isArray(val);

    if (deep && stop && stop(val)) {
      deep = false;
    }

    if (deep) {
      const flatObject = flatten(val, delim, stop);
      Object.keys(flatObject).forEach(flatKey => {
        ret[key + delim + flatKey] = flatObject[flatKey];
      });
    } else {
      ret[key] = val;
    }
  }); // eslint-disable-next-line no-restricted-syntax

  for (const key in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, key)) {
      continue;
    }
  }

  return ret;
}

/***/ }),

/***/ 81115:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/platform/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Platform": () => (/* binding */ Platform)
/* harmony export */ });
const ua = navigator.userAgent;
var Platform;

(function (Platform) {
  Platform.IS_MAC = navigator.appVersion.indexOf('Mac') > 0;
  Platform.IS_IOS = !!ua.match(/(iPad|iPhone|iPod)/g);
  Platform.IS_WINDOWS = navigator.appVersion.indexOf('Win') > 0;
  Platform.IS_IE = ua.indexOf('MSIE') >= 0;
  Platform.IS_IE11 = !!ua.match(/Trident\/7\./);
  Platform.IS_EDGE = !!ua.match(/Edge\//);
  /**
   * A flag indicating whether the browser is Netscape (including Firefox).
   */

  Platform.IS_NETSCAPE = ua.indexOf('Mozilla/') >= 0 && ua.indexOf('MSIE') < 0 && ua.indexOf('Edge/') < 0;
  /**
   * A flag indicating whether the the this is running inside a Chrome App.
   */

  Platform.IS_CHROME_APP = window.chrome != null && window.chrome.app != null && window.chrome.app.runtime != null;
  Platform.IS_CHROME = ua.indexOf('Chrome/') >= 0 && ua.indexOf('Edge/') < 0;
  Platform.IS_OPERA = ua.indexOf('Opera/') >= 0 || ua.indexOf('OPR/') >= 0;
  Platform.IS_FIREFOX = ua.indexOf('Firefox/') >= 0;
  Platform.IS_SAFARI = ua.indexOf('AppleWebKit/') >= 0 && ua.indexOf('Chrome/') < 0 && ua.indexOf('Edge/') < 0;
  /**
   * A flag indicating whether this device supports touchstart/-move/-end
   * events (Apple iOS, Android, Chromebook and Chrome Browser on touch-enabled
   * devices).
   */

  Platform.SUPPORT_TOUCH = 'ontouchstart' in document.documentElement;
  /**
   * A flag indicating whether this device supports Microsoft pointer events.
   */

  Platform.SUPPORT_POINTER = window.PointerEvent != null && !Platform.IS_MAC;
  Platform.SUPPORT_PASSIVE = false; // eslint-disable-line import/no-mutable-exports

  try {
    const options = Object.defineProperty({}, 'passive', {
      get() {
        Platform.SUPPORT_PASSIVE = true;
      }

    });
    const div = document.createElement('div');

    if (div.addEventListener) {
      div.addEventListener('click', () => {}, options);
    }
  } catch (err) {// pass
  }
  /**
   * A flag indicating whether foreignObject support is not available. This
   * is the case for Opera, older SVG-based browsers and all versions of IE.
   */


  Platform.NO_FOREIGNOBJECT = !document.createElementNS || `${document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')}` !== '[object SVGForeignObjectElement]' || ua.indexOf('Opera/') >= 0;
  Platform.SUPPORT_FOREIGNOBJECT = !Platform.NO_FOREIGNOBJECT;
})(Platform || (Platform = {}));

(function (Platform) {
  function getHMRStatus() {
    const mod = window.module;

    if (mod != null && mod.hot != null && mod.hot.status != null) {
      return mod.hot.status();
    }

    return 'unkonwn';
  }

  Platform.getHMRStatus = getHMRStatus;

  function isApplyingHMR() {
    return getHMRStatus() === 'apply';
  }

  Platform.isApplyingHMR = isApplyingHMR; // This function checks if the specified event is supported by the browser.
  // Source: http://perfectionkills.com/detecting-event-support-without-browser-sniffing/

  const TAGNAMES = {
    select: 'input',
    change: 'input',
    submit: 'form',
    reset: 'form',
    error: 'img',
    load: 'img',
    abort: 'img'
  };

  function isEventSupported(event) {
    const elem = document.createElement(TAGNAMES[event] || 'div');
    const eventName = `on${event}`;
    let isSupported = (eventName in elem);

    if (!isSupported) {
      elem.setAttribute(eventName, 'return;');
      isSupported = typeof elem[eventName] === 'function';
    }

    return isSupported;
  }

  Platform.isEventSupported = isEventSupported;
})(Platform || (Platform = {}));

/***/ }),

/***/ 8300:
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/polyfill/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery_mousewheel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery-mousewheel */ 4361);
/* harmony import */ var jquery_mousewheel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_mousewheel__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform */ 81115);




if (_platform__WEBPACK_IMPORTED_MODULE_2__.Platform.SUPPORT_PASSIVE) {
  (jquery__WEBPACK_IMPORTED_MODULE_0___default().event.special.touchstart) = {
    setup(data, ns, handle) {
      if (!this.addEventListener) {
        return false;
      }

      this.addEventListener('touchstart', handle, {
        passive: true
      });
    }

  };
  const hook = (jquery__WEBPACK_IMPORTED_MODULE_0___default().event.special.mousewheel);

  if (hook) {
    const setup = hook.setup;

    hook.setup = function () {
      const addEventListener = this.addEventListener;

      if (!addEventListener) {
        return false;
      }

      this.addEventListener = (name, handler) => {
        addEventListener.call(this, name, handler, {
          passive: true
        });
      };

      setup.call(this);
      this.addEventListener = addEventListener;
    };
  }
} // compatible with NodeList.prototype.forEach() before chrome 51
// https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach


if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = Array.prototype.forEach;
} // compatible with ParentNode.append() before chrome 54
// https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/append()/append().md


;

(function (arr) {
  arr.forEach(item => {
    if (Object.prototype.hasOwnProperty.call(item, 'append')) {
      return;
    }

    Object.defineProperty(item, 'append', {
      configurable: true,
      enumerable: true,
      writable: true,

      value(...args) {
        const docFrag = document.createDocumentFragment();
        args.forEach(arg => {
          const isNode = arg instanceof Node;
          docFrag.appendChild(isNode ? arg : document.createTextNode(String(arg)));
        });
        this.appendChild(docFrag);
      }

    });
  });
})([Element.prototype, Document.prototype, DocumentFragment.prototype]);

/***/ }),

/***/ 32220:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/scheduler/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scheduler": () => (/* binding */ Scheduler)
/* harmony export */ });
var Scheduler;

(function (Scheduler) {
  const queue = [];
  const threshold = 1000 / 60;
  const unit = [];
  let deadline = 0;

  const getTime = () => performance.now();

  const peek = queue => queue[0];

  const schedule = cb => unit.push(cb) === 1 && postMessage();

  const postMessage = (() => {
    const cb = () => unit.splice(0, unit.length).forEach(c => c());

    if (typeof MessageChannel !== 'undefined') {
      const {
        port1,
        port2
      } = new MessageChannel();
      port1.onmessage = cb;
      return () => port2.postMessage(null);
    }

    return () => setTimeout(cb);
  })();

  const flushTask = () => {
    deadline = getTime() + threshold;
    let job = peek(queue);

    while (job && !Scheduler.shouldYield()) {
      const {
        callback,
        data
      } = job;
      job.callback = null;
      const next = callback && callback(data);

      if (next) {
        job.callback = next;
      } else {
        queue.shift();
      }

      job = peek(queue);
    }

    job && schedule(flushTask);
  };

  Scheduler.scheduleTask = (callback, data) => {
    const task = {
      callback,
      data
    };
    queue.push(task);
    schedule(flushTask);
  };

  Scheduler.shouldYield = () => {
    var _a, _b;

    return ((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline;
  };
})(Scheduler || (Scheduler = {}));

/***/ }),

/***/ 93109:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/size-sensor/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SizeSensor": () => (/* binding */ SizeSensor)
/* harmony export */ });
/* harmony import */ var _sensors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sensors */ 96057);

var SizeSensor;

(function (SizeSensor) {
  const cache = new WeakMap();

  function get(element) {
    let sensor = cache.get(element);

    if (sensor) {
      return sensor;
    }

    sensor = (0,_sensors__WEBPACK_IMPORTED_MODULE_0__.createSensor)(element);
    cache.set(element, sensor);
    return sensor;
  }

  function remove(sensor) {
    sensor.destroy();
    cache.delete(sensor.element);
  }

  SizeSensor.bind = (element, cb) => {
    const sensor = get(element);
    sensor.bind(cb);
    return () => sensor.unbind(cb);
  };

  SizeSensor.clear = element => {
    const sensor = get(element);
    remove(sensor);
  };
})(SizeSensor || (SizeSensor = {}));

/***/ }),

/***/ 96057:
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/size-sensor/sensors/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSensor": () => (/* binding */ createSensor)
/* harmony export */ });
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object */ 22263);
/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observer */ 99396);


const createSensor = typeof ResizeObserver !== 'undefined' ? _observer__WEBPACK_IMPORTED_MODULE_1__.createSensor : _object__WEBPACK_IMPORTED_MODULE_0__.createSensor;

/***/ }),

/***/ 22263:
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/size-sensor/sensors/object.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSensor": () => (/* binding */ createSensor)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 69744);

function createSensor(element) {
  let sensor = null;
  let listeners = [];

  const create = () => {
    if (getComputedStyle(element).position === 'static') {
      const style = element.style;
      style.position = 'relative';
    }

    const obj = document.createElement('object');

    obj.onload = () => {
      obj.contentDocument.defaultView.addEventListener('resize', trigger);
      trigger();
    };

    obj.style.display = 'block';
    obj.style.position = 'absolute';
    obj.style.top = '0';
    obj.style.left = '0';
    obj.style.height = '100%';
    obj.style.width = '100%';
    obj.style.overflow = 'hidden';
    obj.style.pointerEvents = 'none';
    obj.style.zIndex = '-1';
    obj.style.opacity = '0';
    obj.setAttribute('tabindex', '-1');
    obj.type = 'text/html';
    element.appendChild(obj); // for ie, should set data attribute delay, or will be white screen

    obj.data = 'about:blank';
    return obj;
  };

  const trigger = (0,_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {
    listeners.forEach(listener => listener(element));
  });

  const bind = listener => {
    if (!sensor) {
      sensor = create();
    }

    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };

  const destroy = () => {
    if (sensor && sensor.parentNode) {
      if (sensor.contentDocument) {
        sensor.contentDocument.defaultView.removeEventListener('resize', trigger);
      }

      sensor.parentNode.removeChild(sensor);
      sensor = null;
      listeners = [];
    }
  };

  const unbind = listener => {
    const idx = listeners.indexOf(listener);

    if (idx !== -1) {
      listeners.splice(idx, 1);
    } // no listener, and sensor is exist then destroy the sensor


    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };

  return {
    element,
    bind,
    destroy,
    unbind
  };
}

/***/ }),

/***/ 99396:
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/size-sensor/sensors/observer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSensor": () => (/* binding */ createSensor)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ 69744);

function createSensor(element) {
  let sensor = null;
  let listeners = [];
  const trigger = (0,_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {
    listeners.forEach(listener => {
      listener(element);
    });
  });

  const create = () => {
    const s = new ResizeObserver(trigger);
    s.observe(element);
    trigger();
    return s;
  };

  const bind = listener => {
    if (!sensor) {
      sensor = create();
    }

    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };

  const destroy = () => {
    if (sensor) {
      sensor.disconnect();
      listeners = [];
      sensor = null;
    }
  };

  const unbind = listener => {
    const idx = listeners.indexOf(listener);

    if (idx !== -1) {
      listeners.splice(idx, 1);
    } // no listener, and sensor is exist then destroy the sensor


    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };

  return {
    element,
    bind,
    destroy,
    unbind
  };
}

/***/ }),

/***/ 69744:
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/size-sensor/sensors/util.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounce": () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn, delay = 60) {
  let timer = null;
  return (...args) => {
    if (timer) {
      clearTimeout(timer);
    }

    timer = window.setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

/***/ }),

/***/ 46042:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/string/eval.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "exec": () => (/* binding */ exec)
/* harmony export */ });
function exec(exp) {
  let result = null;

  try {
    result = window.eval(exp); // eslint-disable-line
  } catch (e) {// pass
  }

  return result;
}

/***/ }),

/***/ 67763:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/string/format.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "camelCase": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "constantCase": () => (/* binding */ constantCase),
/* harmony export */   "dotCase": () => (/* binding */ dotCase),
/* harmony export */   "kebabCase": () => (/* binding */ kebabCase),
/* harmony export */   "lowerFirst": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "pascalCase": () => (/* binding */ pascalCase),
/* harmony export */   "pathCase": () => (/* binding */ pathCase),
/* harmony export */   "sentenceCase": () => (/* binding */ sentenceCase),
/* harmony export */   "titleCase": () => (/* binding */ titleCase),
/* harmony export */   "upperFirst": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ 55770);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ 13870);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ 78686);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ 3163);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ 93284);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ 5937);

 // @see: https://medium.com/@robertsavian/javascript-case-converters-using-lodash-4f2f964091cc

const cacheStringFunction = fn => {
  const cache = Object.create(null);
  return str => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

const kebabCase = cacheStringFunction(s => s.replace(/\B([A-Z])/g, '-$1').toLowerCase());
const pascalCase = cacheStringFunction(s => (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(s)).replace(/ /g, ''));
const constantCase = cacheStringFunction(s => (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(s).replace(/ /g, '_'));
const dotCase = cacheStringFunction(s => (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(s).replace(/ /g, '.'));
const pathCase = cacheStringFunction(s => (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(s).replace(/ /g, '/'));
const sentenceCase = cacheStringFunction(s => (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(s)));
const titleCase = cacheStringFunction(s => (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(s)));

/***/ }),

/***/ 54377:
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/string/hashcode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hashcode": () => (/* binding */ hashcode)
/* harmony export */ });
/* eslint-disable no-bitwise */

/**
 * Return a simple hash code from a string.
 * Source from: https://github.com/sindresorhus/fnv1a/blob/master/index.js#L25
 */
function hashcode(str) {
  let hash = 2166136261;
  let isUnicoded = false;
  let string = str;

  for (let i = 0, ii = string.length; i < ii; i += 1) {
    let characterCode = string.charCodeAt(i); // Non-ASCII characters trigger the Unicode escape logic

    if (characterCode > 0x7f && !isUnicoded) {
      string = unescape(encodeURIComponent(string));
      characterCode = string.charCodeAt(i);
      isUnicoded = true;
    }

    hash ^= characterCode;
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
  }

  return hash >>> 0;
}

/***/ }),

/***/ 13464:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/string/html.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sanitizeHTML": () => (/* binding */ sanitizeHTML)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);

function sanitizeHTML(html, options = {}) {
  // If documentContext (second parameter) is not specified or given as
  // `null` or `undefined`, a new document is used. Inline events will not
  // execute when the HTML is parsed; this includes, for example, sending
  // GET requests for images.
  // If keepScripts (last parameter) is `false`, scripts are not executed.
  const nodes = jquery__WEBPACK_IMPORTED_MODULE_0___default().parseHTML(html, null, false);
  nodes.forEach(node => {
    const elem = node;

    if (elem) {
      const attrs = elem.attributes;

      if (attrs) {
        for (let i = 0, ii = attrs.length; i < ii; i += 1) {
          const attr = attrs.item(i);

          if (attr) {
            const val = attr.value.toLowerCase();
            const name = attr.name.toLowerCase(); // Removes attribute name starts with "on" (e.g. onload,
            // onerror...).
            // Removes attribute value starts with "javascript:" pseudo
            // protocol (e.g. `href="javascript:alert(1)"`).

            if (name.startsWith('on') || val.startsWith('javascript:') || // eslint-disable-line no-script-url
            // ref: https://lgtm.com/rules/1510852698359/
            val.startsWith('data:') || val.startsWith('vbscript:')) {
              elem.removeAttribute(name);
            }
          }
        }
      }
    }
  });

  if (options.raw) {
    return nodes;
  }

  return jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div/>').append(nodes).html();
}

/***/ }),

/***/ 6402:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/string/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringExt": () => (/* reexport module object */ _string__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string */ 13989);



/***/ }),

/***/ 13989:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/string/string.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "camelCase": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.camelCase),
/* harmony export */   "constantCase": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.constantCase),
/* harmony export */   "dotCase": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.dotCase),
/* harmony export */   "endsWith": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "escape": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "eval": () => (/* reexport safe */ _eval__WEBPACK_IMPORTED_MODULE_14__.exec),
/* harmony export */   "getSpellingSuggestion": () => (/* reexport safe */ _suggestion__WEBPACK_IMPORTED_MODULE_19__.getSpellingSuggestion),
/* harmony export */   "hashcode": () => (/* reexport safe */ _hashcode__WEBPACK_IMPORTED_MODULE_16__.hashcode),
/* harmony export */   "isString": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "kebabCase": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.kebabCase),
/* harmony export */   "lowerFirst": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.lowerFirst),
/* harmony export */   "pad": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "padEnd": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "padStart": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "pascalCase": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.pascalCase),
/* harmony export */   "pathCase": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.pathCase),
/* harmony export */   "repeat": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "sanitizeHTML": () => (/* reexport safe */ _html__WEBPACK_IMPORTED_MODULE_18__.sanitizeHTML),
/* harmony export */   "sentenceCase": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.sentenceCase),
/* harmony export */   "split": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "startsWith": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "template": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "titleCase": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.titleCase),
/* harmony export */   "toString": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "truncate": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "unescape": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "uniqueId": () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "upperFirst": () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_15__.upperFirst),
/* harmony export */   "uuid": () => (/* reexport safe */ _uuid__WEBPACK_IMPORTED_MODULE_17__.uuid)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ 7190);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ 59191);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ 16459);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ 78030);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ 80014);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ 754);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ 56875);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ 99912);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ 5913);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ 95971);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ 12871);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ 38472);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash-es */ 14822);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash-es */ 38684);
/* harmony import */ var _eval__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./eval */ 46042);
/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./format */ 67763);
/* harmony import */ var _hashcode__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./hashcode */ 54377);
/* harmony import */ var _uuid__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./uuid */ 91480);
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./html */ 13464);
/* harmony import */ var _suggestion__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./suggestion */ 92499);








/***/ }),

/***/ 92499:
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/string/suggestion.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSpellingSuggestion": () => (/* binding */ getSpellingSuggestion)
/* harmony export */ });
// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts

/**
 * Given a name and a list of names that are not equal to the name, return a
 * spelling suggestion if there is one that is close enough. Names less than
 * length 3 only check for case-insensitive equality, not Levenshtein distance.
 *
 * - If there is a candidate that's the same except for case, return that.
 * - If there is a candidate that's within one edit of the name, return that.
 * - Otherwise, return the candidate with the smallest Levenshtein distance,
 *     except for candidates:
 *       * With no name
 *       * Whose length differs from the target name by more than 0.34 of the
 *         length of the name.
 *       * Whose levenshtein distance is more than 0.4 of the length of the
 *         name (0.4 allows 1 substitution/transposition for every 5 characters,
 *         and 1 insertion/deletion at 3 characters)
 */
function getSpellingSuggestion(name, candidates, getName) {
  const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34)); // If the best result isn't better than this, don't bother.

  let bestDistance = Math.floor(name.length * 0.4) + 1;
  let bestCandidate;
  let justCheckExactMatches = false;
  const nameLowerCase = name.toLowerCase(); // eslint-disable-next-line

  for (const candidate of candidates) {
    const candidateName = getName(candidate);

    if (candidateName !== undefined && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference) {
      const candidateNameLowerCase = candidateName.toLowerCase();

      if (candidateNameLowerCase === nameLowerCase) {
        if (candidateName === name) {
          continue;
        }

        return candidate;
      }

      if (justCheckExactMatches) {
        continue;
      }

      if (candidateName.length < 3) {
        // Don't bother, user would have noticed a
        // 2-character name having an extra character.
        continue;
      } // Only care about a result better than the best so far.


      const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);

      if (distance === undefined) {
        continue;
      }

      if (distance < 3) {
        justCheckExactMatches = true;
        bestCandidate = candidate;
      } else {
        // Debug.assert(distance < bestDistance)
        bestDistance = distance;
        bestCandidate = candidate;
      }
    }
  }

  return bestCandidate;
}

function levenshteinWithMax(s1, s2, max) {
  let previous = new Array(s2.length + 1); // eslint-disable-line

  let current = new Array(s2.length + 1); // eslint-disable-line

  /** Represents any value > max. We don't care about the particular value. */

  const big = max + 1;

  for (let i = 0; i <= s2.length; i += 1) {
    previous[i] = i;
  }

  for (let i = 1; i <= s1.length; i += 1) {
    const c1 = s1.charCodeAt(i - 1);
    const minJ = i > max ? i - max : 1;
    const maxJ = s2.length > max + i ? max + i : s2.length;
    current[0] = i;
    /** Smallest value of the matrix in the ith column. */

    let colMin = i;

    for (let j = 1; j < minJ; j += 1) {
      current[j] = big;
    }

    for (let j = minJ; j <= maxJ; j += 1) {
      const dist = c1 === s2.charCodeAt(j - 1) ? previous[j - 1] : Math.min(
      /* delete */
      previous[j] + 1,
      /* insert */
      current[j - 1] + 1,
      /* substitute */
      previous[j - 1] + 2);
      current[j] = dist;
      colMin = Math.min(colMin, dist);
    }

    for (let j = maxJ + 1; j <= s2.length; j += 1) {
      current[j] = big;
    }

    if (colMin > max) {
      // Give up -- everything in this column is > max
      // and it can't get better in future columns.
      return undefined;
    }

    const temp = previous;
    previous = current;
    current = temp;
  }

  const res = previous[s2.length];
  return res > max ? undefined : res;
}

/***/ }),

/***/ 91480:
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/string/uuid.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uuid": () => (/* binding */ uuid)
/* harmony export */ });
/* eslint-disable no-bitwise */
function uuid() {
  // credit: http://stackoverflow.com/posts/2117523/revisions
  // return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
  //   const r = (Math.random() * 16) | 0
  //   const v = c === 'x' ? r : (r & 0x3) | 0x8
  //   return v.toString(16)
  // })
  let res = '';
  const template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';

  for (let i = 0, len = template.length; i < len; i += 1) {
    const s = template[i];
    const r = Math.random() * 16 | 0;
    const v = s === 'x' ? r : s === 'y' ? r & 0x3 | 0x8 : s;
    res += v.toString(16);
  }

  return res;
}

/***/ }),

/***/ 13711:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/text/annotate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "annotate": () => (/* binding */ annotate),
/* harmony export */   "findAnnotationsAtIndex": () => (/* binding */ findAnnotationsAtIndex),
/* harmony export */   "findAnnotationsBetweenIndexes": () => (/* binding */ findAnnotationsBetweenIndexes),
/* harmony export */   "shiftAnnotations": () => (/* binding */ shiftAnnotations)
/* harmony export */ });
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../object */ 79747);
/* harmony import */ var _dom_attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/attr */ 11844);


function annotate(t, annotations, opt = {}) {
  const offset = opt.offset || 0;
  const compacted = [];
  const ret = [];
  let curr;
  let prev;
  let batch = null;

  for (let i = 0; i < t.length; i += 1) {
    curr = ret[i] = t[i];

    for (let j = 0, jj = annotations.length; j < jj; j += 1) {
      const annotation = annotations[j];
      const start = annotation.start + offset;
      const end = annotation.end + offset;

      if (i >= start && i < end) {
        if (typeof curr === 'string') {
          curr = ret[i] = {
            t: t[i],
            attrs: annotation.attrs
          };
        } else {
          curr.attrs = (0,_dom_attr__WEBPACK_IMPORTED_MODULE_1__.mergeAttrs)((0,_dom_attr__WEBPACK_IMPORTED_MODULE_1__.mergeAttrs)({}, curr.attrs), annotation.attrs);
        }

        if (opt.includeAnnotationIndices) {
          if (curr.annotations == null) {
            curr.annotations = [];
          }

          curr.annotations.push(j);
        }
      }
    }

    prev = ret[i - 1];

    if (!prev) {
      batch = curr;
    } else if (_object__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(curr) && _object__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(prev)) {
      batch = batch; // Both previous item and the current one are annotations.
      // If the attributes didn't change, merge the text.

      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {
        batch.t += curr.t;
      } else {
        compacted.push(batch);
        batch = curr;
      }
    } else if (_object__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(curr)) {
      // Previous item was a string, current item is an annotation.
      batch = batch;
      compacted.push(batch);
      batch = curr;
    } else if (_object__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(prev)) {
      // Previous item was an annotation, current item is a string.
      batch = batch;
      compacted.push(batch);
      batch = curr;
    } else {
      // Both previous and current item are strings.
      batch = (batch || '') + curr;
    }
  }

  if (batch != null) {
    compacted.push(batch);
  }

  return compacted;
}
function findAnnotationsAtIndex(annotations, index) {
  return annotations ? annotations.filter(a => a.start < index && index <= a.end) : [];
}
function findAnnotationsBetweenIndexes(annotations, start, end) {
  return annotations ? annotations.filter(a => start >= a.start && start < a.end || end > a.start && end <= a.end || a.start >= start && a.end < end) : [];
}
function shiftAnnotations(annotations, index, offset) {
  if (annotations) {
    annotations.forEach(a => {
      if (a.start < index && a.end >= index) {
        a.end += offset;
      } else if (a.start >= index) {
        a.start += offset;
        a.end += offset;
      }
    });
  }

  return annotations;
}

/***/ }),

/***/ 24489:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/text/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Text": () => (/* reexport module object */ _main__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ 62817);



/***/ }),

/***/ 62817:
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/text/main.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "annotate": () => (/* reexport safe */ _annotate__WEBPACK_IMPORTED_MODULE_0__.annotate),
/* harmony export */   "findAnnotationsAtIndex": () => (/* reexport safe */ _annotate__WEBPACK_IMPORTED_MODULE_0__.findAnnotationsAtIndex),
/* harmony export */   "findAnnotationsBetweenIndexes": () => (/* reexport safe */ _annotate__WEBPACK_IMPORTED_MODULE_0__.findAnnotationsBetweenIndexes),
/* harmony export */   "sanitize": () => (/* reexport safe */ _sanitize__WEBPACK_IMPORTED_MODULE_1__.sanitize),
/* harmony export */   "shiftAnnotations": () => (/* reexport safe */ _annotate__WEBPACK_IMPORTED_MODULE_0__.shiftAnnotations)
/* harmony export */ });
/* harmony import */ var _annotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotate */ 13711);
/* harmony import */ var _sanitize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sanitize */ 10441);



/***/ }),

/***/ 10441:
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/text/sanitize.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sanitize": () => (/* binding */ sanitize)
/* harmony export */ });
/**
 * Replaces all spaces with the Unicode No-break space.
 * ref: http://www.fileformat.info/info/unicode/char/a0/index.htm
 *
 * IE would otherwise collapse all spaces into one. This is useful
 * e.g. in tests when you want to compare the actual DOM text content
 * without having to add the unicode character in the place of all spaces.
 */
function sanitize(text) {
  return text.replace(/ /g, '\u00A0');
}

/***/ }),

/***/ 69526:
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/unit/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Unit": () => (/* binding */ Unit)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);

let millimeterSize;
const supportedUnits = {
  px(val) {
    return val;
  },

  mm(val) {
    return millimeterSize * val;
  },

  cm(val) {
    return millimeterSize * val * 10;
  },

  in(val) {
    return millimeterSize * val * 25.4;
  },

  pt(val) {
    return millimeterSize * (25.4 * val / 72);
  },

  pc(val) {
    return millimeterSize * (25.4 * val / 6);
  }

}; // eslint-disable-next-line

var Unit;

(function (Unit) {
  function measure(cssWidth, cssHeight, unit) {
    const div = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div/>').css({
      display: 'inline-block',
      position: 'absolute',
      left: -15000,
      top: -15000,
      width: cssWidth + (unit || ''),
      height: cssHeight + (unit || '')
    }).appendTo(document.body);
    const size = {
      width: div.width() || 0,
      height: div.height() || 0
    };
    div.remove();
    return size;
  }

  Unit.measure = measure;

  function toPx(val, unit) {
    if (millimeterSize == null) {
      millimeterSize = measure(`1`, `1`, 'mm').width;
    }

    const convert = unit ? supportedUnits[unit] : null;

    if (convert) {
      return convert(val);
    }

    return val;
  }

  Unit.toPx = toPx;
})(Unit || (Unit = {}));

/***/ }),

/***/ 9502:
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/vector/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vector": () => (/* binding */ Vector)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry */ 17653);
/* harmony import */ var _dom_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/core */ 64879);


class Vector {
  constructor(elem, attrs, children) {
    if (!elem) {
      throw new TypeError('Invalid element to create vector');
    }

    let node;

    if (Vector.isVector(elem)) {
      node = elem.node;
    } else if (typeof elem === 'string') {
      if (elem.toLowerCase() === 'svg') {
        node = _dom_core__WEBPACK_IMPORTED_MODULE_1__.createSvgDocument();
      } else if (elem[0] === '<') {
        const doc = _dom_core__WEBPACK_IMPORTED_MODULE_1__.createSvgDocument(elem); // only import the first child

        node = document.importNode(doc.firstChild, true);
      } else {
        node = document.createElementNS(_dom_core__WEBPACK_IMPORTED_MODULE_1__.ns.svg, elem);
      }
    } else {
      node = elem;
    }

    this.node = node;

    if (attrs) {
      this.setAttributes(attrs);
    }

    if (children) {
      this.append(children);
    }
  }

  get [Symbol.toStringTag]() {
    return Vector.toStringTag;
  }

  get type() {
    return this.node.nodeName;
  }

  get id() {
    return this.node.id;
  }

  set id(id) {
    this.node.id = id;
  }

  transform(matrix, options) {
    if (matrix == null) {
      return _dom_core__WEBPACK_IMPORTED_MODULE_1__.transform(this.node);
    }

    _dom_core__WEBPACK_IMPORTED_MODULE_1__.transform(this.node, matrix, options);
    return this;
  }

  translate(tx, ty = 0, options = {}) {
    if (tx == null) {
      return _dom_core__WEBPACK_IMPORTED_MODULE_1__.translate(this.node);
    }

    _dom_core__WEBPACK_IMPORTED_MODULE_1__.translate(this.node, tx, ty, options);
    return this;
  }

  rotate(angle, cx, cy, options = {}) {
    if (angle == null) {
      return _dom_core__WEBPACK_IMPORTED_MODULE_1__.rotate(this.node);
    }

    _dom_core__WEBPACK_IMPORTED_MODULE_1__.rotate(this.node, angle, cx, cy, options);
    return this;
  }

  scale(sx, sy) {
    if (sx == null) {
      return _dom_core__WEBPACK_IMPORTED_MODULE_1__.scale(this.node);
    }

    _dom_core__WEBPACK_IMPORTED_MODULE_1__.scale(this.node, sx, sy);
    return this;
  }
  /**
   * Returns an SVGMatrix that specifies the transformation necessary
   * to convert this coordinate system into `target` coordinate system.
   */


  getTransformToElement(target) {
    const ref = Vector.toNode(target);
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.getTransformToElement(this.node, ref);
  }

  removeAttribute(name) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.removeAttribute(this.node, name);
    return this;
  }

  getAttribute(name) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.getAttribute(this.node, name);
  }

  setAttribute(name, value) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.setAttribute(this.node, name, value);
    return this;
  }

  setAttributes(attrs) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.setAttributes(this.node, attrs);
    return this;
  }

  attr(name, value) {
    if (name == null) {
      return _dom_core__WEBPACK_IMPORTED_MODULE_1__.attr(this.node);
    }

    if (typeof name === 'string' && value === undefined) {
      return _dom_core__WEBPACK_IMPORTED_MODULE_1__.attr(this.node, name);
    }

    if (typeof name === 'object') {
      _dom_core__WEBPACK_IMPORTED_MODULE_1__.attr(this.node, name);
    } else {
      _dom_core__WEBPACK_IMPORTED_MODULE_1__.attr(this.node, name, value);
    }

    return this;
  }

  svg() {
    return this.node instanceof SVGSVGElement ? this : Vector.create(this.node.ownerSVGElement);
  }

  defs() {
    const context = this.svg() || this;
    const defsNode = context.node.getElementsByTagName('defs')[0];

    if (defsNode) {
      return Vector.create(defsNode);
    }

    return Vector.create('defs').appendTo(context);
  }

  text(content, options = {}) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.text(this.node, content, options);
    return this;
  }

  tagName() {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.tagName(this.node);
  }

  clone() {
    return Vector.create(this.node.cloneNode(true));
  }

  remove() {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.remove(this.node);
    return this;
  }

  empty() {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.empty(this.node);
    return this;
  }

  append(elems) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.append(this.node, Vector.toNodes(elems));
    return this;
  }

  appendTo(target) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.appendTo(this.node, Vector.isVector(target) ? target.node : target);
    return this;
  }

  prepend(elems) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.prepend(this.node, Vector.toNodes(elems));
    return this;
  }

  before(elems) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.before(this.node, Vector.toNodes(elems));
    return this;
  }

  replace(elem) {
    if (this.node.parentNode) {
      this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);
    }

    return Vector.create(elem);
  }

  first() {
    return this.node.firstChild ? Vector.create(this.node.firstChild) : null;
  }

  last() {
    return this.node.lastChild ? Vector.create(this.node.lastChild) : null;
  }

  get(index) {
    const child = this.node.childNodes[index];
    return child ? Vector.create(child) : null;
  }

  indexOf(elem) {
    const children = Array.prototype.slice.call(this.node.childNodes);
    return children.indexOf(Vector.toNode(elem));
  }

  find(selector) {
    const vels = [];
    const nodes = _dom_core__WEBPACK_IMPORTED_MODULE_1__.find(this.node, selector);

    if (nodes) {
      for (let i = 0, ii = nodes.length; i < ii; i += 1) {
        vels.push(Vector.create(nodes[i]));
      }
    }

    return vels;
  }

  findOne(selector) {
    const found = _dom_core__WEBPACK_IMPORTED_MODULE_1__.findOne(this.node, selector);
    return found ? Vector.create(found) : null;
  }

  findParentByClass(className, terminator) {
    const node = _dom_core__WEBPACK_IMPORTED_MODULE_1__.findParentByClass(this.node, className, terminator);
    return node ? Vector.create(node) : null;
  }

  matches(selector) {
    const node = this.node;
    const matches = this.node.matches;
    const matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;
    return matcher && matcher.call(node, selector);
  }

  contains(child) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.contains(this.node, Vector.isVector(child) ? child.node : child);
  }

  wrap(node) {
    const vel = Vector.create(node);
    const parentNode = this.node.parentNode;

    if (parentNode != null) {
      parentNode.insertBefore(vel.node, this.node);
    }

    return vel.append(this);
  }

  parent(type) {
    let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias
    // check for parent

    if (parent.node.parentNode == null) {
      return null;
    } // get parent element


    parent = Vector.create(parent.node.parentNode);

    if (type == null) {
      return parent;
    } // loop trough ancestors if type is given


    do {
      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {
        return parent;
      }
    } while (parent = Vector.create(parent.node.parentNode));

    return parent;
  }

  children() {
    const children = this.node.childNodes;
    const vels = [];

    for (let i = 0; i < children.length; i += 1) {
      const currentChild = children[i];

      if (currentChild.nodeType === 1) {
        vels.push(Vector.create(children[i]));
      }
    }

    return vels;
  }

  eachChild(fn, deep) {
    const children = this.children();

    for (let i = 0, l = children.length; i < l; i += 1) {
      fn.call(children[i], children[i], i, children);

      if (deep) {
        children[i].eachChild(fn, deep);
      }
    }

    return this;
  }

  index() {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.index(this.node);
  }

  hasClass(className) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.hasClass(this.node, className);
  }

  addClass(className) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.addClass(this.node, className);
    return this;
  }

  removeClass(className) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.removeClass(this.node, className);
    return this;
  }

  toggleClass(className, stateVal) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.toggleClass(this.node, className, stateVal);
    return this;
  }

  toLocalPoint(x, y) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.toLocalPoint(this.node, x, y);
  }

  toGeometryShape() {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.toGeometryShape(this.node);
  }

  translateCenterToPoint(p) {
    const bbox = this.getBBox({
      target: this.svg()
    });
    const center = bbox.getCenter();
    this.translate(p.x - center.x, p.y - center.y);
    return this;
  }

  translateAndAutoOrient(position, reference, target) {
    _dom_core__WEBPACK_IMPORTED_MODULE_1__.translateAndAutoOrient(this.node, position, reference, target);
    return this;
  }

  animate(options) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.animate(this.node, options);
  }

  animateTransform(options) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.animateTransform(this.node, options);
  }

  animateAlongPath(options, path) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.animateAlongPath(this.node, options, path);
  }
  /**
   * Normalize this element's d attribute. SVGPathElements without
   * a path data attribute obtain a value of 'M 0 0'.
   */


  normalizePath() {
    const tagName = this.tagName();

    if (tagName === 'path') {
      this.attr('d', _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.normalize(this.attr('d')));
    }

    return this;
  }
  /**
   * Returns the bounding box of the element after transformations are applied.
   * If `withoutTransformations` is `true`, transformations of the element
   * will not be considered when computing the bounding box. If `target` is
   * specified, bounding box will be computed relatively to the target element.
   */


  bbox(withoutTransformations, target) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.bbox(this.node, withoutTransformations, target);
  }

  getBBox(options = {}) {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.getBBox(this.node, {
      recursive: options.recursive,
      target: options.target ? Vector.toNode(options.target) : null
    });
  }
  /**
   * Samples the underlying SVG element (it currently works only on
   * paths - where it is most useful anyway). Returns an array of objects
   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
   * objects represent a point on the path. This basically creates a discrete
   * representation of the path (which is possible a curve). The sampling
   * interval defines the accuracy of the sampling. In other words, we travel
   * from the beginning of the path to the end by interval distance (on the
   * path, not between the resulting points) and collect the discrete points
   * on the path. This is very useful in many situations. For example, SVG
   * does not provide a built-in mechanism to find intersections between two
   * paths. Using sampling, we can just generate bunch of points for each of
   * the path and find the closest ones from each set.
   */


  sample(interval = 1) {
    if (this.node instanceof SVGPathElement) {
      return _dom_core__WEBPACK_IMPORTED_MODULE_1__.sample(this.node, interval);
    }

    return [];
  }

  toPath() {
    return Vector.create(_dom_core__WEBPACK_IMPORTED_MODULE_1__.toPath(this.node));
  }

  toPathData() {
    return _dom_core__WEBPACK_IMPORTED_MODULE_1__.toPathData(this.node);
  }

}

(function (Vector) {
  Vector.toStringTag = `X6.${Vector.name}`;

  function isVector(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof Vector) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const vector = instance;

    if ((tag == null || tag === Vector.toStringTag) && vector.node instanceof SVGElement && typeof vector.animate === 'function' && typeof vector.sample === 'function' && typeof vector.normalizePath === 'function' && typeof vector.toPath === 'function') {
      return true;
    }

    return false;
  }

  Vector.isVector = isVector;

  function create(elem, attrs, children) {
    return new Vector(elem, attrs, children);
  }

  Vector.create = create;

  function createVectors(markup) {
    if (markup[0] === '<') {
      const svgDoc = _dom_core__WEBPACK_IMPORTED_MODULE_1__.createSvgDocument(markup);
      const vels = [];

      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
        const childNode = svgDoc.childNodes[i];
        vels.push(create(document.importNode(childNode, true)));
      }

      return vels;
    }

    return [create(markup)];
  }

  Vector.createVectors = createVectors;

  function toNode(elem) {
    if (isVector(elem)) {
      return elem.node;
    }

    return elem;
  }

  Vector.toNode = toNode;

  function toNodes(elems) {
    if (Array.isArray(elems)) {
      return elems.map(elem => toNode(elem));
    }

    return [toNode(elems)];
  }

  Vector.toNodes = toNodes;
})(Vector || (Vector = {}));

/***/ }),

/***/ 54216:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/attr.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttrManager": () => (/* binding */ AttrManager)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ 57566);
/* harmony import */ var _registry_attr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../registry/attr */ 18945);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view */ 58458);





class AttrManager {
  constructor(view) {
    this.view = view;
  }

  get cell() {
    return this.view.cell;
  }

  getDefinition(attrName) {
    return this.cell.getAttrDefinition(attrName);
  }

  processAttrs(elem, raw) {
    let normal;
    let set;
    let offset;
    let position;
    let delay;
    const specials = []; // divide the attributes between normal and special

    Object.keys(raw).forEach(name => {
      const val = raw[name];
      const definition = this.getDefinition(name);
      const isValid = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_registry_attr__WEBPACK_IMPORTED_MODULE_3__.Attr.isValidDefinition, this.view, definition, val, {
        elem,
        attrs: raw,
        cell: this.cell,
        view: this.view
      });

      if (definition && isValid) {
        if (typeof definition === 'string') {
          if (normal == null) {
            normal = {};
          }

          normal[definition] = val;
        } else if (val !== null) {
          specials.push({
            name,
            definition
          });
        }
      } else {
        if (normal == null) {
          normal = {};
        }

        const normalName = AttrManager.CASE_SENSITIVE_ATTR.includes(name) ? name : _util__WEBPACK_IMPORTED_MODULE_0__.StringExt.kebabCase(name);
        normal[normalName] = val;
      }
    });
    specials.forEach(({
      name,
      definition
    }) => {
      const val = raw[name];
      const setDefine = definition;

      if (typeof setDefine.set === 'function') {
        if (!_util__WEBPACK_IMPORTED_MODULE_0__.Dom.isHTMLElement(elem) && AttrManager.DELAY_ATTRS.includes(name)) {
          if (delay == null) {
            delay = {};
          }

          delay[name] = val;
        } else {
          if (set == null) {
            set = {};
          }

          set[name] = val;
        }
      }

      const offsetDefine = definition;

      if (typeof offsetDefine.offset === 'function') {
        if (offset == null) {
          offset = {};
        }

        offset[name] = val;
      }

      const positionDefine = definition;

      if (typeof positionDefine.position === 'function') {
        if (position == null) {
          position = {};
        }

        position[name] = val;
      }
    });
    return {
      raw,
      normal,
      set,
      offset,
      position,
      delay
    };
  }

  mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {
    allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);
    allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);
    allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset); // Handle also the special transform property.

    const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;

    if (transform != null && roProcessedAttrs.normal) {
      roProcessedAttrs.normal.transform = transform;
    }

    allProcessedAttrs.normal = roProcessedAttrs.normal;
  }

  findAttrs(cellAttrs, rootNode, selectorCache, selectors) {
    const merge = [];
    const result = new _common__WEBPACK_IMPORTED_MODULE_2__.Dictionary();
    Object.keys(cellAttrs).forEach(selector => {
      const attrs = cellAttrs[selector];

      if (!_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(attrs)) {
        return;
      }

      const {
        isCSSSelector,
        elems
      } = _view__WEBPACK_IMPORTED_MODULE_4__.View.find(selector, rootNode, selectors);
      selectorCache[selector] = elems;

      for (let i = 0, l = elems.length; i < l; i += 1) {
        const elem = elems[i];
        const unique = selectors && selectors[selector] === elem;
        const prev = result.get(elem);

        if (prev) {
          if (!prev.array) {
            merge.push(elem);
            prev.array = true;
            prev.attrs = [prev.attrs];
            prev.priority = [prev.priority];
          }

          const attributes = prev.attrs;
          const selectedLength = prev.priority;

          if (unique) {
            // node referenced by `selector`
            attributes.unshift(attrs);
            selectedLength.unshift(-1);
          } else {
            // node referenced by `groupSelector` or CSSSelector
            const sortIndex = _util__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);
            attributes.splice(sortIndex, 0, attrs);
            selectedLength.splice(sortIndex, 0, l);
          }
        } else {
          result.set(elem, {
            elem,
            attrs,
            priority: unique ? -1 : l,
            array: false
          });
        }
      }
    });
    merge.forEach(node => {
      const item = result.get(node);
      const arr = item.attrs;
      item.attrs = arr.reduceRight((memo, attrs) => _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(memo, attrs), {});
    });
    return result;
  }

  updateRelativeAttrs(elem, processedAttrs, refBBox, options) {
    const rawAttrs = processedAttrs.raw || {};
    let nodeAttrs = processedAttrs.normal || {};
    const setAttrs = processedAttrs.set;
    const positionAttrs = processedAttrs.position;
    const offsetAttrs = processedAttrs.offset;
    const delayAttrs = processedAttrs.delay;

    const getOptions = () => ({
      elem,
      cell: this.cell,
      view: this.view,
      attrs: rawAttrs,
      refBBox: refBBox.clone()
    });

    if (setAttrs != null) {
      Object.keys(setAttrs).forEach(name => {
        const val = setAttrs[name];
        const def = this.getDefinition(name);

        if (def != null) {
          const ret = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.set, this.view, val, getOptions());

          if (typeof ret === 'object') {
            nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);
          } else if (ret != null) {
            nodeAttrs[name] = ret;
          }
        }
      });
    }

    if (_util__WEBPACK_IMPORTED_MODULE_0__.Dom.isHTMLElement(elem)) {
      // TODO: setting the `transform` attribute on HTMLElements
      // via `node.style.transform = 'matrix(...)';` would introduce
      // a breaking change (e.g. basic.TextBlock).
      this.view.setAttrs(nodeAttrs, elem);
      return;
    } // The final translation of the subelement.


    const nodeTransform = nodeAttrs.transform;
    const transform = nodeTransform ? `${nodeTransform}` : null;
    const nodeMatrix = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformStringToMatrix(transform);
    const nodePosition = new _geometry__WEBPACK_IMPORTED_MODULE_1__.Point(nodeMatrix.e, nodeMatrix.f);

    if (nodeTransform) {
      delete nodeAttrs.transform;
      nodeMatrix.e = 0;
      nodeMatrix.f = 0;
    } // Calculates node scale determined by the scalable group.


    let sx = 1;
    let sy = 1;

    if (positionAttrs || offsetAttrs) {
      const scale = this.view.getScaleOfElement(elem, options.scalableNode);
      sx = scale.sx;
      sy = scale.sy;
    }

    let positioned = false;

    if (positionAttrs != null) {
      Object.keys(positionAttrs).forEach(name => {
        const val = positionAttrs[name];
        const def = this.getDefinition(name);

        if (def != null) {
          const ts = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.position, this.view, val, getOptions());

          if (ts != null) {
            positioned = true;
            nodePosition.translate(_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(ts).scale(sx, sy));
          }
        }
      });
    } // The node bounding box could depend on the `size`
    // set from the previous loop.


    this.view.setAttrs(nodeAttrs, elem);
    let offseted = false;

    if (offsetAttrs != null) {
      // Check if the node is visible
      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);

      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
        const nodeBBox = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);
        Object.keys(offsetAttrs).forEach(name => {
          const val = offsetAttrs[name];
          const def = this.getDefinition(name);

          if (def != null) {
            const ts = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.offset, this.view, val, {
              elem,
              cell: this.cell,
              view: this.view,
              attrs: rawAttrs,
              refBBox: nodeBBox
            });

            if (ts != null) {
              offseted = true;
              nodePosition.translate(_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(ts).scale(sx, sy));
            }
          }
        });
      }
    }

    if (nodeTransform != null || positioned || offseted) {
      nodePosition.round(1);
      nodeMatrix.e = nodePosition.x;
      nodeMatrix.f = nodePosition.y;
      elem.setAttribute('transform', _util__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToTransformString(nodeMatrix));
    } // delay render


    const updateDelayAttrs = () => {
      if (delayAttrs != null) {
        Object.keys(delayAttrs).forEach(name => {
          const val = delayAttrs[name];
          const def = this.getDefinition(name);

          if (def != null) {
            const ret = _util__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.set, this.view, val, getOptions());

            if (typeof ret === 'object') {
              this.view.setAttrs(ret, elem);
            } else if (ret != null) {
              this.view.setAttrs({
                [name]: ret
              }, elem);
            }
          }
        });
      }
    };

    if (options.forceSync) {
      updateDelayAttrs();
    } else {
      _util__WEBPACK_IMPORTED_MODULE_0__.Scheduler.scheduleTask(updateDelayAttrs);
    }
  }

  update(rootNode, attrs, options) {
    const selectorCache = {};
    const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors); // `nodesAttrs` are different from all attributes, when
    // rendering only attributes sent to this method.

    const nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;
    const specialItems = [];
    nodesAttrs.each(data => {
      const node = data.elem;
      const nodeAttrs = data.attrs;
      const processed = this.processAttrs(node, nodeAttrs);

      if (processed.set == null && processed.position == null && processed.offset == null && processed.delay == null) {
        this.view.setAttrs(processed.normal, node);
      } else {
        const data = nodesAllAttrs.get(node);
        const nodeAllAttrs = data ? data.attrs : null;
        const refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;
        let refNode;

        if (refSelector) {
          refNode = (selectorCache[refSelector] || this.view.find(refSelector, rootNode, options.selectors))[0];

          if (!refNode) {
            throw new Error(`"${refSelector}" reference does not exist.`);
          }
        } else {
          refNode = null;
        }

        const item = {
          node,
          refNode,
          attributes: nodeAllAttrs,
          processedAttributes: processed
        }; // If an element in the list is positioned relative to this one, then
        // we want to insert this one before it in the list.

        const index = specialItems.findIndex(item => item.refNode === node);

        if (index > -1) {
          specialItems.splice(index, 0, item);
        } else {
          specialItems.push(item);
        }
      }
    });
    const bboxCache = new _common__WEBPACK_IMPORTED_MODULE_2__.Dictionary();
    let rotatableMatrix;
    specialItems.forEach(item => {
      const node = item.node;
      const refNode = item.refNode;
      let unrotatedRefBBox;
      const isRefNodeRotatable = refNode != null && options.rotatableNode != null && _util__WEBPACK_IMPORTED_MODULE_0__.Dom.contains(options.rotatableNode, refNode); // Find the reference element bounding box. If no reference was
      // provided, we use the optional bounding box.

      if (refNode) {
        unrotatedRefBBox = bboxCache.get(refNode);
      }

      if (!unrotatedRefBBox) {
        const target = isRefNodeRotatable ? options.rotatableNode : rootNode;
        unrotatedRefBBox = refNode ? _util__WEBPACK_IMPORTED_MODULE_0__.Dom.getBBox(refNode, {
          target
        }) : options.rootBBox;

        if (refNode) {
          bboxCache.set(refNode, unrotatedRefBBox);
        }
      }

      let processedAttrs;

      if (options.attrs && item.attributes) {
        // If there was a special attribute affecting the position amongst
        // passed-in attributes we have to merge it with the rest of the
        // element's attributes as they are necessary to update the position
        // relatively (i.e `ref-x` && 'ref-dx').
        processedAttrs = this.processAttrs(node, item.attributes);
        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);
      } else {
        processedAttrs = item.processedAttributes;
      }

      let refBBox = unrotatedRefBBox;

      if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {
        // If the referenced node is inside the rotatable group while the
        // updated node is outside, we need to take the rotatable node
        // transformation into account.
        if (!rotatableMatrix) {
          rotatableMatrix = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformStringToMatrix(_util__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(options.rotatableNode, 'transform'));
        }

        refBBox = _util__WEBPACK_IMPORTED_MODULE_0__.Dom.transformRectangle(unrotatedRefBBox, rotatableMatrix);
      }

      const caller = specialItems.find(item => item.refNode === node);

      if (caller) {
        options.forceSync = true;
      }

      this.updateRelativeAttrs(node, processedAttrs, refBBox, options);
    });
  }

}

(function (AttrManager) {
  AttrManager.CASE_SENSITIVE_ATTR = ['viewBox'];
  AttrManager.DELAY_ATTRS = ['text', 'textWrap', 'sourceMarker', 'targetMarker'];
})(AttrManager || (AttrManager = {}));

/***/ }),

/***/ 1834:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/view/cache.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": () => (/* binding */ Cache)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common */ 57566);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);


class Cache {
  constructor(view) {
    this.view = view;
    this.clean();
  }

  clean() {
    if (this.elemCache) {
      this.elemCache.dispose();
    }

    this.elemCache = new _common__WEBPACK_IMPORTED_MODULE_0__.Dictionary();
    this.pathCache = {};
  }

  get(elem) {
    const cache = this.elemCache;

    if (!cache.has(elem)) {
      this.elemCache.set(elem, {});
    }

    return this.elemCache.get(elem);
  }

  getData(elem) {
    const meta = this.get(elem);

    if (!meta.data) {
      meta.data = {};
    }

    return meta.data;
  }

  getMatrix(elem) {
    const meta = this.get(elem);

    if (meta.matrix == null) {
      const target = this.view.rotatableNode || this.view.container;
      meta.matrix = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.getTransformToElement(elem, target);
    }

    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix(meta.matrix);
  }

  getShape(elem) {
    const meta = this.get(elem);

    if (meta.shape == null) {
      meta.shape = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.toGeometryShape(elem);
    }

    return meta.shape.clone();
  }

  getBoundingRect(elem) {
    const meta = this.get(elem);

    if (meta.boundingRect == null) {
      meta.boundingRect = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.getBBox(elem);
    }

    return meta.boundingRect.clone();
  }

}

/***/ }),

/***/ 58670:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/cell.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellView": () => (/* binding */ CellView)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _registry_registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry/registry */ 80618);
/* harmony import */ var _registry_connection_strategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../registry/connection-strategy */ 74566);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./view */ 58458);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cache */ 1834);
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./markup */ 8676);
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tool */ 92654);
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr */ 54216);
/* harmony import */ var _flag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flag */ 51562);
/* eslint-disable @typescript-eslint/no-unused-vars */
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};











class CellView extends _view__WEBPACK_IMPORTED_MODULE_4__.View {
  constructor(cell, options = {}) {
    super();
    this.cell = cell;
    this.options = this.ensureOptions(options);
    this.graph = this.options.graph;
    this.attr = new _attr__WEBPACK_IMPORTED_MODULE_8__.AttrManager(this);
    this.flag = new _flag__WEBPACK_IMPORTED_MODULE_9__.FlagManager(this, this.options.actions, this.options.bootstrap);
    this.cache = new _cache__WEBPACK_IMPORTED_MODULE_5__.Cache(this);
    this.setContainer(this.ensureContainer());
    this.setup();
    this.$(this.container).data('view', this);
    this.init();
  }

  static getDefaults() {
    return this.defaults;
  }

  static config(options) {
    this.defaults = this.getOptions(options);
  }

  static getOptions(options) {
    const mergeActions = (arr1, arr2) => {
      if (arr2 != null) {
        return _util__WEBPACK_IMPORTED_MODULE_1__.ArrayExt.uniq([...(Array.isArray(arr1) ? arr1 : [arr1]), ...(Array.isArray(arr2) ? arr2 : [arr2])]);
      }

      return Array.isArray(arr1) ? [...arr1] : [arr1];
    };

    const ret = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.getDefaults());

    const {
      bootstrap,
      actions,
      events,
      documentEvents
    } = options,
          others = __rest(options, ["bootstrap", "actions", "events", "documentEvents"]);

    if (bootstrap) {
      ret.bootstrap = mergeActions(ret.bootstrap, bootstrap);
    }

    if (actions) {
      Object.keys(actions).forEach(key => {
        const val = actions[key];
        const raw = ret.actions[key];

        if (val && raw) {
          ret.actions[key] = mergeActions(raw, val);
        } else if (val) {
          ret.actions[key] = mergeActions(val);
        }
      });
    }

    if (events) {
      ret.events = Object.assign(Object.assign({}, ret.events), events);
    }

    if (options.documentEvents) {
      ret.documentEvents = Object.assign(Object.assign({}, ret.documentEvents), documentEvents);
    }

    return _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge(ret, others);
  }

  get [Symbol.toStringTag]() {
    return CellView.toStringTag;
  }

  init() {}

  onRemove() {
    this.removeTools();
  }

  get priority() {
    return this.options.priority;
  }

  get rootSelector() {
    return this.options.rootSelector;
  }

  getConstructor() {
    return this.constructor;
  }

  ensureOptions(options) {
    return this.getConstructor().getOptions(options);
  }

  getContainerTagName() {
    return this.options.isSvgElement ? 'g' : 'div';
  }

  getContainerStyle() {}

  getContainerAttrs() {
    return {
      'data-cell-id': this.cell.id,
      'data-shape': this.cell.shape
    };
  }

  getContainerClassName() {
    return this.prefixClassName('cell');
  }

  ensureContainer() {
    return _view__WEBPACK_IMPORTED_MODULE_4__.View.createElement(this.getContainerTagName(), this.options.isSvgElement);
  }

  setContainer(container) {
    if (this.container !== container) {
      this.undelegateEvents();
      this.container = container;

      if (this.options.events != null) {
        this.delegateEvents(this.options.events);
      }

      const attrs = this.getContainerAttrs();

      if (attrs != null) {
        this.setAttrs(attrs, container);
      }

      const style = this.getContainerStyle();

      if (style != null) {
        this.setStyle(style, container);
      }

      const className = this.getContainerClassName();

      if (className != null) {
        this.addClass(className, container);
      }
    }

    return this;
  }

  isNodeView() {
    return false;
  }

  isEdgeView() {
    return false;
  }

  render() {
    return this;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  confirmUpdate(flag, options = {}) {
    return 0;
  }

  getBootstrapFlag() {
    return this.flag.getBootstrapFlag();
  }

  getFlag(actions) {
    return this.flag.getFlag(actions);
  }

  hasAction(flag, actions) {
    return this.flag.hasAction(flag, actions);
  }

  removeAction(flag, actions) {
    return this.flag.removeAction(flag, actions);
  }

  handleAction(flag, action, handle, additionalRemovedActions) {
    if (this.hasAction(flag, action)) {
      handle();
      const removedFlags = [action];

      if (additionalRemovedActions) {
        if (typeof additionalRemovedActions === 'string') {
          removedFlags.push(additionalRemovedActions);
        } else {
          removedFlags.push(...additionalRemovedActions);
        }
      }

      return this.removeAction(flag, removedFlags);
    }

    return flag;
  }

  setup() {
    this.cell.on('changed', ({
      options
    }) => this.onAttrsChange(options));
  }

  onAttrsChange(options) {
    let flag = this.flag.getChangedFlag();

    if (options.updated || !flag) {
      return;
    }

    if (options.dirty && this.hasAction(flag, 'update')) {
      flag |= this.getFlag('render'); // eslint-disable-line no-bitwise
    } // tool changes should be sync render


    if (options.toolId) {
      options.async = false;
    }

    if (this.graph != null) {
      this.graph.renderer.requestViewUpdate(this, flag, this.priority, options);
    }
  }

  parseJSONMarkup(markup, rootElem) {
    const result = _markup__WEBPACK_IMPORTED_MODULE_6__.Markup.parseJSONMarkup(markup);
    const selectors = result.selectors;
    const rootSelector = this.rootSelector;

    if (rootElem && rootSelector) {
      if (selectors[rootSelector]) {
        throw new Error('Invalid root selector');
      }

      selectors[rootSelector] = rootElem;
    }

    return result;
  }

  can(feature) {
    let interacting = this.graph.options.interacting;

    if (typeof interacting === 'function') {
      interacting = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(interacting, this.graph, this);
    }

    if (typeof interacting === 'object') {
      let val = interacting[feature];

      if (typeof val === 'function') {
        val = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(val, this.graph, this);
      }

      return val !== false;
    }

    if (typeof interacting === 'boolean') {
      return interacting;
    }

    return false;
  }

  cleanCache() {
    this.cache.clean();
    return this;
  }

  getCache(elem) {
    return this.cache.get(elem);
  }

  getDataOfElement(elem) {
    return this.cache.getData(elem);
  }

  getMatrixOfElement(elem) {
    return this.cache.getMatrix(elem);
  }

  getShapeOfElement(elem) {
    return this.cache.getShape(elem);
  }

  getScaleOfElement(node, scalableNode) {
    let sx;
    let sy;

    if (scalableNode && scalableNode.contains(node)) {
      const scale = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.scale(scalableNode);
      sx = 1 / scale.sx;
      sy = 1 / scale.sy;
    } else {
      sx = 1;
      sy = 1;
    }

    return {
      sx,
      sy
    };
  }

  getBoundingRectOfElement(elem) {
    return this.cache.getBoundingRect(elem);
  }

  getBBoxOfElement(elem) {
    const rect = this.getBoundingRectOfElement(elem);
    const matrix = this.getMatrixOfElement(elem);
    const rm = this.getRootRotatedMatrix();
    const tm = this.getRootTranslatedMatrix();
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformRectangle(rect, tm.multiply(rm).multiply(matrix));
  }

  getUnrotatedBBoxOfElement(elem) {
    const rect = this.getBoundingRectOfElement(elem);
    const matrix = this.getMatrixOfElement(elem);
    const tm = this.getRootTranslatedMatrix();
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.transformRectangle(rect, tm.multiply(matrix));
  }

  getBBox(options = {}) {
    let bbox;

    if (options.useCellGeometry) {
      const cell = this.cell;
      const angle = cell.isNode() ? cell.getAngle() : 0;
      bbox = cell.getBBox().bbox(angle);
    } else {
      bbox = this.getBBoxOfElement(this.container);
    }

    return this.graph.localToGraph(bbox);
  }

  getRootTranslatedMatrix() {
    const cell = this.cell;
    const pos = cell.isNode() ? cell.getPosition() : {
      x: 0,
      y: 0
    };
    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix().translate(pos.x, pos.y);
  }

  getRootRotatedMatrix() {
    let matrix = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix();
    const cell = this.cell;
    const angle = cell.isNode() ? cell.getAngle() : 0;

    if (angle) {
      const bbox = cell.getBBox();
      const cx = bbox.width / 2;
      const cy = bbox.height / 2;
      matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy);
    }

    return matrix;
  }

  findMagnet(elem = this.container) {
    // If the overall cell has set `magnet === false`, then returns
    // `undefined` to announce there is no magnet found for this cell.
    // This is especially useful to set on cells that have 'ports'.
    // In this case, only the ports have set `magnet === true` and the
    // overall element has `magnet === false`.
    return this.findByAttr('magnet', elem);
  }

  updateAttrs(rootNode, attrs, options = {}) {
    if (options.rootBBox == null) {
      options.rootBBox = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
    }

    if (options.selectors == null) {
      options.selectors = this.selectors;
    }

    this.attr.update(rootNode, attrs, options);
  }

  isEdgeElement(magnet) {
    return this.cell.isEdge() && (magnet == null || magnet === this.container);
  } // #region highlight


  prepareHighlight(elem, options = {}) {
    const magnet = elem && this.$(elem)[0] || this.container;
    options.partial = magnet === this.container;
    return magnet;
  }

  highlight(elem, options = {}) {
    const magnet = this.prepareHighlight(elem, options);
    this.notify('cell:highlight', {
      magnet,
      options,
      view: this,
      cell: this.cell
    });

    if (this.isEdgeView()) {
      this.notify('edge:highlight', {
        magnet,
        options,
        view: this,
        edge: this.cell,
        cell: this.cell
      });
    } else if (this.isNodeView()) {
      this.notify('node:highlight', {
        magnet,
        options,
        view: this,
        node: this.cell,
        cell: this.cell
      });
    }

    return this;
  }

  unhighlight(elem, options = {}) {
    const magnet = this.prepareHighlight(elem, options);
    this.notify('cell:unhighlight', {
      magnet,
      options,
      view: this,
      cell: this.cell
    });

    if (this.isNodeView()) {
      this.notify('node:unhighlight', {
        magnet,
        options,
        view: this,
        node: this.cell,
        cell: this.cell
      });
    } else if (this.isEdgeView()) {
      this.notify('edge:unhighlight', {
        magnet,
        options,
        view: this,
        edge: this.cell,
        cell: this.cell
      });
    }

    return this;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  notifyUnhighlight(magnet, options) {} // #endregion


  getEdgeTerminal(magnet, x, y, edge, type) {
    const cell = this.cell;
    const portId = this.findAttr('port', magnet);
    const selector = magnet.getAttribute('data-selector');
    const terminal = {
      cell: cell.id
    };

    if (selector != null) {
      terminal.magnet = selector;
    }

    if (portId != null) {
      terminal.port = portId;

      if (cell.isNode()) {
        if (!cell.hasPort(portId) && selector == null) {
          // port created via the `port` attribute (not API)
          terminal.selector = this.getSelector(magnet);
        }
      }
    } else if (selector == null && this.container !== magnet) {
      terminal.selector = this.getSelector(magnet);
    }

    return this.customizeEdgeTerminal(terminal, magnet, x, y, edge, type);
  }

  customizeEdgeTerminal(terminal, magnet, x, y, edge, type) {
    const raw = edge.getStrategy() || this.graph.options.connecting.strategy;

    if (raw) {
      const name = typeof raw === 'string' ? raw : raw.name;
      const args = typeof raw === 'string' ? {} : raw.args || {};
      const registry = _registry_connection_strategy__WEBPACK_IMPORTED_MODULE_3__.ConnectionStrategy.registry;

      if (name) {
        const fn = registry.get(name);

        if (fn == null) {
          return registry.onNotFound(name);
        }

        const result = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this.graph, terminal, this, magnet, new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y), edge, type, args);

        if (result) {
          return result;
        }
      }
    }

    return terminal;
  }

  getMagnetFromEdgeTerminal(terminal) {
    const cell = this.cell;
    const root = this.container;
    const portId = terminal.port;
    let selector = terminal.magnet;
    let magnet;

    if (portId != null && cell.isNode() && cell.hasPort(portId)) {
      magnet = this.findPortElem(portId, selector) || root;
    } else {
      if (!selector) {
        selector = terminal.selector;
      }

      if (!selector && portId != null) {
        selector = `[port="${portId}"]`;
      }

      magnet = this.findOne(selector, root, this.selectors);
    }

    return magnet;
  } // #region animate


  animate(elem, options) {
    const target = typeof elem === 'string' ? this.findOne(elem) : elem;

    if (target == null) {
      throw new Error('Invalid animation element.');
    }

    const parent = target.parentNode;

    const revert = () => {
      if (!parent) {
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.remove(target);
      }
    };

    const vTarget = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(target);

    if (!parent) {
      vTarget.appendTo(this.graph.view.stage);
    }

    const onComplete = options.complete;

    options.complete = e => {
      revert();

      if (onComplete) {
        onComplete(e);
      }
    };

    return vTarget.animate(options);
  }

  animateTransform(elem, options) {
    const target = typeof elem === 'string' ? this.findOne(elem) : elem;

    if (target == null) {
      throw new Error('Invalid animation element.');
    }

    const parent = target.parentNode;

    const revert = () => {
      if (!parent) {
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.remove(target);
      }
    };

    const vTarget = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(target);

    if (!parent) {
      vTarget.appendTo(this.graph.view.stage);
    }

    const onComplete = options.complete;

    options.complete = e => {
      revert();

      if (onComplete) {
        onComplete(e);
      }
    };

    return vTarget.animateTransform(options);
  }

  hasTools(name) {
    const tools = this.tools;

    if (tools == null) {
      return false;
    }

    if (name == null) {
      return true;
    }

    return tools.name === name;
  }

  addTools(config) {
    if (!this.can('toolsAddable')) {
      return this;
    }

    this.removeTools();

    if (config) {
      const tools = _tool__WEBPACK_IMPORTED_MODULE_7__.ToolsView.isToolsView(config) ? config : new _tool__WEBPACK_IMPORTED_MODULE_7__.ToolsView(config);
      this.tools = tools;
      this.graph.on('tools:hide', this.hideTools, this);
      this.graph.on('tools:show', this.showTools, this);
      this.graph.on('tools:remove', this.removeTools, this);
      tools.config({
        view: this
      });
      tools.mount();
    }

    return this;
  }

  updateTools(options = {}) {
    if (this.tools) {
      this.tools.update(options);
    }

    return this;
  }

  removeTools() {
    if (this.tools) {
      this.tools.remove();
      this.graph.off('tools:hide', this.hideTools, this);
      this.graph.off('tools:show', this.showTools, this);
      this.graph.off('tools:remove', this.removeTools, this);
      this.tools = null;
    }

    return this;
  }

  hideTools() {
    if (this.tools) {
      this.tools.hide();
    }

    return this;
  }

  showTools() {
    if (this.tools) {
      this.tools.show();
    }

    return this;
  }

  renderTools() {
    const tools = this.cell.getTools();
    this.addTools(tools);
    return this;
  }

  notify(name, args) {
    this.trigger(name, args);
    this.graph.trigger(name, args);
    return this;
  }

  getEventArgs(e, x, y) {
    const view = this; // eslint-disable-line @typescript-eslint/no-this-alias

    const cell = view.cell;

    if (x == null || y == null) {
      return {
        e,
        view,
        cell
      };
    }

    return {
      e,
      x,
      y,
      view,
      cell
    };
  }

  onClick(e, x, y) {
    this.notify('cell:click', this.getEventArgs(e, x, y));
  }

  onDblClick(e, x, y) {
    this.notify('cell:dblclick', this.getEventArgs(e, x, y));
  }

  onContextMenu(e, x, y) {
    this.notify('cell:contextmenu', this.getEventArgs(e, x, y));
  }

  onMouseDown(e, x, y) {
    if (this.cell.model) {
      this.cachedModelForMouseEvent = this.cell.model;
      this.cachedModelForMouseEvent.startBatch('mouse');
    }

    this.notify('cell:mousedown', this.getEventArgs(e, x, y));
  }

  onMouseUp(e, x, y) {
    this.notify('cell:mouseup', this.getEventArgs(e, x, y));

    if (this.cachedModelForMouseEvent) {
      this.cachedModelForMouseEvent.stopBatch('mouse', {
        cell: this.cell
      });
      this.cachedModelForMouseEvent = null;
    }
  }

  onMouseMove(e, x, y) {
    this.notify('cell:mousemove', this.getEventArgs(e, x, y));
  }

  onMouseOver(e) {
    this.notify('cell:mouseover', this.getEventArgs(e));
  }

  onMouseOut(e) {
    this.notify('cell:mouseout', this.getEventArgs(e));
  }

  onMouseEnter(e) {
    this.notify('cell:mouseenter', this.getEventArgs(e));
  }

  onMouseLeave(e) {
    this.notify('cell:mouseleave', this.getEventArgs(e));
  }

  onMouseWheel(e, x, y, delta) {
    this.notify('cell:mousewheel', Object.assign({
      delta
    }, this.getEventArgs(e, x, y)));
  }

  onCustomEvent(e, name, x, y) {
    this.notify('cell:customevent', Object.assign({
      name
    }, this.getEventArgs(e, x, y)));
    this.notify(name, Object.assign({}, this.getEventArgs(e, x, y)));
  }

  onMagnetMouseDown(e, magnet, x, y) {}

  onMagnetDblClick(e, magnet, x, y) {}

  onMagnetContextMenu(e, magnet, x, y) {}

  onLabelMouseDown(e, x, y) {}

  checkMouseleave(e) {
    const graph = this.graph;

    if (graph.renderer.isAsync()) {
      // Do the updates of the current view synchronously now
      graph.renderer.dumpView(this);
    }

    const target = this.getEventTarget(e, {
      fromPoint: true
    });
    const view = graph.renderer.findViewByElem(target);

    if (view === this) {
      return;
    } // Leaving the current view


    this.onMouseLeave(e);

    if (!view) {
      return;
    } // Entering another view


    view.onMouseEnter(e);
  }

}
CellView.defaults = {
  isSvgElement: true,
  rootSelector: 'root',
  priority: 0,
  bootstrap: [],
  actions: {}
};

(function (CellView) {
  CellView.Flag = _flag__WEBPACK_IMPORTED_MODULE_9__.FlagManager;
  CellView.Attr = _attr__WEBPACK_IMPORTED_MODULE_8__.AttrManager;
})(CellView || (CellView = {}));

(function (CellView) {
  CellView.toStringTag = `X6.${CellView.name}`;

  function isCellView(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof CellView) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const view = instance;

    if ((tag == null || tag === CellView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function') {
      return true;
    }

    return false;
  }

  CellView.isCellView = isCellView;
})(CellView || (CellView = {})); // decorators
// ----


(function (CellView) {
  function priority(value) {
    return function (ctor) {
      ctor.config({
        priority: value
      });
    };
  }

  CellView.priority = priority;

  function bootstrap(actions) {
    return function (ctor) {
      ctor.config({
        bootstrap: actions
      });
    };
  }

  CellView.bootstrap = bootstrap;
})(CellView || (CellView = {}));

(function (CellView) {
  CellView.registry = _registry_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.create({
    type: 'view'
  });
})(CellView || (CellView = {}));

/***/ }),

/***/ 32325:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/edge.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EdgeView": () => (/* binding */ EdgeView)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry */ 73306);
/* harmony import */ var _model_edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/edge */ 51257);
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./markup */ 8676);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cell */ 58670);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







class EdgeView extends _cell__WEBPACK_IMPORTED_MODULE_5__.CellView {
  constructor() {
    super(...arguments);
    this.POINT_ROUNDING = 2;
    this.markerCache = {}; // #endregion
    // #endregion
  }

  get [Symbol.toStringTag]() {
    return EdgeView.toStringTag;
  }

  getContainerClassName() {
    return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');
  }

  get sourceBBox() {
    const sourceView = this.sourceView;

    if (!sourceView) {
      const sourceDef = this.cell.getSource();
      return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(sourceDef.x, sourceDef.y);
    }

    const sourceMagnet = this.sourceMagnet;

    if (sourceView.isEdgeElement(sourceMagnet)) {
      return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);
    }

    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);
  }

  get targetBBox() {
    const targetView = this.targetView;

    if (!targetView) {
      const targetDef = this.cell.getTarget();
      return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(targetDef.x, targetDef.y);
    }

    const targetMagnet = this.targetMagnet;

    if (targetView.isEdgeElement(targetMagnet)) {
      return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(this.targetAnchor.x, this.targetAnchor.y);
    }

    return targetView.getBBoxOfElement(targetMagnet || targetView.container);
  }

  isEdgeView() {
    return true;
  }

  confirmUpdate(flag, options = {}) {
    let ref = flag;

    if (this.hasAction(ref, 'source')) {
      if (!this.updateTerminalProperties('source')) {
        return ref;
      }

      ref = this.removeAction(ref, 'source');
    }

    if (this.hasAction(ref, 'target')) {
      if (!this.updateTerminalProperties('target')) {
        return ref;
      }

      ref = this.removeAction(ref, 'target');
    }

    const graph = this.graph;
    const sourceView = this.sourceView;
    const targetView = this.targetView;

    if (graph && (sourceView && !graph.renderer.isViewMounted(sourceView) || targetView && !graph.renderer.isViewMounted(targetView))) {
      // Wait for the sourceView and targetView to be rendered.
      return ref;
    }

    if (this.hasAction(ref, 'render')) {
      this.render();
      ref = this.removeAction(ref, ['render', 'update', 'vertices', 'labels', 'tools', 'widget']);
      return ref;
    }

    ref = this.handleAction(ref, 'vertices', () => this.renderVertexMarkers());
    ref = this.handleAction(ref, 'update', () => this.update(null, options));
    ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));
    ref = this.handleAction(ref, 'tools', () => {
      this.renderTools();
      this.updateToolsPosition();
    });
    ref = this.handleAction(ref, 'widget', () => this.renderExternalTools());
    return ref;
  }

  onLabelsChange(options = {}) {
    // Note: this optimization works in async=false mode only
    if (this.shouldRerenderLabels(options)) {
      this.renderLabels();
    } else {
      this.updateLabels();
    }

    this.updateLabelPositions();
  }

  shouldRerenderLabels(options = {}) {
    const previousLabels = this.cell.previous('labels');

    if (previousLabels == null) {
      return true;
    } // Here is an optimization for cases when we know, that change does
    // not require re-rendering of all labels.


    if ('propertyPathArray' in options && 'propertyValue' in options) {
      // The label is setting by `prop()` method
      const pathArray = options.propertyPathArray || [];
      const pathLength = pathArray.length;

      if (pathLength > 1) {
        // We are changing a single label here e.g. 'labels/0/position'
        const index = pathArray[1];

        if (previousLabels[index]) {
          if (pathLength === 2) {
            // We are changing the entire label. Need to check if the
            // markup is also being changed.
            return typeof options.propertyValue === 'object' && _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.has(options.propertyValue, 'markup');
          } // We are changing a label property but not the markup


          if (pathArray[2] !== 'markup') {
            return false;
          }
        }
      }
    }

    return true;
  }

  render() {
    this.empty();
    this.containers = {};
    this.renderMarkup();
    this.renderLabels();
    this.update();
    this.renderExternalTools();
    return this;
  }

  renderMarkup() {
    const markup = this.cell.markup;

    if (markup) {
      if (typeof markup === 'string') {
        return this.renderStringMarkup(markup);
      }

      return this.renderJSONMarkup(markup);
    }

    throw new TypeError('Invalid edge markup.');
  }

  renderJSONMarkup(markup) {
    const ret = this.parseJSONMarkup(markup, this.container);
    this.selectors = ret.selectors;
    this.container.append(ret.fragment);
  }

  renderStringMarkup(markup) {
    const cache = this.containers;
    const children = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.createVectors(markup); // Cache children elements for quicker access.

    children.forEach(child => {
      const className = child.attr('class');

      if (className) {
        cache[_util__WEBPACK_IMPORTED_MODULE_1__.StringExt.camelCase(className)] = child.node;
      }
    });
    this.renderTools();
    this.renderVertexMarkers();
    this.renderArrowheadMarkers();
    _util__WEBPACK_IMPORTED_MODULE_1__.Dom.append(this.container, children.map(child => child.node));
  }

  renderLabels() {
    const edge = this.cell;
    const labels = edge.getLabels();
    const count = labels.length;
    let container = this.containers.labels;
    this.labelCache = {};
    this.labelSelectors = {};

    if (count <= 0) {
      if (container && container.parentNode) {
        container.parentNode.removeChild(container);
      }

      return this;
    }

    if (container) {
      this.empty(container);
    } else {
      container = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSvgElement('g');
      this.addClass(this.prefixClassName('edge-labels'), container);
      this.containers.labels = container;
    }

    for (let i = 0, ii = labels.length; i < ii; i += 1) {
      const label = labels[i];
      const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));
      let labelNode;
      let selectors;

      if (normalized) {
        labelNode = normalized.node;
        selectors = normalized.selectors;
      } else {
        const defaultLabel = edge.getDefaultLabel();
        const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));
        labelNode = normalized.node;
        selectors = normalized.selectors;
      }

      labelNode.setAttribute('data-index', `${i}`);
      container.appendChild(labelNode);
      const rootSelector = this.rootSelector;

      if (selectors[rootSelector]) {
        throw new Error('Ambiguous label root selector.');
      }

      selectors[rootSelector] = labelNode;
      this.labelCache[i] = labelNode;
      this.labelSelectors[i] = selectors;
    }

    if (container.parentNode == null) {
      this.container.appendChild(container);
    }

    this.updateLabels();
    this.customizeLabels();
    return this;
  }

  parseLabelMarkup(markup) {
    if (markup) {
      if (typeof markup === 'string') {
        return this.parseLabelStringMarkup(markup);
      }

      return this.parseJSONMarkup(markup);
    }

    return null;
  }

  parseLabelStringMarkup(labelMarkup) {
    const children = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.createVectors(labelMarkup);
    const fragment = document.createDocumentFragment();

    for (let i = 0, n = children.length; i < n; i += 1) {
      const currentChild = children[i].node;
      fragment.appendChild(currentChild);
    }

    return {
      fragment,
      selectors: {}
    };
  }

  normalizeLabelMarkup(markup) {
    if (markup == null) {
      return;
    }

    const fragment = markup.fragment;

    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {
      throw new Error('Invalid label markup.');
    }

    let vel;
    const childNodes = fragment.childNodes;

    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {
      // default markup fragment is not wrapped in `<g/>`
      // add a `<g/>` container
      vel = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create('g').append(fragment);
    } else {
      vel = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(childNodes[0]);
    }

    vel.addClass(this.prefixClassName('edge-label'));
    return {
      node: vel.node,
      selectors: markup.selectors
    };
  }

  updateLabels() {
    if (this.containers.labels) {
      const edge = this.cell;
      const labels = edge.labels;
      const canLabelMove = this.can('edgeLabelMovable');
      const defaultLabel = edge.getDefaultLabel();

      for (let i = 0, n = labels.length; i < n; i += 1) {
        const elem = this.labelCache[i];
        const selectors = this.labelSelectors[i];
        elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');
        const label = labels[i];
        const attrs = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, defaultLabel.attrs, label.attrs);
        this.updateAttrs(elem, attrs, {
          selectors,
          rootBBox: label.size ? _geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.fromSize(label.size) : undefined
        });
      }
    }
  }

  mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {
    if (labelAttrs === null) {
      return null;
    }

    if (labelAttrs === undefined) {
      if (defaultLabelAttrs === null) {
        return null;
      }

      if (defaultLabelAttrs === undefined) {
        return undefined;
      }

      if (hasCustomMarkup) {
        return defaultLabelAttrs;
      }

      return _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, defaultLabelAttrs);
    }

    if (hasCustomMarkup) {
      return _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, defaultLabelAttrs, labelAttrs);
    }
  }

  customizeLabels() {
    if (this.containers.labels) {
      const edge = this.cell;
      const labels = edge.labels;

      for (let i = 0, n = labels.length; i < n; i += 1) {
        const label = labels[i];
        const container = this.labelCache[i];
        const selectors = this.labelSelectors[i];
        this.graph.hook.onEdgeLabelRendered({
          edge,
          label,
          container,
          selectors
        });
      }
    }
  }

  renderTools() {
    const container = this.containers.tools;

    if (container == null) {
      return this;
    }

    const markup = this.cell.toolMarkup;
    const $container = this.$(container).empty();

    if (_markup__WEBPACK_IMPORTED_MODULE_4__.Markup.isStringMarkup(markup)) {
      let template = _util__WEBPACK_IMPORTED_MODULE_1__.StringExt.template(markup);
      const tool = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(template());
      $container.append(tool.node);
      this.toolCache = tool.node; // If `doubleTools` is enabled, we render copy of the tools on the
      // other side of the edge as well but only if the edge is longer
      // than `longLength`.

      if (this.options.doubleTools) {
        let tool2;
        const doubleToolMarkup = this.cell.doubleToolMarkup;

        if (_markup__WEBPACK_IMPORTED_MODULE_4__.Markup.isStringMarkup(doubleToolMarkup)) {
          template = _util__WEBPACK_IMPORTED_MODULE_1__.StringExt.template(doubleToolMarkup);
          tool2 = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(template());
        } else {
          tool2 = tool.clone();
        }

        $container.append(tool2.node);
        this.tool2Cache = tool2.node;
      }
    }

    return this;
  }

  renderExternalTools() {
    const tools = this.cell.getTools();
    this.addTools(tools);
    return this;
  }

  renderVertexMarkers() {
    const container = this.containers.vertices;

    if (container == null) {
      return this;
    }

    const markup = this.cell.vertexMarkup;
    const $container = this.$(container).empty();

    if (_markup__WEBPACK_IMPORTED_MODULE_4__.Markup.isStringMarkup(markup)) {
      const template = _util__WEBPACK_IMPORTED_MODULE_1__.StringExt.template(markup);
      this.cell.getVertices().forEach((vertex, index) => {
        $container.append(_util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(template(Object.assign({
          index
        }, vertex))).node);
      });
    }

    return this;
  }

  renderArrowheadMarkers() {
    const container = this.containers.arrowheads;

    if (container == null) {
      return this;
    }

    const markup = this.cell.arrowheadMarkup;
    const $container = this.$(container).empty();

    if (_markup__WEBPACK_IMPORTED_MODULE_4__.Markup.isStringMarkup(markup)) {
      const template = _util__WEBPACK_IMPORTED_MODULE_1__.StringExt.template(markup);
      const sourceArrowhead = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(template({
        end: 'source'
      })).node;
      const targetArrowhead = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(template({
        end: 'target'
      })).node;
      this.containers.sourceArrowhead = sourceArrowhead;
      this.containers.targetArrowhead = targetArrowhead;
      $container.append(sourceArrowhead, targetArrowhead);
    }

    return this;
  } // #endregion
  // #region updating


  update(partialAttrs, options = {}) {
    this.cleanCache();
    this.updateConnection(options);
    const attrs = this.cell.getAttrs();

    if (attrs != null) {
      this.updateAttrs(this.container, attrs, {
        attrs: partialAttrs === attrs ? null : partialAttrs,
        selectors: this.selectors
      });
    }

    this.updateConnectionPath();
    this.updateLabelPositions();
    this.updateToolsPosition();
    this.updateArrowheadMarkers();
    this.updateTools(options);
    return this;
  }

  removeRedundantLinearVertices(options = {}) {
    const edge = this.cell;
    const vertices = edge.getVertices();
    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];
    const rawCount = routePoints.length; // Puts the route points into a polyline and try to simplify.

    const polyline = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(routePoints);
    polyline.simplify({
      threshold: 0.01
    });
    const simplifiedPoints = polyline.points.map(point => point.toJSON());
    const simplifiedCount = simplifiedPoints.length; // If simplification did not remove any redundant vertices.

    if (rawCount === simplifiedCount) {
      return 0;
    } // Sets simplified polyline points as edge vertices.
    // Removes first and last polyline points again (source/target anchors).


    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);
    return rawCount - simplifiedCount;
  }

  updateConnectionPath() {
    const containers = this.containers;

    if (containers.connection) {
      const pathData = this.getConnectionPathData();
      containers.connection.setAttribute('d', pathData);
    }

    if (containers.connectionWrap) {
      const pathData = this.getConnectionPathData();
      containers.connectionWrap.setAttribute('d', pathData);
    }

    if (containers.sourceMarker && containers.targetMarker) {
      this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);
    }
  }

  getTerminalView(type) {
    switch (type) {
      case 'source':
        return this.sourceView || null;

      case 'target':
        return this.targetView || null;

      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }

  getTerminalAnchor(type) {
    switch (type) {
      case 'source':
        return _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.sourceAnchor);

      case 'target':
        return _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.targetAnchor);

      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }

  getTerminalConnectionPoint(type) {
    switch (type) {
      case 'source':
        return _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.sourcePoint);

      case 'target':
        return _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.targetPoint);

      default:
        throw new Error(`Unknown terminal type '${type}'`);
    }
  }

  getTerminalMagnet(type, options = {}) {
    switch (type) {
      case 'source':
        {
          if (options.raw) {
            return this.sourceMagnet;
          }

          const sourceView = this.sourceView;

          if (!sourceView) {
            return null;
          }

          return this.sourceMagnet || sourceView.container;
        }

      case 'target':
        {
          if (options.raw) {
            return this.targetMagnet;
          }

          const targetView = this.targetView;

          if (!targetView) {
            return null;
          }

          return this.targetMagnet || targetView.container;
        }

      default:
        {
          throw new Error(`Unknown terminal type '${type}'`);
        }
    }
  }

  updateConnection(options = {}) {
    const edge = this.cell; // The edge is being translated by an ancestor that will shift
    // source, target and vertices by an equal distance.

    if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {
      const tx = options.tx || 0;
      const ty = options.ty || 0;
      this.routePoints = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(this.routePoints).translate(tx, ty).points;
      this.translateConnectionPoints(tx, ty);
      this.path.translate(tx, ty);
    } else {
      const vertices = edge.getVertices(); // 1. Find anchor points

      const anchors = this.findAnchors(vertices);
      this.sourceAnchor = anchors.source;
      this.targetAnchor = anchors.target; // 2. Find route points

      this.routePoints = this.findRoutePoints(vertices); // 3. Find connection points

      const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
      this.sourcePoint = connectionPoints.source;
      this.targetPoint = connectionPoints.target; // 4. Find Marker Connection Point

      const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint); // 5. Make path

      this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);
    }

    this.cleanCache();
  }

  findAnchors(vertices) {
    const edge = this.cell;
    const source = edge.source;
    const target = edge.target;
    const firstVertex = vertices[0];
    const lastVertex = vertices[vertices.length - 1];

    if (target.priority && !source.priority) {
      // Reversed order
      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);
    } // Usual order


    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);
  }

  findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {
    let firstAnchor;
    let secondAnchor;
    const edge = this.cell;
    const firstTerminal = edge[firstType];
    const secondTerminal = edge[secondType];
    const firstView = this.getTerminalView(firstType);
    const secondView = this.getTerminalView(secondType);
    const firstMagnet = this.getTerminalMagnet(firstType);
    const secondMagnet = this.getTerminalMagnet(secondType);

    if (firstView) {
      let firstRef;

      if (firstPoint) {
        firstRef = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(firstPoint);
      } else if (secondView) {
        firstRef = secondMagnet;
      } else {
        firstRef = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(secondTerminal);
      }

      firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);
    } else {
      firstAnchor = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(firstTerminal);
    }

    if (secondView) {
      const secondRef = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(secondPoint || firstAnchor);
      secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);
    } else {
      secondAnchor = _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.isPointLike(secondTerminal) ? _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(secondTerminal) : new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point();
    }

    return {
      [firstType]: firstAnchor,
      [secondType]: secondAnchor
    };
  }

  getAnchor(def, cellView, magnet, ref, terminalType) {
    const isEdge = cellView.isEdgeElement(magnet);
    const connecting = this.graph.options.connecting;
    let config = typeof def === 'string' ? {
      name: def
    } : def;

    if (!config) {
      const defaults = isEdge ? (terminalType === 'source' ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === 'source' ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;
      config = typeof defaults === 'string' ? {
        name: defaults
      } : defaults;
    }

    if (!config) {
      throw new Error(`Anchor should be specified.`);
    }

    let anchor;
    const name = config.name;

    if (isEdge) {
      const fn = _registry__WEBPACK_IMPORTED_MODULE_2__.EdgeAnchor.registry.get(name);

      if (typeof fn !== 'function') {
        return _registry__WEBPACK_IMPORTED_MODULE_2__.EdgeAnchor.registry.onNotFound(name);
      }

      anchor = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
    } else {
      const fn = _registry__WEBPACK_IMPORTED_MODULE_2__.NodeAnchor.registry.get(name);

      if (typeof fn !== 'function') {
        return _registry__WEBPACK_IMPORTED_MODULE_2__.NodeAnchor.registry.onNotFound(name);
      }

      anchor = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
    }

    return anchor ? anchor.round(this.POINT_ROUNDING) : new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point();
  }

  findRoutePoints(vertices = []) {
    const defaultRouter = this.graph.options.connecting.router || _registry__WEBPACK_IMPORTED_MODULE_2__.Router.presets.normal;
    const router = this.cell.getRouter() || defaultRouter;
    let routePoints;

    if (typeof router === 'function') {
      routePoints = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(router, this, vertices, {}, this);
    } else {
      const name = typeof router === 'string' ? router : router.name;
      const args = typeof router === 'string' ? {} : router.args || {};
      const fn = name ? _registry__WEBPACK_IMPORTED_MODULE_2__.Router.registry.get(name) : _registry__WEBPACK_IMPORTED_MODULE_2__.Router.presets.normal;

      if (typeof fn !== 'function') {
        return _registry__WEBPACK_IMPORTED_MODULE_2__.Router.registry.onNotFound(name);
      }

      routePoints = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, vertices, args, this);
    }

    return routePoints == null ? vertices.map(p => _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(p)) : routePoints.map(p => _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(p));
  }

  findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {
    const edge = this.cell;
    const connecting = this.graph.options.connecting;
    const sourceTerminal = edge.getSource();
    const targetTerminal = edge.getTarget();
    const sourceView = this.sourceView;
    const targetView = this.targetView;
    const firstRoutePoint = routePoints[0];
    const lastRoutePoint = routePoints[routePoints.length - 1]; // source

    let sourcePoint;

    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {
      const sourceMagnet = this.sourceMagnet || sourceView.container;
      const sourcePointRef = firstRoutePoint || targetAnchor;
      const sourceLine = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(sourcePointRef, sourceAnchor);
      const connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;
      sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');
    } else {
      sourcePoint = sourceAnchor;
    } // target


    let targetPoint;

    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {
      const targetMagnet = this.targetMagnet || targetView.container;
      const targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;
      const targetPointRef = lastRoutePoint || sourceAnchor;
      const targetLine = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Line(targetPointRef, targetAnchor);
      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');
    } else {
      targetPoint = targetAnchor;
    }

    return {
      source: sourcePoint,
      target: targetPoint
    };
  }

  getConnectionPoint(def, view, magnet, line, endType) {
    const anchor = line.end;

    if (def == null) {
      return anchor;
    }

    const name = typeof def === 'string' ? def : def.name;
    const args = typeof def === 'string' ? {} : def.args;
    const fn = _registry__WEBPACK_IMPORTED_MODULE_2__.ConnectionPoint.registry.get(name);

    if (typeof fn !== 'function') {
      return _registry__WEBPACK_IMPORTED_MODULE_2__.ConnectionPoint.registry.onNotFound(name);
    }

    const connectionPoint = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);
    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;
  }

  updateMarkerAttr(type) {
    const attrs = this.cell.getAttrs();
    const key = `.${type}-marker`;
    const partial = attrs && attrs[key];

    if (partial) {
      this.updateAttrs(this.container, {}, {
        attrs: {
          [key]: partial
        },
        selectors: this.selectors
      });
    }
  }

  findMarkerPoints(routePoints, sourcePoint, targetPoint) {
    const getLineWidth = type => {
      const attrs = this.cell.getAttrs();
      const keys = Object.keys(attrs);

      for (let i = 0, l = keys.length; i < l; i += 1) {
        const attr = attrs[keys[i]];

        if (attr[`${type}Marker`] || attr[`${type}-marker`]) {
          const strokeWidth = attr.strokeWidth || attr['stroke-width'];

          if (strokeWidth) {
            return parseFloat(strokeWidth);
          }

          break;
        }
      }

      return null;
    };

    const firstRoutePoint = routePoints[0];
    const lastRoutePoint = routePoints[routePoints.length - 1];
    const sourceMarkerElem = this.containers.sourceMarker;
    const targetMarkerElem = this.containers.targetMarker;
    const cache = this.markerCache;
    let sourceMarkerPoint;
    let targetMarkerPoint; // Move the source point by the width of the marker taking into
    // account its scale around x-axis. Note that scale is the only
    // transform that makes sense to be set in `.marker-source`
    // attributes object as all other transforms (translate/rotate)
    // will be replaced by the `translateAndAutoOrient()` function.

    if (sourceMarkerElem) {
      this.updateMarkerAttr('source'); // support marker connection point registry???

      cache.sourceBBox = cache.sourceBBox || _util__WEBPACK_IMPORTED_MODULE_1__.Dom.getBBox(sourceMarkerElem);

      if (cache.sourceBBox.width > 0) {
        const scale = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.scale(sourceMarkerElem);
        sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1);
      }
    } else {
      const strokeWidth = getLineWidth('source');

      if (strokeWidth) {
        sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -strokeWidth);
      }
    }

    if (targetMarkerElem) {
      this.updateMarkerAttr('target');
      cache.targetBBox = cache.targetBBox || _util__WEBPACK_IMPORTED_MODULE_1__.Dom.getBBox(targetMarkerElem);

      if (cache.targetBBox.width > 0) {
        const scale = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.scale(targetMarkerElem);
        targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, cache.targetBBox.width * scale.sx * -1);
      }
    } else {
      const strokeWidth = getLineWidth('target');

      if (strokeWidth) {
        targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -strokeWidth);
      }
    } // If there was no markup for the marker, use the connection point.


    cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();
    cache.targetPoint = targetMarkerPoint || targetPoint.clone();
    return {
      source: sourceMarkerPoint,
      target: targetMarkerPoint
    };
  }

  findPath(routePoints, sourcePoint, targetPoint) {
    const def = this.cell.getConnector() || this.graph.options.connecting.connector;
    let name;
    let args;
    let fn;

    if (typeof def === 'string') {
      name = def;
    } else {
      name = def.name;
      args = def.args;
    }

    if (name) {
      const method = _registry__WEBPACK_IMPORTED_MODULE_2__.Connector.registry.get(name);

      if (typeof method !== 'function') {
        return _registry__WEBPACK_IMPORTED_MODULE_2__.Connector.registry.onNotFound(name);
      }

      fn = method;
    } else {
      fn = _registry__WEBPACK_IMPORTED_MODULE_2__.Connector.presets.normal;
    }

    const path = _util__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), {
      raw: true
    }), this);
    return typeof path === 'string' ? _geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(path) : path;
  }

  translateConnectionPoints(tx, ty) {
    const cache = this.markerCache;

    if (cache.sourcePoint) {
      cache.sourcePoint.translate(tx, ty);
    }

    if (cache.targetPoint) {
      cache.targetPoint.translate(tx, ty);
    }

    this.sourcePoint.translate(tx, ty);
    this.targetPoint.translate(tx, ty);
    this.sourceAnchor.translate(tx, ty);
    this.targetAnchor.translate(tx, ty);
  }

  updateLabelPositions() {
    if (this.containers.labels == null) {
      return this;
    }

    const path = this.path;

    if (!path) {
      return this;
    }

    const edge = this.cell;
    const labels = edge.getLabels();

    if (labels.length === 0) {
      return this;
    }

    const defaultLabel = edge.getDefaultLabel();
    const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);

    for (let i = 0, ii = labels.length; i < ii; i += 1) {
      const label = labels[i];
      const labelPosition = this.normalizeLabelPosition(label.position);
      const pos = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, defaultPosition, labelPosition);
      const matrix = this.getLabelTransformationMatrix(pos);
      this.labelCache[i].setAttribute('transform', _util__WEBPACK_IMPORTED_MODULE_1__.Dom.matrixToTransformString(matrix));
    }

    return this;
  }

  updateToolsPosition() {
    if (this.containers.tools == null) {
      return this;
    } // Move the tools a bit to the target position but don't cover the
    // `sourceArrowhead` marker. Note that the offset is hardcoded here.
    // The offset should be always more than the
    // `this.$('.marker-arrowhead[end="source"]')[0].bbox().width` but looking
    // this up all the time would be slow.


    let scale = '';
    let offset = this.options.toolsOffset;
    const connectionLength = this.getConnectionLength(); // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).
    // In that case we won't update tools position at all.

    if (connectionLength != null) {
      // If the edge is too short, make the tools half the
      // size and the offset twice as low.
      if (connectionLength < this.options.shortLength) {
        scale = 'scale(.5)';
        offset /= 2;
      }

      let pos = this.getPointAtLength(offset);

      if (pos != null) {
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.attr(this.toolCache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);
      }

      if (this.options.doubleTools && connectionLength >= this.options.longLength) {
        const doubleToolsOffset = this.options.doubleToolsOffset || offset;
        pos = this.getPointAtLength(connectionLength - doubleToolsOffset);

        if (pos != null) {
          _util__WEBPACK_IMPORTED_MODULE_1__.Dom.attr(this.tool2Cache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);
        }

        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.attr(this.tool2Cache, 'visibility', 'visible');
      } else if (this.options.doubleTools) {
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.attr(this.tool2Cache, 'visibility', 'hidden');
      }
    }

    return this;
  }

  updateArrowheadMarkers() {
    const container = this.containers.arrowheads;

    if (container == null) {
      return this;
    }

    if (container.style.display === 'none') {
      return this;
    }

    const sourceArrowhead = this.containers.sourceArrowhead;
    const targetArrowhead = this.containers.targetArrowhead;

    if (sourceArrowhead && targetArrowhead) {
      const len = this.getConnectionLength() || 0;
      const sx = len < this.options.shortLength ? 0.5 : 1;
      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.scale(sourceArrowhead, sx);
      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.scale(targetArrowhead, sx);
      this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);
    }

    return this;
  }

  updateTerminalProperties(type) {
    const edge = this.cell;
    const graph = this.graph;
    const terminal = edge[type];
    const nodeId = terminal && terminal.cell;
    const viewKey = `${type}View`; // terminal is a point

    if (!nodeId) {
      this[viewKey] = null;
      this.updateTerminalMagnet(type);
      return true;
    }

    const terminalCell = graph.getCellById(nodeId);

    if (!terminalCell) {
      throw new Error(`Edge's ${type} node with id "${nodeId}" not exists`);
    }

    const endView = terminalCell.findView(graph);

    if (!endView) {
      return false;
    }

    this[viewKey] = endView;
    this.updateTerminalMagnet(type);
    return true;
  }

  updateTerminalMagnet(type) {
    const propName = `${type}Magnet`;
    const terminalView = this.getTerminalView(type);

    if (terminalView) {
      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);

      if (magnet === terminalView.container) {
        magnet = null;
      }

      this[propName] = magnet;
    } else {
      this[propName] = null;
    }
  }

  translateAndAutoOrientArrows(sourceArrow, targetArrow) {
    const route = this.routePoints;

    if (sourceArrow) {
      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);
    }

    if (targetArrow) {
      _util__WEBPACK_IMPORTED_MODULE_1__.Dom.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);
    }
  }

  getLabelPositionAngle(idx) {
    const label = this.cell.getLabelAt(idx);

    if (label && label.position && typeof label.position === 'object') {
      return label.position.angle || 0;
    }

    return 0;
  }

  getLabelPositionArgs(idx) {
    const label = this.cell.getLabelAt(idx);

    if (label && label.position && typeof label.position === 'object') {
      return label.position.options;
    }
  }

  getDefaultLabelPositionArgs() {
    const defaultLabel = this.cell.getDefaultLabel();

    if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === 'object') {
      return defaultLabel.position.options;
    }
  } // merge default label position args into label position args
  // keep `undefined` or `null` because `{}` means something else


  mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {
    if (labelPositionArgs === null) {
      return null;
    }

    if (labelPositionArgs === undefined) {
      if (defaultLabelPositionArgs === null) {
        return null;
      }

      return defaultLabelPositionArgs;
    }

    return _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);
  }

  addLabel(p1, p2, p3, options) {
    let localX;
    let localY;
    let localAngle = 0;
    let localOptions;

    if (typeof p1 !== 'number') {
      localX = p1.x;
      localY = p1.y;

      if (typeof p2 === 'number') {
        localAngle = p2;
        localOptions = p3;
      } else {
        localOptions = p2;
      }
    } else {
      localX = p1;
      localY = p2;

      if (typeof p3 === 'number') {
        localAngle = p3;
        localOptions = options;
      } else {
        localOptions = p3;
      }
    } // merge label position arguments


    const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
    const labelPositionArgs = localOptions;
    const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs); // append label to labels array

    const label = {
      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)
    };
    const index = -1;
    this.cell.insertLabel(label, index, localOptions);
    return index;
  }

  addVertex(x, y, options) {
    const isPoint = typeof x !== 'number';
    const localX = isPoint ? x.x : x;
    const localY = isPoint ? x.y : y;
    const localOptions = isPoint ? y : options;
    const vertex = {
      x: localX,
      y: localY
    };
    const index = this.getVertexIndex(localX, localY);
    this.cell.insertVertex(vertex, index, localOptions);
    return index;
  }

  sendToken(token, options, callback) {
    let duration;
    let reversed;
    let selector;
    let rorate;
    let timing = 'linear';

    if (typeof options === 'object') {
      duration = options.duration;
      reversed = options.reversed === true;
      selector = options.selector;

      if (options.rotate === false) {
        rorate = '';
      } else if (options.rotate === true) {
        rorate = 'auto';
      } else if (options.rotate != null) {
        rorate = `${options.rotate}`;
      }

      if (options.timing) {
        timing = options.timing;
      }
    } else {
      duration = options;
      reversed = false;
      selector = null;
    }

    duration = duration || 1000;
    const attrs = {
      dur: `${duration}ms`,
      repeatCount: '1',
      calcMode: timing,
      fill: 'freeze'
    };

    if (rorate) {
      attrs.rotate = rorate;
    }

    if (reversed) {
      attrs.keyPoints = '1;0';
      attrs.keyTimes = '0;1';
    }

    if (typeof options === 'object') {
      const {
        duration,
        reversed,
        selector,
        rotate,
        timing
      } = options,
            others = __rest(options, ["duration", "reversed", "selector", "rotate", "timing"]);

      Object.keys(others).forEach(key => {
        attrs[key] = others[key];
      });
    }

    let path;

    if (typeof selector === 'string') {
      path = this.findOne(selector, this.container, this.selectors);
    } else {
      // Select connection path automatically.
      path = this.containers.connection ? this.containers.connection : this.container.querySelector('path');
    }

    if (!(path instanceof SVGPathElement)) {
      throw new Error('Token animation requires a valid connection path.');
    }

    const target = typeof token === 'string' ? this.findOne(token) : token;

    if (target == null) {
      throw new Error('Token animation requires a valid token element.');
    }

    const parent = target.parentNode;

    const revert = () => {
      if (!parent) {
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.remove(target);
      }
    };

    const vToken = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.create(target);

    if (!parent) {
      vToken.appendTo(this.graph.view.stage);
    }

    const onComplete = attrs.complete;

    attrs.complete = e => {
      revert();

      if (callback) {
        callback();
      }

      if (onComplete) {
        onComplete(e);
      }
    };

    const stop = vToken.animateAlongPath(attrs, path);
    return () => {
      revert();
      stop();
    };
  } // #endregion


  getConnection() {
    return this.path != null ? this.path.clone() : null;
  }

  getConnectionPathData() {
    if (this.path == null) {
      return '';
    }

    const cache = this.cache.pathCache;

    if (!_util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.has(cache, 'data')) {
      cache.data = this.path.serialize();
    }

    return cache.data || '';
  }

  getConnectionSubdivisions() {
    if (this.path == null) {
      return null;
    }

    const cache = this.cache.pathCache;

    if (!_util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.has(cache, 'segmentSubdivisions')) {
      cache.segmentSubdivisions = this.path.getSegmentSubdivisions();
    }

    return cache.segmentSubdivisions;
  }

  getConnectionLength() {
    if (this.path == null) {
      return 0;
    }

    const cache = this.cache.pathCache;

    if (!_util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.has(cache, 'length')) {
      cache.length = this.path.length({
        segmentSubdivisions: this.getConnectionSubdivisions()
      });
    }

    return cache.length;
  }

  getPointAtLength(length) {
    if (this.path == null) {
      return null;
    }

    return this.path.pointAtLength(length, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }

  getPointAtRatio(ratio) {
    if (this.path == null) {
      return null;
    }

    if (_util__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(ratio)) {
      // eslint-disable-next-line
      ratio = parseFloat(ratio) / 100;
    }

    return this.path.pointAt(ratio, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }

  getTangentAtLength(length) {
    if (this.path == null) {
      return null;
    }

    return this.path.tangentAtLength(length, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }

  getTangentAtRatio(ratio) {
    if (this.path == null) {
      return null;
    }

    return this.path.tangentAt(ratio, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }

  getClosestPoint(point) {
    if (this.path == null) {
      return null;
    }

    return this.path.closestPoint(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }

  getClosestPointLength(point) {
    if (this.path == null) {
      return null;
    }

    return this.path.closestPointLength(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }

  getClosestPointRatio(point) {
    if (this.path == null) {
      return null;
    }

    return this.path.closestPointNormalizedLength(point, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }

  getLabelPosition(x, y, p3, p4) {
    const pos = {
      distance: 0
    }; // normalize data from the two possible signatures

    let angle = 0;
    let options;

    if (typeof p3 === 'number') {
      angle = p3;
      options = p4;
    } else {
      options = p3;
    }

    if (options != null) {
      pos.options = options;
    } // identify distance/offset settings


    const isOffsetAbsolute = options && options.absoluteOffset;
    const isDistanceRelative = !(options && options.absoluteDistance);
    const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance; // find closest point t

    const path = this.path;
    const pathOptions = {
      segmentSubdivisions: this.getConnectionSubdivisions()
    };
    const labelPoint = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);
    const t = path.closestPointT(labelPoint, pathOptions); // distance

    const totalLength = this.getConnectionLength() || 0;
    let labelDistance = path.lengthAtT(t, pathOptions);

    if (isDistanceRelative) {
      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;
    }

    if (isDistanceAbsoluteReverse) {
      // fix for end point (-0 => 1)
      labelDistance = -1 * (totalLength - labelDistance) || 1;
    }

    pos.distance = labelDistance; // offset
    // use absolute offset if:
    // - options.absoluteOffset is true,
    // - options.absoluteOffset is not true but there is no tangent

    let tangent;
    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);
    let labelOffset;

    if (tangent) {
      labelOffset = tangent.pointOffset(labelPoint);
    } else {
      const closestPoint = path.pointAtT(t);
      const labelOffsetDiff = labelPoint.diff(closestPoint);
      labelOffset = {
        x: labelOffsetDiff.x,
        y: labelOffsetDiff.y
      };
    }

    pos.offset = labelOffset;
    pos.angle = angle;
    return pos;
  }

  normalizeLabelPosition(pos) {
    if (typeof pos === 'number') {
      return {
        distance: pos
      };
    }

    return pos;
  }

  getLabelTransformationMatrix(labelPosition) {
    const pos = this.normalizeLabelPosition(labelPosition);
    const options = pos.options || {};
    const labelAngle = pos.angle || 0;
    const labelDistance = pos.distance;
    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
    let labelOffset = 0;
    const offsetCoord = {
      x: 0,
      y: 0
    };
    const offset = pos.offset;

    if (offset) {
      if (typeof offset === 'number') {
        labelOffset = offset;
      } else {
        if (offset.x != null) {
          offsetCoord.x = offset.x;
        }

        if (offset.y != null) {
          offsetCoord.y = offset.y;
        }
      }
    }

    const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;
    const isKeepGradient = options.keepGradient;
    const isEnsureLegibility = options.ensureLegibility;
    const path = this.path;
    const pathOpt = {
      segmentSubdivisions: this.getConnectionSubdivisions()
    };
    const distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;
    const tangent = path.tangentAtLength(distance, pathOpt);
    let translation;
    let angle = labelAngle;

    if (tangent) {
      if (isOffsetAbsolute) {
        translation = tangent.start;
        translation.translate(offsetCoord);
      } else {
        const normal = tangent.clone();
        normal.rotate(-90, tangent.start);
        normal.setLength(labelOffset);
        translation = normal.end;
      }

      if (isKeepGradient) {
        angle = tangent.angle() + labelAngle;

        if (isEnsureLegibility) {
          angle = _geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize((angle + 90) % 180 - 90);
        }
      }
    } else {
      // fallback - the connection has zero length
      translation = path.start;

      if (isOffsetAbsolute) {
        translation.translate(offsetCoord);
      }
    }

    return _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);
  }

  getLabelCoordinates(pos) {
    const matrix = this.getLabelTransformationMatrix(pos);
    return new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(matrix.e, matrix.f);
  }

  getVertexIndex(x, y) {
    const edge = this.cell;
    const vertices = edge.getVertices();
    const vertexLength = this.getClosestPointLength(new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y));
    let index = 0;

    if (vertexLength != null) {
      for (const ii = vertices.length; index < ii; index += 1) {
        const currentVertex = vertices[index];
        const currentLength = this.getClosestPointLength(currentVertex);

        if (currentLength != null && vertexLength < currentLength) {
          break;
        }
      }
    }

    return index;
  }

  getEventArgs(e, x, y) {
    const view = this; // eslint-disable-line

    const edge = view.cell;
    const cell = edge;

    if (x == null || y == null) {
      return {
        e,
        view,
        edge,
        cell
      };
    }

    return {
      e,
      x,
      y,
      view,
      edge,
      cell
    };
  }

  notifyUnhandledMouseDown(e, x, y) {
    this.notify('edge:unhandled:mousedown', {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }

  notifyMouseDown(e, x, y) {
    super.onMouseDown(e, x, y);
    this.notify('edge:mousedown', this.getEventArgs(e, x, y));
  }

  notifyMouseMove(e, x, y) {
    super.onMouseMove(e, x, y);
    this.notify('edge:mousemove', this.getEventArgs(e, x, y));
  }

  notifyMouseUp(e, x, y) {
    super.onMouseUp(e, x, y);
    this.notify('edge:mouseup', this.getEventArgs(e, x, y));
  }

  onClick(e, x, y) {
    super.onClick(e, x, y);
    this.notify('edge:click', this.getEventArgs(e, x, y));
  }

  onDblClick(e, x, y) {
    super.onDblClick(e, x, y);
    this.notify('edge:dblclick', this.getEventArgs(e, x, y));
  }

  onContextMenu(e, x, y) {
    super.onContextMenu(e, x, y);
    this.notify('edge:contextmenu', this.getEventArgs(e, x, y));
  }

  onMouseDown(e, x, y) {
    this.notifyMouseDown(e, x, y);
    const className = e.target.getAttribute('class');

    switch (className) {
      case 'vertex':
        {
          this.startVertexDragging(e, x, y);
          return;
        }

      case 'vertex-remove':
      case 'vertex-remove-area':
        {
          this.handleVertexRemoving(e, x, y);
          return;
        }

      case 'connection':
      case 'connection-wrap':
        {
          this.handleVertexAdding(e, x, y);
          return;
        }

      case 'arrowhead':
        {
          this.startArrowheadDragging(e, x, y);
          return;
        }

      case 'source-marker':
      case 'target-marker':
        {
          this.notifyUnhandledMouseDown(e, x, y);
          return;
        }

      default:
        break;
    }

    this.startEdgeDragging(e, x, y);
  }

  onMouseMove(e, x, y) {
    const data = this.getEventData(e);

    switch (data.action) {
      case 'drag-vertex':
        {
          this.dragVertex(e, x, y);
          break;
        }

      case 'drag-label':
        {
          this.dragLabel(e, x, y);
          break;
        }

      case 'drag-arrowhead':
        {
          this.dragArrowhead(e, x, y);
          break;
        }

      case 'drag-edge':
        {
          this.dragEdge(e, x, y);
          break;
        }

      default:
        break;
    }

    this.notifyMouseMove(e, x, y);
    return data;
  }

  onMouseUp(e, x, y) {
    const data = this.getEventData(e);

    switch (data.action) {
      case 'drag-vertex':
        {
          this.stopVertexDragging(e, x, y);
          break;
        }

      case 'drag-label':
        {
          this.stopLabelDragging(e, x, y);
          break;
        }

      case 'drag-arrowhead':
        {
          this.stopArrowheadDragging(e, x, y);
          break;
        }

      case 'drag-edge':
        {
          this.stopEdgeDragging(e, x, y);
          break;
        }

      default:
        break;
    }

    this.notifyMouseUp(e, x, y);
    this.checkMouseleave(e);
    return data;
  }

  onMouseOver(e) {
    super.onMouseOver(e);
    this.notify('edge:mouseover', this.getEventArgs(e));
  }

  onMouseOut(e) {
    super.onMouseOut(e);
    this.notify('edge:mouseout', this.getEventArgs(e));
  }

  onMouseEnter(e) {
    super.onMouseEnter(e);
    this.notify('edge:mouseenter', this.getEventArgs(e));
  }

  onMouseLeave(e) {
    super.onMouseLeave(e);
    this.notify('edge:mouseleave', this.getEventArgs(e));
  }

  onMouseWheel(e, x, y, delta) {
    super.onMouseWheel(e, x, y, delta);
    this.notify('edge:mousewheel', Object.assign({
      delta
    }, this.getEventArgs(e, x, y)));
  }

  onCustomEvent(e, name, x, y) {
    // For default edge tool
    const tool = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.findParentByClass(e.target, 'edge-tool', this.container);

    if (tool) {
      e.stopPropagation(); // no further action to be executed

      if (this.can('useEdgeTools')) {
        if (name === 'edge:remove') {
          this.cell.remove({
            ui: true
          });
          return;
        }

        this.notify('edge:customevent', Object.assign({
          name
        }, this.getEventArgs(e, x, y)));
      }

      this.notifyMouseDown(e, x, y);
    } else {
      this.notify('edge:customevent', Object.assign({
        name
      }, this.getEventArgs(e, x, y)));
      super.onCustomEvent(e, name, x, y);
    }
  }

  onLabelMouseDown(e, x, y) {
    this.notifyMouseDown(e, x, y);
    this.startLabelDragging(e, x, y);
    const stopPropagation = this.getEventData(e).stopPropagation;

    if (stopPropagation) {
      e.stopPropagation();
    }
  } // #region drag edge


  startEdgeDragging(e, x, y) {
    if (!this.can('edgeMovable')) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    }

    this.setEventData(e, {
      x,
      y,
      moving: false,
      action: 'drag-edge'
    });
  }

  dragEdge(e, x, y) {
    const data = this.getEventData(e);

    if (!data.moving) {
      data.moving = true;
      this.addClass('edge-moving');
      this.notify('edge:move', {
        e,
        x,
        y,
        view: this,
        cell: this.cell,
        edge: this.cell
      });
    }

    this.cell.translate(x - data.x, y - data.y, {
      ui: true
    });
    this.setEventData(e, {
      x,
      y
    });
    this.notify('edge:moving', {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }

  stopEdgeDragging(e, x, y) {
    const data = this.getEventData(e);

    if (data.moving) {
      this.removeClass('edge-moving');
      this.notify('edge:moved', {
        e,
        x,
        y,
        view: this,
        cell: this.cell,
        edge: this.cell
      });
    }

    data.moving = false;
  } // #endregion
  // #region drag arrowhead


  prepareArrowheadDragging(type, options) {
    const magnet = this.getTerminalMagnet(type);
    const data = {
      action: 'drag-arrowhead',
      x: options.x,
      y: options.y,
      isNewEdge: options.isNewEdge === true,
      terminalType: type,
      initialMagnet: magnet,
      initialTerminal: _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.clone(this.cell[type]),
      fallbackAction: options.fallbackAction || 'revert',
      getValidateConnectionArgs: this.createValidateConnectionArgs(type),
      options: options.options
    };
    this.beforeArrowheadDragging(data);
    return data;
  }

  createValidateConnectionArgs(type) {
    const args = [];
    args[4] = type;
    args[5] = this;
    let opposite;
    let i = 0;
    let j = 0;

    if (type === 'source') {
      i = 2;
      opposite = 'target';
    } else {
      j = 2;
      opposite = 'source';
    }

    const terminal = this.cell[opposite];
    const cellId = terminal.cell;

    if (cellId) {
      let magnet;
      const view = args[i] = this.graph.renderer.findViewByCell(cellId);

      if (view) {
        magnet = view.getMagnetFromEdgeTerminal(terminal);

        if (magnet === view.container) {
          magnet = undefined;
        }
      }

      args[i + 1] = magnet;
    }

    return (cellView, magnet) => {
      args[j] = cellView;
      args[j + 1] = cellView.container === magnet ? undefined : magnet;
      return args;
    };
  }

  beforeArrowheadDragging(data) {
    data.zIndex = this.cell.zIndex;
    this.cell.toFront();
    const style = this.container.style;
    data.pointerEvents = style.pointerEvents;
    style.pointerEvents = 'none';

    if (this.graph.options.connecting.highlight) {
      this.highlightAvailableMagnets(data);
    }
  }

  afterArrowheadDragging(data) {
    if (data.zIndex != null) {
      this.cell.setZIndex(data.zIndex, {
        ui: true
      });
      data.zIndex = null;
    }

    const container = this.container;
    container.style.pointerEvents = data.pointerEvents || '';

    if (this.graph.options.connecting.highlight) {
      this.unhighlightAvailableMagnets(data);
    }
  }

  arrowheadDragging(target, x, y, data) {
    data.x = x;
    data.y = y; // Checking views right under the pointer

    if (data.currentTarget !== target) {
      // Unhighlight the previous view under pointer if there was one.
      if (data.currentMagnet && data.currentView) {
        data.currentView.unhighlight(data.currentMagnet, {
          type: 'magnetAdsorbed'
        });
      }

      data.currentView = this.graph.renderer.findViewByElem(target);

      if (data.currentView) {
        // If we found a view that is under the pointer, we need to find
        // the closest magnet based on the real target element of the event.
        data.currentMagnet = data.currentView.findMagnet(target);

        if (data.currentMagnet && this.graph.hook.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {
          data.currentView.highlight(data.currentMagnet, {
            type: 'magnetAdsorbed'
          });
        } else {
          // This type of connection is not valid. Disregard this magnet.
          data.currentMagnet = null;
        }
      } else {
        // Make sure we'll unset previous magnet.
        data.currentMagnet = null;
      }
    }

    data.currentTarget = target;
    this.cell.prop(data.terminalType, {
      x,
      y
    }, Object.assign(Object.assign({}, data.options), {
      ui: true
    }));
  }

  arrowheadDragged(data, x, y) {
    const view = data.currentView;
    const magnet = data.currentMagnet;

    if (!magnet || !view) {
      return;
    }

    view.unhighlight(magnet, {
      type: 'magnetAdsorbed'
    });
    const type = data.terminalType;
    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);
    this.cell.setTerminal(type, terminal, {
      ui: true
    });
  }

  snapArrowhead(x, y, data) {
    const graph = this.graph;
    const {
      snap,
      allowEdge
    } = graph.options.connecting;
    const radius = typeof snap === 'object' && snap.radius || 50;
    const findViewsOption = {
      x: x - radius,
      y: y - radius,
      width: 2 * radius,
      height: 2 * radius
    };
    const views = graph.renderer.findViewsInArea(findViewsOption);

    if (allowEdge) {
      const edgeViews = graph.renderer.findEdgeViewsInArea(findViewsOption).filter(view => {
        return view !== this;
      });
      views.push(...edgeViews);
    }

    const prevView = data.closestView || null;
    const prevMagnet = data.closestMagnet || null;
    data.closestView = null;
    data.closestMagnet = null;
    let distance;
    let minDistance = Number.MAX_SAFE_INTEGER;
    const pos = new _geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);
    views.forEach(view => {
      if (view.container.getAttribute('magnet') !== 'false') {
        // Find distance from the center of the cell to pointer coordinates
        distance = view.cell.getBBox().getCenter().distance(pos); // the connection is looked up in a circle area by `distance < r`

        if (distance < radius && distance < minDistance) {
          if (prevMagnet === view.container || graph.hook.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {
            minDistance = distance;
            data.closestView = view;
            data.closestMagnet = view.container;
          }
        }
      }

      view.container.querySelectorAll('[magnet]').forEach(magnet => {
        if (magnet.getAttribute('magnet') !== 'false') {
          const bbox = view.getBBoxOfElement(magnet);
          distance = pos.distance(bbox.getCenter());

          if (distance < radius && distance < minDistance) {
            if (prevMagnet === magnet || graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {
              minDistance = distance;
              data.closestView = view;
              data.closestMagnet = magnet;
            }
          }
        }
      });
    });
    let terminal;
    const type = data.terminalType;
    const closestView = data.closestView;
    const closestMagnet = data.closestMagnet;
    const changed = prevMagnet !== closestMagnet;

    if (prevView && changed) {
      prevView.unhighlight(prevMagnet, {
        type: 'magnetAdsorbed'
      });
    }

    if (closestView) {
      if (!changed) {
        return;
      }

      closestView.highlight(closestMagnet, {
        type: 'magnetAdsorbed'
      });
      terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);
    } else {
      terminal = {
        x,
        y
      };
    }

    this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), {
      ui: true
    }));
  }

  snapArrowheadEnd(data) {
    // Finish off link snapping.
    // Everything except view unhighlighting was already done on pointermove.
    const closestView = data.closestView;
    const closestMagnet = data.closestMagnet;

    if (closestView && closestMagnet) {
      closestView.unhighlight(closestMagnet, {
        type: 'magnetAdsorbed'
      });
      data.currentMagnet = closestView.findMagnet(closestMagnet);
    }

    data.closestView = null;
    data.closestMagnet = null;
  }

  finishEmbedding(data) {
    // Resets parent of the edge if embedding is enabled
    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {
      // Make sure we don't reverse to the original 'z' index
      data.zIndex = null;
    }
  }

  fallbackConnection(data) {
    switch (data.fallbackAction) {
      case 'remove':
        this.cell.remove({
          ui: true
        });
        break;

      case 'revert':
      default:
        this.cell.prop(data.terminalType, data.initialTerminal, {
          ui: true
        });
        break;
    }
  }

  notifyConnectionEvent(data, e) {
    const terminalType = data.terminalType;
    const initialTerminal = data.initialTerminal;
    const currentTerminal = this.cell[terminalType];
    const changed = currentTerminal && !_model_edge__WEBPACK_IMPORTED_MODULE_3__.Edge.equalTerminals(initialTerminal, currentTerminal);

    if (changed) {
      const graph = this.graph;
      const previous = initialTerminal;
      const previousCell = previous.cell ? graph.getCellById(previous.cell) : null;
      const previousPort = previous.port;
      const previousView = previousCell ? graph.findViewByCell(previousCell) : null;
      const previousPoint = previousCell || data.isNewEdge ? null : _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(initialTerminal).toJSON();
      const current = currentTerminal;
      const currentCell = current.cell ? graph.getCellById(current.cell) : null;
      const currentPort = current.port;
      const currentView = currentCell ? graph.findViewByCell(currentCell) : null;
      const currentPoint = currentCell ? null : _geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(currentTerminal).toJSON();
      this.notify('edge:connected', {
        e,
        previousCell,
        previousPort,
        previousView,
        previousPoint,
        currentCell,
        currentView,
        currentPort,
        currentPoint,
        previousMagnet: data.initialMagnet,
        currentMagnet: data.currentMagnet,
        edge: this.cell,
        view: this,
        type: terminalType,
        isNew: data.isNewEdge
      });
    }
  }

  highlightAvailableMagnets(data) {
    const graph = this.graph;
    const cells = graph.model.getCells();
    data.marked = {};

    for (let i = 0, ii = cells.length; i < ii; i += 1) {
      const view = graph.renderer.findViewByCell(cells[i]);

      if (!view) {
        continue;
      }

      const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));

      if (view.container.getAttribute('magnet') !== 'false') {
        magnets.push(view.container);
      }

      const availableMagnets = magnets.filter(magnet => graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));

      if (availableMagnets.length > 0) {
        // highlight all available magnets
        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {
          view.highlight(availableMagnets[j], {
            type: 'magnetAvailable'
          });
        } // highlight the entire view


        view.highlight(null, {
          type: 'nodeAvailable'
        });
        data.marked[view.cell.id] = availableMagnets;
      }
    }
  }

  unhighlightAvailableMagnets(data) {
    const marked = data.marked || {};
    Object.keys(marked).forEach(id => {
      const view = this.graph.renderer.findViewByCell(id);

      if (view) {
        const magnets = marked[id];
        magnets.forEach(magnet => {
          view.unhighlight(magnet, {
            type: 'magnetAvailable'
          });
        });
        view.unhighlight(null, {
          type: 'nodeAvailable'
        });
      }
    });
    data.marked = null;
  }

  startArrowheadDragging(e, x, y) {
    if (!this.can('arrowheadMovable')) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    }

    const elem = e.target;
    const type = elem.getAttribute('data-terminal');
    const data = this.prepareArrowheadDragging(type, {
      x,
      y
    });
    this.setEventData(e, data);
  }

  dragArrowhead(e, x, y) {
    const data = this.getEventData(e);

    if (this.graph.options.connecting.snap) {
      this.snapArrowhead(x, y, data);
    } else {
      this.arrowheadDragging(this.getEventTarget(e), x, y, data);
    }
  }

  stopArrowheadDragging(e, x, y) {
    const graph = this.graph;
    const data = this.getEventData(e);

    if (graph.options.connecting.snap) {
      this.snapArrowheadEnd(data);
    } else {
      this.arrowheadDragged(data, x, y);
    }

    const valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);

    if (valid) {
      this.finishEmbedding(data);
      this.notifyConnectionEvent(data, e);
    } else {
      // If the changed edge is not allowed, revert to its previous state.
      this.fallbackConnection(data);
    }

    this.afterArrowheadDragging(data);
  } // #endregion
  // #region drag lable
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  startLabelDragging(e, x, y) {
    if (this.can('edgeLabelMovable')) {
      const target = e.currentTarget;
      const index = parseInt(target.getAttribute('data-index'), 10);
      const positionAngle = this.getLabelPositionAngle(index);
      const labelPositionArgs = this.getLabelPositionArgs(index);
      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
      const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
      this.setEventData(e, {
        index,
        positionAngle,
        positionArgs,
        stopPropagation: true,
        action: 'drag-label'
      });
    } else {
      // If labels can't be dragged no default action is triggered.
      this.setEventData(e, {
        stopPropagation: true
      });
    }

    this.graph.view.delegateDragEvents(e, this);
  }

  dragLabel(e, x, y) {
    const data = this.getEventData(e);
    const originLabel = this.cell.getLabelAt(data.index);
    const label = _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, originLabel, {
      position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)
    });
    this.cell.setLabelAt(data.index, label);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  stopLabelDragging(e, x, y) {} // #endregion
  // #region drag vertex


  handleVertexAdding(e, x, y) {
    if (!this.can('vertexAddable')) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    } // Store the index at which the new vertex has just been placed.
    // We'll be update the very same vertex position in `pointermove()`.


    const index = this.addVertex({
      x,
      y
    }, {
      ui: true
    });
    this.setEventData(e, {
      index,
      action: 'drag-vertex'
    });
  }

  handleVertexRemoving(e, x, y) {
    if (!this.can('vertexDeletable')) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    }

    const target = e.target;
    const index = parseInt(target.getAttribute('idx'), 10);
    this.cell.removeVertexAt(index);
  }

  startVertexDragging(e, x, y) {
    if (!this.can('vertexMovable')) {
      this.notifyUnhandledMouseDown(e, x, y);
      return;
    }

    const target = e.target;
    const index = parseInt(target.getAttribute('idx'), 10);
    this.setEventData(e, {
      index,
      action: 'drag-vertex'
    });
  }

  dragVertex(e, x, y) {
    const data = this.getEventData(e);
    this.cell.setVertexAt(data.index, {
      x,
      y
    }, {
      ui: true
    });
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  stopVertexDragging(e, x, y) {}

}

(function (EdgeView) {
  EdgeView.toStringTag = `X6.${EdgeView.name}`;

  function isEdgeView(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof EdgeView) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const view = instance;

    if ((tag == null || tag === EdgeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.getConnection === 'function') {
      return true;
    }

    return false;
  }

  EdgeView.isEdgeView = isEdgeView;
})(EdgeView || (EdgeView = {}));

EdgeView.config({
  isSvgElement: true,
  priority: 1,
  bootstrap: ['render', 'source', 'target'],
  actions: {
    view: ['render'],
    markup: ['render'],
    attrs: ['update'],
    source: ['source', 'update'],
    target: ['target', 'update'],
    router: ['update'],
    connector: ['update'],
    labels: ['labels'],
    defaultLabel: ['labels'],
    vertices: ['vertices', 'update'],
    vertexMarkup: ['vertices'],
    toolMarkup: ['tools'],
    tools: ['widget']
  },
  shortLength: 105,
  longLength: 155,
  toolsOffset: 40,
  doubleTools: false,
  doubleToolsOffset: 65,
  sampleInterval: 50
});
EdgeView.registry.register('edge', EdgeView, true);

/***/ }),

/***/ 51562:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/flag.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FlagManager": () => (/* binding */ FlagManager)
/* harmony export */ });
/* eslint-disable no-bitwise */
class FlagManager {
  constructor(view, actions, bootstrap = []) {
    this.view = view;
    const flags = {};
    const attrs = {};
    let shift = 0;
    Object.keys(actions).forEach(attr => {
      let labels = actions[attr];

      if (!Array.isArray(labels)) {
        labels = [labels];
      }

      labels.forEach(label => {
        let flag = flags[label];

        if (!flag) {
          shift += 1;
          flag = flags[label] = 1 << shift;
        }

        attrs[attr] |= flag;
      });
    });
    let labels = bootstrap;

    if (!Array.isArray(labels)) {
      labels = [labels];
    }

    labels.forEach(label => {
      if (!flags[label]) {
        shift += 1;
        flags[label] = 1 << shift;
      }
    }); // 26 - 30 are reserved for paper flags
    // 31+ overflows maximal number

    if (shift > 25) {
      throw new Error('Maximum number of flags exceeded.');
    }

    this.flags = flags;
    this.attrs = attrs;
    this.bootstrap = bootstrap;
  }

  get cell() {
    return this.view.cell;
  }

  getFlag(label) {
    const flags = this.flags;

    if (flags == null) {
      return 0;
    }

    if (Array.isArray(label)) {
      return label.reduce((memo, key) => memo | flags[key], 0);
    }

    return flags[label] | 0;
  }

  hasAction(flag, label) {
    return flag & this.getFlag(label);
  }

  removeAction(flag, label) {
    return flag ^ flag & this.getFlag(label);
  }

  getBootstrapFlag() {
    return this.getFlag(this.bootstrap);
  }

  getChangedFlag() {
    let flag = 0;

    if (!this.attrs) {
      return flag;
    }

    Object.keys(this.attrs).forEach(attr => {
      if (this.cell.hasChanged(attr)) {
        flag |= this.attrs[attr];
      }
    });
    return flag;
  }

}

/***/ }),

/***/ 29818:
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/view/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CellView": () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_2__.CellView),
/* harmony export */   "EdgeView": () => (/* reexport safe */ _edge__WEBPACK_IMPORTED_MODULE_3__.EdgeView),
/* harmony export */   "Markup": () => (/* reexport safe */ _markup__WEBPACK_IMPORTED_MODULE_0__.Markup),
/* harmony export */   "NodeView": () => (/* reexport safe */ _node__WEBPACK_IMPORTED_MODULE_4__.NodeView),
/* harmony export */   "ToolsView": () => (/* reexport safe */ _tool__WEBPACK_IMPORTED_MODULE_5__.ToolsView),
/* harmony export */   "View": () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_1__.View)
/* harmony export */ });
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./markup */ 8676);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ 58458);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cell */ 58670);
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./edge */ 32325);
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node */ 78415);
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tool */ 92654);







/***/ }),

/***/ 8676:
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/view/markup.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Markup": () => (/* binding */ Markup)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);

 // eslint-disable-next-line

var Markup;

(function (Markup) {
  function isJSONMarkup(markup) {
    return markup != null && !isStringMarkup(markup);
  }

  Markup.isJSONMarkup = isJSONMarkup;

  function isStringMarkup(markup) {
    return markup != null && typeof markup === 'string';
  }

  Markup.isStringMarkup = isStringMarkup;

  function clone(markup) {
    return markup == null || isStringMarkup(markup) ? markup : _util__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(markup);
  }

  Markup.clone = clone;
  /**
   * Removes blank space in markup to prevent create empty text node.
   */

  function sanitize(markup) {
    return `${markup}`.trim().replace(/[\r|\n]/g, ' ').replace(/>\s+</g, '><');
  }

  Markup.sanitize = sanitize;

  function parseStringMarkup(markup) {
    const fragment = document.createDocumentFragment();
    const groups = {};
    const selectors = {};
    const sanitized = sanitize(markup);
    const nodes = _util__WEBPACK_IMPORTED_MODULE_1__.StringExt.sanitizeHTML(sanitized, {
      raw: true
    });
    nodes.forEach(node => {
      fragment.appendChild(node);
    });
    return {
      fragment,
      selectors,
      groups
    };
  }

  Markup.parseStringMarkup = parseStringMarkup;

  function parseJSONMarkup(markup, options = {
    ns: _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.svg
  }) {
    const fragment = document.createDocumentFragment();
    const groups = {};
    const selectors = {};
    const queue = [{
      markup: Array.isArray(markup) ? markup : [markup],
      parent: fragment,
      ns: options.ns
    }];

    while (queue.length > 0) {
      const item = queue.pop();
      let ns = item.ns || _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.svg;
      const defines = item.markup;
      const parentNode = item.parent;
      defines.forEach(define => {
        // tagName
        const tagName = define.tagName;

        if (!tagName) {
          throw new TypeError('Invalid tagName');
        } // ns


        if (define.ns) {
          ns = define.ns;
        }

        const svg = ns === _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.svg;
        const node = ns ? _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createElementNS(tagName, ns) : _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createElement(tagName); // attrs

        const attrs = define.attrs;

        if (attrs) {
          if (svg) {
            _util__WEBPACK_IMPORTED_MODULE_1__.Dom.attr(node, _util__WEBPACK_IMPORTED_MODULE_1__.Dom.kebablizeAttrs(attrs));
          } else {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()(node).attr(attrs);
          }
        } // style


        const style = define.style;

        if (style) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(node).css(style);
        } // classname


        const className = define.className;

        if (className != null) {
          node.setAttribute('class', Array.isArray(className) ? className.join(' ') : className);
        } // textContent


        if (define.textContent) {
          node.textContent = define.textContent;
        } // selector


        const selector = define.selector;

        if (selector != null) {
          if (selectors[selector]) {
            throw new TypeError('Selector must be unique');
          }

          selectors[selector] = node;
        } // group


        if (define.groupSelector) {
          let nodeGroups = define.groupSelector;

          if (!Array.isArray(nodeGroups)) {
            nodeGroups = [nodeGroups];
          }

          nodeGroups.forEach(name => {
            if (!groups[name]) {
              groups[name] = [];
            }

            groups[name].push(node);
          });
        }

        parentNode.appendChild(node); // children

        const children = define.children;

        if (Array.isArray(children)) {
          queue.push({
            ns,
            markup: children,
            parent: node
          });
        }
      });
    }

    Object.keys(groups).forEach(groupName => {
      if (selectors[groupName]) {
        throw new Error('Ambiguous group selector');
      }

      selectors[groupName] = groups[groupName];
    });
    return {
      fragment,
      selectors,
      groups
    };
  }

  Markup.parseJSONMarkup = parseJSONMarkup;

  function createContainer(firstChild) {
    return firstChild instanceof SVGElement ? _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSvgElement('g') : _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createElement('div');
  }

  function renderMarkup(markup) {
    if (isStringMarkup(markup)) {
      const nodes = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.createVectors(markup);
      const count = nodes.length;

      if (count === 1) {
        return {
          elem: nodes[0].node
        };
      }

      if (count > 1) {
        const elem = createContainer(nodes[0].node);
        nodes.forEach(node => {
          elem.appendChild(node.node);
        });
        return {
          elem
        };
      }

      return {};
    }

    const result = parseJSONMarkup(markup);
    const fragment = result.fragment;
    let elem = null;

    if (fragment.childNodes.length > 1) {
      elem = createContainer(fragment.firstChild);
      elem.appendChild(fragment);
    } else {
      elem = fragment.firstChild;
    }

    return {
      elem,
      selectors: result.selectors
    };
  }

  Markup.renderMarkup = renderMarkup;

  function parseLabelStringMarkup(markup) {
    const children = _util__WEBPACK_IMPORTED_MODULE_1__.Vector.createVectors(markup);
    const fragment = document.createDocumentFragment();

    for (let i = 0, n = children.length; i < n; i += 1) {
      const currentChild = children[i].node;
      fragment.appendChild(currentChild);
    }

    return {
      fragment,
      selectors: {}
    };
  }

  Markup.parseLabelStringMarkup = parseLabelStringMarkup;
})(Markup || (Markup = {})); // eslint-disable-next-line


(function (Markup) {
  function getSelector(elem, stop, prev) {
    if (elem != null) {
      let selector;
      const tagName = elem.tagName.toLowerCase();

      if (elem === stop) {
        if (typeof prev === 'string') {
          selector = `> ${tagName} > ${prev}`;
        } else {
          selector = `> ${tagName}`;
        }

        return selector;
      }

      const parent = elem.parentNode;

      if (parent && parent.childNodes.length > 1) {
        const nth = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.index(elem) + 1;
        selector = `${tagName}:nth-child(${nth})`;
      } else {
        selector = tagName;
      }

      if (prev) {
        selector += ` > ${prev}`;
      }

      return getSelector(elem.parentNode, stop, selector);
    }

    return prev;
  }

  Markup.getSelector = getSelector;

  function parseNode(node, root, ns) {
    if (node.nodeName === '#text') {
      return null;
    }

    let selector = null;
    let groupSelector = null; // let classNames: string | null = null

    let attrs = null;
    let isCSSSelector = false;
    const markup = {
      tagName: node.tagName
    };

    if (node.attributes) {
      attrs = {};

      for (let i = 0, l = node.attributes.length; i < l; i += 1) {
        const attr = node.attributes[i];
        const name = attr.nodeName;
        const value = attr.nodeValue;

        if (name === 'selector') {
          selector = value;
        } else if (name === 'groupSelector') {
          groupSelector = value;
        } else if (name === 'class') {
          markup.attrs = {
            class: value
          };
        } else {
          attrs[name] = value;
        }
      }
    }

    if (selector == null) {
      isCSSSelector = true;
      selector = getSelector(node, root);
    }

    if (node.namespaceURI) {
      markup.ns = node.namespaceURI;
    }

    if (markup.ns == null) {
      if (['body', 'div', 'section', 'main', 'nav', 'footer', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dl', 'center', 'strong', 'pre', 'form', 'select', 'textarea', 'fieldset', 'marquee', 'bgsound', 'iframe', 'frameset'].includes(node.tagName)) {
        markup.ns = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.xhtml;
      } else if (ns) {
        markup.ns = ns;
      }
    }

    if (selector) {
      markup.selector = selector;
    }

    if (groupSelector != null) {
      markup.groupSelector = groupSelector;
    }

    return {
      markup,
      attrs,
      isCSSSelector
    };
  }

  function xml2json(xml) {
    const sanitized = Markup.sanitize(xml);
    const doc = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.parseXML(sanitized, {
      mimeType: 'image/svg+xml'
    });
    const nodes = Array.prototype.slice.call(doc.childNodes);
    const attrMap = {};
    const markupMap = new WeakMap();

    const parse = (node, root, ns) => {
      const data = parseNode(node, root, ns);

      if (data == null) {
        const parent = markupMap.get(node.parentNode);

        if (parent && node.textContent) {
          parent.textContent = node.textContent;
        }
      } else {
        const {
          markup,
          attrs,
          isCSSSelector
        } = data;
        markupMap.set(node, markup);

        if (markup.selector && attrs != null) {
          if (Object.keys(attrs).length) {
            attrMap[markup.selector] = attrs;
          }

          if (isCSSSelector) {
            delete markup.selector;
          }
        }

        if (node.childNodes && node.childNodes.length > 0) {
          for (let i = 0, l = node.childNodes.length; i < l; i += 1) {
            const child = node.childNodes[i];
            const childMarkup = parse(child, root, markup.ns);

            if (childMarkup) {
              if (markup.children == null) {
                markup.children = [];
              }

              markup.children.push(childMarkup);
            }
          }
        }

        return markup;
      }
    };

    const markup = nodes.map(node => parse(node, node)).filter(mk => mk != null);
    return {
      markup,
      attrs: attrMap
    };
  }

  Markup.xml2json = xml2json;
})(Markup || (Markup = {})); // eslint-disable-next-line


(function (Markup) {
  function getPortContainerMarkup() {
    return 'g';
  }

  Markup.getPortContainerMarkup = getPortContainerMarkup;

  function getPortMarkup() {
    return {
      tagName: 'circle',
      selector: 'circle',
      attrs: {
        r: 10,
        fill: '#FFFFFF',
        stroke: '#000000'
      }
    };
  }

  Markup.getPortMarkup = getPortMarkup;

  function getPortLabelMarkup() {
    return {
      tagName: 'text',
      selector: 'text',
      attrs: {
        fill: '#000000'
      }
    };
  }

  Markup.getPortLabelMarkup = getPortLabelMarkup;
})(Markup || (Markup = {})); // eslint-disable-next-line


(function (Markup) {
  function getEdgeMarkup() {
    return Markup.sanitize(`
    <path class="connection" stroke="black" d="M 0 0 0 0"/>
    <path class="source-marker" fill="black" stroke="black" d="M 0 0 0 0"/>
    <path class="target-marker" fill="black" stroke="black" d="M 0 0 0 0"/>
    <path class="connection-wrap" d="M 0 0 0 0"/>
    <g class="labels"/>
    <g class="vertices"/>
    <g class="arrowheads"/>
    <g class="tools"/>
  `);
  }

  Markup.getEdgeMarkup = getEdgeMarkup;

  function getEdgeToolMarkup() {
    return Markup.sanitize(`
    <g class="edge-tool">
      <g class="tool-remove" event="edge:remove">
        <circle r="11" />
        <path transform="scale(.8) translate(-16, -16)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z" />
        <title>Remove edge.</title>
      </g>
      <g class="tool-options" event="edge:options">
        <circle r="11" transform="translate(25)"/>
        <path fill="white" transform="scale(.55) translate(29, -16)" d="M31.229,17.736c0.064-0.571,0.104-1.148,0.104-1.736s-0.04-1.166-0.104-1.737l-4.377-1.557c-0.218-0.716-0.504-1.401-0.851-2.05l1.993-4.192c-0.725-0.91-1.549-1.734-2.458-2.459l-4.193,1.994c-0.647-0.347-1.334-0.632-2.049-0.849l-1.558-4.378C17.165,0.708,16.588,0.667,16,0.667s-1.166,0.041-1.737,0.105L12.707,5.15c-0.716,0.217-1.401,0.502-2.05,0.849L6.464,4.005C5.554,4.73,4.73,5.554,4.005,6.464l1.994,4.192c-0.347,0.648-0.632,1.334-0.849,2.05l-4.378,1.557C0.708,14.834,0.667,15.412,0.667,16s0.041,1.165,0.105,1.736l4.378,1.558c0.217,0.715,0.502,1.401,0.849,2.049l-1.994,4.193c0.725,0.909,1.549,1.733,2.459,2.458l4.192-1.993c0.648,0.347,1.334,0.633,2.05,0.851l1.557,4.377c0.571,0.064,1.148,0.104,1.737,0.104c0.588,0,1.165-0.04,1.736-0.104l1.558-4.377c0.715-0.218,1.399-0.504,2.049-0.851l4.193,1.993c0.909-0.725,1.733-1.549,2.458-2.458l-1.993-4.193c0.347-0.647,0.633-1.334,0.851-2.049L31.229,17.736zM16,20.871c-2.69,0-4.872-2.182-4.872-4.871c0-2.69,2.182-4.872,4.872-4.872c2.689,0,4.871,2.182,4.871,4.872C20.871,18.689,18.689,20.871,16,20.871z"/>
        <title>Edge options.</title>
      </g>
    </g>
  `);
  }

  Markup.getEdgeToolMarkup = getEdgeToolMarkup;

  function getEdgeVertexMarkup() {
    return Markup.sanitize(`
    <g class="vertex-group" transform="translate(<%= x %>, <%= y %>)">
      <circle class="vertex" data-index="<%= index %>" r="10" />
      <path class="vertex-remove-area" data-index="<%= index %>" d="M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z" transform="translate(5, -33)"/>
      <path class="vertex-remove" data-index="<%= index %>" transform="scale(.8) translate(9.5, -37)" d="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z">
      <title>Remove vertex.</title>
      </path>
    </g>
  `);
  }

  Markup.getEdgeVertexMarkup = getEdgeVertexMarkup;

  function getEdgeArrowheadMarkup() {
    return Markup.sanitize(`
    <g class="arrowhead-group arrowhead-group-<%= end %>">
      <path class="arrowhead" data-terminal="<%= end %>" d="M 26 0 L 0 13 L 26 26 z" />
    </g>
  `);
  }

  Markup.getEdgeArrowheadMarkup = getEdgeArrowheadMarkup;
})(Markup || (Markup = {})); // eslint-disable-next-line


(function (Markup) {
  function getForeignObjectMarkup(bare = false) {
    return {
      tagName: 'foreignObject',
      selector: 'fo',
      children: [{
        ns: _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.xhtml,
        tagName: 'body',
        selector: 'foBody',
        attrs: {
          xmlns: _util__WEBPACK_IMPORTED_MODULE_1__.Dom.ns.xhtml
        },
        style: {
          width: '100%',
          height: '100%',
          background: 'transparent'
        },
        children: bare ? [] : [{
          tagName: 'div',
          selector: 'foContent',
          style: {
            width: '100%',
            height: '100%'
          }
        }]
      }]
    };
  }

  Markup.getForeignObjectMarkup = getForeignObjectMarkup;
})(Markup || (Markup = {}));

/***/ }),

/***/ 78415:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/node.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeView": () => (/* binding */ NodeView)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global */ 9789);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ 17653);
/* harmony import */ var _model_cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/cell */ 30936);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cell */ 58670);
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./markup */ 8676);







class NodeView extends _cell__WEBPACK_IMPORTED_MODULE_5__.CellView {
  constructor() {
    super(...arguments);
    this.scalableNode = null;
    this.rotatableNode = null;
    this.scalableSelector = 'scalable';
    this.rotatableSelector = 'rotatable';
    this.defaultPortMarkup = _markup__WEBPACK_IMPORTED_MODULE_6__.Markup.getPortMarkup();
    this.defaultPortLabelMarkup = _markup__WEBPACK_IMPORTED_MODULE_6__.Markup.getPortLabelMarkup();
    this.defaultPortContainerMarkup = _markup__WEBPACK_IMPORTED_MODULE_6__.Markup.getPortContainerMarkup();
    this.portsCache = {}; // #endregion
  }

  get [Symbol.toStringTag]() {
    return NodeView.toStringTag;
  }

  getContainerClassName() {
    const classList = [super.getContainerClassName(), this.prefixClassName('node')];

    if (!this.can('nodeMovable')) {
      classList.push(this.prefixClassName('node-immovable'));
    }

    return classList.join(' ');
  }

  updateClassName(e) {
    const target = e.target;

    if (target.hasAttribute('magnet')) {
      // port
      const className = this.prefixClassName('port-unconnectable');

      if (this.can('magnetConnectable')) {
        _util__WEBPACK_IMPORTED_MODULE_2__.Dom.removeClass(target, className);
      } else {
        _util__WEBPACK_IMPORTED_MODULE_2__.Dom.addClass(target, className);
      }
    } else {
      // node
      const className = this.prefixClassName('node-immovable');

      if (this.can('nodeMovable')) {
        this.removeClass(className);
      } else {
        this.addClass(className);
      }
    }
  }

  isNodeView() {
    return true;
  }

  confirmUpdate(flag, options = {}) {
    let ret = flag;

    if (this.hasAction(ret, 'ports')) {
      this.removePorts();
      this.cleanPortsCache();
    }

    if (this.hasAction(ret, 'render')) {
      this.render();
      ret = this.removeAction(ret, ['render', 'update', 'resize', 'translate', 'rotate', 'ports', 'tools']);
    } else {
      ret = this.handleAction(ret, 'resize', () => this.resize(options), 'update');
      ret = this.handleAction(ret, 'update', () => this.update(), // `update()` will render ports when useCSSSelectors are enabled
      _global__WEBPACK_IMPORTED_MODULE_1__.Config.useCSSSelector ? 'ports' : null);
      ret = this.handleAction(ret, 'translate', () => this.translate());
      ret = this.handleAction(ret, 'rotate', () => this.rotate());
      ret = this.handleAction(ret, 'ports', () => this.renderPorts());
      ret = this.handleAction(ret, 'tools', () => this.renderTools());
    }

    return ret;
  }

  update(partialAttrs) {
    this.cleanCache(); // When CSS selector strings are used, make sure no rule matches port nodes.

    if (_global__WEBPACK_IMPORTED_MODULE_1__.Config.useCSSSelector) {
      this.removePorts();
    }

    const node = this.cell;
    const size = node.getSize();
    const attrs = node.getAttrs();
    this.updateAttrs(this.container, attrs, {
      attrs: partialAttrs === attrs ? null : partialAttrs,
      rootBBox: new _geometry__WEBPACK_IMPORTED_MODULE_3__.Rectangle(0, 0, size.width, size.height),
      selectors: this.selectors,
      scalableNode: this.scalableNode,
      rotatableNode: this.rotatableNode
    });

    if (_global__WEBPACK_IMPORTED_MODULE_1__.Config.useCSSSelector) {
      this.renderPorts();
    }
  }

  renderMarkup() {
    const markup = this.cell.markup;

    if (markup) {
      if (typeof markup === 'string') {
        return this.renderStringMarkup(markup);
      }

      return this.renderJSONMarkup(markup);
    }

    throw new TypeError('Invalid node markup.');
  }

  renderJSONMarkup(markup) {
    const ret = this.parseJSONMarkup(markup, this.container);

    const one = elems => Array.isArray(elems) ? elems[0] : elems;

    this.selectors = ret.selectors;
    this.rotatableNode = one(this.selectors[this.rotatableSelector]);
    this.scalableNode = one(this.selectors[this.scalableSelector]);
    this.container.appendChild(ret.fragment);
  }

  renderStringMarkup(markup) {
    _util__WEBPACK_IMPORTED_MODULE_2__.Dom.append(this.container, _util__WEBPACK_IMPORTED_MODULE_2__.Vector.toNodes(_util__WEBPACK_IMPORTED_MODULE_2__.Vector.createVectors(markup)));
    this.rotatableNode = _util__WEBPACK_IMPORTED_MODULE_2__.Dom.findOne(this.container, `.${this.rotatableSelector}`);
    this.scalableNode = _util__WEBPACK_IMPORTED_MODULE_2__.Dom.findOne(this.container, `.${this.scalableSelector}`);
    this.selectors = {};

    if (this.rootSelector) {
      this.selectors[this.rootSelector] = this.container;
    }
  }

  render() {
    this.empty();
    this.renderMarkup();

    if (this.scalableNode) {
      // Double update is necessary for elements with the scalable group only
      // Note the `resize()` triggers the other `update`.
      this.update();
    }

    this.resize();

    if (this.rotatableNode) {
      this.rotate();
      this.translate();
    } else {
      this.updateTransform();
    }

    if (!_global__WEBPACK_IMPORTED_MODULE_1__.Config.useCSSSelector) {
      this.renderPorts();
    }

    this.renderTools();
    return this;
  }

  resize(opt = {}) {
    if (this.scalableNode) {
      return this.updateSize(opt);
    }

    if (this.cell.getAngle()) {
      this.rotate();
    }

    this.update();
  }

  translate() {
    if (this.rotatableNode) {
      return this.updateTranslation();
    }

    this.updateTransform();
  }

  rotate() {
    if (this.rotatableNode) {
      this.updateRotation(); // It's necessary to call the update for the nodes outside
      // the rotatable group referencing nodes inside the group

      this.update();
      return;
    }

    this.updateTransform();
  }

  getTranslationString() {
    const position = this.cell.getPosition();
    return `translate(${position.x},${position.y})`;
  }

  getRotationString() {
    const angle = this.cell.getAngle();

    if (angle) {
      const size = this.cell.getSize();
      return `rotate(${angle},${size.width / 2},${size.height / 2})`;
    }
  }

  updateTransform() {
    let transform = this.getTranslationString();
    const rot = this.getRotationString();

    if (rot) {
      transform += ` ${rot}`;
    }

    this.container.setAttribute('transform', transform);
  }

  updateRotation() {
    if (this.rotatableNode != null) {
      const transform = this.getRotationString();

      if (transform != null) {
        this.rotatableNode.setAttribute('transform', transform);
      } else {
        this.rotatableNode.removeAttribute('transform');
      }
    }
  }

  updateTranslation() {
    this.container.setAttribute('transform', this.getTranslationString());
  }

  updateSize(opt = {}) {
    const cell = this.cell;
    const size = cell.getSize();
    const angle = cell.getAngle();
    const scalableNode = this.scalableNode; // Getting scalable group's bbox.
    // Due to a bug in webkit's native SVG .getBBox implementation, the
    // bbox of groups with path children includes the paths' control points.
    // To work around the issue, we need to check whether there are any path
    // elements inside the scalable group.

    let recursive = false;

    if (scalableNode.getElementsByTagName('path').length > 0) {
      // If scalable has at least one descendant that is a path, we need
      // toswitch to recursive bbox calculation. Otherwise, group bbox
      // calculation works and so we can use the (faster) native function.
      recursive = true;
    }

    const scalableBBox = _util__WEBPACK_IMPORTED_MODULE_2__.Dom.getBBox(scalableNode, {
      recursive
    }); // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero
    // which can happen if the element does not have any content.

    const sx = size.width / (scalableBBox.width || 1);
    const sy = size.height / (scalableBBox.height || 1);
    scalableNode.setAttribute('transform', `scale(${sx},${sy})`); // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`
    // Order of transformations is significant but we want to reconstruct the object always in the order:
    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,
    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the
    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation
    // around the center of the resized object (which is a different origin then the origin of the previous rotation)
    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.
    // Cancel the rotation but now around a different origin, which is the center of the scaled object.

    const rotatableNode = this.rotatableNode;

    if (rotatableNode != null) {
      const transform = rotatableNode.getAttribute('transform');

      if (transform) {
        rotatableNode.setAttribute('transform', `${transform} rotate(${-angle},${size.width / 2},${size.height / 2})`);
        const rotatableBBox = _util__WEBPACK_IMPORTED_MODULE_2__.Dom.getBBox(scalableNode, {
          target: this.graph.view.stage
        }); // Store new x, y and perform rotate() again against the new rotation origin.

        cell.prop('position', {
          x: rotatableBBox.x,
          y: rotatableBBox.y
        }, Object.assign({
          updated: true
        }, opt));
        this.translate();
        this.rotate();
      }
    } // Update must always be called on non-rotated element. Otherwise,
    // relative positioning would work with wrong (rotated) bounding boxes.


    this.update();
  } // #region ports


  findPortElem(portId, selector) {
    const cache = portId ? this.portsCache[portId] : null;

    if (!cache) {
      return null;
    }

    const portRoot = cache.portContentElement;
    const portSelectors = cache.portContentSelectors || {};
    return this.findOne(selector, portRoot, portSelectors);
  }

  initializePorts() {
    this.cleanPortsCache();
  }

  refreshPorts() {
    this.removePorts();
    this.cleanPortsCache();
    this.renderPorts();
  }

  cleanPortsCache() {
    this.portsCache = {};
  }

  removePorts() {
    Object.keys(this.portsCache).forEach(portId => {
      const cached = this.portsCache[portId];
      _util__WEBPACK_IMPORTED_MODULE_2__.Dom.remove(cached.portElement);
    });
  }

  renderPorts() {
    const container = this.getPortsContainer(); // References to rendered elements without z-index

    const references = [];
    container.childNodes.forEach(child => {
      references.push(child);
    });
    const portsGropsByZ = _util__WEBPACK_IMPORTED_MODULE_2__.ArrayExt.groupBy(this.cell.getParsedPorts(), 'zIndex');
    const autoZIndexKey = 'auto'; // render non-z first

    if (portsGropsByZ[autoZIndexKey]) {
      portsGropsByZ[autoZIndexKey].forEach(port => {
        const portElement = this.getPortElement(port);
        container.append(portElement);
        references.push(portElement);
      });
    }

    Object.keys(portsGropsByZ).forEach(key => {
      if (key !== autoZIndexKey) {
        const zIndex = parseInt(key, 10);
        this.appendPorts(portsGropsByZ[key], zIndex, references);
      }
    });
    this.updatePorts();
  }

  getPortsContainer() {
    return this.rotatableNode || this.container;
  }

  appendPorts(ports, zIndex, refs) {
    const elems = ports.map(p => this.getPortElement(p));

    if (refs[zIndex] || zIndex < 0) {
      _util__WEBPACK_IMPORTED_MODULE_2__.Dom.before(refs[Math.max(zIndex, 0)], elems);
    } else {
      _util__WEBPACK_IMPORTED_MODULE_2__.Dom.append(this.getPortsContainer(), elems);
    }
  }

  getPortElement(port) {
    const cached = this.portsCache[port.id];

    if (cached) {
      return cached.portElement;
    }

    return this.createPortElement(port);
  }

  createPortElement(port) {
    let renderResult = _markup__WEBPACK_IMPORTED_MODULE_6__.Markup.renderMarkup(this.getPortContainerMarkup());
    const portElement = renderResult.elem;

    if (portElement == null) {
      throw new Error('Invalid port container markup.');
    }

    renderResult = _markup__WEBPACK_IMPORTED_MODULE_6__.Markup.renderMarkup(this.getPortMarkup(port));
    const portContentElement = renderResult.elem;
    const portContentSelectors = renderResult.selectors;

    if (portContentElement == null) {
      throw new Error('Invalid port markup.');
    }

    this.setAttrs({
      port: port.id,
      'port-group': port.group
    }, portContentElement);
    renderResult = _markup__WEBPACK_IMPORTED_MODULE_6__.Markup.renderMarkup(this.getPortLabelMarkup(port.label));
    const portLabelElement = renderResult.elem;
    const portLabelSelectors = renderResult.selectors;

    if (portLabelElement == null) {
      throw new Error('Invalid port label markup.');
    }

    let portSelectors;

    if (portContentSelectors && portLabelSelectors) {
      // eslint-disable-next-line
      for (const key in portLabelSelectors) {
        if (portContentSelectors[key] && key !== this.rootSelector) {
          throw new Error('Selectors within port must be unique.');
        }
      }

      portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);
    } else {
      portSelectors = portContentSelectors || portLabelSelectors;
    }

    let portClass = 'x6-port';

    if (port.group) {
      portClass += ` x6-port-${port.group}`;
    }

    _util__WEBPACK_IMPORTED_MODULE_2__.Dom.addClass(portElement, portClass);
    _util__WEBPACK_IMPORTED_MODULE_2__.Dom.addClass(portContentElement, 'x6-port-body');
    _util__WEBPACK_IMPORTED_MODULE_2__.Dom.addClass(portLabelElement, 'x6-port-label');
    portElement.appendChild(portContentElement);
    portElement.appendChild(portLabelElement);
    this.portsCache[port.id] = {
      portElement,
      portSelectors,
      portLabelElement,
      portLabelSelectors,
      portContentElement,
      portContentSelectors
    };
    this.graph.hook.onPortRendered({
      port,
      node: this.cell,
      container: portElement,
      selectors: portSelectors,
      labelContainer: portLabelElement,
      labelSelectors: portLabelSelectors,
      contentContainer: portContentElement,
      contentSelectors: portContentSelectors
    });
    return portElement;
  }

  updatePorts() {
    // Layout ports without group
    this.updatePortGroup(); // Layout ports with explicit group

    const groups = this.cell.getParsedGroups();
    Object.keys(groups).forEach(groupName => this.updatePortGroup(groupName));
  }

  updatePortGroup(groupName) {
    const bbox = _geometry__WEBPACK_IMPORTED_MODULE_3__.Rectangle.fromSize(this.cell.getSize());
    const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);

    for (let i = 0, n = metrics.length; i < n; i += 1) {
      const metric = metrics[i];
      const portId = metric.portId;
      const cached = this.portsCache[portId] || {};
      const portLayout = metric.portLayout;
      this.applyPortTransform(cached.portElement, portLayout);

      if (metric.portAttrs != null) {
        const options = {
          selectors: cached.portSelectors || {}
        };

        if (metric.portSize) {
          options.rootBBox = _geometry__WEBPACK_IMPORTED_MODULE_3__.Rectangle.fromSize(metric.portSize);
        }

        this.updateAttrs(cached.portElement, metric.portAttrs, options);
      }

      const labelLayout = metric.labelLayout;

      if (labelLayout) {
        this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));

        if (labelLayout.attrs) {
          const options = {
            selectors: cached.portLabelSelectors || {}
          };

          if (metric.labelSize) {
            options.rootBBox = _geometry__WEBPACK_IMPORTED_MODULE_3__.Rectangle.fromSize(metric.labelSize);
          }

          this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);
        }
      }
    }
  }

  applyPortTransform(element, layout, initialAngle = 0) {
    const angle = layout.angle;
    const position = layout.position;
    const matrix = _util__WEBPACK_IMPORTED_MODULE_2__.Dom.createSVGMatrix().rotate(initialAngle).translate(position.x || 0, position.y || 0).rotate(angle || 0);
    _util__WEBPACK_IMPORTED_MODULE_2__.Dom.transform(element, matrix, {
      absolute: true
    });
  }

  getPortContainerMarkup() {
    return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup;
  }

  getPortMarkup(port) {
    return port.markup || this.cell.portMarkup || this.defaultPortMarkup;
  }

  getPortLabelMarkup(label) {
    return label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup;
  }

  getEventArgs(e, x, y) {
    const view = this; // eslint-disable-line

    const node = view.cell;
    const cell = node;

    if (x == null || y == null) {
      return {
        e,
        view,
        node,
        cell
      };
    }

    return {
      e,
      x,
      y,
      view,
      node,
      cell
    };
  }

  notifyMouseDown(e, x, y) {
    super.onMouseDown(e, x, y);
    this.notify('node:mousedown', this.getEventArgs(e, x, y));
  }

  notifyMouseMove(e, x, y) {
    super.onMouseMove(e, x, y);
    this.notify('node:mousemove', this.getEventArgs(e, x, y));
  }

  notifyMouseUp(e, x, y) {
    super.onMouseUp(e, x, y);
    this.notify('node:mouseup', this.getEventArgs(e, x, y));
  }

  onClick(e, x, y) {
    super.onClick(e, x, y);
    this.notify('node:click', this.getEventArgs(e, x, y));
  }

  onDblClick(e, x, y) {
    super.onDblClick(e, x, y);
    this.notify('node:dblclick', this.getEventArgs(e, x, y));
  }

  onContextMenu(e, x, y) {
    super.onContextMenu(e, x, y);
    this.notify('node:contextmenu', this.getEventArgs(e, x, y));
  }

  onMouseDown(e, x, y) {
    if (this.isPropagationStopped(e)) {
      return;
    }

    this.notifyMouseDown(e, x, y);
    this.startNodeDragging(e, x, y);
  }

  onMouseMove(e, x, y) {
    const data = this.getEventData(e);
    const action = data.action;

    if (action === 'magnet') {
      this.dragMagnet(e, x, y);
    } else {
      if (action === 'move') {
        const meta = data;
        const view = meta.targetView || this;
        view.dragNode(e, x, y);
        view.notify('node:moving', {
          e,
          x,
          y,
          view,
          cell: view.cell,
          node: view.cell
        });
      }

      this.notifyMouseMove(e, x, y);
    }

    this.setEventData(e, data);
  }

  onMouseUp(e, x, y) {
    const data = this.getEventData(e);
    const action = data.action;

    if (action === 'magnet') {
      this.stopMagnetDragging(e, x, y);
    } else {
      this.notifyMouseUp(e, x, y);

      if (action === 'move') {
        const meta = data;
        const view = meta.targetView || this;
        view.stopNodeDragging(e, x, y);
      }
    }

    const magnet = data.targetMagnet;

    if (magnet) {
      this.onMagnetClick(e, magnet, x, y);
    }

    this.checkMouseleave(e);
  }

  onMouseOver(e) {
    super.onMouseOver(e);
    this.notify('node:mouseover', this.getEventArgs(e));
  }

  onMouseOut(e) {
    super.onMouseOut(e);
    this.notify('node:mouseout', this.getEventArgs(e));
  }

  onMouseEnter(e) {
    this.updateClassName(e);
    super.onMouseEnter(e);
    this.notify('node:mouseenter', this.getEventArgs(e));
  }

  onMouseLeave(e) {
    super.onMouseLeave(e);
    this.notify('node:mouseleave', this.getEventArgs(e));
  }

  onMouseWheel(e, x, y, delta) {
    super.onMouseWheel(e, x, y, delta);
    this.notify('node:mousewheel', Object.assign({
      delta
    }, this.getEventArgs(e, x, y)));
  }

  onMagnetClick(e, magnet, x, y) {
    const count = this.graph.view.getMouseMovedCount(e);

    if (count > this.graph.options.clickThreshold) {
      return;
    }

    this.notify('node:magnet:click', Object.assign({
      magnet
    }, this.getEventArgs(e, x, y)));
  }

  onMagnetDblClick(e, magnet, x, y) {
    this.notify('node:magnet:dblclick', Object.assign({
      magnet
    }, this.getEventArgs(e, x, y)));
  }

  onMagnetContextMenu(e, magnet, x, y) {
    this.notify('node:magnet:contextmenu', Object.assign({
      magnet
    }, this.getEventArgs(e, x, y)));
  }

  onMagnetMouseDown(e, magnet, x, y) {
    this.startMagnetDragging(e, x, y);
  }

  onCustomEvent(e, name, x, y) {
    this.notify('node:customevent', Object.assign({
      name
    }, this.getEventArgs(e, x, y)));
    super.onCustomEvent(e, name, x, y);
  }

  prepareEmbedding(e) {
    // const cell = data.cell || this.cell
    // const graph = data.graph || this.graph
    // const model = graph.model
    // model.startBatch('to-front')
    // // Bring the model to the front with all his embeds.
    // cell.toFront({ deep: true, ui: true })
    // const maxZ = model
    //   .getNodes()
    //   .reduce((max, cell) => Math.max(max, cell.getZIndex() || 0), 0)
    // const connectedEdges = model.getConnectedEdges(cell, {
    //   deep: true,
    //   enclosed: true,
    // })
    // connectedEdges.forEach((edge) => {
    //   const zIndex = edge.getZIndex() || 0
    //   if (zIndex <= maxZ) {
    //     edge.setZIndex(maxZ + 1, { ui: true })
    //   }
    // })
    // model.stopBatch('to-front')
    // Before we start looking for suitable parent we remove the current one.
    // const parent = cell.getParent()
    // if (parent) {
    //   parent.unembed(cell, { ui: true })
    // }
    const data = this.getEventData(e);
    const node = data.cell || this.cell;
    const view = this.graph.findViewByCell(node);
    const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
    this.notify('node:embed', {
      e,
      node,
      view,
      cell: node,
      x: localPoint.x,
      y: localPoint.y,
      currentParent: node.getParent()
    });
  }

  processEmbedding(e, data) {
    const cell = data.cell || this.cell;
    const graph = data.graph || this.graph;
    const options = graph.options.embedding;
    const findParent = options.findParent;
    let candidates = typeof findParent === 'function' ? _util__WEBPACK_IMPORTED_MODULE_2__.FunctionExt.call(findParent, graph, {
      view: this,
      node: this.cell
    }).filter(c => {
      return _model_cell__WEBPACK_IMPORTED_MODULE_4__.Cell.isCell(c) && this.cell.id !== c.id && !c.isDescendantOf(this.cell);
    }) : graph.model.getNodesUnderNode(cell, {
      by: findParent
    }); // Picks the node with the highest `z` index

    if (options.frontOnly) {
      if (candidates.length > 0) {
        const zIndexMap = _util__WEBPACK_IMPORTED_MODULE_2__.ArrayExt.groupBy(candidates, 'zIndex');
        const maxZIndex = _util__WEBPACK_IMPORTED_MODULE_2__.ArrayExt.max(Object.keys(zIndexMap));

        if (maxZIndex) {
          candidates = zIndexMap[maxZIndex];
        }
      }
    } // Filter the nodes which is invisiable


    candidates = candidates.filter(candidate => candidate.visible);
    let newCandidateView = null;
    const prevCandidateView = data.candidateEmbedView;
    const validateEmbeding = options.validate;

    for (let i = candidates.length - 1; i >= 0; i -= 1) {
      const candidate = candidates[i];

      if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {
        // candidate remains the same
        newCandidateView = prevCandidateView;
        break;
      } else {
        const view = candidate.findView(graph);

        if (_util__WEBPACK_IMPORTED_MODULE_2__.FunctionExt.call(validateEmbeding, graph, {
          child: this.cell,
          parent: view.cell,
          childView: this,
          parentView: view
        })) {
          // flip to the new candidate
          newCandidateView = view;
          break;
        }
      }
    }

    this.clearEmbedding(data);

    if (newCandidateView) {
      newCandidateView.highlight(null, {
        type: 'embedding'
      });
    }

    data.candidateEmbedView = newCandidateView;
    const localPoint = graph.snapToGrid(e.clientX, e.clientY);
    this.notify('node:embedding', {
      e,
      cell,
      node: cell,
      view: graph.findViewByCell(cell),
      x: localPoint.x,
      y: localPoint.y,
      currentParent: cell.getParent(),
      candidateParent: newCandidateView ? newCandidateView.cell : null
    });
  }

  clearEmbedding(data) {
    const candidateView = data.candidateEmbedView;

    if (candidateView) {
      candidateView.unhighlight(null, {
        type: 'embedding'
      });
      data.candidateEmbedView = null;
    }
  }

  finalizeEmbedding(e, data) {
    const cell = data.cell || this.cell;
    const graph = data.graph || this.graph;
    const view = graph.findViewByCell(cell);
    const parent = cell.getParent();
    const candidateView = data.candidateEmbedView;

    if (candidateView) {
      // Candidate view is chosen to become the parent of the node.
      candidateView.unhighlight(null, {
        type: 'embedding'
      });
      data.candidateEmbedView = null;

      if (parent == null || parent.id !== candidateView.cell.id) {
        candidateView.cell.insertChild(cell, undefined, {
          ui: true
        });
      }
    } else if (parent) {
      parent.unembed(cell, {
        ui: true
      });
    }

    graph.model.getConnectedEdges(cell, {
      deep: true
    }).forEach(edge => {
      edge.updateParent({
        ui: true
      });
    });

    if (view && candidateView) {
      const localPoint = graph.snapToGrid(e.clientX, e.clientY);
      view.notify('node:embedded', {
        e,
        cell,
        x: localPoint.x,
        y: localPoint.y,
        node: cell,
        view: graph.findViewByCell(cell),
        previousParent: parent,
        currentParent: cell.getParent()
      });
    }
  }

  getDelegatedView() {
    let cell = this.cell;
    let view = this; // eslint-disable-line

    while (view) {
      if (cell.isEdge()) {
        break;
      }

      if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {
        return view;
      }

      cell = cell.getParent();
      view = this.graph.renderer.findViewByCell(cell);
    }

    return null;
  }

  startMagnetDragging(e, x, y) {
    if (!this.can('magnetConnectable')) {
      return;
    }

    e.stopPropagation();
    const magnet = e.currentTarget;
    const graph = this.graph;
    this.setEventData(e, {
      targetMagnet: magnet
    });

    if (graph.hook.validateMagnet(this, magnet, e)) {
      if (graph.options.magnetThreshold <= 0) {
        this.startConnectting(e, magnet, x, y);
      }

      this.setEventData(e, {
        action: 'magnet'
      });
      this.stopPropagation(e);
    } else {
      // 只需要阻止port的冒泡 #2258
      if (_util__WEBPACK_IMPORTED_MODULE_2__.Dom.hasClass(magnet, 'x6-port-body') || jquery__WEBPACK_IMPORTED_MODULE_0___default()(magnet).closest('.x6-port-body').length > 0) {
        this.stopPropagation(e);
      }

      this.onMouseDown(e, x, y);
    }

    graph.view.delegateDragEvents(e, this);
  }

  startConnectting(e, magnet, x, y) {
    this.graph.model.startBatch('add-edge');
    const edgeView = this.createEdgeFromMagnet(magnet, x, y);
    edgeView.notifyMouseDown(e, x, y); // backwards compatibility events

    edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {
      x,
      y,
      isNewEdge: true,
      fallbackAction: 'remove'
    }));
    this.setEventData(e, {
      edgeView
    });
  }

  createEdgeFromMagnet(magnet, x, y) {
    const graph = this.graph;
    const model = graph.model;
    const edge = graph.hook.getDefaultEdge(this, magnet);
    edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));
    edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {
      x,
      y
    }));
    edge.addTo(model, {
      async: false,
      ui: true
    });
    return edge.findView(graph);
  }

  dragMagnet(e, x, y) {
    const data = this.getEventData(e);
    const edgeView = data.edgeView;

    if (edgeView) {
      edgeView.onMouseMove(e, x, y);
      this.autoScrollGraph(e.clientX, e.clientY);
    } else {
      const graph = this.graph;
      const magnetThreshold = graph.options.magnetThreshold;
      const currentTarget = this.getEventTarget(e);
      const targetMagnet = data.targetMagnet; // magnetThreshold when the pointer leaves the magnet

      if (magnetThreshold === 'onleave') {
        if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {
          return;
        } // eslint-disable-next-line no-lonely-if

      } else {
        // magnetThreshold defined as a number of movements
        if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {
          return;
        }
      }

      this.startConnectting(e, targetMagnet, x, y);
    }
  }

  stopMagnetDragging(e, x, y) {
    const data = this.eventData(e);
    const edgeView = data.edgeView;

    if (edgeView) {
      edgeView.onMouseUp(e, x, y);
      this.graph.model.stopBatch('add-edge');
    }
  }

  notifyUnhandledMouseDown(e, x, y) {
    this.notify('node:unhandled:mousedown', {
      e,
      x,
      y,
      view: this,
      cell: this.cell,
      node: this.cell
    });
  }

  notifyNodeMove(name, e, x, y, cell) {
    let cells = [cell];
    const selection = this.graph.selection.widget;

    if (selection && selection.options.movable) {
      const selectedCells = this.graph.getSelectedCells();

      if (selectedCells.includes(cell)) {
        cells = selectedCells.filter(c => c.isNode());
      }
    }

    cells.forEach(c => {
      this.notify(name, {
        e,
        x,
        y,
        cell: c,
        node: c,
        view: c.findView(this.graph)
      });
    });
  }

  startNodeDragging(e, x, y) {
    const targetView = this.getDelegatedView();

    if (targetView == null || !targetView.can('nodeMovable')) {
      return this.notifyUnhandledMouseDown(e, x, y);
    }

    this.setEventData(e, {
      targetView,
      action: 'move'
    });
    const position = _geometry__WEBPACK_IMPORTED_MODULE_3__.Point.create(targetView.cell.getPosition());
    targetView.setEventData(e, {
      moving: false,
      offset: position.diff(x, y),
      restrict: this.graph.hook.getRestrictArea(targetView)
    });
  }

  dragNode(e, x, y) {
    const node = this.cell;
    const graph = this.graph;
    const gridSize = graph.getGridSize();
    const data = this.getEventData(e);
    const offset = data.offset;
    const restrict = data.restrict;

    if (!data.moving) {
      data.moving = true;
      this.addClass('node-moving');
      this.notifyNodeMove('node:move', e, x, y, this.cell);
    }

    this.autoScrollGraph(e.clientX, e.clientY);
    const posX = _global__WEBPACK_IMPORTED_MODULE_1__.Util.snapToGrid(x + offset.x, gridSize);
    const posY = _global__WEBPACK_IMPORTED_MODULE_1__.Util.snapToGrid(y + offset.y, gridSize);
    node.setPosition(posX, posY, {
      restrict,
      deep: true,
      ui: true
    });

    if (graph.options.embedding.enabled) {
      if (!data.embedding) {
        this.prepareEmbedding(e);
        data.embedding = true;
      }

      this.processEmbedding(e, data);
    }
  }

  stopNodeDragging(e, x, y) {
    const data = this.getEventData(e);

    if (data.embedding) {
      this.finalizeEmbedding(e, data);
    }

    if (data.moving) {
      this.removeClass('node-moving');
      this.notifyNodeMove('node:moved', e, x, y, this.cell);
    }

    data.moving = false;
    data.embedding = false;
  }

  autoScrollGraph(x, y) {
    const scroller = this.graph.scroller.widget;

    if (scroller) {
      scroller.autoScroll(x, y);
    }
  }

}

(function (NodeView) {
  NodeView.toStringTag = `X6.${NodeView.name}`;

  function isNodeView(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof NodeView) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const view = instance;

    if ((tag == null || tag === NodeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.findPortElem === 'function' && typeof view.resize === 'function' && typeof view.rotate === 'function' && typeof view.translate === 'function') {
      return true;
    }

    return false;
  }

  NodeView.isNodeView = isNodeView;
})(NodeView || (NodeView = {}));

NodeView.config({
  isSvgElement: true,
  priority: 0,
  bootstrap: ['render'],
  actions: {
    view: ['render'],
    markup: ['render'],
    attrs: ['update'],
    size: ['resize', 'ports', 'tools'],
    angle: ['rotate', 'tools'],
    position: ['translate', 'tools'],
    ports: ['ports'],
    tools: ['tools']
  }
});
NodeView.registry.register('node', NodeView, true);

/***/ }),

/***/ 92654:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/tool.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolsView": () => (/* binding */ ToolsView)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _registry_tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry/tool */ 59912);
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view */ 58458);
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cell */ 58670);
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./markup */ 8676);





class ToolsView extends _view__WEBPACK_IMPORTED_MODULE_2__.View {
  constructor(options = {}) {
    super();
    this.svgContainer = this.createContainer(true, options);
    this.htmlContainer = this.createContainer(false, options);
    this.config(options);
  }

  get name() {
    return this.options.name;
  }

  get graph() {
    return this.cellView.graph;
  }

  get cell() {
    return this.cellView.cell;
  }

  get [Symbol.toStringTag]() {
    return ToolsView.toStringTag;
  }

  createContainer(svg, options) {
    const container = svg ? _view__WEBPACK_IMPORTED_MODULE_2__.View.createElement('g', true) : _view__WEBPACK_IMPORTED_MODULE_2__.View.createElement('div', false);
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(container, this.prefixClassName('cell-tools'));

    if (options.className) {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(container, options.className);
    }

    return container;
  }

  config(options) {
    this.options = Object.assign(Object.assign({}, this.options), options);

    if (!_cell__WEBPACK_IMPORTED_MODULE_3__.CellView.isCellView(options.view) || options.view === this.cellView) {
      return this;
    }

    this.cellView = options.view;

    if (this.cell.isEdge()) {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.svgContainer, this.prefixClassName('edge-tools'));
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.htmlContainer, this.prefixClassName('edge-tools'));
    } else if (this.cell.isNode()) {
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.svgContainer, this.prefixClassName('node-tools'));
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.htmlContainer, this.prefixClassName('node-tools'));
    }

    this.svgContainer.setAttribute('data-cell-id', this.cell.id);
    this.htmlContainer.setAttribute('data-cell-id', this.cell.id);

    if (this.name) {
      this.svgContainer.setAttribute('data-tools-name', this.name);
      this.htmlContainer.setAttribute('data-tools-name', this.name);
    }

    const tools = this.options.items;

    if (!Array.isArray(tools)) {
      return this;
    }

    this.tools = [];
    const normalizedTools = [];
    tools.forEach(meta => {
      if (ToolsView.ToolItem.isToolItem(meta)) {
        if (meta.name === 'vertices') {
          normalizedTools.unshift(meta);
        } else {
          normalizedTools.push(meta);
        }
      } else {
        const name = typeof meta === 'object' ? meta.name : meta;

        if (name === 'vertices') {
          normalizedTools.unshift(meta);
        } else {
          normalizedTools.push(meta);
        }
      }
    });

    for (let i = 0; i < normalizedTools.length; i += 1) {
      const meta = normalizedTools[i];
      let tool;

      if (ToolsView.ToolItem.isToolItem(meta)) {
        tool = meta;
      } else {
        const name = typeof meta === 'object' ? meta.name : meta;
        const args = typeof meta === 'object' ? meta.args || {} : {};

        if (name) {
          if (this.cell.isNode()) {
            const ctor = _registry_tool__WEBPACK_IMPORTED_MODULE_1__.NodeTool.registry.get(name);

            if (ctor) {
              tool = new ctor(args); // eslint-disable-line
            } else {
              return _registry_tool__WEBPACK_IMPORTED_MODULE_1__.NodeTool.registry.onNotFound(name);
            }
          } else if (this.cell.isEdge()) {
            const ctor = _registry_tool__WEBPACK_IMPORTED_MODULE_1__.EdgeTool.registry.get(name);

            if (ctor) {
              tool = new ctor(args); // eslint-disable-line
            } else {
              return _registry_tool__WEBPACK_IMPORTED_MODULE_1__.EdgeTool.registry.onNotFound(name);
            }
          }
        }
      }

      if (tool) {
        tool.config(this.cellView, this);
        tool.render();
        const container = tool.options.isSVGElement !== false ? this.svgContainer : this.htmlContainer;
        container.appendChild(tool.container);
        this.tools.push(tool);
      }
    }

    return this;
  }

  update(options = {}) {
    const tools = this.tools;

    if (tools) {
      tools.forEach(tool => {
        if (options.toolId !== tool.cid && tool.isVisible()) {
          tool.update();
        }
      });
    }

    return this;
  }

  focus(focusedTool) {
    const tools = this.tools;

    if (tools) {
      tools.forEach(tool => {
        if (focusedTool === tool) {
          tool.show();
        } else {
          tool.hide();
        }
      });
    }

    return this;
  }

  blur(blurredTool) {
    const tools = this.tools;

    if (tools) {
      tools.forEach(tool => {
        if (tool !== blurredTool && !tool.isVisible()) {
          tool.show();
          tool.update();
        }
      });
    }

    return this;
  }

  hide() {
    return this.focus(null);
  }

  show() {
    return this.blur(null);
  }

  remove() {
    const tools = this.tools;

    if (tools) {
      tools.forEach(tool => tool.remove());
      this.tools = null;
    }

    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(this.svgContainer);
    _util__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(this.htmlContainer);
    return super.remove();
  }

  mount() {
    const tools = this.tools;
    const cellView = this.cellView;

    if (cellView && tools) {
      const hasSVG = tools.some(tool => tool.options.isSVGElement !== false);
      const hasHTML = tools.some(tool => tool.options.isSVGElement === false);

      if (hasSVG) {
        const parent = this.options.local ? cellView.container : cellView.graph.view.decorator;
        parent.appendChild(this.svgContainer);
      }

      if (hasHTML) {
        this.graph.container.appendChild(this.htmlContainer);
      }
    }

    return this;
  }

}

(function (ToolsView) {
  ToolsView.toStringTag = `X6.${ToolsView.name}`;

  function isToolsView(instance) {
    if (instance == null) {
      return false;
    }

    if (instance instanceof ToolsView) {
      return true;
    }

    const tag = instance[Symbol.toStringTag];
    const view = instance;

    if ((tag == null || tag === ToolsView.toStringTag) && view.graph != null && view.cell != null && typeof view.config === 'function' && typeof view.update === 'function' && typeof view.focus === 'function' && typeof view.blur === 'function' && typeof view.show === 'function' && typeof view.hide === 'function') {
      return true;
    }

    return false;
  }

  ToolsView.isToolsView = isToolsView;
})(ToolsView || (ToolsView = {}));

(function (ToolsView) {
  class ToolItem extends _view__WEBPACK_IMPORTED_MODULE_2__.View {
    constructor(options = {}) {
      super();
      this.visible = true;
      this.options = this.getOptions(options);
      this.container = _view__WEBPACK_IMPORTED_MODULE_2__.View.createElement(this.options.tagName || 'g', this.options.isSVGElement !== false);
      _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('cell-tool'));

      if (typeof this.options.className === 'string') {
        _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.options.className);
      }

      this.init();
    }

    static getDefaults() {
      return this.defaults;
    }

    static config(options) {
      this.defaults = this.getOptions(options);
    }

    static getOptions(options) {
      return _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(_util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.getDefaults()), options);
    }

    get graph() {
      return this.cellView.graph;
    }

    get cell() {
      return this.cellView.cell;
    }

    get name() {
      return this.options.name;
    }

    get [Symbol.toStringTag]() {
      return ToolItem.toStringTag;
    }

    init() {}

    getOptions(options) {
      const ctor = this.constructor;
      return ctor.getOptions(options);
    }

    delegateEvents() {
      if (this.options.events) {
        super.delegateEvents(this.options.events);
      }

      return this;
    }

    config(view, toolsView) {
      this.cellView = view;
      this.parent = toolsView;
      this.stamp(this.container);

      if (this.cell.isEdge()) {
        _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('edge-tool'));
      } else if (this.cell.isNode()) {
        _util__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('node-tool'));
      }

      if (this.name) {
        this.container.setAttribute('data-tool-name', this.name);
      }

      this.delegateEvents();
      return this;
    }

    render() {
      this.empty();
      const markup = this.options.markup;

      if (markup) {
        const meta = _markup__WEBPACK_IMPORTED_MODULE_4__.Markup.isStringMarkup(markup) ? _markup__WEBPACK_IMPORTED_MODULE_4__.Markup.parseStringMarkup(markup) : _markup__WEBPACK_IMPORTED_MODULE_4__.Markup.parseJSONMarkup(markup);
        this.container.appendChild(meta.fragment);
        this.childNodes = meta.selectors;
      }

      this.onRender();
      return this;
    }

    onRender() {}

    update() {
      return this;
    }

    stamp(elem = this.container) {
      if (elem) {
        elem.setAttribute('data-cell-id', this.cellView.cell.id);
      }
    }

    show() {
      this.container.style.display = '';
      this.visible = true;
      return this;
    }

    hide() {
      this.container.style.display = 'none';
      this.visible = false;
      return this;
    }

    isVisible() {
      return !!this.visible;
    }

    focus() {
      const opacity = this.options.focusOpacity;

      if (opacity != null && Number.isFinite(opacity)) {
        this.container.style.opacity = `${opacity}`;
      }

      this.parent.focus(this);
      return this;
    }

    blur() {
      this.container.style.opacity = '';
      this.parent.blur(this);
      return this;
    }

    guard(evt) {
      if (this.graph == null || this.cellView == null) {
        return true;
      }

      return this.graph.view.guard(evt, this.cellView);
    }

  } // #region static


  ToolItem.defaults = {
    isSVGElement: true,
    tagName: 'g'
  };
  ToolsView.ToolItem = ToolItem;

  (function (ToolItem) {
    let counter = 0;

    function getClassName(name) {
      if (name) {
        return _util__WEBPACK_IMPORTED_MODULE_0__.StringExt.pascalCase(name);
      }

      counter += 1;
      return `CustomTool${counter}`;
    }

    function define(options) {
      const tool = _util__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.createClass(getClassName(options.name), this);
      tool.config(options);
      return tool;
    }

    ToolItem.define = define;
  })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));

  (function (ToolItem) {
    ToolItem.toStringTag = `X6.${ToolItem.name}`;

    function isToolItem(instance) {
      if (instance == null) {
        return false;
      }

      if (instance instanceof ToolItem) {
        return true;
      }

      const tag = instance[Symbol.toStringTag];
      const view = instance;

      if ((tag == null || tag === ToolItem.toStringTag) && view.graph != null && view.cell != null && typeof view.config === 'function' && typeof view.update === 'function' && typeof view.focus === 'function' && typeof view.blur === 'function' && typeof view.show === 'function' && typeof view.hide === 'function' && typeof view.isVisible === 'function') {
        return true;
      }

      return false;
    }

    ToolItem.isToolItem = isToolItem;
  })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));
})(ToolsView || (ToolsView = {}));

/***/ }),

/***/ 58458:
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/view.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "View": () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ 85139);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ 44650);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common */ 57566);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global */ 9789);




class View extends _common__WEBPACK_IMPORTED_MODULE_2__.Basecoat {
  constructor() {
    super();
    this.cid = Private.uniqueId();
    View.views[this.cid] = this;
  }

  get priority() {
    return 2;
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  confirmUpdate(flag, options) {
    return 0;
  }

  $(elem) {
    return View.$(elem);
  }

  empty(elem = this.container) {
    this.$(elem).empty();
    return this;
  }

  unmount(elem = this.container) {
    this.$(elem).remove();
    return this;
  }

  remove(elem = this.container) {
    if (elem === this.container) {
      this.removeEventListeners(document);
      this.onRemove();
      delete View.views[this.cid];
    }

    this.unmount(elem);
    return this;
  }

  onRemove() {}

  setClass(className, elem = this.container) {
    elem.classList.value = Array.isArray(className) ? className.join(' ') : className;
  }

  addClass(className, elem = this.container) {
    this.$(elem).addClass(Array.isArray(className) ? className.join(' ') : className);
    return this;
  }

  removeClass(className, elem = this.container) {
    this.$(elem).removeClass(Array.isArray(className) ? className.join(' ') : className);
    return this;
  }

  setStyle(style, elem = this.container) {
    this.$(elem).css(style);
    return this;
  }

  setAttrs(attrs, elem = this.container) {
    if (attrs != null && elem != null) {
      if (elem instanceof SVGElement) {
        _util__WEBPACK_IMPORTED_MODULE_1__.Dom.attr(elem, attrs);
      } else {
        this.$(elem).attr(attrs);
      }
    }

    return this;
  }
  /**
   * Returns the value of the specified attribute of `node`.
   *
   * If the node does not set a value for attribute, start recursing up
   * the DOM tree from node to lookup for attribute at the ancestors of
   * node. If the recursion reaches CellView's root node and attribute
   * is not found even there, return `null`.
   */


  findAttr(attrName, elem = this.container) {
    let current = elem;

    while (current && current.nodeType === 1) {
      const value = current.getAttribute(attrName);

      if (value != null) {
        return value;
      }

      if (current === this.container) {
        return null;
      }

      current = current.parentNode;
    }

    return null;
  }

  find(selector, rootElem = this.container, selectors = this.selectors) {
    return View.find(selector, rootElem, selectors).elems;
  }

  findOne(selector, rootElem = this.container, selectors = this.selectors) {
    const nodes = this.find(selector, rootElem, selectors);
    return nodes.length > 0 ? nodes[0] : null;
  }

  findByAttr(attrName, elem = this.container) {
    let node = elem;

    while (node && node.getAttribute) {
      const val = node.getAttribute(attrName);

      if ((val != null || node === this.container) && val !== 'false') {
        return node;
      }

      node = node.parentNode;
    } // If the overall cell has set `magnet === false`, then returns
    // `null` to announce there is no magnet found for this cell.
    // This is especially useful to set on cells that have 'ports'.
    // In this case, only the ports have set `magnet === true` and the
    // overall element has `magnet === false`.


    return null;
  }

  getSelector(elem, prevSelector) {
    let selector;

    if (elem === this.container) {
      if (typeof prevSelector === 'string') {
        selector = `> ${prevSelector}`;
      }

      return selector;
    }

    if (elem) {
      const nth = _util__WEBPACK_IMPORTED_MODULE_1__.Dom.index(elem) + 1;
      selector = `${elem.tagName.toLowerCase()}:nth-child(${nth})`;

      if (prevSelector) {
        selector += ` > ${prevSelector}`;
      }

      selector = this.getSelector(elem.parentNode, selector);
    }

    return selector;
  }

  prefixClassName(className) {
    return _global__WEBPACK_IMPORTED_MODULE_3__.Util.prefix(className);
  }

  delegateEvents(events, append) {
    if (events == null) {
      return this;
    }

    if (!append) {
      this.undelegateEvents();
    }

    const splitter = /^(\S+)\s*(.*)$/;
    Object.keys(events).forEach(key => {
      const match = key.match(splitter);

      if (match == null) {
        return;
      }

      const method = this.getEventHandler(events[key]);

      if (typeof method === 'function') {
        this.delegateEvent(match[1], match[2], method);
      }
    });
    return this;
  }

  undelegateEvents() {
    this.$(this.container).off(this.getEventNamespace());
    return this;
  }

  delegateDocumentEvents(events, data) {
    this.addEventListeners(document, events, data);
    return this;
  }

  undelegateDocumentEvents() {
    this.removeEventListeners(document);
    return this;
  }

  delegateEvent(eventName, selector, listener) {
    this.$(this.container).on(eventName + this.getEventNamespace(), selector, listener);
    return this;
  }

  undelegateEvent(eventName, selector, listener) {
    const name = eventName + this.getEventNamespace();

    if (selector == null) {
      this.$(this.container).off(name);
    } else if (typeof selector === 'string') {
      this.$(this.container).off(name, selector, listener);
    } else {
      this.$(this.container).off(name, selector);
    }

    return this;
  }

  addEventListeners(elem, events, data) {
    if (events == null) {
      return this;
    }

    const ns = this.getEventNamespace();
    const $elem = this.$(elem);
    Object.keys(events).forEach(eventName => {
      const method = this.getEventHandler(events[eventName]);

      if (typeof method === 'function') {
        $elem.on(eventName + ns, data, method);
      }
    });
    return this;
  }

  removeEventListeners(elem) {
    if (elem != null) {
      this.$(elem).off(this.getEventNamespace());
    }

    return this;
  }

  getEventNamespace() {
    return `.${_global__WEBPACK_IMPORTED_MODULE_3__.Config.prefixCls}-event-${this.cid}`;
  } // eslint-disable-next-line


  getEventHandler(handler) {
    // eslint-disable-next-line
    let method;

    if (typeof handler === 'string') {
      const fn = this[handler];

      if (typeof fn === 'function') {
        method = (...args) => fn.call(this, ...args);
      }
    } else {
      method = (...args) => handler.call(this, ...args);
    }

    return method;
  }

  getEventTarget(e, options = {}) {
    // Touchmove/Touchend event's target is not reflecting the element
    // under the coordinates as mousemove does.
    // It holds the element when a touchstart triggered.
    const {
      target,
      type,
      clientX = 0,
      clientY = 0
    } = e;

    if (options.fromPoint || type === 'touchmove' || type === 'touchend') {
      return document.elementFromPoint(clientX, clientY);
    }

    return target;
  }

  stopPropagation(e) {
    this.setEventData(e, {
      propagationStopped: true
    });
    return this;
  }

  isPropagationStopped(e) {
    return this.getEventData(e).propagationStopped === true;
  }

  getEventData(e) {
    return this.eventData(e);
  }

  setEventData(e, data) {
    return this.eventData(e, data);
  }

  eventData(e, data) {
    if (e == null) {
      throw new TypeError('Event object required');
    }

    let currentData = e.data;
    const key = `__${this.cid}__`; // get

    if (data == null) {
      if (currentData == null) {
        return {};
      }

      return currentData[key] || {};
    } // set


    if (currentData == null) {
      currentData = e.data = {};
    }

    if (currentData[key] == null) {
      currentData[key] = Object.assign({}, data);
    } else {
      currentData[key] = Object.assign(Object.assign({}, currentData[key]), data);
    }

    return currentData[key];
  }

  normalizeEvent(evt) {
    return View.normalizeEvent(evt);
  }

}

(function (View) {
  function $(elem) {
    return jquery__WEBPACK_IMPORTED_MODULE_0___default()(elem);
  }

  View.$ = $;

  function createElement(tagName, isSvgElement) {
    return isSvgElement ? _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createSvgElement(tagName || 'g') : _util__WEBPACK_IMPORTED_MODULE_1__.Dom.createElementNS(tagName || 'div');
  }

  View.createElement = createElement;

  function find(selector, rootElem, selectors) {
    if (!selector || selector === '.') {
      return {
        elems: [rootElem]
      };
    }

    if (selectors) {
      const nodes = selectors[selector];

      if (nodes) {
        return {
          elems: Array.isArray(nodes) ? nodes : [nodes]
        };
      }
    }

    if (_global__WEBPACK_IMPORTED_MODULE_3__.Config.useCSSSelector) {
      return {
        isCSSSelector: true,
        // elems: Array.prototype.slice.call(rootElem.querySelectorAll(selector)),
        elems: $(rootElem).find(selector).toArray()
      };
    }

    return {
      elems: []
    };
  }

  View.find = find;

  function normalizeEvent(evt) {
    let normalizedEvent = evt;
    const originalEvent = evt.originalEvent;
    const touchEvt = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];

    if (touchEvt) {
      // eslint-disable-next-line no-restricted-syntax
      for (const key in evt) {
        // copy all the properties from the input event that are not
        // defined on the touch event (functions included).
        if (touchEvt[key] === undefined) {
          touchEvt[key] = evt[key];
        }
      }

      normalizedEvent = touchEvt;
    } // IE: evt.target could be set to SVGElementInstance for SVGUseElement


    const target = normalizedEvent.target;

    if (target) {
      const useElement = target.correspondingUseElement;

      if (useElement) {
        normalizedEvent.target = useElement;
      }
    }

    return normalizedEvent;
  }

  View.normalizeEvent = normalizeEvent;
})(View || (View = {}));

(function (View) {
  View.views = {};

  function getView(cid) {
    return View.views[cid] || null;
  }

  View.getView = getView;
})(View || (View = {}));

var Private;

(function (Private) {
  let counter = 0;

  function uniqueId() {
    const id = `v${counter}`;
    counter += 1;
    return id;
  }

  Private.uniqueId = uniqueId;
})(Private || (Private = {}));

/***/ }),

/***/ 4361:
/*!*************************************************************!*\
  !*** ./node_modules/jquery-mousewheel/jquery.mousewheel.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */
(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 85139)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($) {
  var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
      toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
      slice = Array.prototype.slice,
      nullLowestDeltaTimeout,
      lowestDelta;

  if ($.event.fixHooks) {
    for (var i = toFix.length; i;) {
      $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
    }
  }

  var special = $.event.special.mousewheel = {
    version: '3.1.12',
    setup: function () {
      if (this.addEventListener) {
        for (var i = toBind.length; i;) {
          this.addEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = handler;
      } // Store the line height and page height for this particular element


      $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
      $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
    },
    teardown: function () {
      if (this.removeEventListener) {
        for (var i = toBind.length; i;) {
          this.removeEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = null;
      } // Clean up the data we added to the element


      $.removeData(this, 'mousewheel-line-height');
      $.removeData(this, 'mousewheel-page-height');
    },
    getLineHeight: function (elem) {
      var $elem = $(elem),
          $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();

      if (!$parent.length) {
        $parent = $('body');
      }

      return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
    },
    getPageHeight: function (elem) {
      return $(elem).height();
    },
    settings: {
      adjustOldDeltas: true,
      // see shouldAdjustOldDeltas() below
      normalizeOffset: true // calls getBoundingClientRect for each event

    }
  };
  $.fn.extend({
    mousewheel: function (fn) {
      return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
    },
    unmousewheel: function (fn) {
      return this.unbind('mousewheel', fn);
    }
  });

  function handler(event) {
    var orgEvent = event || window.event,
        args = slice.call(arguments, 1),
        delta = 0,
        deltaX = 0,
        deltaY = 0,
        absDelta = 0,
        offsetX = 0,
        offsetY = 0;
    event = $.event.fix(orgEvent);
    event.type = 'mousewheel'; // Old school scrollwheel delta

    if ('detail' in orgEvent) {
      deltaY = orgEvent.detail * -1;
    }

    if ('wheelDelta' in orgEvent) {
      deltaY = orgEvent.wheelDelta;
    }

    if ('wheelDeltaY' in orgEvent) {
      deltaY = orgEvent.wheelDeltaY;
    }

    if ('wheelDeltaX' in orgEvent) {
      deltaX = orgEvent.wheelDeltaX * -1;
    } // Firefox < 17 horizontal scrolling related to DOMMouseScroll event


    if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
      deltaX = deltaY * -1;
      deltaY = 0;
    } // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy


    delta = deltaY === 0 ? deltaX : deltaY; // New school wheel delta (wheel event)

    if ('deltaY' in orgEvent) {
      deltaY = orgEvent.deltaY * -1;
      delta = deltaY;
    }

    if ('deltaX' in orgEvent) {
      deltaX = orgEvent.deltaX;

      if (deltaY === 0) {
        delta = deltaX * -1;
      }
    } // No change actually happened, no reason to go any further


    if (deltaY === 0 && deltaX === 0) {
      return;
    } // Need to convert lines and pages to pixels if we aren't already in pixels
    // There are three delta modes:
    //   * deltaMode 0 is by pixels, nothing to do
    //   * deltaMode 1 is by lines
    //   * deltaMode 2 is by pages


    if (orgEvent.deltaMode === 1) {
      var lineHeight = $.data(this, 'mousewheel-line-height');
      delta *= lineHeight;
      deltaY *= lineHeight;
      deltaX *= lineHeight;
    } else if (orgEvent.deltaMode === 2) {
      var pageHeight = $.data(this, 'mousewheel-page-height');
      delta *= pageHeight;
      deltaY *= pageHeight;
      deltaX *= pageHeight;
    } // Store lowest absolute delta to normalize the delta values


    absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta; // Adjust older deltas if necessary

      if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
        lowestDelta /= 40;
      }
    } // Adjust older deltas if necessary


    if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
      // Divide all the things by 40!
      delta /= 40;
      deltaX /= 40;
      deltaY /= 40;
    } // Get a whole, normalized value for the deltas


    delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
    deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
    deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta); // Normalise offsetX and offsetY properties

    if (special.settings.normalizeOffset && this.getBoundingClientRect) {
      var boundingRect = this.getBoundingClientRect();
      offsetX = event.clientX - boundingRect.left;
      offsetY = event.clientY - boundingRect.top;
    } // Add information to the event object


    event.deltaX = deltaX;
    event.deltaY = deltaY;
    event.deltaFactor = lowestDelta;
    event.offsetX = offsetX;
    event.offsetY = offsetY; // Go ahead and set deltaMode to 0 since we converted to pixels
    // Although this is a little odd since we overwrite the deltaX/Y
    // properties with normalized deltas.

    event.deltaMode = 0; // Add event and delta to the front of the arguments

    args.unshift(event, delta, deltaX, deltaY); // Clearout lowestDelta after sometime to better
    // handle multiple device types that give different
    // a different lowestDelta
    // Ex: trackpad = 3 and mouse wheel = 120

    if (nullLowestDeltaTimeout) {
      clearTimeout(nullLowestDeltaTimeout);
    }

    nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
    return ($.event.dispatch || $.event.handle).apply(this, args);
  }

  function nullLowestDelta() {
    lowestDelta = null;
  }

  function shouldAdjustOldDeltas(orgEvent, absDelta) {
    // If this is an older event and the delta is divisable by 120,
    // then we are assuming that the browser is treating this as an
    // older mouse wheel event and that we should divide the deltas
    // by 40 to try and get a more usable deltaFactor.
    // Side note, this actually impacts the reported scroll distance
    // in older browsers and can cause scrolling to be slower than native.
    // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
    return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
  }
});

/***/ }),

/***/ 85139:
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
(function (global, factory) {
  "use strict";

  if ( true && typeof module.exports === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }

      return factory(w);
    };
  } else {
    factory(global);
  } // Pass this if window is not defined yet

})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";

  var arr = [];
  var getProto = Object.getPrototypeOf;
  var slice = arr.slice;
  var flat = arr.flat ? function (array) {
    return arr.flat.call(array);
  } : function (array) {
    return arr.concat.apply([], array);
  };
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};

  var isFunction = function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
    // Plus for old WebKit, typeof returns "function" for HTML collections
    // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
    return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
  };

  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };

  var document = window.document;
  var preservedScriptAttributes = {
    type: true,
    src: true,
    nonce: true,
    noModule: true
  };

  function DOMEval(code, node, doc) {
    doc = doc || document;
    var i,
        val,
        script = doc.createElement("script");
    script.text = code;

    if (node) {
      for (i in preservedScriptAttributes) {
        // Support: Firefox 64+, Edge 18+
        // Some browsers don't support the "nonce" property on scripts.
        // On the other hand, just using `getAttribute` is not enough as
        // the `nonce` attribute is reset to an empty string whenever it
        // becomes browsing-context connected.
        // See https://github.com/whatwg/html/issues/2369
        // See https://html.spec.whatwg.org/#nonce-attributes
        // The `node.getAttribute` check was added for the sake of
        // `jQuery.globalEval` so that it can fake a nonce-containing node
        // via an object.
        val = node[i] || node.getAttribute && node.getAttribute(i);

        if (val) {
          script.setAttribute(i, val);
        }
      }
    }

    doc.head.appendChild(script).parentNode.removeChild(script);
  }

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    } // Support: Android <=2.3 only (functionish RegExp)


    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module


  var version = "3.6.0",
      // Define a local copy of jQuery
  jQuery = function (selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function () {
      return slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function (num) {
      // Return all the elements in a clean array
      if (num == null) {
        return slice.call(this);
      } // Return just the one element from the set


      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function (elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function (callback) {
      return jQuery.each(this, callback);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function () {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    even: function () {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return (i + 1) % 2;
      }));
    },
    odd: function () {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return i % 2;
      }));
    },
    eq: function (i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (typeof target !== "object" && !isFunction(target)) {
      target = {};
    } // Extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          copy = options[name]; // Prevent Object.prototype pollution
          // Prevent never-ending loop

          if (name === "__proto__" || target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            src = target[name]; // Ensure proper type for the source value

            if (copyIsArray && !Array.isArray(src)) {
              clone = [];
            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
              clone = {};
            } else {
              clone = src;
            }

            copyIsArray = false; // Never move original objects, clone them

            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function (msg) {
      throw new Error(msg);
    },
    noop: function () {},
    isPlainObject: function (obj) {
      var proto, Ctor; // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects

      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

      if (!proto) {
        return true;
      } // Objects with prototype are plain iff they were constructed by a global Object function


      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function (obj) {
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    // Evaluates a script in a provided context; falls back to the global one
    // if not specified.
    globalEval: function (code, options, doc) {
      DOMEval(code, {
        nonce: options && options.nonce
      }, doc);
    },
    each: function (obj, callback) {
      var length,
          i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;

        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },
    // results is for internal usage only
    makeArray: function (arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function (first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;
      return first;
    },
    grep: function (elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function (elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArrayLike(elems)) {
        length = elems.length;

        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return flat(ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  } // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.6
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2021-02-16
   */
  function (window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
    setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function (a, b) {
      if (a === b) {
        hasDuplicate = true;
      }

      return 0;
    },
        // Instance methods
    hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        pushNative = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function (list, elem) {
      var i = 0,
          len = list.length;

      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions
    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
    // or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
    ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rdescend = new RegExp(whitespace + "|>"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
        rhtml = /HTML$/i,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
        funescape = function (escape, nonHex) {
      var high = "0x" + escape.slice(1) - 0x10000;
      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
        // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function (ch, asCodePoint) {
      if (asCodePoint) {
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        } // Control characters and (dependent upon position) numbers get escaped as code points


        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      } // Other potentially-special ASCII characters get backslash-escaped


      return "\\" + ch;
    },
        // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function () {
      setDocument();
    },
        inDisabledFieldset = addCombinator(function (elem) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    }, {
      dir: "parentNode",
      next: "legend"
    }); // Optimize for push.apply( _, NodeList )


    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
      // Detect silently failing push.apply
      // eslint-disable-next-line no-unused-expressions

      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? // Leverage slice if possible
        function (target, els) {
          pushNative.apply(target, slice.call(els));
        } : // Support: IE<9
        // Otherwise append directly
        function (target, els) {
          var j = target.length,
              i = 0; // Can't trust NodeList.length

          while (target[j++] = els[i++]) {}

          target.length = j - 1;
        }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
      results = results || []; // Return early from calls with invalid selector or context

      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      } // Try to shortcut find operations (as opposed to filters) in HTML documents


      if (!seed) {
        setDocument(context);
        context = context || document;

        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                } // Element context

              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } // Type selector

            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results; // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          } // Take advantage of querySelectorAll


          if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
          // Exclude object elements
          nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
            newSelector = selector;
            newContext = context; // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.

            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
              // supports it & if we're not changing the context.

              if (newContext !== context || !support.scope) {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                }
              } // Prefix every selector in the list


              groups = tokenize(selector);
              i = groups.length;

              while (i--) {
                groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
              }

              newSelector = groups.join(",");
            }

            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */


    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }

        return cache[key + " "] = value;
      }

      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */


    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */


    function assert(fn) {
      var el = document.createElement("fieldset");

      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        } // release memory in IE


        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */


    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */


    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

      if (diff) {
        return diff;
      } // Check if b follows a


      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */


    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ("form" in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            } // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors


            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

            /* jshint -W018 */
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }

          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        } // Remaining elements are neither :enabled nor :disabled


        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */


    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    } // Expose support vars for convenience


    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */

    isXML = Sizzle.isXML = function (elem) {
      var namespace = elem && elem.namespaceURI,
          docElem = elem && (elem.ownerDocument || elem).documentElement; // Support: IE <=8
      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
      // https://bugs.jquery.com/ticket/4833

      return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */


    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      } // Update global variables


      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
      // IE/Edge & older browsers don't support the :scope pseudo-class.
      // Support: Safari 6.0 only
      // Safari 6.0 supports :scope but it's an alias of :root there.


      support.scope = assert(function (el) {
        docElem.appendChild(el).appendChild(document.createElement("div"));
        return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
      });
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)

      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements

      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      }); // Support: IE<9

      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test

      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      }); // ID filter and find

      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };

        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        }; // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut


        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);

            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode("id");

              if (node && node.value === id) {
                return [elem];
              } // Fall back on getElementsByName


              elems = context.getElementsByName(id);
              i = 0;

              while (elem = elems[i++]) {
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                }
              }
            }

            return [];
          }
        };
      } // Tag


      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag); // Filter out possible comments

        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }

          return tmp;
        }

        return results;
      }; // Class

      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378

      rbuggyQSA = [];

      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          var input; // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359

          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          } // Support: IE8
          // Boolean attributes and "value" are not treated correctly


          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          } // Support: IE 11+, Edge 15 - 18+
          // IE 11/Edge don't find elements on a `[name='']` query in some cases.
          // Adding a temporary attribute to the document before the selection works
          // around the issue.
          // Interestingly, IE 10 & older don't seem to have the issue.


          input = document.createElement("input");
          input.setAttribute("name", "");
          el.appendChild(input);

          if (!el.querySelectorAll("[name='']").length) {
            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests


          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          } // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails


          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          } // Support: Firefox <=3.6 - 5 only
          // Old Firefox doesn't throw on a badly-escaped identifier.


          el.querySelectorAll("\\\f");
          rbuggyQSA.push("[\\r\\n\\f]");
        });
        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment

          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D"); // Support: IE8
          // Enforce case-sensitivity of name attribute

          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests


          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets


          docElem.appendChild(el).disabled = true;

          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: Opera 10 - 11 only
          // Opera 10-11 does not throw on post-comma invalid pseudos


          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
          // Gecko does not error, returns false instead

          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      /* Contains
      ---------------------------------------------------------------------- */

      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself

      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }

        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting

      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } // Sort on method existence if only one input has compareDocumentPosition


        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

        if (compare) {
          return compare;
        } // Calculate position if both inputs belong to the same document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq


        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1; // Disconnected nodes

        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
            return -1;
          } // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq


          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
            return 1;
          } // Maintain original order


          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }

        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b]; // Parentless nodes are either documents or disconnected

        if (!aup || !bup) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.

          /* eslint-disable eqeqeq */
          return a == document ? -1 : b == document ? 1 :
          /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        } // Otherwise we need full lists of their ancestors for comparison


        cur = a;

        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }

        cur = b;

        while (cur = cur.parentNode) {
          bp.unshift(cur);
        } // Walk down the tree looking for a discrepancy


        while (ap[i] === bp[i]) {
          i++;
        }

        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.

        /* eslint-disable eqeqeq */
        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
        /* eslint-enable eqeqeq */
        0;
      };
      return document;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      setDocument(elem);

      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((context.ownerDocument || context) != document) {
        setDocument(context);
      }

      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((elem.ownerDocument || elem) != document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };

    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */


    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0; // Unless we *know* we can detect duplicates, assume their presence

      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      } // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225


      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      } // Do not include comment or processing instruction nodes


      return ret;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function (match) {
          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function (match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function (match) {
          var excess,
              unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          } // Accept quoted arguments as-is


          if (match[3]) {
            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
          excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function (className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            /* eslint-disable max-len */

            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            /* eslint-enable max-len */
          };
        },
        "CHILD": function (type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, _context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;

            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;

                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  } // Reverse direction for :only-* (if we haven't yet done so)


                  start = dir = type === "only" && !start && "nextSibling";
                }

                return true;
              }

              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];

                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                } // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)

                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }

                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              } // Incorporate the offset, then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function (pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results); // Don't keep the element (issue #299)

            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }

          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;

            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);

            return false;
          };
        }),
        // Miscellaneous
        "target": function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function (elem) {
          return elem === docElem;
        },
        "focus": function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function (elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function (elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        // Contents
        "empty": function (elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }

          return true;
        },
        "parent": function (elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function (elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function (elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (_matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument > length ? length : argument;

          for (; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }

    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    } // Easy API for creating new setFilters


    function setFilters() {}

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";

      for (; i < len; i++) {
        selector += tokens[i].value;
      }

      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }

        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)

              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

        checkContext = null;
        return ret;
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function (seed, context, xml, results, outermost) {
        var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;

        if (outermost) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          outermostContext = context == document || context || outermost;
        } // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0; // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq

            if (!context && elem.ownerDocument != document) {
              setDocument(elem);
              xml = !documentIsHTML;
            }

            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.


        matchedCount += i; // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.

        if (bySet && i !== matchedCount) {
          j = 0;

          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, match
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }

        i = match.length;

        while (i--) {
          cached = matcherFromTokens(match[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

        cached.selector = selector;
      }

      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */


    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)

      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);

        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

          if (!context) {
            return results; // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        } // Fetch a seed set for right-to-left matching


        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

        while (i--) {
          token = tokens[i]; // Abort if we hit a combinator

          if (Expr.relative[type = token.type]) {
            break;
          }

          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);

              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      } // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above


      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    }; // One-time assignments
    // Sort stability


    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function

    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*

    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    }); // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    } // Support: IE<9
    // Use defaultValue in place of getAttribute("value")


    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, _name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    } // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies


    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;

        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }

    return Sizzle;
  }(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors; // Deprecated

  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;

  var dir = function (elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;

    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }

        matched.push(elem);
      }
    }

    return matched;
  };

  var siblings = function (n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }

  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    } // Single element


    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    } // Arraylike of elements (jQuery, arguments, Array)


    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    } // Filtered directly for both simple and complex selectors


    return jQuery.filter(qualifier, elements, not);
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function (selector) {
      var i,
          ret,
          len = this.length,
          self = this;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function (selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  }); // Initialize a jQuery object
  // A central reference to the root jQuery(document)

  var rootjQuery,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function (selector, context, root) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)


    root = root || rootjQuery; // Handle HTML strings

    if (typeof selector === "string") {
      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]);

          if (elem) {
            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }

          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || root).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    has: function (target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function () {
        var i = 0;

        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function (selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function (elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // Index in selector


      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      } // Locate the position of the desired element


      return indexOf.call(this, // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

    return cur;
  }

  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function (elem, _i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function (elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function (elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function (elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function (elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function (elem, _i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function (elem, _i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function (elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return siblings(elem.firstChild);
    },
    contents: function (elem) {
      if (elem.contentDocument != null && // Support: IE 11+
      // <object> elements with no `data` attribute has an object
      // `contentDocument` with a `null` prototype.
      getProto(elem.contentDocument)) {
        return elem.contentDocument;
      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.


      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }

      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value for non-forgettable lists
    memory,
        // Flag to know if list was already fired
    fired,
        // Flag to prevent firing
    locked,
        // Actual callback list
    list = [],
        // Queue of execution data for repeatable lists
    queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,
        // Fire callbacks
    fire = function () {
      // Enforce single-firing
      locked = locked || options.once; // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes

      fired = firing = true;

      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();

        while (++firingIndex < list.length) {
          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      } // Forget the data if we're done with it


      if (!options.memory) {
        memory = false;
      }

      firing = false; // Clean up if we're done firing for good

      if (locked) {
        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = []; // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function () {
        if (list) {
          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function () {
        jQuery.each(arguments, function (_, arg) {
          var index;

          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1); // Handle firing indexes

            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function (fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
      },
      // Remove all callbacks from the list
      empty: function () {
        if (list) {
          list = [];
        }

        return this;
      },
      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function () {
        locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function () {
        return !list;
      },
      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function () {
        locked = queue = [];

        if (!memory && !firing) {
          list = memory = "";
        }

        return this;
      },
      locked: function () {
        return !!locked;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function (context, args) {
        if (!locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);

          if (!firing) {
            fire();
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function () {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function () {
        return !!fired;
      }
    };

    return self;
  };

  function Identity(v) {
    return v;
  }

  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject); // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject); // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      } // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.

    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function (func) {
      var tuples = [// action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          state = "pending",
          promise = {
        state: function () {
          return state;
        },
        always: function () {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function (fn) {
          return promise.then(null, fn);
        },
        // Keep pipe for back-compat
        pipe: function
          /* fnDone, fnFail, fnProgress */
        () {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (_i, tuple) {
              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && isFunction(returned.promise)) {
                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function (onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                  args = arguments,
                  mightThrow = function () {
                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                // https://promisesaplus.com/#point-59
                // Ignore double-resolution attempts

                if (depth < maxDepth) {
                  return;
                }

                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                // https://promisesaplus.com/#point-48

                if (returned === deferred.promise()) {
                  throw new TypeError("Thenable self-resolution");
                } // Support: Promises/A+ sections 2.3.3.1, 3.5
                // https://promisesaplus.com/#point-54
                // https://promisesaplus.com/#point-75
                // Retrieve `then` only once


                then = returned && ( // Support: Promises/A+ section 2.3.4
                // https://promisesaplus.com/#point-64
                // Only check objects and functions for thenability
                typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                if (isFunction(then)) {
                  // Special processors (notify) just wait for resolution
                  if (special) {
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                  } else {
                    // ...and disregard older resolution values
                    maxDepth++;
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                  } // Handle all other returned values

                } else {
                  // Only substitute handlers pass on context
                  // and multiple values (non-spec behavior)
                  if (handler !== Identity) {
                    that = undefined;
                    args = [returned];
                  } // Process the value(s)
                  // Default process is resolve


                  (special || deferred.resolveWith)(that, args);
                }
              },
                  // Only normal processors (resolve) catch and reject exceptions
              process = special ? mightThrow : function () {
                try {
                  mightThrow();
                } catch (e) {
                  if (jQuery.Deferred.exceptionHook) {
                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                  } // Support: Promises/A+ section 2.3.3.3.4.1
                  // https://promisesaplus.com/#point-61
                  // Ignore post-resolution exceptions


                  if (depth + 1 >= maxDepth) {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Thrower) {
                      that = undefined;
                      args = [e];
                    }

                    deferred.rejectWith(that, args);
                  }
                }
              }; // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors


              if (depth) {
                process();
              } else {
                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }

                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {
            // progress_handlers.add( ... )
            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function (obj) {
          return obj != null ? jQuery.extend(obj, promise) : promise;
        }
      },
          deferred = {}; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[5]; // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add

        promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            state = stateString;
          }, // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable, // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable, // progress_callbacks.lock
          tuples[0][2].lock, // progress_handlers.lock
          tuples[0][3].lock);
        } // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire


        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }

        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        }; // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith


        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      promise.promise(deferred); // Call given func if any

      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function (singleValue) {
      var // count of uncompleted subordinates
      remaining = arguments.length,
          // count of unprocessed arguments
      i = remaining,
          // subordinate fulfillment data
      resolveContexts = Array(i),
          resolveValues = slice.call(arguments),
          // the primary Deferred
      primary = jQuery.Deferred(),
          // subordinate callback factory
      updateFunc = function (i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;

          if (! --remaining) {
            primary.resolveWith(resolveContexts, resolveValues);
          }
        };
      }; // Single- and empty arguments are adopted like Promise.resolve


      if (remaining <= 1) {
        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

        if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return primary.then();
        }
      } // Multiple arguments are aggregated like Promise.all array elements


      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), primary.reject);
      }

      return primary.promise();
    }
  }); // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.

  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  }; // The deferred used on DOM ready


  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function (fn) {
    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch(function (error) {
      jQuery.readyException(error);
    });
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function (wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  } // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon


  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed);
  } // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function


  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null; // Sets many values

    if (toType(key) === "object") {
      chainable = true;

      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function (elem, _key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    if (chainable) {
      return elems;
    } // Gets


    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  }; // Matches dashed string for camelizing


  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

  function fcamelCase(_all, letter) {
    return letter.toUpperCase();
  } // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)


  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }

  var acceptData = function (owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.prototype = {
    cache: function (owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando]; // If not, create one

      if (!value) {
        value = {}; // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.

        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function (owner, data, value) {
      var prop,
          cache = this.cache(owner); // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)

      if (typeof data === "string") {
        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }

      return cache;
    },
    get: function (owner, key) {
      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function (owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      } // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //


      this.set(owner, key, value); // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]

      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i,
          cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key); // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace

          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      } // Remove the expando if there's no more data


      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function (owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data(); //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    } // Only convert to a number if it doesn't change the string


    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name; // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute

    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {} // Make sure we set the data so it isn't changed later


        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  jQuery.extend({
    hasData: function (elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function (elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function (elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function (elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (typeof key === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }

      return access(this, function (value) {
        var data; // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.

        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);

          if (data !== undefined) {
            return data;
          } // Attempt to "discover" the data in
          // HTML5 custom data-* attrs


          data = dataAttr(elem, key);

          if (data !== undefined) {
            return data;
          } // We tried really hard, but the data doesn't exist.


          return;
        } // Set the data...


        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function () {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // Clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function (elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function (type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function (type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function () {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var documentElement = document.documentElement;

  var isAttached = function (elem) {
    return jQuery.contains(elem.ownerDocument, elem);
  },
      composed = {
    composed: true
  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  // Check attachment across shadow DOM boundaries when possible (gh-3504)
  // Support: iOS 10.0-10.2 only
  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  // leading to errors. We need to check for `getRootNode`.


  if (documentElement.getRootNode) {
    isAttached = function (elem) {
      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
  }

  var isHiddenWithinTree = function (elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem; // Inline style trumps all

    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    isAttached(elem) && jQuery.css(elem, "display") === "none";
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function () {
      return tween.cur();
    } : function () {
      return jQuery.css(elem, prop, "");
    },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2; // Trust units reported by jQuery.css

      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

      initialInUnit = +initial || 1;

      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);

        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }

        initialInUnit = initialInUnit / scale;
      }

      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

      valueParts = valueParts || [];
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }

    return adjusted;
  }

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }

    defaultDisplayMap[nodeName] = display;
    return display;
  }

  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length; // Determine new display value for elements that need to change

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      display = elem.style.display;

      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;

          if (!values[index]) {
            elem.style.display = "";
          }
        }

        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none"; // Remember what we're overwriting

          dataPriv.set(elem, "display", display);
        }
      }
    } // Set the display of the elements in a second loop to avoid constant reflow


    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;
  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

  (function () {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)

    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input); // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
    // IE <=9 replaces <option> tags with their contents when inserted outside of
    // the select element.

    div.innerHTML = "<option></option>";
    support.option = !!div.lastChild;
  })(); // We have to close these tags to support XHTML (#13200)


  var wrapMap = {
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td; // Support: IE <=9 only

  if (!support.option) {
    wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
  }

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }

    return ret;
  } // Mark scripts as having already been evaluated


  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        attached,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

          j = wrap[0];

          while (j--) {
            tmp = tmp.lastChild;
          } // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit


          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

          tmp.textContent = "";
        }
      }
    } // Remove wrapper from fragment


    fragment.textContent = "";
    i = 0;

    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      attached = isAttached(elem); // Append to fragment

      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

      if (attached) {
        setGlobalEval(tmp);
      } // Capture executables


      if (scripts) {
        j = 0;

        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  } // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).


  function expectSync(elem, type) {
    return elem === safeActiveElement() === (type === "focus");
  } // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393


  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function on(elem, types, selector, data, fn, one) {
    var origFn, type; // Types can be a map of types/handlers

    if (typeof types === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }

      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }

      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }

    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;

      fn = function (event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      }; // Use same guid so caller can remove using origFn


      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }

    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem); // Only attach events to objects that accept data

      if (!acceptData(elem)) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = Object.create(null);
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      } // Handle multiple events separated by a space


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove data and the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function (nativeEvent) {
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(nativeEvent),
          handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // If the event is namespaced, then each handler is only invoked if it is
          // specially universal or its namespaces are a superset of the event's.
          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function (event, handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target; // Find delegate handlers

      if (delegateCount && // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType && // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};

            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }

            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      cur = this;

      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    addProp: function (name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function (value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function (originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      click: {
        // Utilize native event to ensure correct state for checkable inputs
        setup: function (data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Claim the first handler

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            // dataPriv.set( el, "click", ... )
            leverageNative(el, "click", returnTrue);
          } // Return false to allow normal processing in the caller


          return false;
        },
        trigger: function (data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Force setup before triggering a click

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            leverageNative(el, "click");
          } // Return non-false to allow normal event-path propagation


          return true;
        },
        // For cross-browser consistency, suppress native .click() on links
        // Also prevent it if we're currently inside a leveraged native-event stack
        _default: function (event) {
          var target = event.target;
          return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  }; // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.

  function leverageNative(el, type, expectSync) {
    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
    if (!expectSync) {
      if (dataPriv.get(el, type) === undefined) {
        jQuery.event.add(el, type, returnTrue);
      }

      return;
    } // Register the controller as a special universal handler for all event namespaces


    dataPriv.set(el, type, false);
    jQuery.event.add(el, type, {
      namespace: false,
      handler: function (event) {
        var notAsync,
            result,
            saved = dataPriv.get(this, type);

        if (event.isTrigger & 1 && this[type]) {
          // Interrupt processing of the outer synthetic .trigger()ed event
          // Saved data should be false in such cases, but might be a leftover capture object
          // from an async native handler (gh-4350)
          if (!saved.length) {
            // Store arguments for use when handling the inner native event
            // There will always be at least one argument (an event object), so this array
            // will not be confused with a leftover capture object.
            saved = slice.call(arguments);
            dataPriv.set(this, type, saved); // Trigger the native event and capture its result
            // Support: IE <=9 - 11+
            // focus() and blur() are asynchronous

            notAsync = expectSync(this, type);
            this[type]();
            result = dataPriv.get(this, type);

            if (saved !== result || notAsync) {
              dataPriv.set(this, type, false);
            } else {
              result = {};
            }

            if (saved !== result) {
              // Cancel the outer synthetic event
              event.stopImmediatePropagation();
              event.preventDefault(); // Support: Chrome 86+
              // In Chrome, if an element having a focusout handler is blurred by
              // clicking outside of it, it invokes the handler synchronously. If
              // that handler calls `.remove()` on the element, the data is cleared,
              // leaving `result` undefined. We need to guard against this.

              return result && result.value;
            } // If this is an inner synthetic event for an event with a bubbling surrogate
            // (focus or blur), assume that the surrogate already propagated from triggering the
            // native event and prevent that from happening again here.
            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
            // bubbling surrogate propagates *after* the non-bubbling base), but that seems
            // less bad than duplication.

          } else if ((jQuery.event.special[type] || {}).delegateType) {
            event.stopPropagation();
          } // If this is a native event triggered above, everything is now in order
          // Fire an inner synthetic event with the original arguments

        } else if (saved.length) {
          // ...and capture the result
          dataPriv.set(this, type, {
            value: jQuery.event.trigger( // Support: IE <=9 - 11+
            // Extend with the prototype to reset the above stopImmediatePropagation()
            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
          }); // Abort handling of the native event

          event.stopImmediatePropagation();
        }
      }
    });
  }

  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)

      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Includes all common event props including KeyEvent and MouseEvent specific props

  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: true
  }, jQuery.event.addProp);
  jQuery.each({
    focus: "focusin",
    blur: "focusout"
  }, function (type, delegateType) {
    jQuery.event.special[type] = {
      // Utilize native event if possible so blur/focus sequence is correct
      setup: function () {
        // Claim the first handler
        // dataPriv.set( this, "focus", ... )
        // dataPriv.set( this, "blur", ... )
        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

        return false;
      },
      trigger: function () {
        // Force setup before trigger
        leverageNative(this, type); // Return non-false to allow normal event-path propagation

        return true;
      },
      // Suppress native focus or blur as it's already being fired
      // in leverageNative.
      _default: function () {
        return true;
      },
      delegateType: delegateType
    };
  }); // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function (types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function (types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (typeof types === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }

    return elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    } // 1. Copy private data: events, handlers, etc.


    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.get(src);
      events = pdataOld.events;

      if (events) {
        dataPriv.remove(dest, "handle events");

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    } // 2. Copy user data


    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  } // Fix IE bugs, see support tests


  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = flat(args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);

        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }

        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      } // Require either new content or an interest in ignored elements to invoke the callback


      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length; // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).

        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];

            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl && !node.noModule) {
                  jQuery._evalUrl(node.src, {
                    nonce: node.nonce || node.getAttribute("nonce")
                  }, doc);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && isAttached(node)) {
          setGlobalEval(getAll(node, "script"));
        }

        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function (html) {
      return html;
    },
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = isAttached(elem); // Fix IE cloning issues

      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      } // Return the cloned set


      return clone;
    },
    cleanData: function (elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove


            elem[dataPriv.expando] = undefined;
          }

          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function (selector) {
      return remove(this, selector, true);
    },
    remove: function (selector) {
      return remove(this, selector);
    },
    text: function (value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function () {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function () {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

          elem.textContent = "";
        }
      }

      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);

          try {
            for (; i < l; i++) {
              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;

        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));

          if (parent) {
            parent.replaceChild(elem, this);
          }
        } // Force callback invocation

      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var getStyles = function (elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };

  var swap = function (elem, options, callback) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.call(elem); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  var rboxStyle = new RegExp(cssExpand.join("|"), "i");

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't

      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements

      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)
      // Support: Chrome <=64
      // Don't get tricked when zoom affects offsetWidth (gh-4029)

      div.style.position = "absolute";
      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed

      div = null;
    }

    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }

    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableTrDimensionsVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div"); // Finish early in limited (non-browser) environments

    if (!div.style) {
      return;
    } // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)


    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function () {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function () {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function () {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function () {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function () {
        computeStyleTests();
        return scrollboxSizeVal;
      },
      // Support: IE 9 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Behavior in IE 9 is more subtle than in newer versions & it passes
      // some versions of this test; make sure not to make it pass there!
      //
      // Support: Firefox 70+
      // Only Firefox includes border widths
      // in computed dimensions. (gh-4529)
      reliableTrDimensions: function () {
        var table, tr, trChild, trStyle;

        if (reliableTrDimensionsVal == null) {
          table = document.createElement("table");
          tr = document.createElement("tr");
          trChild = document.createElement("div");
          table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
          tr.style.cssText = "border:1px solid"; // Support: Chrome 86+
          // Height set through cssText does not get applied.
          // Computed height then comes back as 0.

          tr.style.height = "1px";
          trChild.style.height = "9px"; // Support: Android 8 Chrome 86+
          // In our bodyBackground.html iframe,
          // display for all div elements is set to "inline",
          // which causes a problem only in Android 8 Chrome 86.
          // Ensuring the div is display: block
          // gets around this issue.

          trChild.style.display = "block";
          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
          trStyle = window.getComputedStyle(tr);
          reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
          documentElement.removeChild(table);
        }

        return reliableTrDimensionsVal;
      }
    });
  })();

  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;
    computed = computed || getStyles(elem); // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)

    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];

      if (ret === "" && !isAttached(elem)) {
        ret = jQuery.style(elem, name);
      } // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values


      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width; // Revert the changed values

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ? // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function () {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  var cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style,
      vendorProps = {}; // Return a vendor-prefixed property or undefined

  function vendorPropName(name) {
    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


  function finalPropName(name) {
    var final = jQuery.cssProps[name] || vendorProps[name];

    if (final) {
      return final;
    }

    if (name in emptyStyle) {
      return name;
    }

    return vendorProps[name] = vendorPropName(name) || name;
  }

  var // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  };

  function setPositiveNumber(_elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }

  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0; // Adjustment may not be necessary

    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"

      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // For "content" or "padding", subtract border


        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    } // Account for positive content-box scroll gutter when requested by providing computedVal


    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
      // Use an explicit zero to avoid NaN (gh-3964)
      )) || 0;
    }

    return delta;
  }

  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    // Fake content-box until we know it's needed to know the true value.
    boxSizingNeeded = !support.boxSizingReliable() || extra,
        isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox,
        val = curCSS(elem, dimension, styles),
        offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.

    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }

      val = "auto";
    } // Support: IE 9 - 11 only
    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
    // In those cases, the computed value can be trusted to be border-box.


    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
    !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    val === "auto" || // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
    elem.getClientRects().length) {
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
      // retrieved value as a content box dimension.

      valueIsBorderBox = offsetProp in elem;

      if (valueIsBorderBox) {
        val = elem[offsetProp];
      }
    } // Normalize "" and auto


    val = parseFloat(val) || 0; // Adjust for the element's box model

    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "gridArea": true,
      "gridColumn": true,
      "gridColumnEnd": true,
      "gridColumnStart": true,
      "gridRow": true,
      "gridRowEnd": true,
      "gridRowStart": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function (elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style; // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Gets hook for the prefixed version, then unprefixed version


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret); // Fixes bug #9237

          type = "number";
        } // Make sure that null and NaN values aren't set (#7116)


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add the unit (except for certain CSS properties)
        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
        // "px" to a few hardcoded values.


        if (type === "number" && !isCustomProp) {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        } // background-* props affect original clone's values


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Try prefixed name followed by the unprefixed name


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } // Convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Make numeric if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (_i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function (elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function (elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            // Only read styles.position if the test has a chance to fail
        // to avoid forcing a reflow.
        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
        boxSizingNeeded = scrollboxSizeBuggy || extra,
            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)

        if (isBorderBox && scrollboxSizeBuggy) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        } // Convert to pixels if value adjustment is needed


        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0,
            expanded = {},
            // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function (name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result; // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.

        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        } // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function (tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  } // Animations created synchronously will run synchronously


  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {
      height: type
    }; // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // Detect show/hide animations


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true; // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    } // Bail out if this is a no-op like .hide().hide()


    propTween = !jQuery.isEmptyObject(props);

    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    } // Restrict "overflow" and "display" styles during box animations


    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

      restoreDisplay = dataShow && dataShow.display;

      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }

      display = jQuery.css(elem, "display");

      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      } // Animate inline elements as inline-block


      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });

            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }

          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    } // Implement show/hide animations


    propTween = false;

    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


        if (toggle) {
          dataShow.hidden = !hidden;
        } // Show elements before animating them


        if (hidden) {
          showHide([elem], true);
        }
        /* eslint-disable no-loop-func */


        anim.done(function () {
          /* eslint-enable no-loop-func */
          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }

          dataPriv.remove(elem, "fxshow");

          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      } // Per-property setup


      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;

        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function () {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

      if (percent < 1 && length) {
        return remaining;
      } // If this was an empty animation, synthesize a final progress notification


      if (!length) {
        deferred.notifyWith(elem, [animation, 1, 0]);
      } // Resolve the animation and report its conclusion


      deferred.resolveWith(elem, [animation]);
      return false;
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function (prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function (gotoEnd) {
        var index = 0,
            // If we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // Resolve when we played the last frame; otherwise, reject


        if (gotoEnd) {
          deferred.notifyWith(elem, [animation, 1, 0]);
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }

        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    } // Attach callbacks from options


    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function (props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function (callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    }; // Go to the end state if fx are off

    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    } // Normalize opt.queue - true/undefined/null -> "fx"


    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function () {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || dataPriv.get(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // Enable finishing flag on private data

        data.finish = true; // Empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // Look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // Look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // Turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (_i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function () {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);

      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  (function () {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox"; // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"

    support.checkOn = input.value !== ""; // Support: IE <=11 only
    // Must access selectedIndex to make default options select

    support.optSelected = opt.selected; // Support: IE <=11 only
    // An input loses its value after becoming a radio

    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function (name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function (elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      } // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    },
    removeAttr: function (elem, value) {
      var name,
          i = 0,
          // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  }); // Hooks for boolean attributes

  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }

      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function (elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }

      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function (name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function (elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        return elem[name] = value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }

          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }); // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop

  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }

        return null;
      },
      set: function (elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  }); // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }

  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }

    return [];
  }

  jQuery.fn.extend({
    addClass: function (value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    removeClass: function (value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value,
          isValidValue = type === "string" || Array.isArray(value);

      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }

      return this.each(function () {
        var className, i, self, classNames;

        if (isValidValue) {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);

          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (value === undefined || type === "boolean") {
          className = getClass(this);

          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          } // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function (selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";

      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }

      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function (value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value; // Handle most common string cases

          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          } // Handle cases where value is null/undef or number


          return ret == null ? "" : ret;
        }

        return;
      }

      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function (elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          } // Loop through all the selected options


          for (; i < max; i++) {
            option = options[i]; // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function (elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];
            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
            /* eslint-enable no-cond-assign */

          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  }); // Return jQuery for attributes-only inclusion

  support.focusin = "onfocusin" in window;

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function (e) {
    e.stopPropagation();
  };

  jQuery.extend(jQuery.event, {
    trigger: function (event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }

            elem[type]();

            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function (type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  }); // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function (event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function () {
          // Handle: regular nodes (via `this.ownerDocument`), window
          // (via `this.document`) & document (via `this`).
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function () {
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  var location = window.location;
  var nonce = {
    guid: Date.now()
  };
  var rquery = /\?/; // Cross-browser xml parsing

  jQuery.parseXML = function (data) {
    var xml, parserErrorElem;

    if (!data || typeof data !== "string") {
      return null;
    } // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.


    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {}

    parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];

    if (!xml || parserErrorElem) {
      jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
        return el.textContent;
      }).join("\n") : data));
    }

    return xml;
  };

  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function (key, valueOrFunction) {
      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
    };

    if (a == null) {
      return "";
    } // If an array was passed in, assume that it is an array of form elements.


    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (_i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }

        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat("*"),
      // Anchor tag for parsing the document origin
  originAnchor = document.createElement("a");
  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function (target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function (url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (typeof url === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};
      var transport,
          // URL without anti-cache param
      cacheURL,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // timeout handle
      timeoutTimer,
          // Url cleanup var
      urlAnchor,
          // Request state (becomes false upon send and true upon completion)
      completed,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // uncached part of the url
      uncached,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function (key) {
          var match;

          if (completed) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
              }
            }

            match = responseHeaders[key.toLowerCase() + " "];
          }

          return match == null ? null : match.join(", ");
        },
        // Raw string
        getAllResponseHeaders: function () {
          return completed ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function (name, value) {
          if (completed == null) {
            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function (type) {
          if (completed == null) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function (map) {
          var code;

          if (map) {
            if (completed) {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            } else {
              // Lazy-add the new callbacks in a way that preserves old ones
              for (code in map) {
                statusCode[code] = [statusCode[code], map[code]];
              }
            }
          }

          return this;
        },
        // Cancel the request
        abort: function (statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds

      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/

        try {
          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative

          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (completed) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation

      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add or update anti-cache param if needed


        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // Aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error); // Get transport

      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // If request was aborted inside ajaxSend, stop there


        if (completed) {
          return jqXHR;
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          } // Propagate others as results


          done(-1, e);
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Ignore repeat invocations

        if (completed) {
          return;
        }

        completed = true; // Clear timeout if it exists

        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Use a noop converter for missing script but not if jsonp


        if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
          s.converters["text script"] = function () {};
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(statusCode);
        statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (_i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      } // The url can be an options object (which then must have .url)


      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery.ajaxPrefilter(function (s) {
    var i;

    for (i in s.headers) {
      if (i.toLowerCase() === "content-type") {
        s.contentType = s.headers[i] || "";
      }
    }
  });

  jQuery._evalUrl = function (url, options, doc) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      // Only evaluate the response if it is successful (gh-4126)
      // dataFilter is not invoked for failure responses, so using it instead
      // of the default converter is kludgy but it works.
      converters: {
        "text script": function () {}
      },
      dataFilter: function (response) {
        jQuery.globalEval(response, options, doc);
      }
    });
  };

  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;

      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        } // The elements to wrap the target around


        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function (html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function (selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };

  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
    // File protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest

    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          } // Override mime type if needed


          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          } // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.


          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          } // Set headers


          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          } // Callback


          callback = function (type) {
            return function () {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete( // File: protocol always yields status 0; see #8605, #14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          }; // Listen to events


          xhr.onload = callback();
          errorCallback = xhr.onerror = xhr.ontimeout = callback("error"); // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts

          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          } // Create the abort callback


          callback = callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (callback) {
              throw e;
            }
          }
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and crossDomain

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain or forced-by-attrs requests
    if (s.crossDomain || s.scriptAttrs) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function (evt) {
            script.remove();
            callback = null;

            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // Force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        } // Save back as free


        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337

  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }(); // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string


  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)

        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };
  /**
   * Load a url into a page
   */


  jQuery.fn.load = function (url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    } // If it's a function


    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && typeof params === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }

    return this;
  };

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // Set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function (options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var rect,
          win,
          elem = this[0];

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function () {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
        top: 0,
        left: 0
      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified

        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;

        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }

        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      } // Subtract parent offsets and element margins


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;

        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }

        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here

  jQuery.each(["top", "left"], function (_i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.fn.extend({
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  }); // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP

  var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon

  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    } // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.


    if (!isFunction(fn)) {
      return undefined;
    } // Simulated bind


    args = slice.call(arguments, 2);

    proxy = function () {
      return fn.apply(context || this, args.concat(slice.call(arguments)));
    }; // Set the guid of unique handler to the same of original handler, so it can be removed


    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };

  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };

  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;

  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  };

  jQuery.trim = function (text) {
    return text == null ? "" : (text + "").replace(rtrim, "");
  }; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)


  if (typeof noGlobal === "undefined") {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});

/***/ }),

/***/ 69729:
/*!*********************************************!*\
  !*** ./node_modules/mousetrap/mousetrap.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */

/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.5
 * @url craig.is/killing/mice
 */
(function (window, document, undefined) {
  // Check if mousetrap is used inside browser, if not, return
  if (!window) {
    return;
  }
  /**
   * mapping of special keycodes to their corresponding keys
   *
   * everything in this dictionary cannot use keypress events
   * so it has to be here to map to the correct keycodes for
   * keyup/keydown events
   *
   * @type {Object}
   */


  var _MAP = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    16: 'shift',
    17: 'ctrl',
    18: 'alt',
    20: 'capslock',
    27: 'esc',
    32: 'space',
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    45: 'ins',
    46: 'del',
    91: 'meta',
    93: 'meta',
    224: 'meta'
  };
  /**
   * mapping for special characters so they can support
   *
   * this dictionary is only used incase you want to bind a
   * keyup or keydown event to one of these keys
   *
   * @type {Object}
   */

  var _KEYCODE_MAP = {
    106: '*',
    107: '+',
    109: '-',
    110: '.',
    111: '/',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: '\''
  };
  /**
   * this is a mapping of keys that require shift on a US keypad
   * back to the non shift equivelents
   *
   * this is so you can use keyup events with these keys
   *
   * note that this will only work reliably on US keyboards
   *
   * @type {Object}
   */

  var _SHIFT_MAP = {
    '~': '`',
    '!': '1',
    '@': '2',
    '#': '3',
    '$': '4',
    '%': '5',
    '^': '6',
    '&': '7',
    '*': '8',
    '(': '9',
    ')': '0',
    '_': '-',
    '+': '=',
    ':': ';',
    '\"': '\'',
    '<': ',',
    '>': '.',
    '?': '/',
    '|': '\\'
  };
  /**
   * this is a list of special strings you can use to map
   * to modifier keys when you specify your keyboard shortcuts
   *
   * @type {Object}
   */

  var _SPECIAL_ALIASES = {
    'option': 'alt',
    'command': 'meta',
    'return': 'enter',
    'escape': 'esc',
    'plus': '+',
    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
  };
  /**
   * variable to store the flipped version of _MAP from above
   * needed to check if we should use keypress or not when no action
   * is specified
   *
   * @type {Object|undefined}
   */

  var _REVERSE_MAP;
  /**
   * loop through the f keys, f1 to f19 and add them to the map
   * programatically
   */


  for (var i = 1; i < 20; ++i) {
    _MAP[111 + i] = 'f' + i;
  }
  /**
   * loop through to map numbers on the numeric keypad
   */


  for (i = 0; i <= 9; ++i) {
    // This needs to use a string cause otherwise since 0 is falsey
    // mousetrap will never fire for numpad 0 pressed as part of a keydown
    // event.
    //
    // @see https://github.com/ccampbell/mousetrap/pull/258
    _MAP[i + 96] = i.toString();
  }
  /**
   * cross browser add event method
   *
   * @param {Element|HTMLDocument} object
   * @param {string} type
   * @param {Function} callback
   * @returns void
   */


  function _addEvent(object, type, callback) {
    if (object.addEventListener) {
      object.addEventListener(type, callback, false);
      return;
    }

    object.attachEvent('on' + type, callback);
  }
  /**
   * takes the event and returns the key character
   *
   * @param {Event} e
   * @return {string}
   */


  function _characterFromEvent(e) {
    // for keypress events we should return the character as is
    if (e.type == 'keypress') {
      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume
      // that we want the character to be lowercase.  this means if
      // you accidentally have caps lock on then your key bindings
      // will continue to work
      //
      // the only side effect that might not be desired is if you
      // bind something like 'A' cause you want to trigger an
      // event when capital A is pressed caps lock will no longer
      // trigger the event.  shift+a will though.

      if (!e.shiftKey) {
        character = character.toLowerCase();
      }

      return character;
    } // for non keypress events the special maps are needed


    if (_MAP[e.which]) {
      return _MAP[e.which];
    }

    if (_KEYCODE_MAP[e.which]) {
      return _KEYCODE_MAP[e.which];
    } // if it is not in the special map
    // with keydown and keyup events the character seems to always
    // come in as an uppercase character whether you are pressing shift
    // or not.  we should make sure it is always lowercase for comparisons


    return String.fromCharCode(e.which).toLowerCase();
  }
  /**
   * checks if two arrays are equal
   *
   * @param {Array} modifiers1
   * @param {Array} modifiers2
   * @returns {boolean}
   */


  function _modifiersMatch(modifiers1, modifiers2) {
    return modifiers1.sort().join(',') === modifiers2.sort().join(',');
  }
  /**
   * takes a key event and figures out what the modifiers are
   *
   * @param {Event} e
   * @returns {Array}
   */


  function _eventModifiers(e) {
    var modifiers = [];

    if (e.shiftKey) {
      modifiers.push('shift');
    }

    if (e.altKey) {
      modifiers.push('alt');
    }

    if (e.ctrlKey) {
      modifiers.push('ctrl');
    }

    if (e.metaKey) {
      modifiers.push('meta');
    }

    return modifiers;
  }
  /**
   * prevents default for this event
   *
   * @param {Event} e
   * @returns void
   */


  function _preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
      return;
    }

    e.returnValue = false;
  }
  /**
   * stops propogation for this event
   *
   * @param {Event} e
   * @returns void
   */


  function _stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
      return;
    }

    e.cancelBubble = true;
  }
  /**
   * determines if the keycode specified is a modifier key or not
   *
   * @param {string} key
   * @returns {boolean}
   */


  function _isModifier(key) {
    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
  }
  /**
   * reverses the map lookup so that we can look for specific keys
   * to see what can and can't use keypress
   *
   * @return {Object}
   */


  function _getReverseMap() {
    if (!_REVERSE_MAP) {
      _REVERSE_MAP = {};

      for (var key in _MAP) {
        // pull out the numeric keypad from here cause keypress should
        // be able to detect the keys from the character
        if (key > 95 && key < 112) {
          continue;
        }

        if (_MAP.hasOwnProperty(key)) {
          _REVERSE_MAP[_MAP[key]] = key;
        }
      }
    }

    return _REVERSE_MAP;
  }
  /**
   * picks the best action based on the key combination
   *
   * @param {string} key - character for key
   * @param {Array} modifiers
   * @param {string=} action passed in
   */


  function _pickBestAction(key, modifiers, action) {
    // if no action was picked in we should try to pick the one
    // that we think would work best for this key
    if (!action) {
      action = _getReverseMap()[key] ? 'keydown' : 'keypress';
    } // modifier keys don't work as expected with keypress,
    // switch to keydown


    if (action == 'keypress' && modifiers.length) {
      action = 'keydown';
    }

    return action;
  }
  /**
   * Converts from a string key combination to an array
   *
   * @param  {string} combination like "command+shift+l"
   * @return {Array}
   */


  function _keysFromString(combination) {
    if (combination === '+') {
      return ['+'];
    }

    combination = combination.replace(/\+{2}/g, '+plus');
    return combination.split('+');
  }
  /**
   * Gets info for a specific key combination
   *
   * @param  {string} combination key combination ("command+s" or "a" or "*")
   * @param  {string=} action
   * @returns {Object}
   */


  function _getKeyInfo(combination, action) {
    var keys;
    var key;
    var i;
    var modifiers = []; // take the keys from this pattern and figure out what the actual
    // pattern is all about

    keys = _keysFromString(combination);

    for (i = 0; i < keys.length; ++i) {
      key = keys[i]; // normalize key names

      if (_SPECIAL_ALIASES[key]) {
        key = _SPECIAL_ALIASES[key];
      } // if this is not a keypress event then we should
      // be smart about using shift keys
      // this will only work for US keyboards however


      if (action && action != 'keypress' && _SHIFT_MAP[key]) {
        key = _SHIFT_MAP[key];
        modifiers.push('shift');
      } // if this key is a modifier then add it to the list of modifiers


      if (_isModifier(key)) {
        modifiers.push(key);
      }
    } // depending on what the key combination is
    // we will try to pick the best event for it


    action = _pickBestAction(key, modifiers, action);
    return {
      key: key,
      modifiers: modifiers,
      action: action
    };
  }

  function _belongsTo(element, ancestor) {
    if (element === null || element === document) {
      return false;
    }

    if (element === ancestor) {
      return true;
    }

    return _belongsTo(element.parentNode, ancestor);
  }

  function Mousetrap(targetElement) {
    var self = this;
    targetElement = targetElement || document;

    if (!(self instanceof Mousetrap)) {
      return new Mousetrap(targetElement);
    }
    /**
     * element to attach key events to
     *
     * @type {Element}
     */


    self.target = targetElement;
    /**
     * a list of all the callbacks setup via Mousetrap.bind()
     *
     * @type {Object}
     */

    self._callbacks = {};
    /**
     * direct map of string combinations to callbacks used for trigger()
     *
     * @type {Object}
     */

    self._directMap = {};
    /**
     * keeps track of what level each sequence is at since multiple
     * sequences can start out with the same sequence
     *
     * @type {Object}
     */

    var _sequenceLevels = {};
    /**
     * variable to store the setTimeout call
     *
     * @type {null|number}
     */

    var _resetTimer;
    /**
     * temporary state where we will ignore the next keyup
     *
     * @type {boolean|string}
     */


    var _ignoreNextKeyup = false;
    /**
     * temporary state where we will ignore the next keypress
     *
     * @type {boolean}
     */

    var _ignoreNextKeypress = false;
    /**
     * are we currently inside of a sequence?
     * type of action ("keyup" or "keydown" or "keypress") or false
     *
     * @type {boolean|string}
     */

    var _nextExpectedAction = false;
    /**
     * resets all sequence counters except for the ones passed in
     *
     * @param {Object} doNotReset
     * @returns void
     */

    function _resetSequences(doNotReset) {
      doNotReset = doNotReset || {};
      var activeSequences = false,
          key;

      for (key in _sequenceLevels) {
        if (doNotReset[key]) {
          activeSequences = true;
          continue;
        }

        _sequenceLevels[key] = 0;
      }

      if (!activeSequences) {
        _nextExpectedAction = false;
      }
    }
    /**
     * finds all callbacks that match based on the keycode, modifiers,
     * and action
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event|Object} e
     * @param {string=} sequenceName - name of the sequence we are looking for
     * @param {string=} combination
     * @param {number=} level
     * @returns {Array}
     */


    function _getMatches(character, modifiers, e, sequenceName, combination, level) {
      var i;
      var callback;
      var matches = [];
      var action = e.type; // if there are no events related to this keycode

      if (!self._callbacks[character]) {
        return [];
      } // if a modifier key is coming up on its own we should allow it


      if (action == 'keyup' && _isModifier(character)) {
        modifiers = [character];
      } // loop through all callbacks for the key that was pressed
      // and see if any of them match


      for (i = 0; i < self._callbacks[character].length; ++i) {
        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at
        // the wrong level then move onto the next match

        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
          continue;
        } // if the action we are looking for doesn't match the action we got
        // then we should keep going


        if (action != callback.action) {
          continue;
        } // if this is a keypress event and the meta key and control key
        // are not pressed that means that we need to only look at the
        // character, otherwise check the modifiers as well
        //
        // chrome will not fire a keypress if meta or control is down
        // safari will fire a keypress if meta or meta+shift is down
        // firefox will fire a keypress if meta or control is down


        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
          // when you bind a combination or sequence a second time it
          // should overwrite the first one.  if a sequenceName or
          // combination is specified in this call it does just that
          //
          // @todo make deleting its own method?
          var deleteCombo = !sequenceName && callback.combo == combination;
          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;

          if (deleteCombo || deleteSequence) {
            self._callbacks[character].splice(i, 1);
          }

          matches.push(callback);
        }
      }

      return matches;
    }
    /**
     * actually calls the callback function
     *
     * if your callback function returns false this will use the jquery
     * convention - prevent default and stop propogation on the event
     *
     * @param {Function} callback
     * @param {Event} e
     * @returns void
     */


    function _fireCallback(callback, e, combo, sequence) {
      // if this event should not happen stop here
      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
        return;
      }

      if (callback(e, combo) === false) {
        _preventDefault(e);

        _stopPropagation(e);
      }
    }
    /**
     * handles a character key event
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event} e
     * @returns void
     */


    self._handleKey = function (character, modifiers, e) {
      var callbacks = _getMatches(character, modifiers, e);

      var i;
      var doNotReset = {};
      var maxLevel = 0;
      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence

      for (i = 0; i < callbacks.length; ++i) {
        if (callbacks[i].seq) {
          maxLevel = Math.max(maxLevel, callbacks[i].level);
        }
      } // loop through matching callbacks for this key event


      for (i = 0; i < callbacks.length; ++i) {
        // fire for all sequence callbacks
        // this is because if for example you have multiple sequences
        // bound such as "g i" and "g t" they both need to fire the
        // callback for matching g cause otherwise you can only ever
        // match the first one
        if (callbacks[i].seq) {
          // only fire callbacks for the maxLevel to prevent
          // subsequences from also firing
          //
          // for example 'a option b' should not cause 'option b' to fire
          // even though 'option b' is part of the other sequence
          //
          // any sequences that do not match here will be discarded
          // below by the _resetSequences call
          if (callbacks[i].level != maxLevel) {
            continue;
          }

          processedSequenceCallback = true; // keep a list of which sequences were matches for later

          doNotReset[callbacks[i].seq] = 1;

          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);

          continue;
        } // if there were no sequence matches but we are still here
        // that means this is a regular match so we should fire that


        if (!processedSequenceCallback) {
          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
        }
      } // if the key you pressed matches the type of sequence without
      // being a modifier (ie "keyup" or "keypress") then we should
      // reset all sequences that were not matched by this event
      //
      // this is so, for example, if you have the sequence "h a t" and you
      // type "h e a r t" it does not match.  in this case the "e" will
      // cause the sequence to reset
      //
      // modifier keys are ignored because you can have a sequence
      // that contains modifiers such as "enter ctrl+space" and in most
      // cases the modifier key will be pressed before the next key
      //
      // also if you have a sequence such as "ctrl+b a" then pressing the
      // "b" key will trigger a "keypress" and a "keydown"
      //
      // the "keydown" is expected when there is a modifier, but the
      // "keypress" ends up matching the _nextExpectedAction since it occurs
      // after and that causes the sequence to reset
      //
      // we ignore keypresses in a sequence that directly follow a keydown
      // for the same character


      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;

      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
        _resetSequences(doNotReset);
      }

      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
    };
    /**
     * handles a keydown event
     *
     * @param {Event} e
     * @returns void
     */


    function _handleKeyEvent(e) {
      // normalize e.which for key events
      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
      if (typeof e.which !== 'number') {
        e.which = e.keyCode;
      }

      var character = _characterFromEvent(e); // no character found then stop


      if (!character) {
        return;
      } // need to use === for the character check because the character can be 0


      if (e.type == 'keyup' && _ignoreNextKeyup === character) {
        _ignoreNextKeyup = false;
        return;
      }

      self.handleKey(character, _eventModifiers(e), e);
    }
    /**
     * called to set a 1 second timeout on the specified sequence
     *
     * this is so after each key press in the sequence you have 1 second
     * to press the next key before you have to start over
     *
     * @returns void
     */


    function _resetSequenceTimer() {
      clearTimeout(_resetTimer);
      _resetTimer = setTimeout(_resetSequences, 1000);
    }
    /**
     * binds a key sequence to an event
     *
     * @param {string} combo - combo specified in bind call
     * @param {Array} keys
     * @param {Function} callback
     * @param {string=} action
     * @returns void
     */


    function _bindSequence(combo, keys, callback, action) {
      // start off by adding a sequence level record for this combination
      // and setting the level to 0
      _sequenceLevels[combo] = 0;
      /**
       * callback to increase the sequence level for this sequence and reset
       * all other sequences that were active
       *
       * @param {string} nextAction
       * @returns {Function}
       */

      function _increaseSequence(nextAction) {
        return function () {
          _nextExpectedAction = nextAction;
          ++_sequenceLevels[combo];

          _resetSequenceTimer();
        };
      }
      /**
       * wraps the specified callback inside of another function in order
       * to reset all sequence counters as soon as this sequence is done
       *
       * @param {Event} e
       * @returns void
       */


      function _callbackAndReset(e) {
        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down
        // or keypress.  this is so if you finish a sequence and
        // release the key the final key will not trigger a keyup


        if (action !== 'keyup') {
          _ignoreNextKeyup = _characterFromEvent(e);
        } // weird race condition if a sequence ends with the key
        // another sequence begins with


        setTimeout(_resetSequences, 10);
      } // loop through keys one at a time and bind the appropriate callback
      // function.  for any key leading up to the final one it should
      // increase the sequence. after the final, it should reset all sequences
      //
      // if an action is specified in the original bind call then that will
      // be used throughout.  otherwise we will pass the action that the
      // next key in the sequence should match.  this allows a sequence
      // to mix and match keypress and keydown events depending on which
      // ones are better suited to the key provided


      for (var i = 0; i < keys.length; ++i) {
        var isFinal = i + 1 === keys.length;
        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);

        _bindSingle(keys[i], wrappedCallback, action, combo, i);
      }
    }
    /**
     * binds a single keyboard combination
     *
     * @param {string} combination
     * @param {Function} callback
     * @param {string=} action
     * @param {string=} sequenceName - name of sequence if part of sequence
     * @param {number=} level - what part of the sequence the command is
     * @returns void
     */


    function _bindSingle(combination, callback, action, sequenceName, level) {
      // store a direct mapped reference for use with Mousetrap.trigger
      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space

      combination = combination.replace(/\s+/g, ' ');
      var sequence = combination.split(' ');
      var info; // if this pattern is a sequence of keys then run through this method
      // to reprocess each pattern one key at a time

      if (sequence.length > 1) {
        _bindSequence(combination, sequence, callback, action);

        return;
      }

      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time
      // a callback is added for this key

      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one

      _getMatches(info.key, info.modifiers, {
        type: info.action
      }, sequenceName, combination, level); // add this call back to the array
      // if it is a sequence put it at the beginning
      // if not put it at the end
      //
      // this is important because the way these are processed expects
      // the sequence ones to come first


      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
        callback: callback,
        modifiers: info.modifiers,
        action: info.action,
        seq: sequenceName,
        level: level,
        combo: combination
      });
    }
    /**
     * binds multiple combinations to the same callback
     *
     * @param {Array} combinations
     * @param {Function} callback
     * @param {string|undefined} action
     * @returns void
     */


    self._bindMultiple = function (combinations, callback, action) {
      for (var i = 0; i < combinations.length; ++i) {
        _bindSingle(combinations[i], callback, action);
      }
    }; // start!


    _addEvent(targetElement, 'keypress', _handleKeyEvent);

    _addEvent(targetElement, 'keydown', _handleKeyEvent);

    _addEvent(targetElement, 'keyup', _handleKeyEvent);
  }
  /**
   * binds an event to mousetrap
   *
   * can be a single key, a combination of keys separated with +,
   * an array of keys, or a sequence of keys separated by spaces
   *
   * be sure to list the modifier keys first to make sure that the
   * correct key ends up getting bound (the last key in the pattern)
   *
   * @param {string|Array} keys
   * @param {Function} callback
   * @param {string=} action - 'keypress', 'keydown', or 'keyup'
   * @returns void
   */


  Mousetrap.prototype.bind = function (keys, callback, action) {
    var self = this;
    keys = keys instanceof Array ? keys : [keys];

    self._bindMultiple.call(self, keys, callback, action);

    return self;
  };
  /**
   * unbinds an event to mousetrap
   *
   * the unbinding sets the callback function of the specified key combo
   * to an empty function and deletes the corresponding key in the
   * _directMap dict.
   *
   * TODO: actually remove this from the _callbacks dictionary instead
   * of binding an empty function
   *
   * the keycombo+action has to be exactly the same as
   * it was defined in the bind method
   *
   * @param {string|Array} keys
   * @param {string} action
   * @returns void
   */


  Mousetrap.prototype.unbind = function (keys, action) {
    var self = this;
    return self.bind.call(self, keys, function () {}, action);
  };
  /**
   * triggers an event that has already been bound
   *
   * @param {string} keys
   * @param {string=} action
   * @returns void
   */


  Mousetrap.prototype.trigger = function (keys, action) {
    var self = this;

    if (self._directMap[keys + ':' + action]) {
      self._directMap[keys + ':' + action]({}, keys);
    }

    return self;
  };
  /**
   * resets the library back to its initial state.  this is useful
   * if you want to clear out the current keyboard shortcuts and bind
   * new ones - for example if you switch to another page
   *
   * @returns void
   */


  Mousetrap.prototype.reset = function () {
    var self = this;
    self._callbacks = {};
    self._directMap = {};
    return self;
  };
  /**
   * should we stop this event before firing off callbacks
   *
   * @param {Event} e
   * @param {Element} element
   * @return {boolean}
   */


  Mousetrap.prototype.stopCallback = function (e, element) {
    var self = this; // if the element has the class "mousetrap" then no need to stop

    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
      return false;
    }

    if (_belongsTo(element, self.target)) {
      return false;
    } // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,
    // not the initial event target in the shadow tree. Note that not all events cross the
    // shadow boundary.
    // For shadow trees with `mode: 'open'`, the initial event target is the first element in
    // the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event
    // target cannot be obtained.


    if ('composedPath' in e && typeof e.composedPath === 'function') {
      // For open shadow trees, update `element` so that the following check works.
      var initialEventTarget = e.composedPath()[0];

      if (initialEventTarget !== e.target) {
        element = initialEventTarget;
      }
    } // stop for input, select, and textarea


    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
  };
  /**
   * exposes _handleKey publicly so it can be overwritten by extensions
   */


  Mousetrap.prototype.handleKey = function () {
    var self = this;
    return self._handleKey.apply(self, arguments);
  };
  /**
   * allow custom key mappings
   */


  Mousetrap.addKeycodes = function (object) {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        _MAP[key] = object[key];
      }
    }

    _REVERSE_MAP = null;
  };
  /**
   * Init the global mousetrap functions
   *
   * This method is needed to allow the global mousetrap functions to work
   * now that mousetrap is a constructor function.
   */


  Mousetrap.init = function () {
    var documentMousetrap = Mousetrap(document);

    for (var method in documentMousetrap) {
      if (method.charAt(0) !== '_') {
        Mousetrap[method] = function (method) {
          return function () {
            return documentMousetrap[method].apply(documentMousetrap, arguments);
          };
        }(method);
      }
    }
  };

  Mousetrap.init(); // expose mousetrap to the global object

  window.Mousetrap = Mousetrap; // expose as a common js module

  if ( true && module.exports) {
    module.exports = Mousetrap;
  } // expose mousetrap as an AMD module


  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return Mousetrap;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);

/***/ }),

/***/ 28230:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_DataView.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ 94727);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ 84261);


/* Built-in method references that are verified to be native. */

var DataView = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'DataView');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataView);

/***/ }),

/***/ 14181:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_Hash.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hashClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hashClear.js */ 35606);
/* harmony import */ var _hashDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hashDelete.js */ 65168);
/* harmony import */ var _hashGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_hashGet.js */ 51099);
/* harmony import */ var _hashHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_hashHas.js */ 86920);
/* harmony import */ var _hashSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_hashSet.js */ 65689);





/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = _hashClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
Hash.prototype['delete'] = _hashDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
Hash.prototype.get = _hashGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
Hash.prototype.has = _hashHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
Hash.prototype.set = _hashSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Hash);

/***/ }),

/***/ 95751:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_ListCache.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _listCacheClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_listCacheClear.js */ 15909);
/* harmony import */ var _listCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_listCacheDelete.js */ 48380);
/* harmony import */ var _listCacheGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_listCacheGet.js */ 81129);
/* harmony import */ var _listCacheHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_listCacheHas.js */ 73503);
/* harmony import */ var _listCacheSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_listCacheSet.js */ 98643);





/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = _listCacheClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
ListCache.prototype['delete'] = _listCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
ListCache.prototype.get = _listCacheGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
ListCache.prototype.has = _listCacheHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
ListCache.prototype.set = _listCacheSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListCache);

/***/ }),

/***/ 83686:
/*!****************************************!*\
  !*** ./node_modules/lodash-es/_Map.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ 94727);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ 84261);


/* Built-in method references that are verified to be native. */

var Map = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Map');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Map);

/***/ }),

/***/ 12733:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_MapCache.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _mapCacheClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_mapCacheClear.js */ 74305);
/* harmony import */ var _mapCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_mapCacheDelete.js */ 82579);
/* harmony import */ var _mapCacheGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_mapCacheGet.js */ 44933);
/* harmony import */ var _mapCacheHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_mapCacheHas.js */ 13624);
/* harmony import */ var _mapCacheSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_mapCacheSet.js */ 83392);





/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = _mapCacheClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
MapCache.prototype['delete'] = _mapCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
MapCache.prototype.get = _mapCacheGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
MapCache.prototype.has = _mapCacheHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
MapCache.prototype.set = _mapCacheSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapCache);

/***/ }),

/***/ 69420:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_Promise.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ 94727);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ 84261);


/* Built-in method references that are verified to be native. */

var Promise = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Promise');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Promise);

/***/ }),

/***/ 63538:
/*!****************************************!*\
  !*** ./node_modules/lodash-es/_Set.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ 94727);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ 84261);


/* Built-in method references that are verified to be native. */

var Set = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Set');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Set);

/***/ }),

/***/ 85675:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_SetCache.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_MapCache.js */ 12733);
/* harmony import */ var _setCacheAdd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setCacheAdd.js */ 31622);
/* harmony import */ var _setCacheHas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_setCacheHas.js */ 18403);



/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd_js__WEBPACK_IMPORTED_MODULE_1__["default"];
SetCache.prototype.has = _setCacheHas_js__WEBPACK_IMPORTED_MODULE_2__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCache);

/***/ }),

/***/ 90246:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_Stack.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ 95751);
/* harmony import */ var _stackClear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stackClear.js */ 78792);
/* harmony import */ var _stackDelete_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stackDelete.js */ 73459);
/* harmony import */ var _stackGet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_stackGet.js */ 11138);
/* harmony import */ var _stackHas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_stackHas.js */ 15188);
/* harmony import */ var _stackSet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_stackSet.js */ 87079);






/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"](entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = _stackClear_js__WEBPACK_IMPORTED_MODULE_1__["default"];
Stack.prototype['delete'] = _stackDelete_js__WEBPACK_IMPORTED_MODULE_2__["default"];
Stack.prototype.get = _stackGet_js__WEBPACK_IMPORTED_MODULE_3__["default"];
Stack.prototype.has = _stackHas_js__WEBPACK_IMPORTED_MODULE_4__["default"];
Stack.prototype.set = _stackSet_js__WEBPACK_IMPORTED_MODULE_5__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stack);

/***/ }),

/***/ 194:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_Symbol.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ 84261);

/** Built-in value references. */

var Symbol = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Symbol;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Symbol);

/***/ }),

/***/ 13410:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_Uint8Array.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ 84261);

/** Built-in value references. */

var Uint8Array = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Uint8Array;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Uint8Array);

/***/ }),

/***/ 57571:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_WeakMap.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ 94727);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ 84261);


/* Built-in method references that are verified to be native. */

var WeakMap = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'WeakMap');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WeakMap);

/***/ }),

/***/ 49419:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_apply.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (apply);

/***/ }),

/***/ 64491:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_arrayAggregator.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }

  return accumulator;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayAggregator);

/***/ }),

/***/ 75805:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_arrayEach.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayEach);

/***/ }),

/***/ 28468:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_arrayFilter.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayFilter);

/***/ }),

/***/ 79637:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_arrayIncludes.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIndexOf.js */ 81944);

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && (0,_baseIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, value, 0) > -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayIncludes);

/***/ }),

/***/ 54540:
/*!******************************************************!*\
  !*** ./node_modules/lodash-es/_arrayIncludesWith.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayIncludesWith);

/***/ }),

/***/ 87224:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_arrayLikeKeys.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseTimes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseTimes.js */ 56116);
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArguments.js */ 3056);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isBuffer.js */ 28057);
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_isIndex.js */ 89802);
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTypedArray.js */ 46716);






/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value),
      isArg = !isArr && (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value),
      isBuff = !isArr && !isArg && (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value),
      isType = !isArr && !isArg && !isBuff && (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? (0,_baseTimes_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    (0,_isIndex_js__WEBPACK_IMPORTED_MODULE_5__["default"])(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayLikeKeys);

/***/ }),

/***/ 66717:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_arrayMap.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayMap);

/***/ }),

/***/ 82784:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_arrayPush.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayPush);

/***/ }),

/***/ 9751:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_arrayReduce.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }

  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }

  return accumulator;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayReduce);

/***/ }),

/***/ 40760:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_arraySome.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arraySome);

/***/ }),

/***/ 37045:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_asciiSize.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseProperty.js */ 30754);

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */

var asciiSize = (0,_baseProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])('length');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (asciiSize);

/***/ }),

/***/ 10650:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_asciiToArray.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (asciiToArray);

/***/ }),

/***/ 45893:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_asciiWords.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */

function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (asciiWords);

/***/ }),

/***/ 90135:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_assignMergeValue.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseAssignValue.js */ 67138);
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq.js */ 36802);


/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !(0,_eq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object[key], value) || value === undefined && !(key in object)) {
    (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, value);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assignMergeValue);

/***/ }),

/***/ 21123:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_assignValue.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseAssignValue.js */ 67138);
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq.js */ 36802);


/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && (0,_eq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objValue, value)) || value === undefined && !(key in object)) {
    (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, value);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assignValue);

/***/ }),

/***/ 84311:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_assocIndexOf.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq.js */ 36802);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if ((0,_eq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assocIndexOf);

/***/ }),

/***/ 83052:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseAggregator.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseEach.js */ 74065);

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */

function baseAggregator(collection, setter, iteratee, accumulator) {
  (0,_baseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection, function (value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAggregator);

/***/ }),

/***/ 29065:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseAssign.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ 1540);
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ 24876);


/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */

function baseAssign(object, source) {
  return object && (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, (0,_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAssign);

/***/ }),

/***/ 76563:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseAssignIn.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ 1540);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keysIn.js */ 39274);


/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */

function baseAssignIn(object, source) {
  return object && (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAssignIn);

/***/ }),

/***/ 67138:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseAssignValue.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_defineProperty.js */ 45552);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAssignValue);

/***/ }),

/***/ 12416:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseClamp.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }

    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }

  return number;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseClamp);

/***/ }),

/***/ 19702:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseClone.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./_Stack.js */ 90246);
/* harmony import */ var _arrayEach_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./_arrayEach.js */ 75805);
/* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./_assignValue.js */ 21123);
/* harmony import */ var _baseAssign_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_baseAssign.js */ 29065);
/* harmony import */ var _baseAssignIn_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_baseAssignIn.js */ 76563);
/* harmony import */ var _cloneBuffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_cloneBuffer.js */ 59097);
/* harmony import */ var _copyArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_copyArray.js */ 77331);
/* harmony import */ var _copySymbols_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_copySymbols.js */ 14104);
/* harmony import */ var _copySymbolsIn_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_copySymbolsIn.js */ 64488);
/* harmony import */ var _getAllKeys_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./_getAllKeys.js */ 11922);
/* harmony import */ var _getAllKeysIn_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./_getAllKeysIn.js */ 24173);
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_getTag.js */ 33221);
/* harmony import */ var _initCloneArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_initCloneArray.js */ 13530);
/* harmony import */ var _initCloneByTag_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_initCloneByTag.js */ 84191);
/* harmony import */ var _initCloneObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_initCloneObject.js */ 65914);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isBuffer.js */ 28057);
/* harmony import */ var _isMap_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./isMap.js */ 5088);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _isSet_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isSet.js */ 59486);
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./keys.js */ 24876);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./keysIn.js */ 39274);






















/** Used to compose bitmasks for cloning. */

var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return value;
  }

  var isArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);

  if (isArr) {
    result = (0,_initCloneArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

    if (!isDeep) {
      return (0,_copyArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value, result);
    }
  } else {
    var tag = (0,_getTag_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value),
        isFunc = tag == funcTag || tag == genTag;

    if ((0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value)) {
      return (0,_cloneBuffer_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : (0,_initCloneObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value);

      if (!isDeep) {
        return isFlat ? (0,_copySymbolsIn_js__WEBPACK_IMPORTED_MODULE_8__["default"])(value, (0,_baseAssignIn_js__WEBPACK_IMPORTED_MODULE_9__["default"])(result, value)) : (0,_copySymbols_js__WEBPACK_IMPORTED_MODULE_10__["default"])(value, (0,_baseAssign_js__WEBPACK_IMPORTED_MODULE_11__["default"])(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = (0,_initCloneByTag_js__WEBPACK_IMPORTED_MODULE_12__["default"])(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_13__["default"]());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if ((0,_isSet_js__WEBPACK_IMPORTED_MODULE_14__["default"])(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if ((0,_isMap_js__WEBPACK_IMPORTED_MODULE_15__["default"])(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? _getAllKeysIn_js__WEBPACK_IMPORTED_MODULE_16__["default"] : _getAllKeys_js__WEBPACK_IMPORTED_MODULE_17__["default"] : isFlat ? _keysIn_js__WEBPACK_IMPORTED_MODULE_18__["default"] : _keys_js__WEBPACK_IMPORTED_MODULE_19__["default"];
  var props = isArr ? undefined : keysFunc(value);
  (0,_arrayEach_js__WEBPACK_IMPORTED_MODULE_20__["default"])(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    (0,_assignValue_js__WEBPACK_IMPORTED_MODULE_21__["default"])(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseClone);

/***/ }),

/***/ 8722:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseCreate.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseCreate);

/***/ }),

/***/ 63189:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseDelay.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * The base implementation of `_.delay` and `_.defer` which accepts `args`
 * to provide to `func`.
 *
 * @private
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {Array} args The arguments to provide to `func`.
 * @returns {number|Object} Returns the timer id or timeout object.
 */

function baseDelay(func, wait, args) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  return setTimeout(function () {
    func.apply(undefined, args);
  }, wait);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseDelay);

/***/ }),

/***/ 12774:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseDifference.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SetCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_SetCache.js */ 85675);
/* harmony import */ var _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayIncludes.js */ 79637);
/* harmony import */ var _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_arrayIncludesWith.js */ 54540);
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayMap.js */ 66717);
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseUnary.js */ 7560);
/* harmony import */ var _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_cacheHas.js */ 36149);






/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */

function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }

  if (iteratee) {
    values = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values, (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee));
  }

  if (comparator) {
    includes = _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_3__["default"];
    isCommon = false;
  } else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    isCommon = false;
    values = new _SetCache_js__WEBPACK_IMPORTED_MODULE_5__["default"](values);
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;

      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }

      result.push(value);
    } else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseDifference);

/***/ }),

/***/ 74065:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseEach.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseForOwn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseForOwn.js */ 33985);
/* harmony import */ var _createBaseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createBaseEach.js */ 85062);


/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */

var baseEach = (0,_createBaseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_baseForOwn_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseEach);

/***/ }),

/***/ 1977:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseExtremum.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ 48455);

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */

function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined ? current === current && !(0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(current) : comparator(current, computed))) {
      var computed = current,
          result = value;
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseExtremum);

/***/ }),

/***/ 19402:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_baseFindIndex.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseFindIndex);

/***/ }),

/***/ 43932:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseFlatten.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayPush.js */ 82784);
/* harmony import */ var _isFlattenable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isFlattenable.js */ 3981);


/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */

function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = _isFlattenable_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        (0,_arrayPush_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseFlatten);

/***/ }),

/***/ 58601:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseFor.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createBaseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createBaseFor.js */ 78361);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor = (0,_createBaseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseFor);

/***/ }),

/***/ 33985:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseForOwn.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFor.js */ 58601);
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ 24876);


/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */

function baseForOwn(object, iteratee) {
  return object && (0,_baseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, iteratee, _keys_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseForOwn);

/***/ }),

/***/ 90202:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseGet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_castPath.js */ 63611);
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toKey.js */ 1564);


/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = (0,_castPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[(0,_toKey_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGet);

/***/ }),

/***/ 6288:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseGetAllKeys.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayPush.js */ 82784);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ 17191);


/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object) ? result : (0,_arrayPush_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, symbolsFunc(object));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGetAllKeys);

/***/ }),

/***/ 4035:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseGetTag.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ 194);
/* harmony import */ var _getRawTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getRawTag.js */ 33521);
/* harmony import */ var _objectToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_objectToString.js */ 62820);



/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? (0,_getRawTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) : (0,_objectToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGetTag);

/***/ }),

/***/ 87803:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_baseGt.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGt);

/***/ }),

/***/ 87173:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseHas.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseHas);

/***/ }),

/***/ 82779:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseHasIn.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseHasIn);

/***/ }),

/***/ 19636:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseInRange.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * The base implementation of `_.inRange` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 */

function baseInRange(number, start, end) {
  return number >= nativeMin(start, end) && number < nativeMax(start, end);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseInRange);

/***/ }),

/***/ 81944:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseIndexOf.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFindIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseFindIndex.js */ 19402);
/* harmony import */ var _baseIsNaN_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsNaN.js */ 43876);
/* harmony import */ var _strictIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_strictIndexOf.js */ 35161);



/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function baseIndexOf(array, value, fromIndex) {
  return value === value ? (0,_strictIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, value, fromIndex) : (0,_baseFindIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, _baseIsNaN_js__WEBPACK_IMPORTED_MODULE_2__["default"], fromIndex);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIndexOf);

/***/ }),

/***/ 35387:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsArguments.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == argsTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsArguments);

/***/ }),

/***/ 76603:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsEqual.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsEqualDeep_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIsEqualDeep.js */ 44964);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !(0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && !(0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other)) {
    return value !== value && other !== other;
  }

  return (0,_baseIsEqualDeep_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, other, bitmask, customizer, baseIsEqual, stack);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsEqual);

/***/ }),

/***/ 44964:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsEqualDeep.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_Stack.js */ 90246);
/* harmony import */ var _equalArrays_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_equalArrays.js */ 8377);
/* harmony import */ var _equalByTag_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_equalByTag.js */ 81541);
/* harmony import */ var _equalObjects_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_equalObjects.js */ 49795);
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getTag.js */ 33221);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isBuffer.js */ 28057);
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTypedArray.js */ 46716);








/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object),
      othIsArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other),
      objTag = objIsArr ? arrayTag : (0,_getTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object),
      othTag = othIsArr ? arrayTag : (0,_getTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object)) {
    if (!(0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_3__["default"]());
    return objIsArr || (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object) ? (0,_equalArrays_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object, other, bitmask, customizer, equalFunc, stack) : (0,_equalByTag_js__WEBPACK_IMPORTED_MODULE_6__["default"])(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_3__["default"]());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_3__["default"]());
  return (0,_equalObjects_js__WEBPACK_IMPORTED_MODULE_7__["default"])(object, other, bitmask, customizer, equalFunc, stack);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsEqualDeep);

/***/ }),

/***/ 44774:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseIsMap.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getTag.js */ 33221);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/** `Object#toString` result references. */

var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_getTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == mapTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsMap);

/***/ }),

/***/ 19507:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsMatch.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Stack.js */ 90246);
/* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIsEqual.js */ 76603);


/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? (0,_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_1__["default"])(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsMatch);

/***/ }),

/***/ 43876:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseIsNaN.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsNaN);

/***/ }),

/***/ 88831:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsNative.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isFunction.js */ 15849);
/* harmony import */ var _isMasked_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isMasked.js */ 8260);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _toSource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toSource.js */ 66018);




/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) || (0,_isMasked_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    return false;
  }

  var pattern = (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) ? reIsNative : reIsHostCtor;
  return pattern.test((0,_toSource_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsNative);

/***/ }),

/***/ 44351:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsRegExp.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/** `Object#toString` result references. */

var regexpTag = '[object RegExp]';
/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */

function baseIsRegExp(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == regexpTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsRegExp);

/***/ }),

/***/ 60694:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseIsSet.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getTag.js */ 33221);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/** `Object#toString` result references. */

var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_getTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == setTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsSet);

/***/ }),

/***/ 62347:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsTypedArray.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isLength.js */ 75227);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);



/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_isLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value.length) && !!typedArrayTags[(0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value)];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsTypedArray);

/***/ }),

/***/ 22244:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIteratee.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseMatches_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseMatches.js */ 68510);
/* harmony import */ var _baseMatchesProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseMatchesProperty.js */ 57324);
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ 80570);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./property.js */ 15472);





/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  }

  if (typeof value == 'object') {
    return (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) ? (0,_baseMatchesProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value[0], value[1]) : (0,_baseMatches_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value);
  }

  return (0,_property_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIteratee);

/***/ }),

/***/ 962:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeys.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isPrototype.js */ 5908);
/* harmony import */ var _nativeKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_nativeKeys.js */ 70081);


/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!(0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return (0,_nativeKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseKeys);

/***/ }),

/***/ 53003:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeysIn.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isPrototype.js */ 5908);
/* harmony import */ var _nativeKeysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_nativeKeysIn.js */ 48242);



/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return (0,_nativeKeysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
  }

  var isProto = (0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseKeysIn);

/***/ }),

/***/ 70653:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseMap.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseEach.js */ 74065);
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ 83917);


/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function baseMap(collection, iteratee) {
  var index = -1,
      result = (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? Array(collection.length) : [];
  (0,_baseEach_js__WEBPACK_IMPORTED_MODULE_1__["default"])(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMap);

/***/ }),

/***/ 68510:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseMatches.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsMatch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsMatch.js */ 19507);
/* harmony import */ var _getMatchData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMatchData.js */ 84722);
/* harmony import */ var _matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_matchesStrictComparable.js */ 71458);



/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches(source) {
  var matchData = (0,_getMatchData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return (0,_matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__["default"])(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || (0,_baseIsMatch_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object, source, matchData);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMatches);

/***/ }),

/***/ 57324:
/*!********************************************************!*\
  !*** ./node_modules/lodash-es/_baseMatchesProperty.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_baseIsEqual.js */ 76603);
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get.js */ 94894);
/* harmony import */ var _hasIn_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hasIn.js */ 38189);
/* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isKey.js */ 17386);
/* harmony import */ var _isStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isStrictComparable.js */ 80604);
/* harmony import */ var _matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_matchesStrictComparable.js */ 71458);
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toKey.js */ 1564);







/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if ((0,_isKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path) && (0,_isStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__["default"])(srcValue)) {
    return (0,_matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_toKey_js__WEBPACK_IMPORTED_MODULE_3__["default"])(path), srcValue);
  }

  return function (object) {
    var objValue = (0,_get_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object, path);
    return objValue === undefined && objValue === srcValue ? (0,_hasIn_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object, path) : (0,_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_6__["default"])(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMatchesProperty);

/***/ }),

/***/ 55226:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseMerge.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Stack.js */ 90246);
/* harmony import */ var _assignMergeValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_assignMergeValue.js */ 90135);
/* harmony import */ var _baseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFor.js */ 58601);
/* harmony import */ var _baseMergeDeep_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseMergeDeep.js */ 61565);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keysIn.js */ 39274);
/* harmony import */ var _safeGet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_safeGet.js */ 42812);







/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  (0,_baseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, function (srcValue, key) {
    stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_1__["default"]());

    if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"])(srcValue)) {
      (0,_baseMergeDeep_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer((0,_safeGet_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      (0,_assignMergeValue_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object, key, newValue);
    }
  }, _keysIn_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMerge);

/***/ }),

/***/ 61565:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_baseMergeDeep.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assignMergeValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assignMergeValue.js */ 90135);
/* harmony import */ var _cloneBuffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_cloneBuffer.js */ 59097);
/* harmony import */ var _cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_cloneTypedArray.js */ 22856);
/* harmony import */ var _copyArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_copyArray.js */ 77331);
/* harmony import */ var _initCloneObject_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./_initCloneObject.js */ 65914);
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./isArguments.js */ 3056);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isArrayLikeObject.js */ 69275);
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isBuffer.js */ 28057);
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isFunction.js */ 15849);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./isPlainObject.js */ 8978);
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTypedArray.js */ 46716);
/* harmony import */ var _safeGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_safeGet.js */ 42812);
/* harmony import */ var _toPlainObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./toPlainObject.js */ 23997);















/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = (0,_safeGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key),
      srcValue = (0,_safeGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    (0,_assignMergeValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(srcValue),
        isBuff = !isArr && (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(srcValue),
        isTyped = !isArr && !isBuff && (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(objValue)) {
        newValue = objValue;
      } else if ((0,_isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_5__["default"])(objValue)) {
        newValue = (0,_copyArray_js__WEBPACK_IMPORTED_MODULE_6__["default"])(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = (0,_cloneBuffer_js__WEBPACK_IMPORTED_MODULE_7__["default"])(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = (0,_cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_8__["default"])(srcValue, true);
      } else {
        newValue = [];
      }
    } else if ((0,_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__["default"])(srcValue) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_10__["default"])(srcValue)) {
      newValue = objValue;

      if ((0,_isArguments_js__WEBPACK_IMPORTED_MODULE_10__["default"])(objValue)) {
        newValue = (0,_toPlainObject_js__WEBPACK_IMPORTED_MODULE_11__["default"])(objValue);
      } else if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_12__["default"])(objValue) || (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_13__["default"])(objValue)) {
        newValue = (0,_initCloneObject_js__WEBPACK_IMPORTED_MODULE_14__["default"])(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  (0,_assignMergeValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, newValue);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMergeDeep);

/***/ }),

/***/ 46827:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseOrderBy.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayMap.js */ 66717);
/* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseGet.js */ 90202);
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_baseIteratee.js */ 22244);
/* harmony import */ var _baseMap_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_baseMap.js */ 70653);
/* harmony import */ var _baseSortBy_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_baseSortBy.js */ 25201);
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseUnary.js */ 7560);
/* harmony import */ var _compareMultiple_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_compareMultiple.js */ 30664);
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./identity.js */ 80570);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ 17191);









/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */

function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratees, function (iteratee) {
      if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee)) {
        return function (value) {
          return (0,_baseGet_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }

      return iteratee;
    });
  } else {
    iteratees = [_identity_js__WEBPACK_IMPORTED_MODULE_3__["default"]];
  }

  var index = -1;
  iteratees = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratees, (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_baseIteratee_js__WEBPACK_IMPORTED_MODULE_5__["default"]));
  var result = (0,_baseMap_js__WEBPACK_IMPORTED_MODULE_6__["default"])(collection, function (value, key, collection) {
    var criteria = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return {
      'criteria': criteria,
      'index': ++index,
      'value': value
    };
  });
  return (0,_baseSortBy_js__WEBPACK_IMPORTED_MODULE_7__["default"])(result, function (object, other) {
    return (0,_compareMultiple_js__WEBPACK_IMPORTED_MODULE_8__["default"])(object, other, orders);
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseOrderBy);

/***/ }),

/***/ 77620:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_basePick.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basePickBy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_basePickBy.js */ 5394);
/* harmony import */ var _hasIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hasIn.js */ 38189);


/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */

function basePick(object, paths) {
  return (0,_basePickBy_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, paths, function (value, path) {
    return (0,_hasIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, path);
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basePick);

/***/ }),

/***/ 5394:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_basePickBy.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGet.js */ 90202);
/* harmony import */ var _baseSet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseSet.js */ 48422);
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_castPath.js */ 63611);



/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */

function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = (0,_baseGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path);

    if (predicate(value, path)) {
      (0,_baseSet_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, (0,_castPath_js__WEBPACK_IMPORTED_MODULE_2__["default"])(path, object), value);
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basePickBy);

/***/ }),

/***/ 30754:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseProperty.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseProperty);

/***/ }),

/***/ 22245:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_basePropertyDeep.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGet.js */ 90202);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep(path) {
  return function (object) {
    return (0,_baseGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basePropertyDeep);

/***/ }),

/***/ 30195:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_basePropertyOf.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basePropertyOf);

/***/ }),

/***/ 4608:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseRepeat.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeFloor = Math.floor;
/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */

function baseRepeat(string, n) {
  var result = '';

  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  } // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.


  do {
    if (n % 2) {
      result += string;
    }

    n = nativeFloor(n / 2);

    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseRepeat);

/***/ }),

/***/ 67269:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseRest.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity.js */ 80570);
/* harmony import */ var _overRest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_overRest.js */ 64702);
/* harmony import */ var _setToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setToString.js */ 20802);



/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest(func, start) {
  return (0,_setToString_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_overRest_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, start, _identity_js__WEBPACK_IMPORTED_MODULE_2__["default"]), func + '');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseRest);

/***/ }),

/***/ 48422:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseSet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_assignValue.js */ 21123);
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_castPath.js */ 63611);
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isIndex.js */ 89802);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_toKey.js */ 1564);





/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */

function baseSet(object, path, value, customizer) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return object;
  }

  path = (0,_castPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = (0,_toKey_js__WEBPACK_IMPORTED_MODULE_2__["default"])(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = (0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objValue) ? objValue : (0,_isIndex_js__WEBPACK_IMPORTED_MODULE_3__["default"])(path[index + 1]) ? [] : {};
      }
    }

    (0,_assignValue_js__WEBPACK_IMPORTED_MODULE_4__["default"])(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSet);

/***/ }),

/***/ 45529:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseSetToString.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ 19005);
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_defineProperty.js */ 45552);
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity.js */ 80570);



/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString = !_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"] : function (func, string) {
  return (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string),
    'writable': true
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSetToString);

/***/ }),

/***/ 76593:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseSlice.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }

  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSlice);

/***/ }),

/***/ 25201:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseSortBy.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);

  while (length--) {
    array[length] = array[length].value;
  }

  return array;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSortBy);

/***/ }),

/***/ 69459:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseSortedIndex.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSortedIndexBy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseSortedIndexBy.js */ 24568);
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity.js */ 80570);
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ 48455);



/** Used as references for the maximum length and index of an array. */

var MAX_ARRAY_LENGTH = 4294967295,
    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
/**
 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
 * performs a binary search of `array` to determine the index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */

function baseSortedIndex(array, value, retHighest) {
  var low = 0,
      high = array == null ? low : array.length;

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1,
          computed = array[mid];

      if (computed !== null && !(0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }

    return high;
  }

  return (0,_baseSortedIndexBy_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, value, _identity_js__WEBPACK_IMPORTED_MODULE_2__["default"], retHighest);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSortedIndex);

/***/ }),

/***/ 24568:
/*!******************************************************!*\
  !*** ./node_modules/lodash-es/_baseSortedIndexBy.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ 48455);

/** Used as references for the maximum length and index of an array. */

var MAX_ARRAY_LENGTH = 4294967295,
    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeFloor = Math.floor,
    nativeMin = Math.min;
/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */

function baseSortedIndexBy(array, value, iteratee, retHighest) {
  var low = 0,
      high = array == null ? 0 : array.length;

  if (high === 0) {
    return 0;
  }

  value = iteratee(value);
  var valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }

    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return nativeMin(high, MAX_ARRAY_INDEX);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSortedIndexBy);

/***/ }),

/***/ 56116:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseTimes.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseTimes);

/***/ }),

/***/ 33192:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseToString.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ 194);
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_arrayMap.js */ 66717);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isSymbol.js */ 48455);




/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value, baseToString) + '';
  }

  if ((0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseToString);

/***/ }),

/***/ 12695:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseTrim.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_trimmedEndIndex.js */ 51463);

/** Used to match leading whitespace. */

var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim(string) {
  return string ? string.slice(0, (0,_trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string) + 1).replace(reTrimStart, '') : string;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseTrim);

/***/ }),

/***/ 7560:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseUnary.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseUnary);

/***/ }),

/***/ 36857:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseUniq.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SetCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_SetCache.js */ 85675);
/* harmony import */ var _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayIncludes.js */ 79637);
/* harmony import */ var _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayIncludesWith.js */ 54540);
/* harmony import */ var _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_cacheHas.js */ 36149);
/* harmony import */ var _createSet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_createSet.js */ 12780);
/* harmony import */ var _setToArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_setToArray.js */ 92357);






/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : (0,_createSet_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array);

    if (set) {
      return (0,_setToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(set);
    }

    isCommon = false;
    includes = _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    seen = new _SetCache_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseUniq);

/***/ }),

/***/ 17381:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseValues.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayMap.js */ 66717);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues(object, props) {
  return (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"])(props, function (key) {
    return object[key];
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseValues);

/***/ }),

/***/ 36149:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_cacheHas.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cacheHas);

/***/ }),

/***/ 79225:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_castFunction.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ 80570);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */

function castFunction(value) {
  return typeof value == 'function' ? value : _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (castFunction);

/***/ }),

/***/ 63611:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_castPath.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isKey.js */ 17386);
/* harmony import */ var _stringToPath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringToPath.js */ 87728);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString.js */ 59191);




/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return value;
  }

  return (0,_isKey_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, object) ? [value] : (0,_stringToPath_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_toString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (castPath);

/***/ }),

/***/ 90221:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_castSlice.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSlice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseSlice.js */ 76593);

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */

function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return !start && end >= length ? array : (0,_baseSlice_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, start, end);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (castSlice);

/***/ }),

/***/ 57094:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_cloneArrayBuffer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Uint8Array.js */ 13410);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__["default"](result).set(new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__["default"](arrayBuffer));
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneArrayBuffer);

/***/ }),

/***/ 59097:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneBuffer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ 84261);

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneBuffer);

/***/ }),

/***/ 17674:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_cloneDataView.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ 57094);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */

function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? (0,_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneDataView);

/***/ }),

/***/ 43992:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneRegExp.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneRegExp);

/***/ }),

/***/ 64149:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneSymbol.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ 194);

/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneSymbol);

/***/ }),

/***/ 22856:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_cloneTypedArray.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ 57094);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? (0,_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneTypedArray);

/***/ }),

/***/ 84771:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_compareAscending.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ 48455);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */

function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (compareAscending);

/***/ }),

/***/ 30664:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_compareMultiple.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compareAscending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_compareAscending.js */ 84771);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */

function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = (0,_compareAscending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


  return object.index - other.index;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (compareMultiple);

/***/ }),

/***/ 77331:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_copyArray.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (copyArray);

/***/ }),

/***/ 1540:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_copyObject.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assignValue.js */ 21123);
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseAssignValue.js */ 67138);


/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key, newValue);
    } else {
      (0,_assignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, newValue);
    }
  }

  return object;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (copyObject);

/***/ }),

/***/ 14104:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_copySymbols.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ 1540);
/* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getSymbols.js */ 65175);


/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */

function copySymbols(source, object) {
  return (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, (0,_getSymbols_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (copySymbols);

/***/ }),

/***/ 64488:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_copySymbolsIn.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ 1540);
/* harmony import */ var _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getSymbolsIn.js */ 8065);


/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */

function copySymbolsIn(source, object) {
  return (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, (0,_getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (copySymbolsIn);

/***/ }),

/***/ 71948:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_coreJsData.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ 84261);

/** Used to detect overreaching core-js shims. */

var coreJsData = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"]["__core-js_shared__"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (coreJsData);

/***/ }),

/***/ 2549:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_createAggregator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayAggregator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayAggregator.js */ 64491);
/* harmony import */ var _baseAggregator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseAggregator.js */ 83052);
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseIteratee.js */ 22244);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ 17191);




/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */

function createAggregator(setter, initializer) {
  return function (collection, iteratee) {
    var func = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? _arrayAggregator_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _baseAggregator_js__WEBPACK_IMPORTED_MODULE_2__["default"],
        accumulator = initializer ? initializer() : {};
    return func(collection, setter, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_3__["default"])(iteratee, 2), accumulator);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createAggregator);

/***/ }),

/***/ 91034:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_createAssigner.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ 67269);
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isIterateeCall.js */ 49048);


/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner(assigner) {
  return (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createAssigner);

/***/ }),

/***/ 85062:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_createBaseEach.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ 83917);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!(0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createBaseEach);

/***/ }),

/***/ 78361:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_createBaseFor.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createBaseFor);

/***/ }),

/***/ 54737:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_createCaseFirst.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _castSlice_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_castSlice.js */ 90221);
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hasUnicode.js */ 82945);
/* harmony import */ var _stringToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringToArray.js */ 68108);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);




/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */

function createCaseFirst(methodName) {
  return function (string) {
    string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
    var strSymbols = (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string) ? (0,_stringToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string) : undefined;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? (0,_castSlice_js__WEBPACK_IMPORTED_MODULE_3__["default"])(strSymbols, 1).join('') : string.slice(1);
    return chr[methodName]() + trailing;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createCaseFirst);

/***/ }),

/***/ 42853:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_createCompounder.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayReduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayReduce.js */ 9751);
/* harmony import */ var _deburr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deburr.js */ 25747);
/* harmony import */ var _words_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./words.js */ 98222);



/** Used to compose unicode capture groups. */

var rsApos = "['\u2019]";
/** Used to match apostrophes. */

var reApos = RegExp(rsApos, 'g');
/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */

function createCompounder(callback) {
  return function (string) {
    return (0,_arrayReduce_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_words_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_deburr_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string).replace(reApos, '')), callback, '');
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createCompounder);

/***/ }),

/***/ 35517:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_createPadding.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseRepeat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseRepeat.js */ 4608);
/* harmony import */ var _baseToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseToString.js */ 33192);
/* harmony import */ var _castSlice_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_castSlice.js */ 90221);
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_hasUnicode.js */ 82945);
/* harmony import */ var _stringSize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringSize.js */ 32896);
/* harmony import */ var _stringToArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_stringToArray.js */ 68108);






/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeCeil = Math.ceil;
/**
 * Creates the padding for `string` based on `length`. The `chars` string
 * is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for `string`.
 */

function createPadding(length, chars) {
  chars = chars === undefined ? ' ' : (0,_baseToString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(chars);
  var charsLength = chars.length;

  if (charsLength < 2) {
    return charsLength ? (0,_baseRepeat_js__WEBPACK_IMPORTED_MODULE_1__["default"])(chars, length) : chars;
  }

  var result = (0,_baseRepeat_js__WEBPACK_IMPORTED_MODULE_1__["default"])(chars, nativeCeil(length / (0,_stringSize_js__WEBPACK_IMPORTED_MODULE_2__["default"])(chars)));
  return (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(chars) ? (0,_castSlice_js__WEBPACK_IMPORTED_MODULE_4__["default"])((0,_stringToArray_js__WEBPACK_IMPORTED_MODULE_5__["default"])(result), 0, length).join('') : result.slice(0, length);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createPadding);

/***/ }),

/***/ 12780:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_createSet.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Set_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Set.js */ 63538);
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop.js */ 14403);
/* harmony import */ var _setToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setToArray.js */ 92357);



/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(_Set_js__WEBPACK_IMPORTED_MODULE_0__["default"] && 1 / (0,_setToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(new _Set_js__WEBPACK_IMPORTED_MODULE_0__["default"]([, -0]))[1] == INFINITY) ? _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"] : function (values) {
  return new _Set_js__WEBPACK_IMPORTED_MODULE_0__["default"](values);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSet);

/***/ }),

/***/ 45824:
/*!***********************************************************!*\
  !*** ./node_modules/lodash-es/_customDefaultsAssignIn.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq.js */ 36802);

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || (0,_eq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (customDefaultsAssignIn);

/***/ }),

/***/ 95089:
/*!********************************************************!*\
  !*** ./node_modules/lodash-es/_customDefaultsMerge.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseMerge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseMerge.js */ 55226);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);


/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
 * objects into destination objects that are passed thru.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objValue) && (0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    (0,_baseMerge_js__WEBPACK_IMPORTED_MODULE_1__["default"])(objValue, srcValue, undefined, customDefaultsMerge, stack);
    stack['delete'](srcValue);
  }

  return objValue;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (customDefaultsMerge);

/***/ }),

/***/ 40807:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_deburrLetter.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basePropertyOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_basePropertyOf.js */ 30195);

/** Used to map Latin Unicode letters to basic Latin letters. */

var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',
  '\xc1': 'A',
  '\xc2': 'A',
  '\xc3': 'A',
  '\xc4': 'A',
  '\xc5': 'A',
  '\xe0': 'a',
  '\xe1': 'a',
  '\xe2': 'a',
  '\xe3': 'a',
  '\xe4': 'a',
  '\xe5': 'a',
  '\xc7': 'C',
  '\xe7': 'c',
  '\xd0': 'D',
  '\xf0': 'd',
  '\xc8': 'E',
  '\xc9': 'E',
  '\xca': 'E',
  '\xcb': 'E',
  '\xe8': 'e',
  '\xe9': 'e',
  '\xea': 'e',
  '\xeb': 'e',
  '\xcc': 'I',
  '\xcd': 'I',
  '\xce': 'I',
  '\xcf': 'I',
  '\xec': 'i',
  '\xed': 'i',
  '\xee': 'i',
  '\xef': 'i',
  '\xd1': 'N',
  '\xf1': 'n',
  '\xd2': 'O',
  '\xd3': 'O',
  '\xd4': 'O',
  '\xd5': 'O',
  '\xd6': 'O',
  '\xd8': 'O',
  '\xf2': 'o',
  '\xf3': 'o',
  '\xf4': 'o',
  '\xf5': 'o',
  '\xf6': 'o',
  '\xf8': 'o',
  '\xd9': 'U',
  '\xda': 'U',
  '\xdb': 'U',
  '\xdc': 'U',
  '\xf9': 'u',
  '\xfa': 'u',
  '\xfb': 'u',
  '\xfc': 'u',
  '\xdd': 'Y',
  '\xfd': 'y',
  '\xff': 'y',
  '\xc6': 'Ae',
  '\xe6': 'ae',
  '\xde': 'Th',
  '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',
  '\u0102': 'A',
  '\u0104': 'A',
  '\u0101': 'a',
  '\u0103': 'a',
  '\u0105': 'a',
  '\u0106': 'C',
  '\u0108': 'C',
  '\u010a': 'C',
  '\u010c': 'C',
  '\u0107': 'c',
  '\u0109': 'c',
  '\u010b': 'c',
  '\u010d': 'c',
  '\u010e': 'D',
  '\u0110': 'D',
  '\u010f': 'd',
  '\u0111': 'd',
  '\u0112': 'E',
  '\u0114': 'E',
  '\u0116': 'E',
  '\u0118': 'E',
  '\u011a': 'E',
  '\u0113': 'e',
  '\u0115': 'e',
  '\u0117': 'e',
  '\u0119': 'e',
  '\u011b': 'e',
  '\u011c': 'G',
  '\u011e': 'G',
  '\u0120': 'G',
  '\u0122': 'G',
  '\u011d': 'g',
  '\u011f': 'g',
  '\u0121': 'g',
  '\u0123': 'g',
  '\u0124': 'H',
  '\u0126': 'H',
  '\u0125': 'h',
  '\u0127': 'h',
  '\u0128': 'I',
  '\u012a': 'I',
  '\u012c': 'I',
  '\u012e': 'I',
  '\u0130': 'I',
  '\u0129': 'i',
  '\u012b': 'i',
  '\u012d': 'i',
  '\u012f': 'i',
  '\u0131': 'i',
  '\u0134': 'J',
  '\u0135': 'j',
  '\u0136': 'K',
  '\u0137': 'k',
  '\u0138': 'k',
  '\u0139': 'L',
  '\u013b': 'L',
  '\u013d': 'L',
  '\u013f': 'L',
  '\u0141': 'L',
  '\u013a': 'l',
  '\u013c': 'l',
  '\u013e': 'l',
  '\u0140': 'l',
  '\u0142': 'l',
  '\u0143': 'N',
  '\u0145': 'N',
  '\u0147': 'N',
  '\u014a': 'N',
  '\u0144': 'n',
  '\u0146': 'n',
  '\u0148': 'n',
  '\u014b': 'n',
  '\u014c': 'O',
  '\u014e': 'O',
  '\u0150': 'O',
  '\u014d': 'o',
  '\u014f': 'o',
  '\u0151': 'o',
  '\u0154': 'R',
  '\u0156': 'R',
  '\u0158': 'R',
  '\u0155': 'r',
  '\u0157': 'r',
  '\u0159': 'r',
  '\u015a': 'S',
  '\u015c': 'S',
  '\u015e': 'S',
  '\u0160': 'S',
  '\u015b': 's',
  '\u015d': 's',
  '\u015f': 's',
  '\u0161': 's',
  '\u0162': 'T',
  '\u0164': 'T',
  '\u0166': 'T',
  '\u0163': 't',
  '\u0165': 't',
  '\u0167': 't',
  '\u0168': 'U',
  '\u016a': 'U',
  '\u016c': 'U',
  '\u016e': 'U',
  '\u0170': 'U',
  '\u0172': 'U',
  '\u0169': 'u',
  '\u016b': 'u',
  '\u016d': 'u',
  '\u016f': 'u',
  '\u0171': 'u',
  '\u0173': 'u',
  '\u0174': 'W',
  '\u0175': 'w',
  '\u0176': 'Y',
  '\u0177': 'y',
  '\u0178': 'Y',
  '\u0179': 'Z',
  '\u017b': 'Z',
  '\u017d': 'Z',
  '\u017a': 'z',
  '\u017c': 'z',
  '\u017e': 'z',
  '\u0132': 'IJ',
  '\u0133': 'ij',
  '\u0152': 'Oe',
  '\u0153': 'oe',
  '\u0149': "'n",
  '\u017f': 's'
};
/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */

var deburrLetter = (0,_basePropertyOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(deburredLetters);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deburrLetter);

/***/ }),

/***/ 45552:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_defineProperty.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ 94727);


var defineProperty = function () {
  try {
    var func = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defineProperty);

/***/ }),

/***/ 8377:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_equalArrays.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SetCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_SetCache.js */ 85675);
/* harmony import */ var _arraySome_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arraySome.js */ 40760);
/* harmony import */ var _cacheHas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cacheHas.js */ 36149);



/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!(0,_arraySome_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other, function (othValue, othIndex) {
        if (!(0,_cacheHas_js__WEBPACK_IMPORTED_MODULE_2__["default"])(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (equalArrays);

/***/ }),

/***/ 81541:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_equalByTag.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ 194);
/* harmony import */ var _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Uint8Array.js */ 13410);
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./eq.js */ 36802);
/* harmony import */ var _equalArrays_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_equalArrays.js */ 8377);
/* harmony import */ var _mapToArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_mapToArray.js */ 58874);
/* harmony import */ var _setToArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_setToArray.js */ 92357);






/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__["default"](object), new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__["default"](other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return (0,_eq_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = _mapToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"];

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = _setToArray_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = (0,_equalArrays_js__WEBPACK_IMPORTED_MODULE_5__["default"])(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (equalByTag);

/***/ }),

/***/ 49795:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_equalObjects.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getAllKeys.js */ 11922);

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = (0,_getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object),
      objLength = objProps.length,
      othProps = (0,_getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (equalObjects);

/***/ }),

/***/ 43253:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_escapeHtmlChar.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basePropertyOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_basePropertyOf.js */ 30195);

/** Used to map characters to HTML entities. */

var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = (0,_basePropertyOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(htmlEscapes);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (escapeHtmlChar);

/***/ }),

/***/ 45897:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_escapeStringChar.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (escapeStringChar);

/***/ }),

/***/ 6527:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_flatRest.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flatten.js */ 22109);
/* harmony import */ var _overRest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_overRest.js */ 64702);
/* harmony import */ var _setToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setToString.js */ 20802);



/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */

function flatRest(func) {
  return (0,_setToString_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_overRest_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, undefined, _flatten_js__WEBPACK_IMPORTED_MODULE_2__["default"]), func + '');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (flatRest);

/***/ }),

/***/ 86380:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_freeGlobal.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (freeGlobal);

/***/ }),

/***/ 11922:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getAllKeys.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetAllKeys.js */ 6288);
/* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getSymbols.js */ 65175);
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ 24876);



/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return (0,_baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, _keys_js__WEBPACK_IMPORTED_MODULE_1__["default"], _getSymbols_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getAllKeys);

/***/ }),

/***/ 24173:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getAllKeysIn.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetAllKeys.js */ 6288);
/* harmony import */ var _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getSymbolsIn.js */ 8065);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keysIn.js */ 39274);



/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeysIn(object) {
  return (0,_baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, _keysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"], _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getAllKeysIn);

/***/ }),

/***/ 77659:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getMapData.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isKeyable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isKeyable.js */ 37097);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return (0,_isKeyable_js__WEBPACK_IMPORTED_MODULE_0__["default"])(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getMapData);

/***/ }),

/***/ 84722:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getMatchData.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isStrictComparable.js */ 80604);
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ 24876);


/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData(object) {
  var result = (0,_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, (0,_isStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)];
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getMatchData);

/***/ }),

/***/ 94727:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getNative.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsNative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIsNative.js */ 88831);
/* harmony import */ var _getValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getValue.js */ 79100);


/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = (0,_getValue_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key);
  return (0,_baseIsNative_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) ? value : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getNative);

/***/ }),

/***/ 70118:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getPrototype.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_overArg.js */ 76854);

/** Built-in value references. */

var getPrototype = (0,_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.getPrototypeOf, Object);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getPrototype);

/***/ }),

/***/ 33521:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getRawTag.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ 194);

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRawTag);

/***/ }),

/***/ 65175:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getSymbols.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayFilter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayFilter.js */ 28468);
/* harmony import */ var _stubArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stubArray.js */ 30709);


/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? _stubArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return (0,_arrayFilter_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSymbols);

/***/ }),

/***/ 8065:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getSymbolsIn.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayPush.js */ 82784);
/* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_getPrototype.js */ 70118);
/* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getSymbols.js */ 65175);
/* harmony import */ var _stubArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stubArray.js */ 30709);




/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? _stubArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] : function (object) {
  var result = [];

  while (object) {
    (0,_arrayPush_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, (0,_getSymbols_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object));
    object = (0,_getPrototype_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object);
  }

  return result;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSymbolsIn);

/***/ }),

/***/ 33221:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_getTag.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_DataView.js */ 28230);
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_Map.js */ 83686);
/* harmony import */ var _Promise_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_Promise.js */ 69420);
/* harmony import */ var _Set_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_Set.js */ 63538);
/* harmony import */ var _WeakMap_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_WeakMap.js */ 57571);
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _toSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_toSource.js */ 66018);







/** `Object#toString` result references. */

var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
    mapCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Map_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
    promiseCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
    setCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Set_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
    weakMapCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = _baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__["default"]; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (_DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"] && getTag(new _DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"](new ArrayBuffer(1))) != dataViewTag || _Map_js__WEBPACK_IMPORTED_MODULE_2__["default"] && getTag(new _Map_js__WEBPACK_IMPORTED_MODULE_2__["default"]()) != mapTag || _Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"] && getTag(_Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"].resolve()) != promiseTag || _Set_js__WEBPACK_IMPORTED_MODULE_4__["default"] && getTag(new _Set_js__WEBPACK_IMPORTED_MODULE_4__["default"]()) != setTag || _WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"] && getTag(new _WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"]()) != weakMapTag) {
  getTag = function (value) {
    var result = (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getTag);

/***/ }),

/***/ 79100:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_getValue.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getValue);

/***/ }),

/***/ 40522:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hasPath.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_castPath.js */ 63611);
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isArguments.js */ 3056);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isIndex.js */ 89802);
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLength.js */ 75227);
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toKey.js */ 1564);






/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */

function hasPath(object, path, hasFunc) {
  path = (0,_castPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = (0,_toKey_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && (0,_isLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(length) && (0,_isIndex_js__WEBPACK_IMPORTED_MODULE_3__["default"])(key, length) && ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasPath);

/***/ }),

/***/ 82945:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_hasUnicode.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';
/** Used to compose unicode capture groups. */

var rsZWJ = '\\u200d';
/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */

function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasUnicode);

/***/ }),

/***/ 37801:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_hasUnicodeWord.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */

function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasUnicodeWord);

/***/ }),

/***/ 35606:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_hashClear.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ 22538);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? (0,_nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(null) : {};
  this.size = 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashClear);

/***/ }),

/***/ 65168:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_hashDelete.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashDelete);

/***/ }),

/***/ 51099:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashGet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ 22538);

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (_nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashGet);

/***/ }),

/***/ 86920:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashHas.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ 22538);

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashHas);

/***/ }),

/***/ 65689:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashSet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ 22538);

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashSet);

/***/ }),

/***/ 13530:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneArray.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initCloneArray);

/***/ }),

/***/ 84191:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneByTag.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ 57094);
/* harmony import */ var _cloneDataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_cloneDataView.js */ 17674);
/* harmony import */ var _cloneRegExp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_cloneRegExp.js */ 43992);
/* harmony import */ var _cloneSymbol_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_cloneSymbol.js */ 64149);
/* harmony import */ var _cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cloneTypedArray.js */ 22856);





/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return (0,_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return (0,_cloneDataView_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return (0,_cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return (0,_cloneRegExp_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return (0,_cloneSymbol_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initCloneByTag);

/***/ }),

/***/ 65914:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneObject.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseCreate.js */ 8722);
/* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getPrototype.js */ 70118);
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isPrototype.js */ 5908);



/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !(0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object) ? (0,_baseCreate_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_getPrototype_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object)) : {};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initCloneObject);

/***/ }),

/***/ 3981:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_isFlattenable.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ 194);
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArguments.js */ 3056);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ 17191);



/** Built-in value references. */

var spreadableSymbol = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFlattenable);

/***/ }),

/***/ 89802:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_isIndex.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isIndex);

/***/ }),

/***/ 49048:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_isIterateeCall.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eq.js */ 36802);
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArrayLike.js */ 83917);
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isIndex.js */ 89802);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);




/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall(value, index, object) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object) && (0,_isIndex_js__WEBPACK_IMPORTED_MODULE_2__["default"])(index, object.length) : type == 'string' && index in object) {
    return (0,_eq_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object[index], value);
  }

  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isIterateeCall);

/***/ }),

/***/ 17386:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_isKey.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isSymbol.js */ 48455);


/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isKey);

/***/ }),

/***/ 37097:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_isKeyable.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isKeyable);

/***/ }),

/***/ 8260:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_isMasked.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_coreJsData.js */ 71948);

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(_coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"].keys && _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"].keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isMasked);

/***/ }),

/***/ 5908:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_isPrototype.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPrototype);

/***/ }),

/***/ 80604:
/*!*******************************************************!*\
  !*** ./node_modules/lodash-es/_isStrictComparable.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable(value) {
  return value === value && !(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isStrictComparable);

/***/ }),

/***/ 15909:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheClear.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheClear);

/***/ }),

/***/ 48380:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheDelete.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ 84311);

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = (0,_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheDelete);

/***/ }),

/***/ 81129:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheGet.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ 84311);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = (0,_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);
  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheGet);

/***/ }),

/***/ 73503:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheHas.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ 84311);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return (0,_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this.__data__, key) > -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheHas);

/***/ }),

/***/ 98643:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheSet.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ 84311);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = (0,_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheSet);

/***/ }),

/***/ 74305:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheClear.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Hash.js */ 14181);
/* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_ListCache.js */ 95751);
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Map.js */ 83686);



/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash_js__WEBPACK_IMPORTED_MODULE_0__["default"](),
    'map': new (_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"] || _ListCache_js__WEBPACK_IMPORTED_MODULE_2__["default"])(),
    'string': new _Hash_js__WEBPACK_IMPORTED_MODULE_0__["default"]()
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheClear);

/***/ }),

/***/ 82579:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheDelete.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ 77659);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = (0,_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheDelete);

/***/ }),

/***/ 44933:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheGet.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ 77659);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return (0,_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key).get(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheGet);

/***/ }),

/***/ 13624:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheHas.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ 77659);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return (0,_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key).has(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheHas);

/***/ }),

/***/ 83392:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheSet.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ 77659);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = (0,_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheSet);

/***/ }),

/***/ 58874:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_mapToArray.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapToArray);

/***/ }),

/***/ 71458:
/*!************************************************************!*\
  !*** ./node_modules/lodash-es/_matchesStrictComparable.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (matchesStrictComparable);

/***/ }),

/***/ 18365:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_memoizeCapped.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memoize.js */ 16284);

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = (0,_memoize_js__WEBPACK_IMPORTED_MODULE_0__["default"])(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoizeCapped);

/***/ }),

/***/ 22538:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_nativeCreate.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ 94727);

/* Built-in method references that are verified to be native. */

var nativeCreate = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object, 'create');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nativeCreate);

/***/ }),

/***/ 70081:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeys.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_overArg.js */ 76854);

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = (0,_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.keys, Object);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nativeKeys);

/***/ }),

/***/ 48242:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeysIn.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nativeKeysIn);

/***/ }),

/***/ 25986:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_nodeUtil.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ 86380);

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"].process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nodeUtil);

/***/ }),

/***/ 62820:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_objectToString.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (objectToString);

/***/ }),

/***/ 76854:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_overArg.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (overArg);

/***/ }),

/***/ 64702:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_overRest.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _apply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_apply.js */ 49419);

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return (0,_apply_js__WEBPACK_IMPORTED_MODULE_0__["default"])(func, this, otherArgs);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (overRest);

/***/ }),

/***/ 96610:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_reEscape.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reEscape);

/***/ }),

/***/ 79350:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_reEvaluate.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reEvaluate);

/***/ }),

/***/ 81704:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_reInterpolate.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reInterpolate);

/***/ }),

/***/ 84261:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_root.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ 86380);

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"] || freeSelf || Function('return this')();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (root);

/***/ }),

/***/ 42812:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_safeGet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (safeGet);

/***/ }),

/***/ 31622:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_setCacheAdd.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setCacheAdd);

/***/ }),

/***/ 18403:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_setCacheHas.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setCacheHas);

/***/ }),

/***/ 92357:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_setToArray.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setToArray);

/***/ }),

/***/ 20802:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_setToString.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSetToString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseSetToString.js */ 45529);
/* harmony import */ var _shortOut_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shortOut.js */ 73092);


/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = (0,_shortOut_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_baseSetToString_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setToString);

/***/ }),

/***/ 73092:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_shortOut.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shortOut);

/***/ }),

/***/ 78792:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_stackClear.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ 95751);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
  this.size = 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackClear);

/***/ }),

/***/ 73459:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_stackDelete.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackDelete);

/***/ }),

/***/ 11138:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackGet.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackGet);

/***/ }),

/***/ 15188:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackHas.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackHas);

/***/ }),

/***/ 87079:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackSet.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ 95751);
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Map.js */ 83686);
/* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_MapCache.js */ 12733);



/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    var pairs = data.__data__;

    if (!_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"] || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new _MapCache_js__WEBPACK_IMPORTED_MODULE_2__["default"](pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackSet);

/***/ }),

/***/ 35161:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_strictIndexOf.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (strictIndexOf);

/***/ }),

/***/ 32896:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_stringSize.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asciiSize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_asciiSize.js */ 37045);
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hasUnicode.js */ 82945);
/* harmony import */ var _unicodeSize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_unicodeSize.js */ 85356);



/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */

function stringSize(string) {
  return (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string) ? (0,_unicodeSize_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string) : (0,_asciiSize_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringSize);

/***/ }),

/***/ 68108:
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_stringToArray.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asciiToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_asciiToArray.js */ 10650);
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hasUnicode.js */ 82945);
/* harmony import */ var _unicodeToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_unicodeToArray.js */ 50241);



/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */

function stringToArray(string) {
  return (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string) ? (0,_unicodeToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string) : (0,_asciiToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringToArray);

/***/ }),

/***/ 87728:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_stringToPath.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _memoizeCapped_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_memoizeCapped.js */ 18365);

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = (0,_memoizeCapped_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringToPath);

/***/ }),

/***/ 1564:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_toKey.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ 48455);

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toKey);

/***/ }),

/***/ 66018:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_toSource.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toSource);

/***/ }),

/***/ 51463:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_trimmedEndIndex.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (trimmedEndIndex);

/***/ }),

/***/ 4732:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_unescapeHtmlChar.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basePropertyOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_basePropertyOf.js */ 30195);

/** Used to map HTML entities to characters. */

var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'"
};
/**
 * Used by `_.unescape` to convert HTML entities to characters.
 *
 * @private
 * @param {string} chr The matched character to unescape.
 * @returns {string} Returns the unescaped character.
 */

var unescapeHtmlChar = (0,_basePropertyOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(htmlUnescapes);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unescapeHtmlChar);

/***/ }),

/***/ 85356:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_unicodeSize.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */

function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;

  while (reUnicode.test(string)) {
    ++result;
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unicodeSize);

/***/ }),

/***/ 50241:
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_unicodeToArray.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */

function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unicodeToArray);

/***/ }),

/***/ 53437:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_unicodeWords.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
/** Used to compose unicode capture groups. */

var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';
/** Used to compose unicode regexes. */

var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;
/** Used to match complex or compound words. */

var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */

function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unicodeWords);

/***/ }),

/***/ 57607:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/assignIn.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_copyObject.js */ 1540);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ 91034);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keysIn.js */ 39274);



/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */

var assignIn = (0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (object, source) {
  (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source, (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(source), object);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assignIn);

/***/ }),

/***/ 76228:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/assignInWith.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_copyObject.js */ 1540);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ 91034);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keysIn.js */ 39274);



/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var assignInWith = (0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (object, source, srcIndex, customizer) {
  (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source, (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(source), object, customizer);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assignInWith);

/***/ }),

/***/ 44331:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/attempt.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _apply_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_apply.js */ 49419);
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ 67269);
/* harmony import */ var _isError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isError.js */ 57259);



/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */

var attempt = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (func, args) {
  try {
    return (0,_apply_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, undefined, args);
  } catch (e) {
    return (0,_isError_js__WEBPACK_IMPORTED_MODULE_2__["default"])(e) ? e : new Error(e);
  }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (attempt);

/***/ }),

/***/ 37542:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/before.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toInteger.js */ 26011);

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */

function before(n, func) {
  var result;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  n = (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n);
  return function () {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }

    if (n <= 1) {
      func = undefined;
    }

    return result;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (before);

/***/ }),

/***/ 13870:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/camelCase.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _capitalize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./capitalize.js */ 83434);
/* harmony import */ var _createCompounder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCompounder.js */ 42853);


/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */

var camelCase = (0,_createCompounder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (result, word, index) {
  word = word.toLowerCase();
  return result + (index ? (0,_capitalize_js__WEBPACK_IMPORTED_MODULE_1__["default"])(word) : word);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (camelCase);

/***/ }),

/***/ 83434:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/capitalize.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toString.js */ 59191);
/* harmony import */ var _upperFirst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./upperFirst.js */ 93284);


/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */

function capitalize(string) {
  return (0,_upperFirst_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_toString_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string).toLowerCase());
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (capitalize);

/***/ }),

/***/ 16450:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/clamp.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseClamp.js */ 12416);
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber.js */ 79034);


/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */

function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }

  if (upper !== undefined) {
    upper = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(upper);
    upper = upper === upper ? upper : 0;
  }

  if (lower !== undefined) {
    lower = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(lower);
    lower = lower === lower ? lower : 0;
  }

  return (0,_baseClamp_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(number), lower, upper);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clamp);

/***/ }),

/***/ 27746:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/clone.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClone.js */ 19702);

/** Used to compose bitmasks for cloning. */

var CLONE_SYMBOLS_FLAG = 4;
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */

function clone(value) {
  return (0,_baseClone_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clone);

/***/ }),

/***/ 38163:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/cloneDeep.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClone.js */ 19702);

/** Used to compose bitmasks for cloning. */

var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */

function cloneDeep(value) {
  return (0,_baseClone_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneDeep);

/***/ }),

/***/ 19005:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/constant.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (constant);

/***/ }),

/***/ 88673:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/debounce.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./now.js */ 80600);
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber.js */ 79034);



/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */

function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(wait) || 0;

  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax((0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge((0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  }

  function debounced() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debounce);

/***/ }),

/***/ 25747:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/deburr.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _deburrLetter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_deburrLetter.js */ 40807);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);


/** Used to match Latin Unicode letters (excluding mathematical operators). */

var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
/** Used to compose unicode character classes. */

var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
/** Used to compose unicode capture groups. */

var rsCombo = '[' + rsComboRange + ']';
/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */

var reComboMark = RegExp(rsCombo, 'g');
/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */

function deburr(string) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  return string && string.replace(reLatin, _deburrLetter_js__WEBPACK_IMPORTED_MODULE_1__["default"]).replace(reComboMark, '');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deburr);

/***/ }),

/***/ 50280:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/defaults.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ 67269);
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eq.js */ 36802);
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isIterateeCall.js */ 49048);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keysIn.js */ 39274);




/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var defaults = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (object, sources) {
  object = Object(object);
  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined || (0,_eq_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        object[key] = source[key];
      }
    }
  }

  return object;
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaults);

/***/ }),

/***/ 92078:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/defaultsDeep.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _apply_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_apply.js */ 49419);
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ 67269);
/* harmony import */ var _customDefaultsMerge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_customDefaultsMerge.js */ 95089);
/* harmony import */ var _mergeWith_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mergeWith.js */ 69626);




/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */

var defaultsDeep = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (args) {
  args.push(undefined, _customDefaultsMerge_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return (0,_apply_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_mergeWith_js__WEBPACK_IMPORTED_MODULE_3__["default"], undefined, args);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaultsDeep);

/***/ }),

/***/ 33068:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/defer.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseDelay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseDelay.js */ 63189);
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ 67269);


/**
 * Defers invoking the `func` until the current call stack has cleared. Any
 * additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to defer.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.defer(function(text) {
 *   console.log(text);
 * }, 'deferred');
 * // => Logs 'deferred' after one millisecond.
 */

var defer = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (func, args) {
  return (0,_baseDelay_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, 1, args);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defer);

/***/ }),

/***/ 84251:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/difference.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseDifference_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseDifference.js */ 12774);
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseFlatten.js */ 43932);
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ 67269);
/* harmony import */ var _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArrayLikeObject.js */ 69275);




/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */

var difference = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (array, values) {
  return (0,_isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array) ? (0,_baseDifference_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 1, _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__["default"], true)) : [];
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (difference);

/***/ }),

/***/ 754:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/endsWith.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClamp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseClamp.js */ 12416);
/* harmony import */ var _baseToString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseToString.js */ 33192);
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toInteger.js */ 26011);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);




/**
 * Checks if `string` ends with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=string.length] The position to search up to.
 * @returns {boolean} Returns `true` if `string` ends with `target`,
 *  else `false`.
 * @example
 *
 * _.endsWith('abc', 'c');
 * // => true
 *
 * _.endsWith('abc', 'b');
 * // => false
 *
 * _.endsWith('abc', 'b', 2);
 * // => true
 */

function endsWith(string, target, position) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  target = (0,_baseToString_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target);
  var length = string.length;
  position = position === undefined ? length : (0,_baseClamp_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_toInteger_js__WEBPACK_IMPORTED_MODULE_3__["default"])(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (endsWith);

/***/ }),

/***/ 36802:
/*!**************************************!*\
  !*** ./node_modules/lodash-es/eq.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (eq);

/***/ }),

/***/ 16459:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/escape.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _escapeHtmlChar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_escapeHtmlChar.js */ 43253);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);


/** Used to match HTML entities and HTML characters. */

var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, _escapeHtmlChar_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : string;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (escape);

/***/ }),

/***/ 22109:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/flatten.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFlatten.js */ 43932);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */

function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, 1) : [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (flatten);

/***/ }),

/***/ 19167:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/forIn.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFor.js */ 58601);
/* harmony import */ var _castFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_castFunction.js */ 79225);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keysIn.js */ 39274);



/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */

function forIn(object, iteratee) {
  return object == null ? object : (0,_baseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, (0,_castFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee), _keysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (forIn);

/***/ }),

/***/ 94894:
/*!***************************************!*\
  !*** ./node_modules/lodash-es/get.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGet.js */ 90202);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : (0,_baseGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (get);

/***/ }),

/***/ 69466:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/groupBy.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseAssignValue.js */ 67138);
/* harmony import */ var _createAggregator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAggregator.js */ 2549);


/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */

var groupBy = (0,_createAggregator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key, [value]);
  }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (groupBy);

/***/ }),

/***/ 92941:
/*!***************************************!*\
  !*** ./node_modules/lodash-es/has.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseHas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseHas.js */ 87173);
/* harmony import */ var _hasPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hasPath.js */ 40522);


/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */

function has(object, path) {
  return object != null && (0,_hasPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path, _baseHas_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (has);

/***/ }),

/***/ 38189:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/hasIn.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseHasIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseHasIn.js */ 82779);
/* harmony import */ var _hasPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hasPath.js */ 40522);


/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */

function hasIn(object, path) {
  return object != null && (0,_hasPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path, _baseHasIn_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasIn);

/***/ }),

/***/ 80570:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/identity.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (identity);

/***/ }),

/***/ 10601:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/inRange.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseInRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseInRange.js */ 19636);
/* harmony import */ var _toFinite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFinite.js */ 46503);
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toNumber.js */ 79034);



/**
 * Checks if `n` is between `start` and up to, but not including, `end`. If
 * `end` is not specified, it's set to `start` with `start` then set to `0`.
 * If `start` is greater than `end` the params are swapped to support
 * negative ranges.
 *
 * @static
 * @memberOf _
 * @since 3.3.0
 * @category Number
 * @param {number} number The number to check.
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 * @see _.range, _.rangeRight
 * @example
 *
 * _.inRange(3, 2, 4);
 * // => true
 *
 * _.inRange(4, 8);
 * // => true
 *
 * _.inRange(4, 2);
 * // => false
 *
 * _.inRange(2, 2);
 * // => false
 *
 * _.inRange(1.2, 2);
 * // => true
 *
 * _.inRange(5.2, 4);
 * // => false
 *
 * _.inRange(-3, -2, -6);
 * // => true
 */

function inRange(number, start, end) {
  start = (0,_toFinite_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start);

  if (end === undefined) {
    end = start;
    start = 0;
  } else {
    end = (0,_toFinite_js__WEBPACK_IMPORTED_MODULE_0__["default"])(end);
  }

  number = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_1__["default"])(number);
  return (0,_baseInRange_js__WEBPACK_IMPORTED_MODULE_2__["default"])(number, start, end);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (inRange);

/***/ }),

/***/ 3056:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArguments.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsArguments.js */ 35387);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = (0,_baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  return arguments;
}()) ? _baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"] : function (value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArguments);

/***/ }),

/***/ 17191:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isArray.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArray);

/***/ }),

/***/ 83917:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArrayLike.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ 15849);
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isLength.js */ 75227);


/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && (0,_isLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.length) && !(0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArrayLike);

/***/ }),

/***/ 69275:
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/isArrayLikeObject.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArrayLike.js */ 83917);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArrayLikeObject);

/***/ }),

/***/ 96195:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/isBoolean.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/** `Object#toString` result references. */

var boolTag = '[object Boolean]';
/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */

function isBoolean(value) {
  return value === true || value === false || (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == boolTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isBoolean);

/***/ }),

/***/ 28057:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isBuffer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ 84261);
/* harmony import */ var _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stubFalse.js */ 94326);


/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isBuffer);

/***/ }),

/***/ 34607:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isEmpty.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseKeys_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_baseKeys.js */ 962);
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_getTag.js */ 33221);
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isArguments.js */ 3056);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ 83917);
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isBuffer.js */ 28057);
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_isPrototype.js */ 5908);
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTypedArray.js */ 46716);








/** `Object#toString` result references. */

var mapTag = '[object Map]',
    setTag = '[object Set]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */

function isEmpty(value) {
  if (value == null) {
    return true;
  }

  if ((0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) || typeof value == 'string' || typeof value.splice == 'function' || (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value))) {
    return !value.length;
  }

  var tag = (0,_getTag_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);

  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }

  if ((0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value)) {
    return !(0,_baseKeys_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value).length;
  }

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }

  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isEmpty);

/***/ }),

/***/ 63247:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isEqual.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsEqual.js */ 76603);

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */

function isEqual(value, other) {
  return (0,_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, other);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isEqual);

/***/ }),

/***/ 57259:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isError.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);
/* harmony import */ var _isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isPlainObject.js */ 8978);



/** `Object#toString` result references. */

var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!(0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return false;
  }

  var tag = (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
  return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !(0,_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isError);

/***/ }),

/***/ 48961:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isFinite.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ 84261);

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsFinite = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFinite;
/**
 * Checks if `value` is a finite primitive number.
 *
 * **Note:** This method is based on
 * [`Number.isFinite`](https://mdn.io/Number/isFinite).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
 * @example
 *
 * _.isFinite(3);
 * // => true
 *
 * _.isFinite(Number.MIN_VALUE);
 * // => true
 *
 * _.isFinite(Infinity);
 * // => false
 *
 * _.isFinite('3');
 * // => false
 */

function isFinite(value) {
  return typeof value == 'number' && nativeIsFinite(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFinite);

/***/ }),

/***/ 15849:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/isFunction.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);


/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFunction);

/***/ }),

/***/ 81663:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/isInteger.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toInteger.js */ 26011);

/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */

function isInteger(value) {
  return typeof value == 'number' && value == (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isInteger);

/***/ }),

/***/ 75227:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isLength.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isLength);

/***/ }),

/***/ 5088:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/isMap.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsMap.js */ 44774);
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ 7560);
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ 25986);



/* Node.js helper references. */

var nodeIsMap = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsMap) : _baseIsMap_js__WEBPACK_IMPORTED_MODULE_2__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isMap);

/***/ }),

/***/ 60560:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/isNaN.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isNumber.js */ 65735);

/**
 * Checks if `value` is `NaN`.
 *
 * **Note:** This method is based on
 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
 * `undefined` and other non-number values.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 * @example
 *
 * _.isNaN(NaN);
 * // => true
 *
 * _.isNaN(new Number(NaN));
 * // => true
 *
 * isNaN(undefined);
 * // => true
 *
 * _.isNaN(undefined);
 * // => false
 */

function isNaN(value) {
  // An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return (0,_isNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && value != +value;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isNaN);

/***/ }),

/***/ 55421:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/isNil.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isNil);

/***/ }),

/***/ 48172:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/isNull.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isNull);

/***/ }),

/***/ 65735:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isNumber.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/** `Object#toString` result references. */

var numberTag = '[object Number]';
/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */

function isNumber(value) {
  return typeof value == 'number' || (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == numberTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isNumber);

/***/ }),

/***/ 19089:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isObject.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObject);

/***/ }),

/***/ 86567:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isObjectLike.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObjectLike);

/***/ }),

/***/ 8978:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/isPlainObject.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getPrototype.js */ 70118);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);



/** `Object#toString` result references. */

var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!(0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) || (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) != objectTag) {
    return false;
  }

  var proto = (0,_getPrototype_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPlainObject);

/***/ }),

/***/ 21817:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isRegExp.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsRegExp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsRegExp.js */ 44351);
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ 7560);
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ 25986);



/* Node.js helper references. */

var nodeIsRegExp = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp;
/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */

var isRegExp = nodeIsRegExp ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsRegExp) : _baseIsRegExp_js__WEBPACK_IMPORTED_MODULE_2__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isRegExp);

/***/ }),

/***/ 38804:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/isSafeInteger.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isInteger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isInteger.js */ 81663);

/** Used as references for various `Number` constants. */

var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
 * double precision number which isn't the result of a rounded unsafe integer.
 *
 * **Note:** This method is based on
 * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
 * @example
 *
 * _.isSafeInteger(3);
 * // => true
 *
 * _.isSafeInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isSafeInteger(Infinity);
 * // => false
 *
 * _.isSafeInteger('3');
 * // => false
 */

function isSafeInteger(value) {
  return (0,_isInteger_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSafeInteger);

/***/ }),

/***/ 59486:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/isSet.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsSet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsSet.js */ 60694);
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ 7560);
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ 25986);



/* Node.js helper references. */

var nodeIsSet = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsSet) : _baseIsSet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSet);

/***/ }),

/***/ 7190:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isString.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ 17191);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);



/** `Object#toString` result references. */

var stringTag = '[object String]';
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */

function isString(value) {
  return typeof value == 'string' || !(0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) == stringTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isString);

/***/ }),

/***/ 48455:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isSymbol.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ 4035);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ 86567);


/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == symbolTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSymbol);

/***/ }),

/***/ 46716:
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isTypedArray.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsTypedArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsTypedArray.js */ 62347);
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ 7560);
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ 25986);



/* Node.js helper references. */

var nodeIsTypedArray = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsTypedArray) : _baseIsTypedArray_js__WEBPACK_IMPORTED_MODULE_2__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isTypedArray);

/***/ }),

/***/ 5279:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isUndefined.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isUndefined);

/***/ }),

/***/ 24876:
/*!****************************************!*\
  !*** ./node_modules/lodash-es/keys.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayLikeKeys.js */ 87224);
/* harmony import */ var _baseKeys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseKeys.js */ 962);
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ 83917);



/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object) ? (0,_arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object) : (0,_baseKeys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keys);

/***/ }),

/***/ 39274:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/keysIn.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayLikeKeys.js */ 87224);
/* harmony import */ var _baseKeysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseKeysIn.js */ 53003);
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ 83917);



/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object) ? (0,_arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, true) : (0,_baseKeysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keysIn);

/***/ }),

/***/ 3163:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/lowerCase.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCompounder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCompounder.js */ 42853);

/**
 * Converts `string`, as space separated words, to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.lowerCase('--Foo-Bar--');
 * // => 'foo bar'
 *
 * _.lowerCase('fooBar');
 * // => 'foo bar'
 *
 * _.lowerCase('__FOO_BAR__');
 * // => 'foo bar'
 */

var lowerCase = (0,_createCompounder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (result, word, index) {
  return result + (index ? ' ' : '') + word.toLowerCase();
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lowerCase);

/***/ }),

/***/ 5937:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/lowerFirst.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCaseFirst.js */ 54737);

/**
 * Converts the first character of `string` to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.lowerFirst('Fred');
 * // => 'fred'
 *
 * _.lowerFirst('FRED');
 * // => 'fRED'
 */

var lowerFirst = (0,_createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__["default"])('toLowerCase');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lowerFirst);

/***/ }),

/***/ 41050:
/*!***************************************!*\
  !*** ./node_modules/lodash-es/max.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseExtremum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseExtremum.js */ 1977);
/* harmony import */ var _baseGt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseGt.js */ 87803);
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity.js */ 80570);



/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */

function max(array) {
  return array && array.length ? (0,_baseExtremum_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"], _baseGt_js__WEBPACK_IMPORTED_MODULE_2__["default"]) : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (max);

/***/ }),

/***/ 16284:
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/memoize.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_MapCache.js */ 12733);

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoize);

/***/ }),

/***/ 45269:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/merge.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseMerge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseMerge.js */ 55226);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ 91034);


/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */

var merge = (0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (object, source, srcIndex) {
  (0,_baseMerge_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, source, srcIndex);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (merge);

/***/ }),

/***/ 69626:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/mergeWith.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseMerge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseMerge.js */ 55226);
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ 91034);


/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */

var mergeWith = (0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (object, source, srcIndex, customizer) {
  (0,_baseMerge_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, source, srcIndex, customizer);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mergeWith);

/***/ }),

/***/ 14403:
/*!****************************************!*\
  !*** ./node_modules/lodash-es/noop.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (noop);

/***/ }),

/***/ 80600:
/*!***************************************!*\
  !*** ./node_modules/lodash-es/now.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ 84261);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function () {
  return _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Date.now();
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (now);

/***/ }),

/***/ 95625:
/*!****************************************!*\
  !*** ./node_modules/lodash-es/once.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _before_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./before.js */ 37542);

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */

function once(func) {
  return (0,_before_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, func);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (once);

/***/ }),

/***/ 5913:
/*!***************************************!*\
  !*** ./node_modules/lodash-es/pad.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createPadding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_createPadding.js */ 35517);
/* harmony import */ var _stringSize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringSize.js */ 32896);
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toInteger.js */ 26011);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);




/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeCeil = Math.ceil,
    nativeFloor = Math.floor;
/**
 * Pads `string` on the left and right sides if it's shorter than `length`.
 * Padding characters are truncated if they can't be evenly divided by `length`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.pad('abc', 8);
 * // => '  abc   '
 *
 * _.pad('abc', 8, '_-');
 * // => '_-abc_-_'
 *
 * _.pad('abc', 3);
 * // => 'abc'
 */

function pad(string, length, chars) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  length = (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_1__["default"])(length);
  var strLength = length ? (0,_stringSize_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string) : 0;

  if (!length || strLength >= length) {
    return string;
  }

  var mid = (length - strLength) / 2;
  return (0,_createPadding_js__WEBPACK_IMPORTED_MODULE_3__["default"])(nativeFloor(mid), chars) + string + (0,_createPadding_js__WEBPACK_IMPORTED_MODULE_3__["default"])(nativeCeil(mid), chars);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pad);

/***/ }),

/***/ 95971:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/padEnd.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createPadding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_createPadding.js */ 35517);
/* harmony import */ var _stringSize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringSize.js */ 32896);
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toInteger.js */ 26011);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);




/**
 * Pads `string` on the right side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padEnd('abc', 6);
 * // => 'abc   '
 *
 * _.padEnd('abc', 6, '_-');
 * // => 'abc_-_'
 *
 * _.padEnd('abc', 3);
 * // => 'abc'
 */

function padEnd(string, length, chars) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  length = (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_1__["default"])(length);
  var strLength = length ? (0,_stringSize_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string) : 0;
  return length && strLength < length ? string + (0,_createPadding_js__WEBPACK_IMPORTED_MODULE_3__["default"])(length - strLength, chars) : string;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (padEnd);

/***/ }),

/***/ 12871:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/padStart.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createPadding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_createPadding.js */ 35517);
/* harmony import */ var _stringSize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringSize.js */ 32896);
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toInteger.js */ 26011);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);




/**
 * Pads `string` on the left side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padStart('abc', 6);
 * // => '   abc'
 *
 * _.padStart('abc', 6, '_-');
 * // => '_-_abc'
 *
 * _.padStart('abc', 3);
 * // => 'abc'
 */

function padStart(string, length, chars) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  length = (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_1__["default"])(length);
  var strLength = length ? (0,_stringSize_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string) : 0;
  return length && strLength < length ? (0,_createPadding_js__WEBPACK_IMPORTED_MODULE_3__["default"])(length - strLength, chars) + string : string;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (padStart);

/***/ }),

/***/ 46061:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/parseInt.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ 84261);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toString.js */ 59191);


/** Used to match leading whitespace. */

var reTrimStart = /^\s+/;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeParseInt = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].parseInt;
/**
 * Converts `string` to an integer of the specified radix. If `radix` is
 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
 * hexadecimal, in which case a `radix` of `16` is used.
 *
 * **Note:** This method aligns with the
 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category String
 * @param {string} string The string to convert.
 * @param {number} [radix=10] The radix to interpret `value` by.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.parseInt('08');
 * // => 8
 *
 * _.map(['6', '08', '10'], _.parseInt);
 * // => [6, 8, 10]
 */

function parseInt(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }

  return nativeParseInt((0,_toString_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string).replace(reTrimStart, ''), radix || 0);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseInt);

/***/ }),

/***/ 96928:
/*!****************************************!*\
  !*** ./node_modules/lodash-es/pick.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basePick_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_basePick.js */ 77620);
/* harmony import */ var _flatRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_flatRest.js */ 6527);


/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */

var pick = (0,_flatRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (object, paths) {
  return object == null ? {} : (0,_basePick_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, paths);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pick);

/***/ }),

/***/ 15472:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/property.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseProperty.js */ 30754);
/* harmony import */ var _basePropertyDeep_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_basePropertyDeep.js */ 22245);
/* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isKey.js */ 17386);
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_toKey.js */ 1564);




/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property(path) {
  return (0,_isKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path) ? (0,_baseProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_toKey_js__WEBPACK_IMPORTED_MODULE_2__["default"])(path)) : (0,_basePropertyDeep_js__WEBPACK_IMPORTED_MODULE_3__["default"])(path);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (property);

/***/ }),

/***/ 99912:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/repeat.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseRepeat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseRepeat.js */ 4608);
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isIterateeCall.js */ 49048);
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toInteger.js */ 26011);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString.js */ 59191);




/**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=1] The number of times to repeat the string.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */

function repeat(string, n, guard) {
  if (guard ? (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string, n, guard) : n === undefined) {
    n = 1;
  } else {
    n = (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_1__["default"])(n);
  }

  return (0,_baseRepeat_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_toString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(string), n);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (repeat);

/***/ }),

/***/ 75020:
/*!******************************************!*\
  !*** ./node_modules/lodash-es/sortBy.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseFlatten.js */ 43932);
/* harmony import */ var _baseOrderBy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseOrderBy.js */ 46827);
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ 67269);
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isIterateeCall.js */ 49048);




/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */

var sortBy = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (collection, iteratees) {
  if (collection == null) {
    return [];
  }

  var length = iteratees.length;

  if (length > 1 && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }

  return (0,_baseOrderBy_js__WEBPACK_IMPORTED_MODULE_2__["default"])(collection, (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__["default"])(iteratees, 1), []);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sortBy);

/***/ }),

/***/ 86589:
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/sortedIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSortedIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseSortedIndex.js */ 69459);

/**
 * Uses a binary search to determine the lowest index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedIndex([30, 50], 40);
 * // => 1
 */

function sortedIndex(array, value) {
  return (0,_baseSortedIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sortedIndex);

/***/ }),

/***/ 26617:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/sortedIndexBy.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ 22244);
/* harmony import */ var _baseSortedIndexBy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseSortedIndexBy.js */ 24568);


/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
 * // => 0
 */

function sortedIndexBy(array, value, iteratee) {
  return (0,_baseSortedIndexBy_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, value, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee, 2));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sortedIndexBy);

/***/ }),

/***/ 56875:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/split.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseToString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseToString.js */ 33192);
/* harmony import */ var _castSlice_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_castSlice.js */ 90221);
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_hasUnicode.js */ 82945);
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isIterateeCall.js */ 49048);
/* harmony import */ var _isRegExp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isRegExp.js */ 21817);
/* harmony import */ var _stringToArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_stringToArray.js */ 68108);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toString.js */ 59191);







/** Used as references for the maximum length and index of an array. */

var MAX_ARRAY_LENGTH = 4294967295;
/**
 * Splits `string` by `separator`.
 *
 * **Note:** This method is based on
 * [`String#split`](https://mdn.io/String/split).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to split.
 * @param {RegExp|string} separator The separator pattern to split by.
 * @param {number} [limit] The length to truncate results to.
 * @returns {Array} Returns the string segments.
 * @example
 *
 * _.split('a-b-c', '-', 2);
 * // => ['a', 'b']
 */

function split(string, separator, limit) {
  if (limit && typeof limit != 'number' && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string, separator, limit)) {
    separator = limit = undefined;
  }

  limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;

  if (!limit) {
    return [];
  }

  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string);

  if (string && (typeof separator == 'string' || separator != null && !(0,_isRegExp_js__WEBPACK_IMPORTED_MODULE_2__["default"])(separator))) {
    separator = (0,_baseToString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(separator);

    if (!separator && (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_4__["default"])(string)) {
      return (0,_castSlice_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_stringToArray_js__WEBPACK_IMPORTED_MODULE_6__["default"])(string), 0, limit);
    }
  }

  return string.split(separator, limit);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (split);

/***/ }),

/***/ 55770:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/startCase.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCompounder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCompounder.js */ 42853);
/* harmony import */ var _upperFirst_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./upperFirst.js */ 93284);


/**
 * Converts `string` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @static
 * @memberOf _
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @example
 *
 * _.startCase('--foo-bar--');
 * // => 'Foo Bar'
 *
 * _.startCase('fooBar');
 * // => 'Foo Bar'
 *
 * _.startCase('__FOO_BAR__');
 * // => 'FOO BAR'
 */

var startCase = (0,_createCompounder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (result, word, index) {
  return result + (index ? ' ' : '') + (0,_upperFirst_js__WEBPACK_IMPORTED_MODULE_1__["default"])(word);
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startCase);

/***/ }),

/***/ 80014:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/startsWith.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseClamp.js */ 12416);
/* harmony import */ var _baseToString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseToString.js */ 33192);
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toInteger.js */ 26011);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);




/**
 * Checks if `string` starts with the given target string.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {string} [target] The string to search for.
 * @param {number} [position=0] The position to search from.
 * @returns {boolean} Returns `true` if `string` starts with `target`,
 *  else `false`.
 * @example
 *
 * _.startsWith('abc', 'a');
 * // => true
 *
 * _.startsWith('abc', 'b');
 * // => false
 *
 * _.startsWith('abc', 'b', 1);
 * // => true
 */

function startsWith(string, target, position) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  position = position == null ? 0 : (0,_baseClamp_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_toInteger_js__WEBPACK_IMPORTED_MODULE_2__["default"])(position), 0, string.length);
  target = (0,_baseToString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(target);
  return string.slice(position, position + target.length) == target;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startsWith);

/***/ }),

/***/ 30709:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/stubArray.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stubArray);

/***/ }),

/***/ 94326:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/stubFalse.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stubFalse);

/***/ }),

/***/ 14822:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/template.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assignInWith_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assignInWith.js */ 76228);
/* harmony import */ var _attempt_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attempt.js */ 44331);
/* harmony import */ var _baseValues_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_baseValues.js */ 17381);
/* harmony import */ var _customDefaultsAssignIn_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_customDefaultsAssignIn.js */ 45824);
/* harmony import */ var _escapeStringChar_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_escapeStringChar.js */ 45897);
/* harmony import */ var _isError_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./isError.js */ 57259);
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isIterateeCall.js */ 49048);
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keys.js */ 24876);
/* harmony import */ var _reInterpolate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_reInterpolate.js */ 81704);
/* harmony import */ var _templateSettings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./templateSettings.js */ 48901);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toString.js */ 59191);











/** Error message constants. */

var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';
/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to validate the `validate` option in `_.template` variable.
 *
 * Forbids characters which could potentially change the meaning of the function argument definition:
 * - "()," (modification of function parameters)
 * - "=" (default value)
 * - "[]{}" (destructuring of function parameters)
 * - "/" (beginning of a comment)
 * - whitespace
 */

var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = _templateSettings_js__WEBPACK_IMPORTED_MODULE_0__["default"].imports._.templateSettings || _templateSettings_js__WEBPACK_IMPORTED_MODULE_0__["default"];

  if (guard && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string, options, guard)) {
    options = undefined;
  }

  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string);
  options = (0,_assignInWith_js__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options, settings, _customDefaultsAssignIn_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
  var imports = (0,_assignInWith_js__WEBPACK_IMPORTED_MODULE_3__["default"])({}, options.imports, settings.imports, _customDefaultsAssignIn_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
      importsKeys = (0,_keys_js__WEBPACK_IMPORTED_MODULE_5__["default"])(imports),
      importsValues = (0,_baseValues_js__WEBPACK_IMPORTED_MODULE_6__["default"])(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === _reInterpolate_js__WEBPACK_IMPORTED_MODULE_7__["default"] ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.

  var sourceURL = hasOwnProperty.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/\s/g, ' ') + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, _escapeStringChar_js__WEBPACK_IMPORTED_MODULE_8__["default"]); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.

  var variable = hasOwnProperty.call(options, 'variable') && options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = (0,_attempt_js__WEBPACK_IMPORTED_MODULE_9__["default"])(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if ((0,_isError_js__WEBPACK_IMPORTED_MODULE_10__["default"])(result)) {
    throw result;
  }

  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (template);

/***/ }),

/***/ 48901:
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/templateSettings.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./escape.js */ 16459);
/* harmony import */ var _reEscape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_reEscape.js */ 96610);
/* harmony import */ var _reEvaluate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_reEvaluate.js */ 79350);
/* harmony import */ var _reInterpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_reInterpolate.js */ 81704);




/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */

var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': _reEscape_js__WEBPACK_IMPORTED_MODULE_0__["default"],

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': _reEvaluate_js__WEBPACK_IMPORTED_MODULE_1__["default"],

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': _reInterpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"],

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': _escape_js__WEBPACK_IMPORTED_MODULE_3__["default"]
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (templateSettings);

/***/ }),

/***/ 46503:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toFinite.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber.js */ 79034);

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);

  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toFinite);

/***/ }),

/***/ 26011:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/toInteger.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toFinite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFinite.js */ 46503);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */

function toInteger(value) {
  var result = (0,_toFinite_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value),
      remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toInteger);

/***/ }),

/***/ 79034:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toNumber.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseTrim_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseTrim.js */ 12695);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ 48455);



/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if ((0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return NAN;
  }

  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = (0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = (0,_baseTrim_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toNumber);

/***/ }),

/***/ 23997:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/toPlainObject.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ 1540);
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keysIn.js */ 39274);


/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject(value) {
  return (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toPlainObject);

/***/ }),

/***/ 23374:
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/toSafeInteger.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClamp.js */ 12416);
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toInteger.js */ 26011);


/** Used as references for various `Number` constants. */

var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Converts `value` to a safe integer. A safe integer can be compared and
 * represented correctly.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toSafeInteger(3.2);
 * // => 3
 *
 * _.toSafeInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toSafeInteger(Infinity);
 * // => 9007199254740991
 *
 * _.toSafeInteger('3.2');
 * // => 3
 */

function toSafeInteger(value) {
  return value ? (0,_baseClamp_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_toInteger_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toSafeInteger);

/***/ }),

/***/ 59191:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toString.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseToString.js */ 33192);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : (0,_baseToString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toString);

/***/ }),

/***/ 38472:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/truncate.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseToString.js */ 33192);
/* harmony import */ var _castSlice_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_castSlice.js */ 90221);
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_hasUnicode.js */ 82945);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ 19089);
/* harmony import */ var _isRegExp_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./isRegExp.js */ 21817);
/* harmony import */ var _stringSize_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_stringSize.js */ 32896);
/* harmony import */ var _stringToArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_stringToArray.js */ 68108);
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toInteger.js */ 26011);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString.js */ 59191);









/** Used as default options for `_.truncate`. */

var DEFAULT_TRUNC_LENGTH = 30,
    DEFAULT_TRUNC_OMISSION = '...';
/** Used to match `RegExp` flags from their coerced string values. */

var reFlags = /\w*$/;
/**
 * Truncates `string` if it's longer than the given maximum string length.
 * The last characters of the truncated string are replaced with the omission
 * string which defaults to "...".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to truncate.
 * @param {Object} [options={}] The options object.
 * @param {number} [options.length=30] The maximum string length.
 * @param {string} [options.omission='...'] The string to indicate text is omitted.
 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
 * @returns {string} Returns the truncated string.
 * @example
 *
 * _.truncate('hi-diddly-ho there, neighborino');
 * // => 'hi-diddly-ho there, neighbo...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': ' '
 * });
 * // => 'hi-diddly-ho there,...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'length': 24,
 *   'separator': /,? +/
 * });
 * // => 'hi-diddly-ho there...'
 *
 * _.truncate('hi-diddly-ho there, neighborino', {
 *   'omission': ' [...]'
 * });
 * // => 'hi-diddly-ho there, neig [...]'
 */

function truncate(string, options) {
  var length = DEFAULT_TRUNC_LENGTH,
      omission = DEFAULT_TRUNC_OMISSION;

  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options)) {
    var separator = 'separator' in options ? options.separator : separator;
    length = 'length' in options ? (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options.length) : length;
    omission = 'omission' in options ? (0,_baseToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(options.omission) : omission;
  }

  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(string);
  var strLength = string.length;

  if ((0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_4__["default"])(string)) {
    var strSymbols = (0,_stringToArray_js__WEBPACK_IMPORTED_MODULE_5__["default"])(string);
    strLength = strSymbols.length;
  }

  if (length >= strLength) {
    return string;
  }

  var end = length - (0,_stringSize_js__WEBPACK_IMPORTED_MODULE_6__["default"])(omission);

  if (end < 1) {
    return omission;
  }

  var result = strSymbols ? (0,_castSlice_js__WEBPACK_IMPORTED_MODULE_7__["default"])(strSymbols, 0, end).join('') : string.slice(0, end);

  if (separator === undefined) {
    return result + omission;
  }

  if (strSymbols) {
    end += result.length - end;
  }

  if ((0,_isRegExp_js__WEBPACK_IMPORTED_MODULE_8__["default"])(separator)) {
    if (string.slice(end).search(separator)) {
      var match,
          substring = result;

      if (!separator.global) {
        separator = RegExp(separator.source, (0,_toString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(reFlags.exec(separator)) + 'g');
      }

      separator.lastIndex = 0;

      while (match = separator.exec(substring)) {
        var newEnd = match.index;
      }

      result = result.slice(0, newEnd === undefined ? end : newEnd);
    }
  } else if (string.indexOf((0,_baseToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(separator), end) != end) {
    var index = result.lastIndexOf(separator);

    if (index > -1) {
      result = result.slice(0, index);
    }
  }

  return result + omission;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (truncate);

/***/ }),

/***/ 78030:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/unescape.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);
/* harmony import */ var _unescapeHtmlChar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_unescapeHtmlChar.js */ 4732);


/** Used to match HTML entities and HTML characters. */

var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
    reHasEscapedHtml = RegExp(reEscapedHtml.source);
/**
 * The inverse of `_.escape`; this method converts the HTML entities
 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
 * their corresponding characters.
 *
 * **Note:** No other HTML entities are unescaped. To unescape additional
 * HTML entities use a third-party library like [_he_](https://mths.be/he).
 *
 * @static
 * @memberOf _
 * @since 0.6.0
 * @category String
 * @param {string} [string=''] The string to unescape.
 * @returns {string} Returns the unescaped string.
 * @example
 *
 * _.unescape('fred, barney, &amp; pebbles');
 * // => 'fred, barney, & pebbles'
 */

function unescape(string) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, _unescapeHtmlChar_js__WEBPACK_IMPORTED_MODULE_1__["default"]) : string;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unescape);

/***/ }),

/***/ 96569:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/union.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseFlatten.js */ 43932);
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ 67269);
/* harmony import */ var _baseUniq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUniq.js */ 36857);
/* harmony import */ var _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArrayLikeObject.js */ 69275);




/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */

var union = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (arrays) {
  return (0,_baseUniq_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arrays, 1, _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_3__["default"], true));
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (union);

/***/ }),

/***/ 65097:
/*!****************************************!*\
  !*** ./node_modules/lodash-es/uniq.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseUniq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseUniq.js */ 36857);

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */

function uniq(array) {
  return array && array.length ? (0,_baseUniq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array) : [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uniq);

/***/ }),

/***/ 38684:
/*!********************************************!*\
  !*** ./node_modules/lodash-es/uniqueId.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);

/** Used to generate unique IDs. */

var idCounter = 0;
/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */

function uniqueId(prefix) {
  var id = ++idCounter;
  return (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prefix) + id;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uniqueId);

/***/ }),

/***/ 78686:
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/upperCase.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCompounder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCompounder.js */ 42853);

/**
 * Converts `string`, as space separated words, to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the upper cased string.
 * @example
 *
 * _.upperCase('--foo-bar');
 * // => 'FOO BAR'
 *
 * _.upperCase('fooBar');
 * // => 'FOO BAR'
 *
 * _.upperCase('__foo_bar__');
 * // => 'FOO BAR'
 */

var upperCase = (0,_createCompounder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function (result, word, index) {
  return result + (index ? ' ' : '') + word.toUpperCase();
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (upperCase);

/***/ }),

/***/ 93284:
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/upperFirst.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCaseFirst.js */ 54737);

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */

var upperFirst = (0,_createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__["default"])('toUpperCase');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (upperFirst);

/***/ }),

/***/ 98222:
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/words.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asciiWords_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_asciiWords.js */ 45893);
/* harmony import */ var _hasUnicodeWord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hasUnicodeWord.js */ 37801);
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ 59191);
/* harmony import */ var _unicodeWords_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_unicodeWords.js */ 53437);




/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */

function words(string, pattern, guard) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return (0,_hasUnicodeWord_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string) ? (0,_unicodeWords_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string) : (0,_asciiWords_js__WEBPACK_IMPORTED_MODULE_3__["default"])(string);
  }

  return string.match(pattern) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (words);

/***/ })

}]);
//# sourceMappingURL=src_app_pages_page-demo_flow_flow-chat_flow-chat_module_ts.js.map